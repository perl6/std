# Emulate context vars by localizing 'our' vars living in main
our $ACTIONS;
our $CTX;
our $DELIM;
our $GOAL;
our $IN_DECL;
our $LANG;
our $ORIG;
our $PARSER;
our $PKG;
our $PKGDECL;
our $VOID;
our $begin_compunit;
our $endargs;
our $endsym;
our $ignoreaccent;
our $ignorecase;
our $inquote;
our $ratchet;
our $sigspace;
our $sym;
our $zone;
our @MEMOS;

our $moreinput;
our $DEBUG;
our $DELIM;

our %INSTANTIATED;
require 'mangle.pl';
use utf8;

package STD;
use strict;
use warnings;
no warnings 'qw', 'recursion';
use Cursor; # for base class as well as DEBUG constants
use Moose ':all' => { -prefix => "moose_" };
moose_extends('Cursor');
my $retree;
use feature 'state', 'say';
use utf8;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

sub BUILD {
my $self = shift;
$self->_AUTOLEXpeek('termish',$retree);
}

use YAML::Syck;


# should some of these be parser instance attributes?
local $LANG;
local $PKGDECL =  "";
local $PKG =  "";
my @PKGS;
local $GOAL =  "(eof)";
local $PARSER;
local $ACTIONS;
local $IN_DECL;
my %ROUTINES;
local $ORIG;
local @MEMOS;
local $VOID;
my @PADS;

# random rule for debugging, please ignore
## token foo
##      token foo {
##         'foo' <.ws> 'bar' <.ws> 'baz'
##      }

sub foo__PEEK { $_[0]->_AUTOLEXpeek('foo',$retree) }
sub foo {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "foo", 
do {
if (my ($C) = ($C->_EXACT('foo'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('bar'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT('baz');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# =begin comment overview
# 
# This file is designed to be either preprocessed into a grammar with
# action statements or used as-is without any preprocessing.  The {*}
# notation is a no-op action block, but can be identified uniquely via a
# combination of the preceding token or rule name plus any additional text
# following a #= comment.  We put this into a comment rather than using
# a macro so that bootstrap compilers don't have to worry about macros
# yet, and to keep the main grammar relatively uncluttered by action
# statements.  Note that the preprocessor can certainly generate accesses
# to the match state within the action block, so we need not mention it
# explicitly.
# 
# Also, some rules are named by syntactic category plus an additonal symbol
# specified in adverbial form, either in bare :name form or in :sym<name>
# form.  (It does not matter which form you use for identifier symbols,
# except that to specify a symbol "sym" you must use the :sym<sym> form
# of adverb.)  If you use the <sym> rule within the rule, it will parse the
# symbol at that point.  At the final reduction point of a rule, if $sym
# has been set, that is used as the final symbol name for the rule.  This
# need not match the symbol specified as part the rule name; that is just
# for disambiguating the name.  However, if no $sym is set, the original
# symbol will be used by default.
# 
# Note that rules automatically get an implicit {*} at their return, so
# for the TOP rule the implicit action name is also simply "TOP".
# 
# Another nod toward preprocessing is that blocks that contain nested braces
# are delimited by double braces so that the preprocessor does not need to
# understand Perl 6 code.
# 
# This grammar relies on transitive longest-token semantics, though
# initially we made a feeble attempt to order rules so a procedural
# interpretation of alternation could usually produce a correct parse.
# (This is becoming less true over time.)
# 
# =end comment overview

## method TOP ($STOP = undef)
sub TOP {
my $self = shift;
my $STOP = shift() // undef;


if (defined $STOP) {
local $GOAL =  $STOP;
$self->unitstop($STOP)->comp_unit;
}
else {
$self->comp_unit;
}
}


# XXX shouldn't need this, it should all be defined/imported by the prelude

my @basetypenames = qw[
Object Any Junction Whatever
Capture Match Signature Proxy Matcher
Package Module Class Role Grammar
Scalar Array Hash KeyHash KeySet KeyBag
Pair List Seq Range Set Bag Mapping
Void Undef Failure Exception
Code Block Routine Sub Macro
Method Submethod Regex

Str Blob
Char Byte Codepoint Grapheme StrPos StrLen Version

Num Complex
num complex

Int  int   int1  int2  int4 int8  int16  int32  int64
Rat  rat   rat1  rat2  rat4 rat8  rat16  rat32  rat64
UInt uint uint1 uint2 uint4 uint8 uint16 uint32 uint64
Buf  buf   buf1  buf2  buf4 buf8  buf16  buf32  buf64

Bit Bool
bit bool

Order Increasing Decreasing
Ordered Callable Positional Associatve
Ordering KeyExtractor Comparator OrderingPair

IO

KitchenSink
];
push @basetypenames, "True", "False", "Bool::True", "Bool::False";  # in quotes lest gimme5 translate them

## method is_type ($name)
sub is_type {
my $self = shift;
my $name = shift;


for (reverse @PADS) {
return 1 if $_->{$name};
}
return 0;
}

## method add_type ($name)
sub add_type {
my $self = shift;
my $name = shift;


my $typename = main::mangle($name);
my $qualname = ($::PKG // 'GLOBAL') . '::' . $typename;
$PADS[-1]{$typename} = 'TYPE';
$PADS[-1]{$qualname} = 'TYPE';
$PADS[-1]{$name} = 'TYPE';
}

# XXX likewise for routine defs

my @baseroutinenames = qw[
WHAT WHICH VAR
any all none one

die exit warn
caller want
eval evalfile
callsame callwith nextsame nextwith lastcall
defined undefine item list slice eager hyper

cat classify
quotemeta
chr ord
p5chop chop p5chomp chomp
index rindex substr
join split comb pack unpack
uc ucfirst lc lcfirst
normalize
nfc nfd nfkc nfkd
samecase sameaccent
capitalize
chars graphs codes bytes

say print open close printf sprintf slurp unlink link symlink
elems grep map first reduce sort uniq push reverse take splice

zip each roundrobin caller
return leave pop shift unshift reduce
keys values hash kv key value pairs pair

sign abs floor ceiling round truncate
exp log log10 sqrt roots
rand srand pick
cis unpolar

sin cos tan asin acos atan sec cosec cotan asec acosec
acotan sinh cosh tanh asinh acosh atanh sech cosech cotanh
asech acosech acotanh atan2

plan is ok dies_ok lives_ok skip todo pass flunk force_todo use_ok
isa_ok cmp_ok diag is_deeply isnt like skip_rest unlike nonce
skip_rest eval_dies_ok eval_lives_ok approx is_approx throws_ok version_lt

gmtime localtime time times
gethost getpw chroot getlogin
run runinstead
fork wait kill sleep
];
push @baseroutinenames, "HOW", "fail", "temp", "let";

# please don't add: ref length bless delete exists

my @routinenames;
my %routinenames;

sub init_pads {  
@PKGS = ();
%ROUTINES = ();

@PADS = ();
$PADS[0] = {};
for (@basetypenames) {
$PADS[0]{$_} = 'TYPE';
$PADS[0]{'&' . $_} = 'CODE';
}
for (@baseroutinenames) {
$PADS[0]{'&' . $_} = 'CODE';
}
}

## method is_routine ($name)
sub is_routine {
my $self = shift;
my $name = shift;


my $aname;
if (substr($name,0,1) eq '&') {
$aname = $name;
}
else {
$aname = '&' . $name;
}
for (reverse @PADS) {
return 1 if $_->{$aname};
return 1 if $_->{$name}; # type as routine?
}
return 0;
}

## method add_routine ($name)
sub add_routine {
my $self = shift;
my $name = shift;


$PADS[-1]{'&' . $name} = 'CODE';
}

# The internal precedence levels are *not* part of the public interface.
# The current values are mere implementation; they may change at any time.
# Users should specify precedence only in relation to existing levels.

our %term            = ('prec' => 'z=');
our %methodcall      = ('prec' => 'y=');
our %autoincrement   = ('prec' => 'x=');
our %exponentiation  = ('prec' => 'w=', 'assoc' => 'right', 'assign' => 1);
our %symbolic_unary  = ('prec' => 'v=');
our %multiplicative  = ('prec' => 'u=', 'assoc' => 'left',  'assign' => 1);
our %additive        = ('prec' => 't=', 'assoc' => 'left',  'assign' => 1);
our %replication     = ('prec' => 's=', 'assoc' => 'left',  'assign' => 1);
our %concatenation   = ('prec' => 'r=', 'assoc' => 'left',  'assign' => 1);
our %junctive_and    = ('prec' => 'q=', 'assoc' => 'list',  'assign' => 1);
our %junctive_or     = ('prec' => 'p=', 'assoc' => 'list',  'assign' => 1);
our %named_unary     = ('prec' => 'o=');
our %nonchaining     = ('prec' => 'n=', 'assoc' => 'non');
our %chaining        = ('prec' => 'm=', 'assoc' => 'chain', 'bool' => 1);
our %tight_and       = ('prec' => 'l=', 'assoc' => 'left',  'assign' => 1);
our %tight_or        = ('prec' => 'k=', 'assoc' => 'left',  'assign' => 1);
our %conditional     = ('prec' => 'j=', 'assoc' => 'right');
our %item_assignment = ('prec' => 'i=', 'assoc' => 'right');
our %loose_unary     = ('prec' => 'h=');
our %comma           = ('prec' => 'g=', 'assoc' => 'list', 'nextterm' => 'nulltermish');
our %list_infix      = ('prec' => 'f=', 'assoc' => 'list',  'assign' => 1);
our %list_assignment = ('prec' => 'i=', 'sub' => 'e=', 'assoc' => 'right');
our %list_prefix     = ('prec' => 'e=');
our %loose_and       = ('prec' => 'd=', 'assoc' => 'left',  'assign' => 1);
our %loose_or        = ('prec' => 'c=', 'assoc' => 'left',  'assign' => 1);
our %sequencer      = ('prec' => 'b=', 'assoc' => 'left', 'nextterm' => 'statement');
our %LOOSEST         = ('prec' => 'a=!');
our %terminator      = ('prec' => 'a=', 'assoc' => 'list');

# "epsilon" tighter than terminator
#constant $LOOSEST = %LOOSEST<prec>;
my $LOOSEST = "a=!"; # XXX preceding line is busted


{ package STD::PrecOp;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;

# This is hopefully called on a match to mix in operator info by type.
##     method coerce (Match $m)
sub coerce {
my $self = shift;
my $m = shift;


# $m but= ::?CLASS;
my $var = (ref($self)||$self) . '::o';
my $d = do { no strict 'refs'; \%{$var}}; 
if (not $d->{transparent}) {
for (keys(%$d)) { $m->{O}{$_} = $d->{$_} };
$m->deb("coercing to " . $self) if $::DEBUG & DEBUG::EXPR;
}
$m->{O}{kind} = (ref($self)||$self);
return $m;
}

} ## end role

{ package STD::Hyper;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp)); our %o = ('transparent' => 1);
} ## end class

{ package STD::Term;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %term;
} ## end class
{ package STD::Methodcall;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %methodcall;
} ## end class
{ package STD::Autoincrement;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %autoincrement;
} ## end class
{ package STD::Exponentiation;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %exponentiation;
} ## end class
{ package STD::Symbolic_unary;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %symbolic_unary;
} ## end class
{ package STD::Multiplicative;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %multiplicative;
} ## end class
{ package STD::Additive;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %additive;
} ## end class
{ package STD::Replication;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %replication;
} ## end class
{ package STD::Concatenation;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %concatenation;
} ## end class
{ package STD::Junctive_and;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %junctive_and;
} ## end class
{ package STD::Junctive_or;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %junctive_or;
} ## end class
{ package STD::Named_unary;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %named_unary;
} ## end class
{ package STD::Nonchaining;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %nonchaining;
} ## end class
{ package STD::Chaining;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %chaining;
} ## end class
{ package STD::Tight_and;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %tight_and;
} ## end class
{ package STD::Tight_or;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %tight_or;
} ## end class
{ package STD::Conditional;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %conditional;
} ## end class
{ package STD::Item_assignment;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %item_assignment;
} ## end class
{ package STD::Loose_unary;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %loose_unary;
} ## end class
{ package STD::Comma;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %comma;
} ## end class
{ package STD::List_infix;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %list_infix;
} ## end class
{ package STD::List_assignment;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %list_assignment;
} ## end class
{ package STD::List_prefix;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %list_prefix;
} ## end class
{ package STD::Loose_and;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %loose_and;
} ## end class
{ package STD::Loose_or;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %loose_or;
} ## end class
{ package STD::Sequencer;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %sequencer;
} ## end class
{ package STD::Terminator;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::PrecOp));    our %o = %terminator;
} ## end class

# Categories are designed to be easily extensible in derived grammars
# by merely adding more rules in the same category.  The rules within
# a given category start with the category name followed by a differentiating
# adverbial qualifier to serve (along with the category) as the longer name.

# The endsym context, if specified, says what to implicitly check for in each
# rule right after the initial <sym>.  Normally this is used to make sure
# there's appropriate whitespace.  # Note that endsym isn't called if <sym>
# isn't called.

local $endsym =  "null";
local $endargs =  -1;

#proto token category { <...> }
sub category__PEEK { $_[0]->_AUTOLEXpeek('category:*',$retree); }
sub category {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'category') {
$C->deb("Fate passed to category: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'category:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("category trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "category", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_000category (:$sym is context<rw> = 'category')
##      token category:category { <sym> }

sub category__S_000category__PEEK { $_[0]->_AUTOLEXpeek('category__S_000category',$retree) }
sub category__S_000category {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'category';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_000category", 
$C->_PATTERN(qr/\Gcategory/)
);
}

## token category__S_001sigil (:$sym is context<rw> = 'sigil')
##      token category:sigil { <sym> }

sub category__S_001sigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_001sigil',$retree) }
sub category__S_001sigil {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigil';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_001sigil", 
$C->_PATTERN(qr/\Gsigil/)
);
}
#proto token sigil { <...> }
sub sigil__PEEK { $_[0]->_AUTOLEXpeek('sigil:*',$retree); }
sub sigil {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'sigil') {
$C->deb("Fate passed to sigil: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'sigil:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("sigil trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "sigil", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_002twigil (:$sym is context<rw> = 'twigil')
##      token category:twigil { <sym> }

sub category__S_002twigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_002twigil',$retree) }
sub category__S_002twigil {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'twigil';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_002twigil", 
$C->_PATTERN(qr/\Gtwigil/)
);
}
#proto token twigil { <...> }
sub twigil__PEEK { $_[0]->_AUTOLEXpeek('twigil:*',$retree); }
sub twigil {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'twigil') {
$C->deb("Fate passed to twigil: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'twigil:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("twigil trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "twigil", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_003special_variable (:$sym is context<rw> = 'special_variable')
##      token category:special_variable { <sym> }

sub category__S_003special_variable__PEEK { $_[0]->_AUTOLEXpeek('category__S_003special_variable',$retree) }
sub category__S_003special_variable {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'special_variable';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_003special_variable", 
$C->_PATTERN(qr/\Gspecial_variable/)
);
}
#proto token special_variable { <...> }
sub special_variable__PEEK { $_[0]->_AUTOLEXpeek('special_variable:*',$retree); }
sub special_variable {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'special_variable') {
$C->deb("Fate passed to special_variable: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "special_variable", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_004version (:$sym is context<rw> = 'version')
##      token category:version { <sym> }

sub category__S_004version__PEEK { $_[0]->_AUTOLEXpeek('category__S_004version',$retree) }
sub category__S_004version {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'version';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_004version", 
$C->_PATTERN(qr/\Gversion/)
);
}
#proto token version { <...> }
sub version__PEEK { $_[0]->_AUTOLEXpeek('version:*',$retree); }
sub version {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'version') {
$C->deb("Fate passed to version: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'version:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("version trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "version", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_005module_name (:$sym is context<rw> = 'module_name')
##      token category:module_name { <sym> }

sub category__S_005module_name__PEEK { $_[0]->_AUTOLEXpeek('category__S_005module_name',$retree) }
sub category__S_005module_name {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'module_name';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_005module_name", 
$C->_PATTERN(qr/\Gmodule_name/)
);
}
#proto token module_name { <...> }
sub module_name__PEEK { $_[0]->_AUTOLEXpeek('module_name:*',$retree); }
sub module_name {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'module_name') {
$C->deb("Fate passed to module_name: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'module_name:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("module_name trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "module_name", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_006term (:$sym is context<rw> = 'term')
##      token category:term { <sym> }

sub category__S_006term__PEEK { $_[0]->_AUTOLEXpeek('category__S_006term',$retree) }
sub category__S_006term {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'term';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_006term", 
$C->_PATTERN(qr/\Gterm/)
);
}
#proto token term { <...> }
sub term__PEEK { $_[0]->_AUTOLEXpeek('term:*',$retree); }
sub term {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'term') {
$C->deb("Fate passed to term: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "term", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_007quote (:$sym is context<rw> = 'quote')
##      token category:quote { <sym> }

sub category__S_007quote__PEEK { $_[0]->_AUTOLEXpeek('category__S_007quote',$retree) }
sub category__S_007quote {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quote';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_007quote", 
$C->_PATTERN(qr/\Gquote/)
);
}
#proto token quote () { <...> }
sub quote__PEEK { $_[0]->_AUTOLEXpeek('quote:*',$retree); }
sub quote {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'quote') {
$C->deb("Fate passed to quote: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quote", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_008prefix (:$sym is context<rw> = 'prefix')
##      token category:prefix { <sym> }

sub category__S_008prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_008prefix',$retree) }
sub category__S_008prefix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'prefix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_008prefix", 
$C->_PATTERN(qr/\Gprefix/)
);
}
#proto token prefix is unary is defequiv(%symbolic_unary) { <...> }
sub prefix__PEEK { $_[0]->_AUTOLEXpeek('prefix:*',$retree); }
sub prefix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'prefix') {
$C->deb("Fate passed to prefix: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "prefix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_009infix (:$sym is context<rw> = 'infix')
##      token category:infix { <sym> }

sub category__S_009infix__PEEK { $_[0]->_AUTOLEXpeek('category__S_009infix',$retree) }
sub category__S_009infix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_009infix", 
$C->_PATTERN(qr/\Ginfix/)
);
}
#proto token infix is binary is defequiv(%additive) { <...> }
sub infix__PEEK { $_[0]->_AUTOLEXpeek('infix:*',$retree); }
sub infix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'infix') {
$C->deb("Fate passed to infix: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_010postfix (:$sym is context<rw> = 'postfix')
##      token category:postfix { <sym> }

sub category__S_010postfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_010postfix',$retree) }
sub category__S_010postfix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'postfix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_010postfix", 
$C->_PATTERN(qr/\Gpostfix/)
);
}
#proto token postfix is unary is defequiv(%autoincrement) { <...> }
sub postfix__PEEK { $_[0]->_AUTOLEXpeek('postfix:*',$retree); }
sub postfix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'postfix') {
$C->deb("Fate passed to postfix: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "postfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_011dotty (:$sym is context<rw> = 'dotty')
##      token category:dotty { <sym> }

sub category__S_011dotty__PEEK { $_[0]->_AUTOLEXpeek('category__S_011dotty',$retree) }
sub category__S_011dotty {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'dotty';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_011dotty", 
$C->_PATTERN(qr/\Gdotty/)
);
}
#proto token dotty (:$endsym is context = 'unspacey') { <...> }
sub dotty__PEEK { $_[0]->_AUTOLEXpeek('dotty:*',$retree); }
sub dotty {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'dotty') {
$C->deb("Fate passed to dotty: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dotty:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dotty trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "dotty", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_012circumfix (:$sym is context<rw> = 'circumfix')
##      token category:circumfix { <sym> }

sub category__S_012circumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_012circumfix',$retree) }
sub category__S_012circumfix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'circumfix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_012circumfix", 
$C->_PATTERN(qr/\Gcircumfix/)
);
}
#proto token circumfix { <...> }
sub circumfix__PEEK { $_[0]->_AUTOLEXpeek('circumfix:*',$retree); }
sub circumfix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'circumfix') {
$C->deb("Fate passed to circumfix: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'circumfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("circumfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "circumfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_013postcircumfix (:$sym is context<rw> = 'postcircumfix')
##      token category:postcircumfix { <sym> }

sub category__S_013postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_013postcircumfix',$retree) }
sub category__S_013postcircumfix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'postcircumfix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_013postcircumfix", 
$C->_PATTERN(qr/\Gpostcircumfix/)
);
}
#proto token postcircumfix is unary { <...> }  # unary as far as EXPR knows...
sub postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix:*',$retree); }
sub postcircumfix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'postcircumfix') {
$C->deb("Fate passed to postcircumfix: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postcircumfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postcircumfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "postcircumfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_014quote_mod (:$sym is context<rw> = 'quote_mod')
##      token category:quote_mod { <sym> }

sub category__S_014quote_mod__PEEK { $_[0]->_AUTOLEXpeek('category__S_014quote_mod',$retree) }
sub category__S_014quote_mod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quote_mod';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_014quote_mod", 
$C->_PATTERN(qr/\Gquote_mod/)
);
}
#proto token quote_mod { <...> }
sub quote_mod__PEEK { $_[0]->_AUTOLEXpeek('quote_mod:*',$retree); }
sub quote_mod {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'quote_mod') {
$C->deb("Fate passed to quote_mod: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote_mod:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote_mod trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quote_mod", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_015trait_verb (:$sym is context<rw> = 'trait_verb')
##      token category:trait_verb { <sym> }

sub category__S_015trait_verb__PEEK { $_[0]->_AUTOLEXpeek('category__S_015trait_verb',$retree) }
sub category__S_015trait_verb {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'trait_verb';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_015trait_verb", 
$C->_PATTERN(qr/\Gtrait_verb/)
);
}
#proto token trait_verb (:$endsym is context = 'spacey') { <...> }
sub trait_verb__PEEK { $_[0]->_AUTOLEXpeek('trait_verb:*',$retree); }
sub trait_verb {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'trait_verb') {
$C->deb("Fate passed to trait_verb: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'trait_verb:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("trait_verb trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "trait_verb", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_016trait_auxiliary (:$sym is context<rw> = 'trait_auxiliary')
##      token category:trait_auxiliary { <sym> }

sub category__S_016trait_auxiliary__PEEK { $_[0]->_AUTOLEXpeek('category__S_016trait_auxiliary',$retree) }
sub category__S_016trait_auxiliary {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'trait_auxiliary';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_016trait_auxiliary", 
$C->_PATTERN(qr/\Gtrait_auxiliary/)
);
}
#proto token trait_auxiliary (:$endsym is context = 'spacey') { <...> }
sub trait_auxiliary__PEEK { $_[0]->_AUTOLEXpeek('trait_auxiliary:*',$retree); }
sub trait_auxiliary {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'trait_auxiliary') {
$C->deb("Fate passed to trait_auxiliary: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'trait_auxiliary:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("trait_auxiliary trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "trait_auxiliary", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_017type_declarator (:$sym is context<rw> = 'type_declarator')
##      token category:type_declarator { <sym> }

sub category__S_017type_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_017type_declarator',$retree) }
sub category__S_017type_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'type_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_017type_declarator", 
$C->_PATTERN(qr/\Gtype_declarator/)
);
}
#proto token type_declarator () { <...> }
sub type_declarator__PEEK { $_[0]->_AUTOLEXpeek('type_declarator:*',$retree); }
sub type_declarator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'type_declarator') {
$C->deb("Fate passed to type_declarator: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'type_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("type_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "type_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_018scope_declarator (:$sym is context<rw> = 'scope_declarator')
##      token category:scope_declarator { <sym> }

sub category__S_018scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_018scope_declarator',$retree) }
sub category__S_018scope_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'scope_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_018scope_declarator", 
$C->_PATTERN(qr/\Gscope_declarator/)
);
}
#proto token scope_declarator (:$endsym is context = 'nofun') { <...> }
sub scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator:*',$retree); }
sub scope_declarator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'scope_declarator') {
$C->deb("Fate passed to scope_declarator: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'scope_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("scope_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "scope_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_019package_declarator (:$sym is context<rw> = 'package_declarator')
##      token category:package_declarator { <sym> }

sub category__S_019package_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_019package_declarator',$retree) }
sub category__S_019package_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'package_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_019package_declarator", 
$C->_PATTERN(qr/\Gpackage_declarator/)
);
}
#proto token package_declarator () { <...> }
sub package_declarator__PEEK { $_[0]->_AUTOLEXpeek('package_declarator:*',$retree); }
sub package_declarator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'package_declarator') {
$C->deb("Fate passed to package_declarator: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'package_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("package_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "package_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_020multi_declarator (:$sym is context<rw> = 'multi_declarator')
##      token category:multi_declarator { <sym> }

sub category__S_020multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_020multi_declarator',$retree) }
sub category__S_020multi_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'multi_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_020multi_declarator", 
$C->_PATTERN(qr/\Gmulti_declarator/)
);
}
#proto token multi_declarator () { <...> }
sub multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator:*',$retree); }
sub multi_declarator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'multi_declarator') {
$C->deb("Fate passed to multi_declarator: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'multi_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("multi_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "multi_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_021routine_declarator (:$sym is context<rw> = 'routine_declarator')
##      token category:routine_declarator { <sym> }

sub category__S_021routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_021routine_declarator',$retree) }
sub category__S_021routine_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'routine_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_021routine_declarator", 
$C->_PATTERN(qr/\Groutine_declarator/)
);
}
#proto token routine_declarator () { <...> }
sub routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator:*',$retree); }
sub routine_declarator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'routine_declarator') {
$C->deb("Fate passed to routine_declarator: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'routine_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("routine_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "routine_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_022regex_declarator (:$sym is context<rw> = 'regex_declarator')
##      token category:regex_declarator { <sym> }

sub category__S_022regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_022regex_declarator',$retree) }
sub category__S_022regex_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'regex_declarator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_022regex_declarator", 
$C->_PATTERN(qr/\Gregex_declarator/)
);
}
#proto token regex_declarator () { <...> }
sub regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator:*',$retree); }
sub regex_declarator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'regex_declarator') {
$C->deb("Fate passed to regex_declarator: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_declarator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "regex_declarator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_023statement_prefix (:$sym is context<rw> = 'statement_prefix')
##      token category:statement_prefix { <sym> }

sub category__S_023statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_023statement_prefix',$retree) }
sub category__S_023statement_prefix {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_prefix';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_023statement_prefix", 
$C->_PATTERN(qr/\Gstatement_prefix/)
);
}
#proto rule  statement_prefix () { <...> }
sub statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix:*',$retree); }
sub statement_prefix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'statement_prefix') {
$C->deb("Fate passed to statement_prefix: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_prefix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_prefix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_prefix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_024statement_control (:$sym is context<rw> = 'statement_control')
##      token category:statement_control { <sym> }

sub category__S_024statement_control__PEEK { $_[0]->_AUTOLEXpeek('category__S_024statement_control',$retree) }
sub category__S_024statement_control {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_control';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_024statement_control", 
$C->_PATTERN(qr/\Gstatement_control/)
);
}
#proto rule  statement_control (:$endsym is context = 'spacey') { <...> }
sub statement_control__PEEK { $_[0]->_AUTOLEXpeek('statement_control:*',$retree); }
sub statement_control {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'statement_control') {
$C->deb("Fate passed to statement_control: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_control", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_025statement_mod_cond (:$sym is context<rw> = 'statement_mod_cond')
##      token category:statement_mod_cond { <sym> }

sub category__S_025statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('category__S_025statement_mod_cond',$retree) }
sub category__S_025statement_mod_cond {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_mod_cond';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_025statement_mod_cond", 
$C->_PATTERN(qr/\Gstatement_mod_cond/)
);
}
#proto rule  statement_mod_cond () { <...> }
sub statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond:*',$retree); }
sub statement_mod_cond {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'statement_mod_cond') {
$C->deb("Fate passed to statement_mod_cond: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_mod_cond:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_mod_cond trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_mod_cond", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_026statement_mod_loop (:$sym is context<rw> = 'statement_mod_loop')
##      token category:statement_mod_loop { <sym> }

sub category__S_026statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('category__S_026statement_mod_loop',$retree) }
sub category__S_026statement_mod_loop {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'statement_mod_loop';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_026statement_mod_loop", 
$C->_PATTERN(qr/\Gstatement_mod_loop/)
);
}
#proto rule  statement_mod_loop () { <...> }
sub statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop:*',$retree); }
sub statement_mod_loop {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'statement_mod_loop') {
$C->deb("Fate passed to statement_mod_loop: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_mod_loop:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_mod_loop trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "statement_mod_loop", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_027infix_prefix_meta_operator (:$sym is context<rw> = 'infix_prefix_meta_operator')
##      token category:infix_prefix_meta_operator { <sym> }

sub category__S_027infix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_027infix_prefix_meta_operator',$retree) }
sub category__S_027infix_prefix_meta_operator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix_prefix_meta_operator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_027infix_prefix_meta_operator", 
$C->_PATTERN(qr/\Ginfix_prefix_meta_operator/)
);
}
#proto token infix_prefix_meta_operator is binary { <...> }
sub infix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator:*',$retree); }
sub infix_prefix_meta_operator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'infix_prefix_meta_operator') {
$C->deb("Fate passed to infix_prefix_meta_operator: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_prefix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_prefix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix_prefix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_028infix_postfix_meta_operator (:$sym is context<rw> = 'infix_postfix_meta_operator')
##      token category:infix_postfix_meta_operator { <sym> }

sub category__S_028infix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_028infix_postfix_meta_operator',$retree) }
sub category__S_028infix_postfix_meta_operator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix_postfix_meta_operator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_028infix_postfix_meta_operator", 
$C->_PATTERN(qr/\Ginfix_postfix_meta_operator/)
);
}
#proto token infix_postfix_meta_operator ($op) is binary { <...> }
sub infix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_postfix_meta_operator:*',$retree); }
sub infix_postfix_meta_operator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'infix_postfix_meta_operator') {
$C->deb("Fate passed to infix_postfix_meta_operator: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_postfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_postfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix_postfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_029infix_circumfix_meta_operator (:$sym is context<rw> = 'infix_circumfix_meta_operator')
##      token category:infix_circumfix_meta_operator { <sym> }

sub category__S_029infix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_029infix_circumfix_meta_operator',$retree) }
sub category__S_029infix_circumfix_meta_operator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'infix_circumfix_meta_operator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_029infix_circumfix_meta_operator", 
$C->_PATTERN(qr/\Ginfix_circumfix_meta_operator/)
);
}
#proto token infix_circumfix_meta_operator is binary { <...> }
sub infix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator:*',$retree); }
sub infix_circumfix_meta_operator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'infix_circumfix_meta_operator') {
$C->deb("Fate passed to infix_circumfix_meta_operator: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "infix_circumfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_030postfix_prefix_meta_operator (:$sym is context<rw> = 'postfix_prefix_meta_operator')
##      token category:postfix_prefix_meta_operator { <sym> }

sub category__S_030postfix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_030postfix_prefix_meta_operator',$retree) }
sub category__S_030postfix_prefix_meta_operator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'postfix_prefix_meta_operator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_030postfix_prefix_meta_operator", 
$C->_PATTERN(qr/\Gpostfix_prefix_meta_operator/)
);
}
#proto token postfix_prefix_meta_operator is unary { <...> }
sub postfix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('postfix_prefix_meta_operator:*',$retree); }
sub postfix_prefix_meta_operator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'postfix_prefix_meta_operator') {
$C->deb("Fate passed to postfix_prefix_meta_operator: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postfix_prefix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix_prefix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "postfix_prefix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_031prefix_postfix_meta_operator (:$sym is context<rw> = 'prefix_postfix_meta_operator')
##      token category:prefix_postfix_meta_operator { <sym> }

sub category__S_031prefix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_031prefix_postfix_meta_operator',$retree) }
sub category__S_031prefix_postfix_meta_operator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'prefix_postfix_meta_operator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_031prefix_postfix_meta_operator", 
$C->_PATTERN(qr/\Gprefix_postfix_meta_operator/)
);
}
#proto token prefix_postfix_meta_operator is unary { <...> }
sub prefix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('prefix_postfix_meta_operator:*',$retree); }
sub prefix_postfix_meta_operator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'prefix_postfix_meta_operator') {
$C->deb("Fate passed to prefix_postfix_meta_operator: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_postfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_postfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "prefix_postfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_032prefix_circumfix_meta_operator (:$sym is context<rw> = 'prefix_circumfix_meta_operator')
##      token category:prefix_circumfix_meta_operator { <sym> }

sub category__S_032prefix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_032prefix_circumfix_meta_operator',$retree) }
sub category__S_032prefix_circumfix_meta_operator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'prefix_circumfix_meta_operator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_032prefix_circumfix_meta_operator", 
$C->_PATTERN(qr/\Gprefix_circumfix_meta_operator/)
);
}
#proto token prefix_circumfix_meta_operator is unary { <...> }
sub prefix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('prefix_circumfix_meta_operator:*',$retree); }
sub prefix_circumfix_meta_operator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'prefix_circumfix_meta_operator') {
$C->deb("Fate passed to prefix_circumfix_meta_operator: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "prefix_circumfix_meta_operator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token category__S_033terminator (:$sym is context<rw> = 'terminator')
##      token category:terminator { <sym> }

sub category__S_033terminator__PEEK { $_[0]->_AUTOLEXpeek('category__S_033terminator',$retree) }
sub category__S_033terminator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'terminator';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_033terminator", 
$C->_PATTERN(qr/\Gterminator/)
);
}
#proto token terminator { <...> }
sub terminator__PEEK { $_[0]->_AUTOLEXpeek('terminator:*',$retree); }
sub terminator {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'terminator') {
$C->deb("Fate passed to terminator: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'terminator:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("terminator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "terminator", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


## token unspacey
##      token unspacey { <.unsp>? }

sub unspacey__PEEK { $_[0]->_AUTOLEXpeek('unspacey',$retree) }
sub unspacey {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "unspacey", 
$C->_OPTr(sub { my $C=shift;
$C->unsp
})
);
}
## token spacey
##      token spacey { <?before \s | '#'> }

sub spacey__PEEK { $_[0]->_AUTOLEXpeek('spacey',$retree) }
sub spacey {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "spacey", 
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'spacey_01') {
$C->deb("Fate passed to spacey_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'spacey_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("spacey_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}
## token nofun
##      token nofun { <!before '(' | '.(' | '\\' > }

sub nofun__PEEK { $_[0]->_AUTOLEXpeek('nofun',$retree) }
sub nofun {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "nofun", 
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'nofun_01') {
$C->deb("Fate passed to nofun_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'nofun_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("nofun_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('(')
},
sub { my $C=shift;
$C->_EXACT('.(')
},
sub { my $C=shift;
$C->_EXACT('\\')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
);
}

# Lexical routines

## token ws
##      token ws {
##          :my @stub = return self if @+MEMOS[self.pos]<ws> :exists;
##          :my $startpos = self.pos;
##      
##          :dba('whitespace')
##          [
##      	| \h+ <![#\s\\]> { @+MEMOS[$.pos]<ws> = $startpos; }	# common case
##      	| <?before \w> <?after \w> :::
##      	    { @+MEMOS[$startpos]<ws> = undef; }
##      	    <!>        # must \s+ between words
##          ]
##          ||
##          [
##          | <.unsp>
##          | <.vws> <.heredoc>
##          | <.unv>
##          | $ { $.moreinput }
##          ]*
##      
##          {{
##              if ($.pos == $startpos) {
##                  @+MEMOS[$.pos]<ws> = undef;
##              }
##              else {
##                  @+MEMOS[$.pos]<ws> = $startpos;
##                  @+MEMOS[$.pos]<endstmt> = @+MEMOS[$startpos]<endstmt>
##                      if @+MEMOS[$startpos]<endstmt> :exists;
##              }
##          }}
##      }

sub ws__PEEK { '' }
sub ws {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my @stub = return $self if exists $MEMOS[$self->{_pos}]{'ws'};
my $startpos = $self->{_pos};


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "ws", 
do { my @gather;
eval { push @gather, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'ws_01') {
$C->deb("Fate passed to ws_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'ws_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[#\s\\]/)
}))) {
scalar(do {
$MEMOS[$C->{_pos}]{'ws'} = $startpos; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
}, scalar(do {
$MEMOS[$startpos]{'ws'} = undef; 
}, $C))
}, $C->_COMMITRULE())
}, $C->before( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=\w)/)
})
}))
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
scalar(do {

if (($C->{_pos} == $startpos)) {
$MEMOS[$C->{_pos}]{'ws'} = undef;
}
else {
$MEMOS[$C->{_pos}]{'ws'} = $startpos;
$MEMOS[$C->{_pos}]{'endstmt'} = $MEMOS[$startpos]{'endstmt'}
if exists $MEMOS[$startpos]{'endstmt'};
}

}, $C)
}, $C->_STARr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'ws_05') {
$C->deb("Fate passed to ws_05: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'ws_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->unsp
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->heredoc
}, $C->vws)
},
sub { my $C=shift;
$C->unv
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
$C->moreinput 
}, $C)
}, $C->_PATTERN(qr/\G\z/))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))} or do { die $@ if $@ };
@gather;
}
);
}

## token unsp
##      token unsp {
##          \\ <?before [\s|'#'] >
##          :dba('unspace')
##          [
##          | <.vws>                     {*}                             #= vwhite
##          | <.unv>                  {*}                                #= unv
##          | $ { $.moreinput }
##          ]*
##      }

sub unsp__PEEK { $_[0]->_AUTOLEXpeek('unsp',$retree) }
sub unsp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "unsp", 
do {
if (my ($C) = ($C->_EXACT('\\'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'unsp_02') {
$C->deb("Fate passed to unsp_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unsp_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unsp_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'unsp_03') {
$C->deb("Fate passed to unsp_03: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unsp_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unsp_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->vws)) {
$C->_REDUCE($S, 'unsp_vwhite');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->unv)) {
$C->_REDUCE($S, 'unsp_unv');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
scalar(do {
$C->moreinput 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token vws
##      token vws {
##          :dba('vertical whitespace')
##          \v
##          [ '#DEBUG -1' { say "DEBUG"; $STD::DEBUG = $*DEBUG = -1; } ]?
##      }

sub vws__PEEK { $_[0]->_AUTOLEXpeek('vws',$retree) }
sub vws {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "vws", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\n]/))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('#DEBUG -1'))) {
scalar(do {
say "DEBUG"; $STD::DEBUG = $::DEBUG = -1; 
}, $C);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

# We provide two mechanisms here:
# 1) define $+moreinput, or
# 2) override moreinput method
## method moreinput ()
sub moreinput {
my $self = shift;


$::moreinput->() if $::moreinput;
}

## token unv
##      token unv {
##         :dba('horizontal whitespace')
##         [
##         | \h+                 {*}                                    #= hwhite
##         | <?before '='> ^^ <.pod_comment>  {*}                    #= pod
##         | \h* '#' [
##               |  <?opener>
##                  [ <!after ^^ . > || <.panic: "Can't use embedded comments in column 1"> ]
##                  <.quibble($.cursor_fresh( ::STD::Q ))>   {*}                               #= embedded
##               | {} \N*            {*}                                 #= end
##               ]
##          ]
##      }

sub unv__PEEK { $_[0]->_AUTOLEXpeek('unv',$retree) }
sub unv {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "unv", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'unv_01') {
$C->deb("Fate passed to unv_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unv_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unv_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
$C->_REDUCE($S, 'unv_hwhite');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('=')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?m:^)/))) {
do {
if (my ($C) = ($C->pod_comment)) {
$C->_REDUCE($S, 'unv_pod');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('#'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'unv_03') {
$C->deb("Fate passed to unv_03: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'unv_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("unv_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->opener
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=(?s:.))(?m:^)/)
})
})} 
or
eval { push @gather, $C->panic("Can't use embedded comments in column 1")} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->quibble($C->cursor_fresh( 'STD::Q' )))) {
$C->_REDUCE($S, 'unv_embedded');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
}))) {
$C->_REDUCE($S, 'unv_end');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token ident
##      token ident {
##          <.alpha> \w*
##      }

sub ident__PEEK { $_[0]->_AUTOLEXpeek('ident',$retree) }
sub ident {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "ident", 
$C->_PATTERN(qr/\G[_[:alpha:]]((?:\w)*+)/)
);
}

## token apostrophe
##      token apostrophe {
##          <[ ' \- ]>
##      }

sub apostrophe__PEEK { $_[0]->_AUTOLEXpeek('apostrophe',$retree) }
sub apostrophe {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "apostrophe", 
$C->_PATTERN(qr/\G['\-]/)
);
}

## token identifier
##      token identifier {
##          <.ident> [ <.apostrophe> <.ident> ]*
##      }

sub identifier__PEEK { $_[0]->_AUTOLEXpeek('identifier',$retree) }
sub identifier {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "identifier", 
do {
if (my ($C) = ($C->ident)) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->apostrophe)) {
$C->ident;
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

# XXX We need to parse the pod eventually to support $= variables.

## token pod_comment
##      token pod_comment {
##          ^^ '=' <.unsp>?
##          [
##          | 'begin' \h+ <identifier> ::
##              [
##              ||  .*? "\n=" <.unsp>? 'end' \h+ $<identifier>  \N*          {*} #= tagged
##              ||  .*?                                                       {*} #= end
##              ]
##          | 'begin'  :: \h* [ $$ || '#' || <.panic: "Unrecognized token after =begin"> ]
##              [ .*?  "\n=" <.unsp>? 'end'  \N* || <.panic: "=begin without =end"> ]   {*}       #= anon
##          | :: 
##              [ <?before .*? ^^ '=cut'  > <.panic: "Obsolete pod format, please use =begin/=end instead"> ]?
##              \N*                                           {*}       #= misc
##          ]
##      }

sub pod_comment__PEEK { $_[0]->_AUTOLEXpeek('pod_comment',$retree) }
sub pod_comment {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "pod_comment", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'pod_comment_01') {
$C->deb("Fate passed to pod_comment_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'pod_comment_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("pod_comment_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment_tagged')
}, $C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
}))
}, $C->_PATTERN(qr/\G\b/))
}, $C->_BACKREFn('identifier'))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))
}, $C->_EXACT('end'))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_PATTERN(qr/\G\n=/))
}, $C->_SCANf())} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment_end')
}, $C->_SCANf())} or do { die $@ if $@ };
@gather;
}
})
}, $C->_COMMITBRANCH())
}, $C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))
}, $C->_EXACT('begin'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment_anon')
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
}, $C->_PATTERN(qr/\G\b/))
}, $C->_EXACT('end'))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_PATTERN(qr/\G\n=/))
}, $C->_SCANf())} 
or
eval { push @gather, $C->panic("=begin without =end")} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?m:$)/)} 
or
eval { push @gather, $C->_EXACT('#')} 
or
eval { push @gather, $C->panic("Unrecognized token after =begin")} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\b/))
}, $C->_EXACT('begin'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'pod_comment_misc')
}, $C->_STARr(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->panic("Obsolete pod format, please use =begin/=end instead")
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G\b/)
}, $C->_EXACT('=cut'))
}, $C->_PATTERN(qr/\G(?m:^)/))
}, $C->_SCANf())
}))
})
}))
}, $C->_COMMITBRANCH())
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_EXACT('='))
}, $C->_PATTERN(qr/\G(?m:^)/))
);
}

# Top-level rules

# Note: we only check for the stopper.  We don't check for ^ because
# we might be embedded in something else.
## rule comp_unit
##      rule comp_unit {
##          :my $begin_compunit is context = 1;
##          :my $endargs        is context<rw> = -1;
##      
##          :my $LANG is context;
##          :my $PKGDECL is context = "";
##          :my $PKG is context = "";
##          :my $GOAL is context = "(eof)";
##          :my $PARSER is context<rw>;
##          :my $IN_DECL is context<rw>;
##      
##          { init_pads(); }
##      
##          <statementlist>
##          [ <?unitstopper> || <.panic: "Can't understand next input--giving up"> ]
##          # "CHECK" time...
##          {{
##              if @COMPILING::WORRIES {
##                  warn "Potential difficulties:\n  " ~ join( "\n  ", @COMPILING::WORRIES) ~ "\n";
##              }
##      
##              my %UNKNOWN;
##              for keys(%ROUTINES) {
##                  next if $.is_routine($_);
##                  %UNKNOWN{$_} = %ROUTINES{$_};
##              }
##              if %UNKNOWN {
##                  warn "Unknown routines:\n";
##                  for sort keys(%UNKNOWN) {
##                      warn "\t$_ called at ", %UNKNOWN{$_}, "\n";
##                  }
##              }
##          }}
##      }

sub comp_unit__PEEK { $_[0]->_AUTOLEXpeek('comp_unit',$retree) }
sub comp_unit {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $begin_compunit =  1;
local $endargs =  -1;
local $LANG;
local $PKGDECL =  "";
local $PKG =  "";
local $GOAL =  "(eof)";
local $PARSER;
local $IN_DECL;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "comp_unit", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
init_pads(); 
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->unitstopper
}))) {
$C->ws;
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("Can't understand next input--giving up"))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

if (@COMPILING::WORRIES) {
warn "Potential difficulties:\n  " . join( "\n  ", @COMPILING::WORRIES) . "\n";
}

my %UNKNOWN;
for (keys(%ROUTINES)) {
next if $C->is_routine($_);
$UNKNOWN{$_} = $ROUTINES{$_};
}
if (%UNKNOWN) {
warn "Unknown routines:\n";
for (sort keys(%UNKNOWN)) {
warn "\t$_ called at ", $UNKNOWN{$_}, "\n";
}
}

}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# Note: because of the possibility of placeholders we can't determine arity of
# the block syntactically, so this must be determined via semantic analysis.
# Also, pblocks used in an if/unless statement do not treat $_ as a placeholder,
# while most other blocks treat $_ as equivalent to $^x.  Therefore the first
# possible place to check arity is not here but in the rule that calls this
# rule.  (Could also be done in a later pass.)

## token pblock
##      token pblock {
##          :dba('parameterized block')
##          [ <lambda> <signature> ]? <block>
##      }

sub pblock__PEEK { $_[0]->_AUTOLEXpeek('pblock',$retree) }
sub pblock {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'signature'} = [];
$C->{'lambda'} = [];

$self->_MATCHIFYr($S, "pblock", 
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['lambda'], sub {
my $C = shift;
$C->lambda
}))) {
$C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
});
}
else {
();
}
}
})
}))) {
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
});
}
else {
();
}
}
);
}

## token lambda
##      token lambda { '->' | '<->' }

sub lambda__PEEK { $_[0]->_AUTOLEXpeek('lambda',$retree) }
sub lambda {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "lambda", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'lambda_00') {
$C->deb("Fate passed to lambda_00: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'lambda_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("lambda_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('->')
},
sub { my $C=shift;
$C->_EXACT('<->')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

# Look for an expression followed by a required lambda.
## token xblock
##      token xblock {
##          :my $GOAL is context = '{';
##          <EXPR>
##          <.ws>
##          <pblock>
##      }

sub xblock__PEEK { $_[0]->_AUTOLEXpeek('xblock',$retree) }
sub xblock {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $GOAL =  '{';


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "xblock", 
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token block
##      token block {
##          '{' ~ '}' <statementlist>
##      
##          [
##          | <?before \h* $$> 	# (usual case without comments)
##      	{ @+MEMOS[$.pos]<endstmt> = 2; } {*}                    #= endstmt simple 
##          | \h* <.unsp>? <?before <[,:]>> {*}                         #= normal 
##          | <.unv>? $$
##      	{ @+MEMOS[$.pos]<endstmt> = 2; } {*}                    #= endstmt complex
##          | <.unsp>? { @+MEMOS[$.pos]<endargs> = 1; } {*}             #= endargs
##          ]
##      }

sub block__PEEK { $_[0]->_AUTOLEXpeek('block',$retree) }
sub block {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "block", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'block_01') {
$C->deb("Fate passed to block_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'block_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("block_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'block_endstmt_simple_')
}, scalar(do {
$MEMOS[$C->{_pos}]{'endstmt'} = 2; 
}, $C))
}, $C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G(?m:$)/)
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'block_normal_')
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[,:]/)
}))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'block_endstmt_complex')
}, scalar(do {
$MEMOS[$C->{_pos}]{'endstmt'} = 2; 
}, $C))
}, $C->_PATTERN(qr/\G(?m:$)/))
}, $C->_OPTr(sub { my $C=shift;
$C->unv
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'block_endargs')
}, scalar(do {
$MEMOS[$C->{_pos}]{'endargs'} = 1; 
}, $C))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->FAILGOAL('}' , 'block')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_EXACT('{'))
);
}

## token regex_block
##      token regex_block {
##          :my $lang = ::Regex;
##          :my $GOAL is context = '}';
##      
##          [ <quotepair> <.ws>
##      	{
##      	    my $kv = $<quotepair>[*-1];
##      	    $lang = $lang.tweak($kv.<k>, $kv.<v>)
##                      or self.panic("Unrecognized adverb :" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');
##      	}
##          ]*
##      
##          '{'
##          <nibble( $.cursor_fresh($lang).unbalanced('}') )>
##          [ '}' || <.panic: "Unable to parse regex; couldn't find right brace"> ]
##      
##          [
##          | <?before \h* $$> 	# (usual case without comments)
##      	{ @+MEMOS[$.pos]<endstmt> = 2; } {*}                    #= endstmt simple 
##          | \h* <.unsp>? <?before <[,:]>> {*}                         #= normal 
##          | <.unv>? $$
##      	{ @+MEMOS[$.pos]<endstmt> = 2; } {*}                    #= endstmt complex
##          | <.unsp>? { @+MEMOS[$.pos]<endargs> = 1; }   {*}           #= endargs
##          ]
##      }

sub regex_block__PEEK { $_[0]->_AUTOLEXpeek('regex_block',$retree) }
sub regex_block {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $lang = 'STD::Regex';
local $GOAL =  '}';


my $C = $self;
my $S = $C->{_pos};
$C->{'quotepair'} = [];

$self->_MATCHIFYr($S, "regex_block", 
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
}))) {
do {
if (my ($C) = ($C->ws)) {
scalar(do {
my $M = $C; 
my $kv = $M->{quotepair}[-1];
$lang = $lang->tweak($kv->{'k'}, $kv->{'v'})
or $self->panic("Unrecognized adverb :" . $kv->{'k'} . '(' . $kv->{'v'} . ')');
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble( $C->cursor_fresh($lang)->unbalanced('}') )
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find right brace")} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'regex_block_04') {
$C->deb("Fate passed to regex_block_04: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_block_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_block_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:[\x20\t\r])*+)(?m:$)/)
}))) {
do {
if (my ($C) = (scalar(do {
$MEMOS[$C->{_pos}]{'endstmt'} = 2; 
}, $C))) {
$C->_REDUCE($S, 'regex_block_endstmt_simple_');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[,:]/)
}))) {
$C->_REDUCE($S, 'regex_block_normal_');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unv
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?m:$)/))) {
do {
if (my ($C) = (scalar(do {
$MEMOS[$C->{_pos}]{'endstmt'} = 2; 
}, $C))) {
$C->_REDUCE($S, 'regex_block_endstmt_complex');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = (scalar(do {
$MEMOS[$C->{_pos}]{'endargs'} = 1; 
}, $C))) {
$C->_REDUCE($S, 'regex_block_endargs');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# statement semantics
## rule statementlist
##      rule statementlist {
##          :my $PARSER is context<rw> = self;
##          :dba('statement list')
##          [
##          | $
##          | <?before <[\)\]\}]> >
##          | [<statement><eat_terminator> ]*
##          ]
##      }

sub statementlist__PEEK { $_[0]->_AUTOLEXpeek('statementlist',$retree) }
sub statementlist {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $PARSER =  $self;


my $C = $self;
my $S = $C->{_pos};
$C->{'statement'} = [];
$C->{'eat_terminator'} = [];

$self->_MATCHIFYr($S, "statementlist", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statementlist_01') {
$C->deb("Fate passed to statementlist_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statementlist_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statementlist_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\)\]\}]/))) {
$C->ws;
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# embedded semis, context-dependent semantics
## rule semilist
##      rule semilist {
##          :dba('semicolon list')
##          [
##          | <?before <[\)\]\}]> >
##          | [<statement><eat_terminator> ]*
##          ]
##      }

sub semilist__PEEK { $_[0]->_AUTOLEXpeek('semilist',$retree) }
sub semilist {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'statement'} = [];
$C->{'eat_terminator'} = [];

$self->_MATCHIFYr($S, "semilist", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'semilist_01') {
$C->deb("Fate passed to semilist_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'semilist_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("semilist_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\)\]\}]/))) {
$C->ws;
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token label
##      token label {
##          <identifier> ':' <?before \s> <.ws>
##      
##          [ <?{ $.is_type($<identifier>.text) }>
##            <.panic("You tried to use an existing typename as a label")>
##      #      <suppose("You tried to use an existing name $/{'identifier'} as a label")>
##          ]?
##      
##          # add label as a pseudo type
##          {{ $.add_type($<identifier>.text); }}
##      
##      }

sub label__PEEK { $_[0]->_AUTOLEXpeek('label',$retree) }
sub label {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "label", 
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $C->is_type($M->{identifier}->text) ;
})
}))) {
$C->panic("You tried to use an existing typename as a label");
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C;  $C->add_type($M->{identifier}->text); ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement
##      token statement {
##          :my $endargs is context = -1;
##          <!before <[\)\]\}]> >
##      
##          # this could either be a statement that follows a declaration
##          # or a statement that is within the block of a code declaration
##          <!!{ $ = $+PARSER.bless($); }>
##      
##          [
##          | <label> <statement>                        {*}            #= label
##          | <statement_control>                        {*}            #= control
##          | <EXPR> {*}                                                #= expr
##              :dba('statement end')
##              [
##              || <?{ (@+MEMOS[$.pos]<endstmt> // 0) == 2 }>   # no mod after end-line curly
##              ||
##                  :dba('statement modifier')
##                  <.ws>
##                  [
##                  | <statement_mod_loop> {*}                              #= mod loop
##                  | <statement_mod_cond> {*}                              #= mod cond
##                      :dba('statement modifier loop')
##                      [
##                      || <?{ (@+MEMOS[$.pos]<endstmt> // 0) == 2 }>
##                      || <.ws> <statement_mod_loop>? {*}                  #= mod condloop
##                      ]
##                  ]?
##              ]
##              {*}                                                     #= modexpr
##          | <?before ';'> {*}                                         #= null
##          ]
##      }

sub statement__PEEK { $_[0]->_AUTOLEXpeek('statement',$retree) }
sub statement {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $endargs =  -1;


my $C = $self;
my $S = $C->{_pos};
$C->{'statement_mod_loop'} = [];
$C->{'statement_mod_cond'} = [];

$self->_MATCHIFYr($S, "statement", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\)\]\}]/)
})
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$C = $::PARSER->bless($C); 
})
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_02') {
$C->deb("Fate passed to statement_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['label'], sub {
my $C = shift;
$C->label
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
$C->_REDUCE($S, 'statement_label');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement_control'], sub {
my $C = shift;
$C->statement_control
}))) {
$C->_REDUCE($S, 'statement_control');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_expr'))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
($MEMOS[$C->{_pos}]{'endstmt'} // 0) == 2 
})
})} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_05') {
$C->deb("Fate passed to statement_05: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement_mod_loop'], sub {
my $C = shift;
$C->statement_mod_loop
}))) {
$C->_REDUCE($S, 'statement_mod_loop');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['statement_mod_cond'], sub {
my $C = shift;
$C->statement_mod_cond
}))) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_cond'))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
($MEMOS[$C->{_pos}]{'endstmt'} // 0) == 2 
})
})} 
or
eval { push @gather, do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['statement_mod_loop'], sub {
my $C = shift;
$C->statement_mod_loop
})
}))) {
$C->_REDUCE($S, 'statement_mod_condloop');
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_REDUCE($S, 'statement_modexpr');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT(';')
}))) {
$C->_REDUCE($S, 'statement_null');
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
);
}


## token eat_terminator
##      token eat_terminator {
##          [
##          || ';'
##          || <?{ @+MEMOS[$.pos]<endstmt> }> <.ws>
##          || <?terminator>
##          || $
##          || {{ if @+MEMOS[$.pos]<ws> { $.pos = @+MEMOS[$.pos]<ws>; } }}   # undo any line transition
##              <.panic: "Syntax error">
##          ]
##      }

sub eat_terminator__PEEK { $_[0]->_AUTOLEXpeek('eat_terminator',$retree) }
sub eat_terminator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "eat_terminator", 
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(';')} 
or
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$MEMOS[$C->{_pos}]{'endstmt'} 
})
}))) {
$C->ws;
}
else {
();
}
}} 
or
eval { push @gather, $C->before( sub { my $C=shift;
$C->terminator
})} 
or
eval { push @gather, $C->_PATTERN(qr/\G\z/)} 
or
eval { push @gather, do {
if (my ($C) = (scalar(do {
if ($MEMOS[$C->{_pos}]{'ws'}) { $C->{_pos} = $MEMOS[$C->{_pos}]{'ws'}; } 
}, $C))) {
$C->panic("Syntax error");
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
})
);
}

## token statement_control__S_034use (:$endsym is context = 'spacey', :$sym is context<rw> = 'use')
##      token statement_control:use {
##          <sym> :s
##          [
##          | <version>
##          | <module_name><arglist>?
##              {{
##                  my $longname = $<module_name><longname>;
##                  $.add_type($longname.text);
##              }}
##          ]
##      }

sub statement_control__S_034use__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_034use',$retree) }
sub statement_control__S_034use {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'use';


my $C = $self;
my $S = $C->{_pos};
$C->{'arglist'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_034use", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Guse/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_control__S_034use_01') {
$C->deb("Fate passed to statement_control__S_034use_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_034use_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_034use_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
my $longname = $M->{module_name}{longname};
$C->add_type($longname->text);
;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_035no (:$endsym is context = 'spacey', :$sym is context<rw> = 'no')
##      token statement_control:no {
##          <sym> :s
##          <module_name><arglist>?
##      }

sub statement_control__S_035no__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_035no',$retree) }
sub statement_control__S_035no {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'no';


my $C = $self;
my $S = $C->{_pos};
$C->{'arglist'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_035no", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gno/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_036if (:$endsym is context = 'spacey', :$sym is context<rw> = 'if')
##      token statement_control:if {
##          <sym> :s
##          <xblock>
##          [$<elsif> = (
##              'elsif'<?spacey> <xblock>       {*}                #= elsif
##          )]*
##          [$<else> = (
##              'else'<?spacey> <pblock>       {*}             #= else
##          )]?
##      }

sub statement_control__S_036if__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_036if',$retree) }
sub statement_control__S_036if {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'if';


my $C = $self;
my $S = $C->{_pos};
$C->{'else'} = [];
$C->{'elsif'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_036if", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gif/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_SUBSUMEr(['elsif'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('elsif'))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->spacey
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_036if_elsif'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})}
})
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_SUBSUMEr(['else'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('else'))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->spacey
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_036if_else'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})}
})
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_037unless (:$endsym is context = 'spacey', :$sym is context<rw> = 'unless')
##      token statement_control:unless {
##          <sym> :s
##          <xblock>
##          [ <!before 'else'> || <.panic: "unless does not take \"else\" in Perl 6; please rewrite using \"if\""> ]
##      }

sub statement_control__S_037unless__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_037unless',$retree) }
sub statement_control__S_037unless {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'unless';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_037unless", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gunless/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('else')
})
}))) {
$C->ws;
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("unless does not take \"else\" in Perl 6; please rewrite using \"if\""))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_038while (:$endsym is context = 'spacey', :$sym is context<rw> = 'while')
##      token statement_control:while {
##          <sym> :s
##          [ <?before '(' ['my'? '$'\w+ '=']? '<' '$'?\w+ '>' ')'>   #'
##              <.panic: "This appears to be Perl 5 code"> ]?
##          <xblock>
##      }

sub statement_control__S_038while__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_038while',$retree) }
sub statement_control__S_038while {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'while';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_038while", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhile/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('my')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('$'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT('=');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('$')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('>'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("This appears to be Perl 5 code"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_039until (:$endsym is context = 'spacey', :$sym is context<rw> = 'until')
##      token statement_control:until {
##          <sym> :s
##          <xblock>
##      }

sub statement_control__S_039until__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_039until',$retree) }
sub statement_control__S_039until {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'until';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_039until", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Guntil/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_040repeat (:$endsym is context = 'spacey', :$sym is context<rw> = 'repeat')
##      token statement_control:repeat {
##          <sym> :s
##          [
##              | ('while'|'until')
##                <xblock>
##              | <block>                      {*}                      #= block wu
##                ('while'|'until') <EXPR>         {*}                      #= expr wu
##          ]
##      }

sub statement_control__S_040repeat__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_040repeat',$retree) }
sub statement_control__S_040repeat {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'repeat';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_040repeat", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grepeat/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_control__S_040repeat_01') {
$C->deb("Fate passed to statement_control__S_040repeat_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_040repeat_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_040repeat_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_control__S_040repeat_02') {
$C->deb("Fate passed to statement_control__S_040repeat_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_040repeat_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_040repeat_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('while')
},
sub { my $C=shift;
$C->_EXACT('until')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_040repeat_block_wu'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['1'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'statement_control__S_040repeat_03') {
$C->deb("Fate passed to statement_control__S_040repeat_03: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'statement_control__S_040repeat_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("statement_control__S_040repeat_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('while')
},
sub { my $C=shift;
$C->_EXACT('until')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_040repeat_expr_wu'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_041loop (:$endsym is context = 'spacey', :$sym is context<rw> = 'loop')
##      token statement_control:loop {
##          <sym> :s
##          $<eee> = (
##              '('
##                  <e1=EXPR>? ';'   {*}                            #= e1
##                  <e2=EXPR>? ';'   {*}                            #= e2
##                  <e3=EXPR>?       {*}                            #= e3
##              ')'                      {*}                            #= eee
##          )?
##          <block>                     {*}                             #= block
##      }

sub statement_control__S_041loop__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_041loop',$retree) }
sub statement_control__S_041loop {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'loop';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_041loop", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gloop/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['eee'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['e1','EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_041loop_e1'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['e2','EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(';'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_041loop_e2'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['e3','EXPR'], sub {
my $C = shift;
$C->EXPR
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_041loop_e3'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT(')'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_041loop_eee'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_control__S_041loop_block'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token statement_control__S_042for (:$endsym is context = 'spacey', :$sym is context<rw> = 'for')
##      token statement_control:for {
##          <sym> :s
##          [ <?before 'my'? '$'\w+ '(' >
##              <.panic: "This appears to be Perl 5 code"> ]?
##          <xblock>
##      }

sub statement_control__S_042for__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_042for',$retree) }
sub statement_control__S_042for {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'for';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_042for", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gfor/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('my')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('$'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('('))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->panic("This appears to be Perl 5 code"))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement_control__S_043given (:$endsym is context = 'spacey', :$sym is context<rw> = 'given')
##      token statement_control:given {
##          <sym> :s
##          <xblock>
##      }

sub statement_control__S_043given__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_043given',$retree) }
sub statement_control__S_043given {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'given';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_043given", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggiven/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_control__S_044when (:$endsym is context = 'spacey', :$sym is context<rw> = 'when')
##      token statement_control:when {
##          <sym> :s
##          <xblock>
##      }

sub statement_control__S_044when__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_044when',$retree) }
sub statement_control__S_044when {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'when';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_044when", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhen/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_045default (:$endsym is context = 'spacey', :$sym is context<rw> = 'default')
##      rule statement_control:default {<sym> <block> }

sub statement_control__S_045default__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_045default',$retree) }
sub statement_control__S_045default {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'default';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_045default", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdefault/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_control__S_046BEGIN (:$endsym is context = 'spacey', :$sym is context<rw> = 'BEGIN')
##      rule statement_control:BEGIN   {<sym> <block> }

sub statement_control__S_046BEGIN__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_046BEGIN',$retree) }
sub statement_control__S_046BEGIN {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'BEGIN';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_046BEGIN", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GBEGIN/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_047CHECK (:$endsym is context = 'spacey', :$sym is context<rw> = 'CHECK')
##      rule statement_control:CHECK   {<sym> <block> }

sub statement_control__S_047CHECK__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_047CHECK',$retree) }
sub statement_control__S_047CHECK {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'CHECK';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_047CHECK", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCHECK/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_048INIT (:$endsym is context = 'spacey', :$sym is context<rw> = 'INIT')
##      rule statement_control:INIT    {<sym> <block> }

sub statement_control__S_048INIT__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_048INIT',$retree) }
sub statement_control__S_048INIT {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'INIT';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_048INIT", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GINIT/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_049END (:$endsym is context = 'spacey', :$sym is context<rw> = 'END')
##      rule statement_control:END     {<sym> <block> }

sub statement_control__S_049END__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_049END',$retree) }
sub statement_control__S_049END {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'END';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_049END", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GEND/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_050START (:$endsym is context = 'spacey', :$sym is context<rw> = 'START')
##      rule statement_control:START   {<sym> <block> }

sub statement_control__S_050START__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_050START',$retree) }
sub statement_control__S_050START {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'START';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_050START", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GSTART/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_051ENTER (:$endsym is context = 'spacey', :$sym is context<rw> = 'ENTER')
##      rule statement_control:ENTER   {<sym> <block> }

sub statement_control__S_051ENTER__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_051ENTER',$retree) }
sub statement_control__S_051ENTER {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'ENTER';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_051ENTER", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GENTER/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_052LEAVE (:$endsym is context = 'spacey', :$sym is context<rw> = 'LEAVE')
##      rule statement_control:LEAVE   {<sym> <block> }

sub statement_control__S_052LEAVE__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_052LEAVE',$retree) }
sub statement_control__S_052LEAVE {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'LEAVE';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_052LEAVE", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GLEAVE/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_053KEEP (:$endsym is context = 'spacey', :$sym is context<rw> = 'KEEP')
##      rule statement_control:KEEP    {<sym> <block> }

sub statement_control__S_053KEEP__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_053KEEP',$retree) }
sub statement_control__S_053KEEP {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'KEEP';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_053KEEP", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GKEEP/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_054UNDO (:$endsym is context = 'spacey', :$sym is context<rw> = 'UNDO')
##      rule statement_control:UNDO    {<sym> <block> }

sub statement_control__S_054UNDO__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_054UNDO',$retree) }
sub statement_control__S_054UNDO {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'UNDO';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_054UNDO", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GUNDO/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_055FIRST (:$endsym is context = 'spacey', :$sym is context<rw> = 'FIRST')
##      rule statement_control:FIRST   {<sym> <block> }

sub statement_control__S_055FIRST__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_055FIRST',$retree) }
sub statement_control__S_055FIRST {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'FIRST';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_055FIRST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GFIRST/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_056NEXT (:$endsym is context = 'spacey', :$sym is context<rw> = 'NEXT')
##      rule statement_control:NEXT    {<sym> <block> }

sub statement_control__S_056NEXT__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_056NEXT',$retree) }
sub statement_control__S_056NEXT {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'NEXT';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_056NEXT", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GNEXT/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_057LAST (:$endsym is context = 'spacey', :$sym is context<rw> = 'LAST')
##      rule statement_control:LAST    {<sym> <block> }

sub statement_control__S_057LAST__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_057LAST',$retree) }
sub statement_control__S_057LAST {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'LAST';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_057LAST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GLAST/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_058PRE (:$endsym is context = 'spacey', :$sym is context<rw> = 'PRE')
##      rule statement_control:PRE     {<sym> <block> }

sub statement_control__S_058PRE__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_058PRE',$retree) }
sub statement_control__S_058PRE {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'PRE';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_058PRE", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GPRE/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_059POST (:$endsym is context = 'spacey', :$sym is context<rw> = 'POST')
##      rule statement_control:POST    {<sym> <block> }

sub statement_control__S_059POST__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_059POST',$retree) }
sub statement_control__S_059POST {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'POST';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_059POST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GPOST/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_060CATCH (:$endsym is context = 'spacey', :$sym is context<rw> = 'CATCH')
##      rule statement_control:CATCH   {<sym> <block> }

sub statement_control__S_060CATCH__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_060CATCH',$retree) }
sub statement_control__S_060CATCH {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'CATCH';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_060CATCH", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCATCH/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_061CONTROL (:$endsym is context = 'spacey', :$sym is context<rw> = 'CONTROL')
##      rule statement_control:CONTROL {<sym> <block> }

sub statement_control__S_061CONTROL__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_061CONTROL',$retree) }
sub statement_control__S_061CONTROL {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'CONTROL';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_061CONTROL", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCONTROL/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_control__S_062TEMP (:$endsym is context = 'spacey', :$sym is context<rw> = 'TEMP')
##      rule statement_control:TEMP    {<sym> <block> }

sub statement_control__S_062TEMP__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_062TEMP',$retree) }
sub statement_control__S_062TEMP {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'TEMP';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_control__S_062TEMP", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GTEMP/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule term__S_063BEGIN (:$sym is context<rw> = 'BEGIN')
##      rule term:BEGIN   {<sym> <block> }

sub term__S_063BEGIN__PEEK { $_[0]->_AUTOLEXpeek('term__S_063BEGIN',$retree) }
sub term__S_063BEGIN {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'BEGIN';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_063BEGIN", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GBEGIN/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_064CHECK (:$sym is context<rw> = 'CHECK')
##      rule term:CHECK   {<sym> <block> }

sub term__S_064CHECK__PEEK { $_[0]->_AUTOLEXpeek('term__S_064CHECK',$retree) }
sub term__S_064CHECK {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'CHECK';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_064CHECK", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GCHECK/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_065INIT (:$sym is context<rw> = 'INIT')
##      rule term:INIT    {<sym> <block> }

sub term__S_065INIT__PEEK { $_[0]->_AUTOLEXpeek('term__S_065INIT',$retree) }
sub term__S_065INIT {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'INIT';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_065INIT", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GINIT/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_066START (:$sym is context<rw> = 'START')
##      rule term:START   {<sym> <block> }

sub term__S_066START__PEEK { $_[0]->_AUTOLEXpeek('term__S_066START',$retree) }
sub term__S_066START {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'START';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_066START", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GSTART/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_067ENTER (:$sym is context<rw> = 'ENTER')
##      rule term:ENTER   {<sym> <block> }

sub term__S_067ENTER__PEEK { $_[0]->_AUTOLEXpeek('term__S_067ENTER',$retree) }
sub term__S_067ENTER {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'ENTER';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_067ENTER", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GENTER/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule term__S_068FIRST (:$sym is context<rw> = 'FIRST')
##      rule term:FIRST   {<sym> <block> }

sub term__S_068FIRST__PEEK { $_[0]->_AUTOLEXpeek('term__S_068FIRST',$retree) }
sub term__S_068FIRST {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'FIRST';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_068FIRST", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GFIRST/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule modifier_expr
##      rule modifier_expr { <EXPR> }

sub modifier_expr__PEEK { $_[0]->_AUTOLEXpeek('modifier_expr',$retree) }
sub modifier_expr {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "modifier_expr", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_mod_cond__S_069if (:$sym is context<rw> = 'if')
##      rule statement_mod_cond:if     {<sym> <modifier_expr> {*} }     #= if

sub statement_mod_cond__S_069if__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_069if',$retree) }
sub statement_mod_cond__S_069if {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'if';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_cond__S_069if", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gif/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_cond__S_069if_if'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_cond__S_070unless (:$sym is context<rw> = 'unless')
##      rule statement_mod_cond:unless {<sym> <modifier_expr> {*} }     #= unless

sub statement_mod_cond__S_070unless__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_070unless',$retree) }
sub statement_mod_cond__S_070unless {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'unless';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_cond__S_070unless", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gunless/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_cond__S_070unless_unless'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_cond__S_071when (:$sym is context<rw> = 'when')
##      rule statement_mod_cond:when   {<sym> <modifier_expr> {*} }     #= when

sub statement_mod_cond__S_071when__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_071when',$retree) }
sub statement_mod_cond__S_071when {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'when';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_cond__S_071when", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhen/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_cond__S_071when_when'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_mod_loop__S_072while (:$sym is context<rw> = 'while')
##      rule statement_mod_loop:while {<sym> <modifier_expr> {*} }      #= while

sub statement_mod_loop__S_072while__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_072while',$retree) }
sub statement_mod_loop__S_072while {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'while';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_072while", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwhile/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_loop__S_072while_while'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_loop__S_073until (:$sym is context<rw> = 'until')
##      rule statement_mod_loop:until {<sym> <modifier_expr> {*} }      #= until

sub statement_mod_loop__S_073until__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_073until',$retree) }
sub statement_mod_loop__S_073until {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'until';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_073until", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Guntil/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_loop__S_073until_until'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule statement_mod_loop__S_074for (:$sym is context<rw> = 'for')
##      rule statement_mod_loop:for   {<sym> <modifier_expr> {*} }      #= for

sub statement_mod_loop__S_074for__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_074for',$retree) }
sub statement_mod_loop__S_074for {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'for';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_074for", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gfor/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_loop__S_074for_for'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule statement_mod_loop__S_075given (:$sym is context<rw> = 'given')
##      rule statement_mod_loop:given {<sym> <modifier_expr> {*} }      #= given

sub statement_mod_loop__S_075given__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_075given',$retree) }
sub statement_mod_loop__S_075given {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'given';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_mod_loop__S_075given", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggiven/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'statement_mod_loop__S_075given_given'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token module_name__S_076normal (:$sym is context<rw> = 'normal')
##      token module_name:normal {
##          <longname>
##          [ <?{ ($+PKGDECL//'') eq 'role' }> <?before '['> <postcircumfix> ]?
##      }

sub module_name__S_076normal__PEEK { $_[0]->_AUTOLEXpeek('module_name__S_076normal',$retree) }
sub module_name__S_076normal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'normal';


my $C = $self;
my $S = $C->{_pos};
$C->{'postcircumfix'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "module_name__S_076normal", 
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
($::PKGDECL//'') eq 'role' 
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

## token module_name__S_077deprecated (:$sym is context<rw> = 'deprecated')
##      token module_name:deprecated { 'v6-alpha' }

sub module_name__S_077deprecated__PEEK { $_[0]->_AUTOLEXpeek('module_name__S_077deprecated',$retree) }
sub module_name__S_077deprecated {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'deprecated';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "module_name__S_077deprecated", 
$C->_EXACT('v6-alpha')
);
}

## token vnum
##      token vnum {
##          \d+ | '*'
##      }

sub vnum__PEEK { $_[0]->_AUTOLEXpeek('vnum',$retree) }
sub vnum {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "vnum", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'vnum_00') {
$C->deb("Fate passed to vnum_00: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'vnum_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("vnum_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_EXACT('*')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

## token version__S_078v (:$sym is context<rw> = <v>)
##      token version:sym<v> {
##          'v' <?before \d> :: <vnum> ** '.' '+'?
##      }

sub version__S_078v__PEEK { $_[0]->_AUTOLEXpeek('version__S_078v',$retree) }
sub version__S_078v {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(v);


my $C = $self;
my $S = $C->{_pos};
$C->{'vnum'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "version__S_078v", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_EXACT('+')
})
}, $C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT('.')
}, sub { my $C=shift;
$C->_SUBSUME(['vnum'], sub {
my $C = shift;
$C->vnum
})
}))
}, $C->_COMMITBRANCH())
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\d/)
}))
}, $C->_EXACT('v'))
);
}

###################################################

## token PRE
##      token PRE {
##          :dba('prefix or meta-prefix')
##          [
##          | <prefix>
##              { $<O> = $<prefix><O>; $<sym> = $<prefix><sym> }
##                                                          {*}         #= prefix
##          | <prefix_circumfix_meta_operator>
##              { $<O> = $<prefix_circumfix_meta_operator><O>; $<sym> = $<prefix_circumfix_meta_operator>.text }
##                                                          {*}         #= precircum
##          ]
##          # XXX assuming no precedence change
##          
##          <prefix_postfix_meta_operator>*                 {*}         #= prepost
##          <.ws>
##      }

sub PRE__PEEK { $_[0]->_AUTOLEXpeek('PRE',$retree) }
sub PRE {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'prefix_postfix_meta_operator'} = [];

$self->_MATCHIFYr($S, "PRE", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'PRE_01') {
$C->deb("Fate passed to PRE_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'PRE_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("PRE_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['prefix'], sub {
my $C = shift;
$C->prefix
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{O} = $M->{prefix}{O}; $M->{sym} = $M->{prefix}{sym} ;
}, $C))) {
$C->_REDUCE($S, 'PRE_prefix');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['prefix_circumfix_meta_operator'], sub {
my $C = shift;
$C->prefix_circumfix_meta_operator
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{O} = $M->{prefix_circumfix_meta_operator}{O}; $M->{sym} = $M->{prefix_circumfix_meta_operator}->text ;
}, $C))) {
$C->_REDUCE($S, 'PRE_precircum');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['prefix_postfix_meta_operator'], sub {
my $C = shift;
$C->prefix_postfix_meta_operator
})
}))) {
do {
if (my ($C) = ($C->_REDUCE($S, 'PRE_prepost'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# (for when you want to tell EXPR that infix already parsed the term)
## token nullterm
##      token nullterm {
##          <?>
##      }

sub nullterm__PEEK { $_[0]->_AUTOLEXpeek('nullterm',$retree) }
sub nullterm {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "nullterm", 
$C->before( sub { my $C=shift;
$C
})
);
}

## token nulltermish
##      token nulltermish {
##          :dba('null term')
##          [
##          | <?stdstopper>
##          | <termish>?
##          ]
##      }

sub nulltermish__PEEK { $_[0]->_AUTOLEXpeek('nulltermish',$retree) }
sub nulltermish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'termish'} = [];

$self->_MATCHIFYr($S, "nulltermish", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'nulltermish_01') {
$C->deb("Fate passed to nulltermish_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'nulltermish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("nulltermish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->stdstopper
})
},
sub { my $C=shift;
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['termish'], sub {
my $C = shift;
$C->termish
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token termish
##      token termish {
##          :dba('prefix or noun')
##          [
##          | <PRE>+ <noun>
##          | <noun>
##          ]
##      
##          # also queue up any postfixes
##          :dba('postfix')
##          [ <?stdstopper> ||
##      	<POST>*
##          ]
##      }

sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish',$retree) }
sub termish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'PRE'} = [];
$C->{'POST'} = [];

$self->_MATCHIFYr($S, "termish", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'termish_01') {
$C->deb("Fate passed to termish_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'termish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("termish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['PRE'], sub {
my $C = shift;
$C->PRE
})
}))) {
$C->_SUBSUMEr(['noun'], sub {
my $C = shift;
$C->noun
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['noun'], sub {
my $C = shift;
$C->noun
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
$C->stdstopper
})} 
or
eval { push @gather, $C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['POST'], sub {
my $C = shift;
$C->POST
})
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
}
);
}

## token noun
##      token noun {
##          [
##          | <fatarrow>
##          | <variable> { $<SIGIL> = $<variable><sigil> }
##          | <package_declarator>
##          | <scope_declarator>
##          | <?before 'multi'|'proto'|'only'> <multi_declarator>
##          | <routine_declarator>
##          | <regex_declarator>
##          | <type_declarator>
##          | <circumfix>
##          | <dotty>
##          | <value>
##          | <capterm>
##          | <sigterm>
##          | <term>
##          | <statement_prefix>
##          | [ <colonpair> <.ws> ]+
##          ]
##      }

sub noun__PEEK { $_[0]->_AUTOLEXpeek('noun',$retree) }
sub noun {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "noun", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'noun_01') {
$C->deb("Fate passed to noun_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'noun_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("noun_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['fatarrow'], sub {
my $C = shift;
$C->fatarrow
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;  $M->{SIGIL} = $M->{variable}{sigil} ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['package_declarator'], sub {
my $C = shift;
$C->package_declarator
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['scope_declarator'], sub {
my $C = shift;
$C->scope_declarator
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'noun_02') {
$C->deb("Fate passed to noun_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'noun_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("noun_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('multi')
},
sub { my $C=shift;
$C->_EXACT('proto')
},
sub { my $C=shift;
$C->_EXACT('only')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['routine_declarator'], sub {
my $C = shift;
$C->routine_declarator
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['type_declarator'], sub {
my $C = shift;
$C->type_declarator
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['dotty'], sub {
my $C = shift;
$C->dotty
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['value'], sub {
my $C = shift;
$C->value
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['capterm'], sub {
my $C = shift;
$C->capterm
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['sigterm'], sub {
my $C = shift;
$C->sigterm
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['statement_prefix'], sub {
my $C = shift;
$C->statement_prefix
})
},
sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
$C->ws;
}
else {
();
}
}
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}


## token fatarrow
##      token fatarrow {
##          <key=identifier> \h* '=>' <.ws> <val=EXPR(item %item_assignment)>
##      }

sub fatarrow__PEEK { $_[0]->_AUTOLEXpeek('fatarrow',$retree) }
sub fatarrow {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "fatarrow", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['key'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('=>'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['val'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token colonpair
##      token colonpair {
##          :my $key;
##          :my $value;
##      
##          ':'
##          :dba('colon pair')
##          [
##          | '!' <identifier>
##              { $key = $<identifier>.text; $value = 0; }
##              {*}                                                     #= false
##          | $<num> = [\d+] <identifier>
##          | <identifier>
##              { $key = $<identifier>.text; }
##              [
##              || <.unsp>? '.'? <postcircumfix> { $value = $<postcircumfix>; }
##              || { $value = 1; }
##              ]
##              {*}                                                     #= value
##          | :dba('signature') '(' ~ ')' <signature>
##          | <postcircumfix>
##              { $key = ""; $value = $<postcircumfix>; }
##              {*}                                                     #= structural
##          | $<var> = (<sigil> {} <twigil>? <desigilname>)
##              { $key = $<var><desigilname>.text; $value = $<var>; }
##              {*}                                                     #= varname
##          ]
##          { $<k> = $key; $<v> = $value; }
##      }

sub colonpair__PEEK { $_[0]->_AUTOLEXpeek('colonpair',$retree) }
sub colonpair {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $key;
my $value;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "colonpair", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{k} = $key; $M->{v} = $value; ;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'colonpair_01') {
$C->deb("Fate passed to colonpair_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'colonpair_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("colonpair_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{identifier}->text; $value = 0; ;
}, $C))) {
$C->_REDUCE($S, 'colonpair_false');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['num'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})
}))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{identifier}->text; ;
}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('.')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
my $M = $C;  $value = $M->{postcircumfix}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, scalar(do {
$value = 1; 
}, $C)} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_REDUCE($S, 'colonpair_value');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'signature')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'colonpair_structural')
}, scalar(do {
my $M = $C;  $key = ""; $value = $M->{postcircumfix}; ;
}, $C))
}, $C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'colonpair_varname')
}, scalar(do {
my $M = $C;  $key = $M->{var}{desigilname}->text; $value = $M->{var}; ;
}, $C))
},     $C->_SUBSUME(['var'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
}, scalar(do {

}, $C))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
})}
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_EXACT(':'))
);
}

## token quotepair
##      token quotepair {
##          :my $key;
##          :my $value;
##      
##          ':'
##          :dba('colon pair (restricted)')
##          [
##          | '!' <identifier>
##              { $key = $<identifier>.text; $value = 0; }
##              {*}                                                     #= false
##          | <identifier>
##              { $key = $<identifier>.text; }
##              [
##              || <.unsp>? '.'? <?before '('> <postcircumfix> { $value = $<postcircumfix>; }
##              || { $value = 1; }
##              ]
##              {*}                                                     #= value
##          | $<n>=(\d+) $<id>=(<[a..z]>+)
##              { $key = $<id>.text; $value = $<n>.text; }
##              {*}                                                     #= nth
##          ]
##          { $<k> = $key; $<v> = $value; }
##      }

sub quotepair__PEEK { $_[0]->_AUTOLEXpeek('quotepair',$retree) }
sub quotepair {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $key;
my $value;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "quotepair", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quotepair_01') {
$C->deb("Fate passed to quotepair_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quotepair_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quotepair_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{identifier}->text; $value = 0; ;
}, $C))) {
$C->_REDUCE($S, 'quotepair_false');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{identifier}->text; ;
}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('.')
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('(')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
my $M = $C;  $value = $M->{postcircumfix}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, scalar(do {
$value = 1; 
}, $C)} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_REDUCE($S, 'quotepair_value');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['n'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['id'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:[a-z])++)/)
})}
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $key = $M->{id}->text; $value = $M->{n}->text; ;
}, $C))) {
$C->_REDUCE($S, 'quotepair_nth');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
my $M = $C;  $M->{k} = $key; $M->{v} = $value; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infixish
##      token infixish {
##          <!stdstopper>
##          <!infixstopper>
##          :dba('infix or meta-infix')
##          [
##          | <colonpair> {
##                  $<fake> = 1;
##                  $<sym> = ':';
##                  %<O><prec> = %loose_unary<prec>;
##                  %<O><assoc> = 'left';
##              }
##          | <infix>
##                 { $<O> = $<infix>.<O>; $<sym> = $<infix>.<sym>; }
##          | <infix_prefix_meta_operator>
##              { $<O> = $<infix_prefix_meta_operator><O>;
##                $<sym> = $<infix_prefix_meta_operator><sym>; }
##          | <infix_circumfix_meta_operator>
##              { $<O> = $<infix_circumfix_meta_operator><O>;
##                $<sym> = $<infix_circumfix_meta_operator><sym>; }
##          | <infix> <?before '='> <infix_postfix_meta_operator($<infix>)>
##                 { $<O> = $<infix_postfix_meta_operator>.<O>; $<sym> = $<infix_postfix_meta_operator>.<sym>; }
##          ]
##      }

sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish',$retree) }
sub infixish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "infixish", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infixish_01') {
$C->deb("Fate passed to infixish_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infixish_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixish_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
scalar(do {
my $M = $C; 
$M->{fake} = 1;
$M->{sym} = ':';
$M->{O}{prec} = $loose_unary{prec};
$M->{O}{assoc} = 'left';
;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['infix'], sub {
my $C = shift;
$C->infix
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{infix}->{'O'}; $M->{sym} = $M->{infix}->{'sym'}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['infix_prefix_meta_operator'], sub {
my $C = shift;
$C->infix_prefix_meta_operator
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{infix_prefix_meta_operator}{O};
$M->{sym} = $M->{infix_prefix_meta_operator}{sym}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['infix_circumfix_meta_operator'], sub {
my $C = shift;
$C->infix_circumfix_meta_operator
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{infix_circumfix_meta_operator}{O};
$M->{sym} = $M->{infix_circumfix_meta_operator}{sym}; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['infix'], sub {
my $C = shift;
$C->infix
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('=')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infix_postfix_meta_operator'], sub {
my $C = shift;
do { my $M = $C;
$C->infix_postfix_meta_operator($M->{infix})
; }
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{infix_postfix_meta_operator}->{'O'}; $M->{sym} = $M->{infix_postfix_meta_operator}->{'sym'}; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
);
}

# doing fancy as one rule simplifies LTM
## token dotty__S_079DotStar (:$endsym is context = 'unspacey'  , :$sym is context<rw> = <.*> --> Methodcall)
##      token dotty:sym<.*> ( --> Methodcall) {
##          ('.' [ <[+*?=:]> | '^' '!'? ]) :: <.unspacey> <dottyop>
##          { $<sym> = $0.item; }
##      }

sub dotty__S_079DotStar__PEEK { $_[0]->_AUTOLEXpeek('dotty__S_079DotStar',$retree) }
sub dotty__S_079DotStar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'unspacey'  ;
local $sym = $args{sym} // q(.*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "dotty__S_079DotStar",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{sym} = $$C{0}->item; ;
}, $C)
}, $C->_SUBSUME(['dottyop'], sub {
my $C = shift;
$C->dottyop
}))
}, $C->unspacey)
}, $C->_COMMITBRANCH())
},     $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'dotty__S_079DotStar_02') {
$C->deb("Fate passed to dotty__S_079DotStar_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dotty__S_079DotStar_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dotty__S_079DotStar_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G[+*?=:]/)
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('^'))) {
$C->_OPTr(sub { my $C=shift;
$C->_EXACT('!')
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
})}
}))
);
}

## token dotty__S_080Dot (:$endsym is context = 'unspacey'  , :$sym is context<rw> = <.> --> Methodcall)
##      token dotty:sym<.> ( --> Methodcall) {
##          <sym> <dottyop>
##      }

sub dotty__S_080Dot__PEEK { $_[0]->_AUTOLEXpeek('dotty__S_080Dot',$retree) }
sub dotty__S_080Dot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'unspacey'  ;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "dotty__S_080Dot",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\./))) {
do {
if (my ($C) = ($C->unspacey)) {
$C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token privop ( --> Methodcall)
##      token privop ( --> Methodcall) {
##          '!' <methodop>
##      }

sub privop__PEEK { $_[0]->_AUTOLEXpeek('privop',$retree) }
sub privop {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "privop",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('!'))) {
$C->_SUBSUMEr(['methodop'], sub {
my $C = shift;
$C->methodop
});
}
else {
();
}
}
);
}

## token dottyop
##      token dottyop {
##          :dba('dotty method or postfix')
##          [
##          | <methodop>
##          | <postop>     # forcing postop's precedence to methodcall here
##          ]
##      }

sub dottyop__PEEK { $_[0]->_AUTOLEXpeek('dottyop',$retree) }
sub dottyop {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "dottyop", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'dottyop_01') {
$C->deb("Fate passed to dottyop_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dottyop_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dottyop_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['methodop'], sub {
my $C = shift;
$C->methodop
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['postop'], sub {
my $C = shift;
$C->postop
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# Note, this rule mustn't do anything irreversible because it's used
# as a lookahead by the quote interpolator.

## token POST
##      token POST {
##          <!stdstopper>
##      
##          # last whitespace didn't end here
##          <!{ @+MEMOS[$.pos]<ws> }>
##      
##          [ <.unsp> | '\\' <?before '.'> ]?
##      
##          [ ['.' <.unsp>?]? <postfix_prefix_meta_operator> <.unsp>? ]*
##      
##          :dba('postfix')
##          [
##          | <dotty>  { $<O> = $<dotty><O> }
##          | <privop> { $<O> = $<privop><O> }
##          | <postop> { $<O> = $<postop><O> }
##          ]
##      }

sub POST__PEEK { $_[0]->_AUTOLEXpeek('POST',$retree) }
sub POST {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'postfix_prefix_meta_operator'} = [];

$self->_MATCHIFYr($S, "POST", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$MEMOS[$C->{_pos}]{'ws'} 
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'POST_01') {
$C->deb("Fate passed to POST_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'POST_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("POST_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->unsp
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('\\'))) {
$C->before(sub { my $C=shift;
$C->_EXACT('.')
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_OPTr(sub { my $C=shift;
$C->unsp
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postfix_prefix_meta_operator'], sub {
my $C = shift;
$C->postfix_prefix_meta_operator
}))) {
$C->_OPTr(sub { my $C=shift;
$C->unsp
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'POST_05') {
$C->deb("Fate passed to POST_05: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'POST_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("POST_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['dotty'], sub {
my $C = shift;
$C->dotty
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{dotty}{O} ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['privop'], sub {
my $C = shift;
$C->privop
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{privop}{O} ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['postop'], sub {
my $C = shift;
$C->postop
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{postop}{O} ;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## regex prefix_circumfix_meta_operator__S_081reduce ( :$sym is context<rw> = 'reduce' --> List_prefix)
##      regex prefix_circumfix_meta_operator:reduce (--> List_prefix) {
##          $<s> = (
##              '['
##              [
##              | <op=infix> ']' [''|<?>]
##              | <op=infix_prefix_meta_operator> ']' [''|<?>]
##              | <op=infix_circumfix_meta_operator> ']' [''|<?>]
##              | \\<op=infix> ']' [''|<?>]
##              | \\<op=infix_prefix_meta_operator> ']' [''|<?>]
##              | \\<op=infix_circumfix_meta_operator> ']' [''|<?>]
##              ]
##          ) <?before \s | '(' >
##      
##          { $<O> = $<s><op><O>; $<sym> = $<s>.text; }
##      
##          [ <!{ $<O><assoc> eq 'non' }>
##              || <.panic: "Can't reduce a non-associative operator"> ]
##      
##          [ <!{ $<O><prec> eq %conditional<prec> }>
##              || <.panic: "Can't reduce a conditional operator"> ]
##      
##          { $<O><assoc> = 'unary'; }
##      
##      }

sub prefix_circumfix_meta_operator__S_081reduce__PEEK { $_[0]->_AUTOLEXpeek('prefix_circumfix_meta_operator__S_081reduce',$retree) }
sub prefix_circumfix_meta_operator__S_081reduce {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'reduce';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "prefix_circumfix_meta_operator__S_081reduce",  Cursor::lazymap sub { STD::List_prefix->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
my $M = $C;  $M->{O}{assoc} = 'unary'; ;
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O}{prec} eq $conditional{prec} ;
})
})} 
or
eval { push @gather, $C->panic("Can't reduce a conditional operator")} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O}{assoc} eq 'non' ;
})
})} 
or
eval { push @gather, $C->panic("Can't reduce a non-associative operator")} or do { die $@ if $@ };
@gather;
}
}))
}, scalar(do {
my $M = $C;  $M->{O} = $M->{s}{op}{O}; $M->{sym} = $M->{s}->text; ;
}, $C))
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_081reduce_09') {
$C->deb("Fate passed to prefix_circumfix_meta_operator__S_081reduce_09: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator__S_081reduce_09', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator__S_081reduce_09 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('(')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
},     $C->_SUBSUME(['s'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_081reduce_02') {
$C->deb("Fate passed to prefix_circumfix_meta_operator__S_081reduce_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator__S_081reduce_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator__S_081reduce_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_081reduce_03') {
$C->deb("Fate passed to prefix_circumfix_meta_operator__S_081reduce_03: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator__S_081reduce_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator__S_081reduce_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT(']'))
},     $C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infix
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_081reduce_04') {
$C->deb("Fate passed to prefix_circumfix_meta_operator__S_081reduce_04: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator__S_081reduce_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator__S_081reduce_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT(']'))
},     $C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infix_prefix_meta_operator
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_081reduce_05') {
$C->deb("Fate passed to prefix_circumfix_meta_operator__S_081reduce_05: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator__S_081reduce_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator__S_081reduce_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT(']'))
},     $C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infix_circumfix_meta_operator
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_081reduce_06') {
$C->deb("Fate passed to prefix_circumfix_meta_operator__S_081reduce_06: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator__S_081reduce_06', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator__S_081reduce_06 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT(']'))
},     $C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infix
}))
}, $C->_EXACT('\\'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_081reduce_07') {
$C->deb("Fate passed to prefix_circumfix_meta_operator__S_081reduce_07: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator__S_081reduce_07', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator__S_081reduce_07 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT(']'))
},     $C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infix_prefix_meta_operator
}))
}, $C->_EXACT('\\'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_081reduce_08') {
$C->deb("Fate passed to prefix_circumfix_meta_operator__S_081reduce_08: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator__S_081reduce_08', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_circumfix_meta_operator__S_081reduce_08 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT(']'))
},     $C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infix_circumfix_meta_operator
}))
}, $C->_EXACT('\\'))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT('['))
})}
}))
);
}

## token prefix_postfix_meta_operator__S_082Fre (:$sym is context<rw> = <  >)
##      token prefix_postfix_meta_operator:sym<  >    { <sym> | '<<' }

sub prefix_postfix_meta_operator__S_082Fre__PEEK { $_[0]->_AUTOLEXpeek('prefix_postfix_meta_operator__S_082Fre',$retree) }
sub prefix_postfix_meta_operator__S_082Fre {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(  )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix_postfix_meta_operator__S_082Fre", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'prefix_postfix_meta_operator__S_082Fre_00') {
$C->deb("Fate passed to prefix_postfix_meta_operator__S_082Fre_00: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'prefix_postfix_meta_operator__S_082Fre_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("prefix_postfix_meta_operator__S_082Fre_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G/)
},
sub { my $C=shift;
$C->_EXACT('<<')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

## token postfix_prefix_meta_operator__S_083Nch (:$sym is context<rw> = <  >)
##      token postfix_prefix_meta_operator:sym<  >    { <sym> | '>>' }

sub postfix_prefix_meta_operator__S_083Nch__PEEK { $_[0]->_AUTOLEXpeek('postfix_prefix_meta_operator__S_083Nch',$retree) }
sub postfix_prefix_meta_operator__S_083Nch {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(  )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix_prefix_meta_operator__S_083Nch", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'postfix_prefix_meta_operator__S_083Nch_00') {
$C->deb("Fate passed to postfix_prefix_meta_operator__S_083Nch_00: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postfix_prefix_meta_operator__S_083Nch_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postfix_prefix_meta_operator__S_083Nch_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G/)
},
sub { my $C=shift;
$C->_EXACT('>>')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

## token infix_prefix_meta_operator__S_084Bang (  :$sym is context<rw> = <!> --> Chaining)
##      token infix_prefix_meta_operator:sym<!> ( --> Chaining) {
##          <sym> <!before '!'> <infix>
##      
##          <!!{ $<O> = $<infix><O>; }>
##          <!!lex1: 'negation'>
##      
##          [
##          || <!!{ $<O><assoc> eq 'chain'}>
##          || <!!{ $<O><assoc> and $<O><bool> }>
##          || <.panic: "Only boolean infix operators may be negated">
##          ]
##      
##          <!{ $<O><hyper> and $.panic("Negation of hyper operator not allowed") }>
##      
##      }

sub infix_prefix_meta_operator__S_084Bang__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_084Bang',$retree) }
sub infix_prefix_meta_operator__S_084Bang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_084Bang",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('!')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infix'], sub {
my $C = shift;
$C->infix
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O} = $M->{infix}{O}; ;
})
})
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C->lex1('negation')
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O}{assoc} eq 'chain';
})
})
})} 
or
eval { push @gather, $C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O}{assoc} and $M->{O}{bool} ;
})
})
})} 
or
eval { push @gather, $C->panic("Only boolean infix operators may be negated")} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O}{hyper} and $C->panic("Negation of hyper operator not allowed") ;
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## method lex1 (Str $s)
sub lex1 {
my $self = shift;
my $s = shift;


$self->{'O'}{$s}++ and $self->panic("Nested $s metaoperators not allowed");
$self;
}

## token infix_circumfix_meta_operator__S_085X_X (  :$sym is context<rw> = <X X> --> List_infix)
##      token infix_circumfix_meta_operator:sym<X X> ( --> List_infix) {
##          X <infix> X
##          <!!{ $<O> = $<infix><O>; }>
##          <!!lex1: 'cross'>
##      }

sub infix_circumfix_meta_operator__S_085X_X__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_085X_X',$retree) }
sub infix_circumfix_meta_operator__S_085X_X {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(X X)];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_085X_X",  map { STD::List_infix->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('X'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infix'], sub {
my $C = shift;
$C->infix
}))) {
do {
if (my ($C) = ($C->_EXACT('X'))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O} = $M->{infix}{O}; ;
})
})
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C->lex1('cross')
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix_circumfix_meta_operator__S_086Fre_Nch (  :$sym is context<rw> = < > --> Hyper)
##      token infix_circumfix_meta_operator:sym< > ( --> Hyper) {
##          [
##          | '' <infix> [ '' | '' ]
##          | '' <infix> [ '' | '' ]
##          | '<<' <infix> [ '<<' | '>>' ]
##          | '>>' <infix> [ '<<' | '>>' ]
##          ]
##          <!!{ $<O> := $<infix><O>; }>
##          <!!lex1: 'hyper'>
##      }

sub infix_circumfix_meta_operator__S_086Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_086Fre_Nch',$retree) }
sub infix_circumfix_meta_operator__S_086Fre_Nch {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw( )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_086Fre_Nch",  map { STD::Hyper->coerce($_) } 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix_circumfix_meta_operator__S_086Fre_Nch_01') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_086Fre_Nch_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_086Fre_Nch_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_086Fre_Nch_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(''))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infix'], sub {
my $C = shift;
$C->infix
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix_circumfix_meta_operator__S_086Fre_Nch_02') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_086Fre_Nch_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_086Fre_Nch_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_086Fre_Nch_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->_EXACT('')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(''))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infix'], sub {
my $C = shift;
$C->infix
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix_circumfix_meta_operator__S_086Fre_Nch_03') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_086Fre_Nch_03: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_086Fre_Nch_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_086Fre_Nch_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->_EXACT('')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('<<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infix'], sub {
my $C = shift;
$C->infix
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix_circumfix_meta_operator__S_086Fre_Nch_04') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_086Fre_Nch_04: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_086Fre_Nch_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_086Fre_Nch_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('<<')
},
sub { my $C=shift;
$C->_EXACT('>>')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('>>'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['infix'], sub {
my $C = shift;
$C->infix
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix_circumfix_meta_operator__S_086Fre_Nch_05') {
$C->deb("Fate passed to infix_circumfix_meta_operator__S_086Fre_Nch_05: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator__S_086Fre_Nch_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix_circumfix_meta_operator__S_086Fre_Nch_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('<<')
},
sub { my $C=shift;
$C->_EXACT('>>')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{O} = $M->{infix}{O}; ;
})
})
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C->lex1('hyper')
})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix_postfix_meta_operator__S_087Equal ($op  , :$sym is context<rw> = <=> --> Item_assignment)
##      token infix_postfix_meta_operator:sym<=> ($op --> Item_assignment) {
##          '='
##          { $<O> = $op<O>; }
##          <?lex1: 'assignment'>
##      
##          [ <?{ ($<O><assoc> // '') eq 'chain' }> <.panic: "Can't make assignment op of boolean operator"> ]?
##          [ <?{ ($<O><assoc> // '') eq 'non'   }> <.panic: "Can't make assignment op of non-associative operator"> ]?
##      }

sub infix_postfix_meta_operator__S_087Equal__PEEK { $_[0]->_AUTOLEXpeek('infix_postfix_meta_operator__S_087Equal',$retree) }
sub infix_postfix_meta_operator__S_087Equal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $op = shift;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix_postfix_meta_operator__S_087Equal",  map { STD::Item_assignment->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{O} = $op->{O}; ;
}, $C))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C->lex1('assignment')
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  ($M->{O}{assoc} // '') eq 'chain' ;
})
}))) {
$C->panic("Can't make assignment op of boolean operator");
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  ($M->{O}{assoc} // '') eq 'non'   ;
})
}))) {
$C->panic("Can't make assignment op of non-associative operator");
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postcircumfix__S_088Paren_Thesis (  :$sym is context<rw> = <( )> --> Methodcall)
##      token postcircumfix:sym<( )> ( --> Methodcall)
##          { :dba('argument list') '(' ~ ')' <semilist> }

sub postcircumfix__S_088Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_088Paren_Thesis',$retree) }
sub postcircumfix__S_088Paren_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "postcircumfix__S_088Paren_Thesis",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'argument list')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
);
}

## token postcircumfix__S_089Bra_Ket (  :$sym is context<rw> = <[ ]> --> Methodcall)
##      token postcircumfix:sym<[ ]> ( --> Methodcall)
##          { :dba('subscript') '[' ~ ']' <semilist> }

sub postcircumfix__S_089Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_089Bra_Ket',$retree) }
sub postcircumfix__S_089Bra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "postcircumfix__S_089Bra_Ket",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'subscript')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
);
}

## token postcircumfix__S_090Cur_Ly (  :$sym is context<rw> = <{ }> --> Methodcall)
##      token postcircumfix:sym<{ }> ( --> Methodcall)
##          { :dba('subscript') '{' ~ '}' <semilist> }

sub postcircumfix__S_090Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_090Cur_Ly',$retree) }
sub postcircumfix__S_090Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "postcircumfix__S_090Cur_Ly",  Cursor::lazymap sub { STD::Methodcall->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->FAILGOAL('}' , 'subscript')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_EXACT('{'))
);
}

## token postcircumfix__S_091Lt_Gt (  :$sym is context<rw> = < > --> Methodcall)
##      token postcircumfix:sym< > ( --> Methodcall)
##          { '<' <nibble($.cursor_fresh( ::STD::Q ).tweak(:q).tweak(:w).balanced('<','>'))> [ '>' || <.panic: "Unable to parse quote-words subscript; couldn't find right angle quote"> ] }

sub postcircumfix__S_091Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_091Lt_Gt',$retree) }
sub postcircumfix__S_091Lt_Gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<','>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_091Lt_Gt",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1)->tweak('w' => 1)->balanced('<','>'))
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('>')} 
or
eval { push @gather, $C->panic("Unable to parse quote-words subscript; couldn't find right angle quote")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postcircumfix__S_092LtLt_GtGt (  :$sym is context<rw> = << >> --> Methodcall)
##      token postcircumfix:sym<< >> ( --> Methodcall)
##          { '<<' <nibble($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('<<','>>'))> [ '>>' || <.panic: "Unable to parse quote-words subscript; couldn't find right double-angle quote"> ] }

sub postcircumfix__S_092LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_092LtLt_GtGt',$retree) }
sub postcircumfix__S_092LtLt_GtGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<','>>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_092LtLt_GtGt",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('<<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('<<','>>'))
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('>>')} 
or
eval { push @gather, $C->panic("Unable to parse quote-words subscript; couldn't find right double-angle quote")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postcircumfix__S_093Fre_Nch (  :$sym is context<rw> = < > --> Methodcall)
##      token postcircumfix:sym< > ( --> Methodcall)
##          { '' <nibble($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('',''))> [ '' || <.panic: "Unable to parse quote-words subscript; couldn't find right double-angle quote"> ] }

sub postcircumfix__S_093Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_093Fre_Nch',$retree) }
sub postcircumfix__S_093Fre_Nch {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw( )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postcircumfix__S_093Fre_Nch",  map { STD::Methodcall->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT(''))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('',''))
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('')} 
or
eval { push @gather, $C->panic("Unable to parse quote-words subscript; couldn't find right double-angle quote")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postop
##      token postop {
##          | <postfix>         { $<O> := $<postfix><O> }
##          | <postcircumfix>   { $<O> := $<postcircumfix><O> }
##      }

sub postop__PEEK { $_[0]->_AUTOLEXpeek('postop',$retree) }
sub postop {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "postop", 
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'postop_00') {
$C->deb("Fate passed to postop_00: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'postop_00', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("postop_00 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['postfix'], sub {
my $C = shift;
$C->postfix
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{postfix}{O} ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
my $M = $C;  $M->{O} = $M->{postcircumfix}{O} ;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

);
}

## token methodop
##      token methodop {
##          [
##          | <longname>
##          | <?before '$' | '@' > <variable>
##          | <?before <[ ' " ]> > <quote>
##              { $<quote> ~~ /\W/ or $.panic("Useless use of quotes") }
##          ] <.unsp>? 
##      
##          :dba('method arguments')
##          [
##          | '.'? <.unsp>? '(' ~ ')' <semilist>
##          | ':' <?before \s> <!{ $+inquote }> <arglist>
##          ]?
##      }

sub methodop__PEEK { $_[0]->_AUTOLEXpeek('methodop',$retree) }
sub methodop {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'arglist'} = [];
$C->{'semilist'} = [];

$self->_MATCHIFY($S, "methodop", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'methodop_04') {
$C->deb("Fate passed to methodop_04: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'methodop_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'method arguments')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_EXACT('.')
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['arglist'], sub {
my $C = shift;
$C->arglist
})
}, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$::inquote 
})
}))
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))
}, $C->_EXACT(':'))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
}, $C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'methodop_01') {
$C->deb("Fate passed to methodop_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'methodop_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'methodop_02') {
$C->deb("Fate passed to methodop_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'methodop_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("methodop_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('$')
},
sub { my $C=shift;
$C->_EXACT('@')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G['"]/)
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
}))) {
scalar(do {
my $M = $C;  $M->{quote} =~ qr/\W/ or $C->panic("Useless use of quotes") ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
);
}

## token arglist
##      token arglist {
##          :my StrPos $endargs is context<rw> = 0;
##          :my $GOAL is context = 'endargs';
##          <.ws>
##          :dba('argument list')
##          [
##          | <?stdstopper>
##          | <EXPR(item %list_prefix)>
##          ]
##      }

sub arglist__PEEK { $_[0]->_AUTOLEXpeek('arglist',$retree) }
sub arglist {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $endargs =  0;
local $GOAL =  'endargs';


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "arglist", 
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'arglist_01') {
$C->deb("Fate passed to arglist_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'arglist_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("arglist_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->stdstopper
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%list_prefix)
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token circumfix__S_094Cur_Ly (  :$sym is context<rw> = <{ }> --> Term)
##      token circumfix:sym<{ }> ( --> Term) {
##          <?before '{' | <lambda> > <pblock>
##      }

sub circumfix__S_094Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_094Cur_Ly',$retree) }
sub circumfix__S_094Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "circumfix__S_094Cur_Ly",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'circumfix__S_094Cur_Ly_01') {
$C->deb("Fate passed to circumfix__S_094Cur_Ly_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'circumfix__S_094Cur_Ly_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("circumfix__S_094Cur_Ly_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_SUBSUMEr(['lambda'], sub {
my $C = shift;
$C->lambda
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
});
}
else {
();
}
}
);
}

## token variable_declarator
##      token variable_declarator {
##          :my $IN_DECL is context<rw> = 1;
##          <variable> { $<SIGIL> = $<variable><sigil> }
##          { $IN_DECL = 0; }
##          [   # Is it a shaped array or hash declaration?
##            #  <?{ $<sigil> eq '@' | '%' }>
##              <.unsp>?
##              $<shape> = [
##              | '(' ~ ')' <signature>
##              | :dba('shape definition') '[' ~ ']' <semilist>
##              | :dba('shape definition') '{' ~ '}' <semilist>
##              | <?before '<'> <postcircumfix>
##              ]*
##          ]?
##          <.ws>
##      
##          <trait>*
##      
##          <post_constraint>*
##      }

sub variable_declarator__PEEK { $_[0]->_AUTOLEXpeek('variable_declarator',$retree) }
sub variable_declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $IN_DECL =  1;


my $C = $self;
my $S = $C->{_pos};
$C->{'trait'} = [];
$C->{'signature'} = [];
$C->{'post_constraint'} = [];
$C->{'shape'} = [];
$C->{'postcircumfix'} = [];
$C->{'semilist'} = [];

$self->_MATCHIFY($S, "variable_declarator", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['post_constraint'], sub {
my $C = shift;
$C->post_constraint
})
})
}, $C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['trait'], sub {
my $C = shift;
$C->trait
})
}))
}, $C->ws)
}, $C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['shape'], sub {
my $C = shift;
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'variable_declarator_02') {
$C->deb("Fate passed to variable_declarator_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_declarator_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_declarator_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'variable_declarator')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'shape definition')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->FAILGOAL('}' , 'shape definition')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}' ))
}, $C->_EXACT('{'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
}, $C->before(sub { my $C=shift;
$C->_EXACT('<')
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
})
}, $C->_OPTr(sub { my $C=shift;
$C->unsp
}))
})
}))
}, scalar(do {
$IN_DECL = 0; 
}, $C))
}, scalar(do {
my $M = $C;  $M->{SIGIL} = $M->{variable}{sigil} ;
}, $C))
}, $C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))
);
}

## rule scoped
##      rule scoped {
##          :dba('scoped declarator')
##          [
##          | <declarator> { $<SIGIL> = $<declarator><SIGIL> }
##          | <regex_declarator>
##          | <package_declarator>
##          | <fulltypename>+ <multi_declarator>
##          | <multi_declarator> { $<SIGIL> = $<multi_declarator><SIGIL> }
##      #    | <?before <[A..Z]> > <name> <.panic("Apparent type name " ~ $<name>.text ~ " is not declared yet")>
##          ]
##      }

sub scoped__PEEK { $_[0]->_AUTOLEXpeek('scoped',$retree) }
sub scoped {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'fulltypename'} = [];

$self->_MATCHIFYr($S, "scoped", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'scoped_01') {
$C->deb("Fate passed to scoped_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'scoped_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("scoped_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{SIGIL} = $M->{declarator}{SIGIL} ;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['package_declarator'], sub {
my $C = shift;
$C->package_declarator
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{SIGIL} = $M->{multi_declarator}{SIGIL} ;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token scope_declarator__S_095my (:$endsym is context = 'nofun', :$sym is context<rw> = 'my')
##      token scope_declarator:my       { <sym> <scoped> { $<SIGIL> = $<scoped><SIGIL> } }

sub scope_declarator__S_095my__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_095my',$retree) }
sub scope_declarator__S_095my {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'my';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_095my", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmy/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
}))) {
scalar(do {
my $M = $C;  $M->{SIGIL} = $M->{scoped}{SIGIL} ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_096our (:$endsym is context = 'nofun', :$sym is context<rw> = 'our')
##      token scope_declarator:our      { <sym> <scoped> { $<SIGIL> = $<scoped><SIGIL> } }

sub scope_declarator__S_096our__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_096our',$retree) }
sub scope_declarator__S_096our {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'our';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_096our", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gour/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
}))) {
scalar(do {
my $M = $C;  $M->{SIGIL} = $M->{scoped}{SIGIL} ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_097state (:$endsym is context = 'nofun', :$sym is context<rw> = 'state')
##      token scope_declarator:state    { <sym> <scoped> { $<SIGIL> = $<scoped><SIGIL> } }

sub scope_declarator__S_097state__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_097state',$retree) }
sub scope_declarator__S_097state {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'state';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_097state", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gstate/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
}))) {
scalar(do {
my $M = $C;  $M->{SIGIL} = $M->{scoped}{SIGIL} ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_098constant (:$endsym is context = 'nofun', :$sym is context<rw> = 'constant')
##      token scope_declarator:constant { <sym> <scoped> { $<SIGIL> = $<scoped><SIGIL> } }

sub scope_declarator__S_098constant__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_098constant',$retree) }
sub scope_declarator__S_098constant {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'constant';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_098constant", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gconstant/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
}))) {
scalar(do {
my $M = $C;  $M->{SIGIL} = $M->{scoped}{SIGIL} ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token scope_declarator__S_099has (:$endsym is context = 'nofun', :$sym is context<rw> = 'has')
##      token scope_declarator:has      { <sym> <scoped> { $<SIGIL> = $<scoped><SIGIL> } }

sub scope_declarator__S_099has__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_099has',$retree) }
sub scope_declarator__S_099has {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'nofun';
local $sym = $args{sym} // 'has';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "scope_declarator__S_099has", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ghas/))) {
do {
if (my ($C) = ($C->nofun)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped
}))) {
scalar(do {
my $M = $C;  $M->{SIGIL} = $M->{scoped}{SIGIL} ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}


## token package_declarator__S_100class (:$sym is context<rw> = 'class')
##      token package_declarator:class {
##          :my $PKGDECL is context = 'class';
##          <sym> <package_def>
##      }

sub package_declarator__S_100class__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_100class',$retree) }
sub package_declarator__S_100class {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'class';
local $PKGDECL =  'class';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_100class", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gclass/))) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
}
);
}

## token package_declarator__S_101grammar (:$sym is context<rw> = 'grammar')
##      token package_declarator:grammar {
##          :my $PKGDECL is context = 'grammar';
##          <sym> <package_def>
##      }

sub package_declarator__S_101grammar__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_101grammar',$retree) }
sub package_declarator__S_101grammar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'grammar';
local $PKGDECL =  'grammar';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_101grammar", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggrammar/))) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
}
);
}

## token package_declarator__S_102module (:$sym is context<rw> = 'module')
##      token package_declarator:module {
##          :my $PKGDECL is context = 'module';
##          <sym> <package_def>
##      }

sub package_declarator__S_102module__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_102module',$retree) }
sub package_declarator__S_102module {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'module';
local $PKGDECL =  'module';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_102module", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmodule/))) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
}
);
}

## token package_declarator__S_103package (:$sym is context<rw> = 'package')
##      token package_declarator:package {
##          :my $PKGDECL is context = 'package';
##          <sym> <package_def>
##      }

sub package_declarator__S_103package__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_103package',$retree) }
sub package_declarator__S_103package {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'package';
local $PKGDECL =  'package';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_103package", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gpackage/))) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
}
);
}

## token package_declarator__S_104role (:$sym is context<rw> = 'role')
##      token package_declarator:role {
##          :my $PKGDECL is context = 'role';
##          <sym> <package_def>
##      }

sub package_declarator__S_104role__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_104role',$retree) }
sub package_declarator__S_104role {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'role';
local $PKGDECL =  'role';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_104role", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grole/))) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
}
);
}

## token package_declarator__S_105knowhow (:$sym is context<rw> = 'knowhow')
##      token package_declarator:knowhow {
##          :my $PKGDECL is context = 'knowhow';
##          <sym> <package_def>
##      }

sub package_declarator__S_105knowhow__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_105knowhow',$retree) }
sub package_declarator__S_105knowhow {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'knowhow';
local $PKGDECL =  'knowhow';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_105knowhow", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gknowhow/))) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
});
}
else {
();
}
}
);
}

## token package_declarator__S_106require (:$sym is context<rw> = 'require')
##      token package_declarator:require {   # here because of declarational aspects
##          <sym> <.ws>
##          [
##          || <module_name> <EXPR>?
##          || <EXPR>
##          ]
##      }

sub package_declarator__S_106require__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_106require',$retree) }
sub package_declarator__S_106require {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'require';


my $C = $self;
my $S = $C->{_pos};
$C->{'EXPR'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_106require", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grequire/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})
});
}
else {
();
}
}} 
or
eval { push @gather, $C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_107trusts (:$sym is context<rw> = 'trusts')
##      token package_declarator:trusts {
##          <sym> <.ws>
##          <module_name>
##      }

sub package_declarator__S_107trusts__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_107trusts',$retree) }
sub package_declarator__S_107trusts {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'trusts';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_107trusts", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtrusts/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token package_declarator__S_108does (:$sym is context<rw> = 'does')
##      token package_declarator:does {
##          <sym> <.ws>
##          <typename>
##      }

sub package_declarator__S_108does__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_108does',$retree) }
sub package_declarator__S_108does {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'does';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "package_declarator__S_108does", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdoes/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule package_def
##      rule package_def {
##          :my $longname;
##          [
##      	<module_name>{
##                  $longname = $<module_name>[0]<longname>;
##                  $.add_type($longname.text);
##              }
##          ]?
##          <trait>*
##          [
##             <?before '{'>
##             {{
##      	   # figure out the actual full package name (nested in outer package)
##                  my $pkg = $+PKG // "GLOBAL";
##      	    push @PKGS, $pkg;
##      	    if $longname {
##      		my $shortname = $longname.<name>.text;
##      		$+PKG = $pkg ~ '::' ~ $shortname;
##      	    }
##      	    else {
##      		$+PKG = $pkg ~ '::_anon_';
##      	    }
##      	}}
##              <block>
##      	{{
##      	    $+PKG = pop(@PKGS);
##      	}}
##      	{*}                                                     #= block
##          || <?{ $+begin_compunit }> {} <?before ';'>
##              {
##                  $longname orelse $.panic("Compilation unit cannot be anonymous");
##      	    my $shortname = $longname.<name>.text;
##      	    $+PKG = $shortname;
##                  $+begin_compunit = 0;
##              }
##              {*}                                                     #= semi
##          || <.panic: "Unable to parse " ~ $+PKGDECL ~ " definition">
##          ]
##      }

sub package_def__PEEK { $_[0]->_AUTOLEXpeek('package_def',$retree) }
sub package_def {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $longname;


my $C = $self;
my $S = $C->{_pos};
$C->{'trait'} = [];
$C->{'module_name'} = [];

$self->_MATCHIFYr($S, "package_def", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$longname = $M->{module_name}[0]{'longname'};
$C->add_type($longname->text);
;
}, $C))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

# figure out the actual full package name (nested in outer package)
my $pkg = $::PKG // "GLOBAL";
push @PKGS, $pkg;
if ($longname) {
my $shortname = $longname->{'name'}->text;
$::PKG = $pkg . '::' . $shortname;
}
else {
$::PKG = $pkg . '::_anon_';
}

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

$::PKG = pop(@PKGS);

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'package_def_block'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$::begin_compunit 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT(';')
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {

$longname or $C->panic("Compilation unit cannot be anonymous");
my $shortname = $longname->{'name'}->text;
$::PKG = $shortname;
$::begin_compunit = 0;

}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REDUCE($S, 'package_def_semi'))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->panic("Unable to parse " . $::PKGDECL . " definition"))) {
$C->ws;
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token declarator
##      token declarator {
##          [
##          | <variable_declarator> { $<SIGIL> = $<variable_declarator><SIGIL> }
##          | '(' ~ ')' <signature> <trait>*
##          | <routine_declarator>
##          | <regex_declarator>
##          | <type_declarator>
##          ]
##      }

sub declarator__PEEK { $_[0]->_AUTOLEXpeek('declarator',$retree) }
sub declarator {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'trait'} = [];

$self->_MATCHIFY($S, "declarator", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'declarator_01') {
$C->deb("Fate passed to declarator_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'declarator_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("declarator_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['variable_declarator'], sub {
my $C = shift;
$C->variable_declarator
}))) {
scalar(do {
my $M = $C;  $M->{SIGIL} = $M->{variable_declarator}{SIGIL} ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['trait'], sub {
my $C = shift;
$C->trait
})
})
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'declarator')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
$C->_SUBSUME(['routine_declarator'], sub {
my $C = shift;
$C->routine_declarator
})
},
sub { my $C=shift;
$C->_SUBSUME(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
})
},
sub { my $C=shift;
$C->_SUBSUME(['type_declarator'], sub {
my $C = shift;
$C->type_declarator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token multi_declarator__S_109multi (:$sym is context<rw> = 'multi')
##      token multi_declarator:multi { <sym> <.ws> [ <declarator> { $<SIGIL> = $<declarator><SIGIL> } || <routine_def> ] }

sub multi_declarator__S_109multi__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_109multi',$retree) }
sub multi_declarator__S_109multi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'multi';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_109multi", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmulti/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
}))) {
scalar(do {
my $M = $C;  $M->{SIGIL} = $M->{declarator}{SIGIL} ;
}, $C);
}
else {
();
}
}} 
or
eval { push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token multi_declarator__S_110proto (:$sym is context<rw> = 'proto')
##      token multi_declarator:proto { <sym> <.ws> [ <declarator> { $<SIGIL> = $<declarator><SIGIL> } || <routine_def> ] }

sub multi_declarator__S_110proto__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_110proto',$retree) }
sub multi_declarator__S_110proto {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'proto';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_110proto", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gproto/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
}))) {
scalar(do {
my $M = $C;  $M->{SIGIL} = $M->{declarator}{SIGIL} ;
}, $C);
}
else {
();
}
}} 
or
eval { push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token multi_declarator__S_111only (:$sym is context<rw> = 'only')
##      token multi_declarator:only  { <sym> <.ws> [ <declarator> { $<SIGIL> = $<declarator><SIGIL> } || <routine_def> ] }

sub multi_declarator__S_111only__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_111only',$retree) }
sub multi_declarator__S_111only {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'only';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_111only", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gonly/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
}))) {
scalar(do {
my $M = $C;  $M->{SIGIL} = $M->{declarator}{SIGIL} ;
}, $C);
}
else {
();
}
}} 
or
eval { push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}
## token multi_declarator__S_112null (:$sym is context<rw> = 'null')
##      token multi_declarator:null  { <declarator> { $<SIGIL> = $<declarator><SIGIL> } }

sub multi_declarator__S_112null__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_112null',$retree) }
sub multi_declarator__S_112null {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'null';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "multi_declarator__S_112null", 
do {
if (my ($C) = ($C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
}))) {
scalar(do {
my $M = $C;  $M->{SIGIL} = $M->{declarator}{SIGIL} ;
}, $C);
}
else {
();
}
}
);
}

## token routine_declarator__S_113sub (:$sym is context<rw> = 'sub')
##      token routine_declarator:sub       { <sym> <routine_def> }

sub routine_declarator__S_113sub__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_113sub',$retree) }
sub routine_declarator__S_113sub {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sub';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_113sub", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsub/))) {
$C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def
});
}
else {
();
}
}
);
}
## token routine_declarator__S_114method (:$sym is context<rw> = 'method')
##      token routine_declarator:method    { <sym> <method_def> }

sub routine_declarator__S_114method__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_114method',$retree) }
sub routine_declarator__S_114method {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'method';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_114method", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmethod/))) {
$C->_SUBSUMEr(['method_def'], sub {
my $C = shift;
$C->method_def
});
}
else {
();
}
}
);
}
## token routine_declarator__S_115submethod (:$sym is context<rw> = 'submethod')
##      token routine_declarator:submethod { <sym> <method_def> }

sub routine_declarator__S_115submethod__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_115submethod',$retree) }
sub routine_declarator__S_115submethod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'submethod';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_115submethod", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsubmethod/))) {
$C->_SUBSUMEr(['method_def'], sub {
my $C = shift;
$C->method_def
});
}
else {
();
}
}
);
}
## token routine_declarator__S_116macro (:$sym is context<rw> = 'macro')
##      token routine_declarator:macro     { <sym> <macro_def> }

sub routine_declarator__S_116macro__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_116macro',$retree) }
sub routine_declarator__S_116macro {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'macro';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "routine_declarator__S_116macro", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmacro/))) {
$C->_SUBSUMEr(['macro_def'], sub {
my $C = shift;
$C->macro_def
});
}
else {
();
}
}
);
}

## token regex_declarator__S_117regex (:$sym is context<rw> = 'regex')
##      token regex_declarator:regex { <sym>       <regex_def> }

sub regex_declarator__S_117regex__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_117regex',$retree) }
sub regex_declarator__S_117regex {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'regex';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_declarator__S_117regex", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gregex/))) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def
});
}
else {
();
}
}
);
}
## token regex_declarator__S_118token (:$sym is context<rw> = 'token')
##      token regex_declarator:token { <sym>       <regex_def> }

sub regex_declarator__S_118token__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_118token',$retree) }
sub regex_declarator__S_118token {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'token';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_declarator__S_118token", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtoken/))) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def
});
}
else {
();
}
}
);
}
## token regex_declarator__S_119rule (:$sym is context<rw> = 'rule')
##      token regex_declarator:rule  { <sym>       <regex_def> }

sub regex_declarator__S_119rule__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_119rule',$retree) }
sub regex_declarator__S_119rule {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'rule';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "regex_declarator__S_119rule", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grule/))) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def
});
}
else {
();
}
}
);
}

# Most of these special variable rules are there simply to catch old p5 brainos

## token special_variable__S_120Dollar_a2_ (:$sym is context<rw> = <$>)
##      token special_variable:sym<$> { <sym> }

sub special_variable__S_120Dollar_a2___PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_120Dollar_a2_',$retree) }
sub special_variable__S_120Dollar_a2_ {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_120Dollar_a2_", 
$C->_PATTERN(qr/\G\$/)
);
}

## token special_variable__S_121DollarBang (:$sym is context<rw> = <$!>)
##      token special_variable:sym<$!> { <sym> <!before \w> }

sub special_variable__S_121DollarBang__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_121DollarBang',$retree) }
sub special_variable__S_121DollarBang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_121DollarBang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\!/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
});
}
else {
();
}
}
);
}

## token special_variable__S_122DollarBangCur_Ly (:$sym is context<rw> = <$!{ }>)
##      token special_variable:sym<$!{ }> {
##          # XXX the backslashes are necessary here for bootstrapping, not for P6...
##          ( '$!{' :: (.*?) '}' )
##          <obs($0.text ~ " variable", 'smart match against $!')>
##      }

sub special_variable__S_122DollarBangCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_122DollarBangCur_Ly',$retree) }
sub special_variable__S_122DollarBangCur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw($!{ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_122DollarBangCur_Ly", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs($$C{0}->text . " variable", 'smart match against $!')
})
},     $C->_SUBSUME(['1'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT('}')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_SCANf()
})}
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('$!{'))
})}
}))
);
}

## token special_variable__S_123DollarSlash (:$sym is context<rw> = <$/>)
##      token special_variable:sym<$/> {
##          <sym>
##          # XXX assuming nobody ever wants to assign $/ directly anymore...
##          [ <?before \h* '=' <![=]> >
##              <obs('$/ variable as input record separator',
##                   "filehandle's :irs attribute")>
##          ]?
##      }

sub special_variable__S_123DollarSlash__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_123DollarSlash',$retree) }
sub special_variable__S_123DollarSlash {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($/);


my $C = $self;
my $S = $C->{_pos};
$C->{'obs'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_123DollarSlash", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\//))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
do {
if (my ($C) = ($C->_EXACT('='))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[=]/)
});
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('$/ variable as input record separator',
"filehandle's :irs attribute")
});
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

## token special_variable__S_124DollarTilde (:$sym is context<rw> = <$~>)
##      token special_variable:sym<$~> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <obs('$~ variable', 'Form module')>
##      }

sub special_variable__S_124DollarTilde__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_124DollarTilde',$retree) }
sub special_variable__S_124DollarTilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_124DollarTilde", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$~ variable', 'Form module')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_124DollarTilde_01') {
$C->deb("Fate passed to special_variable__S_124DollarTilde_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_124DollarTilde_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_124DollarTilde_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\~/))
);
}

## token special_variable__S_125DollarGrave (:$sym is context<rw> = <$`>)
##      token special_variable:sym<$`> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <obs('$` variable', 'explicit pattern before <(')>
##      }

sub special_variable__S_125DollarGrave__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_125DollarGrave',$retree) }
sub special_variable__S_125DollarGrave {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($`);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_125DollarGrave", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$` variable', 'explicit pattern before <(')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_125DollarGrave_01') {
$C->deb("Fate passed to special_variable__S_125DollarGrave_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_125DollarGrave_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_125DollarGrave_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\`/))
);
}

## token special_variable__S_126DollarAt (:$sym is context<rw> = <$@>)
##      token special_variable:sym<$@> {
##          <sym> ::
##          <obs('$@ variable as eval error', '$!')>
##      }

sub special_variable__S_126DollarAt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_126DollarAt',$retree) }
sub special_variable__S_126DollarAt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($@);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_126DollarAt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$@ variable as eval error', '$!')
})
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\@/))
);
}

## token special_variable__S_127DollarSharp (:$sym is context<rw> = <$#>)
##      token special_variable:sym<$#> {
##          <sym> ::
##          [
##          || (\w+) <obs("\$#" ~ $0.text ~ " variable", "\@{" ~ $0.text ~ "}.end")>
##          || <obs('$# variable', '.fmt')>
##          ]
##      }

sub special_variable__S_127DollarSharp__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_127DollarSharp',$retree) }
sub special_variable__S_127DollarSharp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($#);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_127DollarSharp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs("\$#" . $$C{0}->text . " variable", "\@{" . $$C{0}->text . "}.end")
})
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\w)++)/)
})}
}))} 
or
eval { push @gather, $C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$# variable', '.fmt')
})} or do { die $@ if $@ };
@gather;
}
})
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\#/))
);
}
## token special_variable__S_128DollarDollar (:$sym is context<rw> = <$$>)
##      token special_variable:sym<$$> {
##          <sym> <!alpha> :: <?before \s | ',' | <terminator> >
##          <obs('$$ variable', '$*PID')>
##      }

sub special_variable__S_128DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_128DollarDollar',$retree) }
sub special_variable__S_128DollarDollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($$);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_128DollarDollar", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$$ variable', '$*PID')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_128DollarDollar_01') {
$C->deb("Fate passed to special_variable__S_128DollarDollar_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_128DollarDollar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_128DollarDollar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))
}, $C->_PATTERN(qr/\G\$\$/))
);
}
## token special_variable__S_129DollarPercent (:$sym is context<rw> = <$%>)
##      token special_variable:sym<$%> {
##          <sym> ::
##          <obs('$% variable', 'Form module')>
##      }

sub special_variable__S_129DollarPercent__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_129DollarPercent',$retree) }
sub special_variable__S_129DollarPercent {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($%);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_129DollarPercent", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$% variable', 'Form module')
})
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\%/))
);
}

# Note: this works because placeholders are restricted to lowercase
## token special_variable__S_130DollarCaretX (:$sym is context<rw> = <$^X>)
##      token special_variable:sym<$^X> {
##          <sigil> '^' $<letter> = [<[A..Z]>] \W
##          <obscaret($<sigil>.text ~ '^' ~ $<letter>.text, $<sigil>, $<letter>.text)>
##      }

sub special_variable__S_130DollarCaretX__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_130DollarCaretX',$retree) }
sub special_variable__S_130DollarCaretX {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($^X);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_130DollarCaretX", 
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_EXACT('^'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['letter'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_PATTERN(qr/\G[A-Z]/)
})
}))) {
do {
if (my ($C) = ($C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) {
$C->_SUBSUMEr(['obscaret'], sub {
my $C = shift;
do { my $M = $C;
$C->obscaret($M->{sigil}->text . '^' . $M->{letter}->text, $M->{sigil}, $M->{letter}->text)
; }
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token special_variable__S_131DollarCaret (:$sym is context<rw> = <$^>)
##      token special_variable:sym<$^> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <obs('$^ variable', 'Form module')>
##      }

sub special_variable__S_131DollarCaret__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_131DollarCaret',$retree) }
sub special_variable__S_131DollarCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_131DollarCaret", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$^ variable', 'Form module')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_131DollarCaret_01') {
$C->deb("Fate passed to special_variable__S_131DollarCaret_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_131DollarCaret_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_131DollarCaret_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\^/))
);
}

## token special_variable__S_132DollarAmp (:$sym is context<rw> = <$&>)
##      token special_variable:sym<$&> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <obs('$& variable', '$/ or $()')>
##      }

sub special_variable__S_132DollarAmp__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_132DollarAmp',$retree) }
sub special_variable__S_132DollarAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_132DollarAmp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$& variable', '$/ or $()')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_132DollarAmp_01') {
$C->deb("Fate passed to special_variable__S_132DollarAmp_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_132DollarAmp_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_132DollarAmp_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\&/))
);
}

## token special_variable__S_133DollarStar (:$sym is context<rw> = <$*>)
##      token special_variable:sym<$*> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <obs('$* variable', '^^ and $$')>
##      }

sub special_variable__S_133DollarStar__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_133DollarStar',$retree) }
sub special_variable__S_133DollarStar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_133DollarStar", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$* variable', '^^ and $$')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_133DollarStar_01') {
$C->deb("Fate passed to special_variable__S_133DollarStar_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_133DollarStar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_133DollarStar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\*/))
);
}

## token special_variable__S_134DollarThesis (:$sym is context<rw> = <$)>)
##      token special_variable:sym<$)> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <obs('$) variable', '$*EGID')>
##      }

sub special_variable__S_134DollarThesis__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_134DollarThesis',$retree) }
sub special_variable__S_134DollarThesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[$)];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_134DollarThesis", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$) variable', '$*EGID')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_134DollarThesis_01') {
$C->deb("Fate passed to special_variable__S_134DollarThesis_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_134DollarThesis_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_134DollarThesis_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\)/))
);
}

## token special_variable__S_135DollarMinus (:$sym is context<rw> = <$->)
##      token special_variable:sym<$-> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <obs('$- variable', 'Form module')>
##      }

sub special_variable__S_135DollarMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_135DollarMinus',$retree) }
sub special_variable__S_135DollarMinus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($-);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_135DollarMinus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$- variable', 'Form module')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_135DollarMinus_01') {
$C->deb("Fate passed to special_variable__S_135DollarMinus_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_135DollarMinus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_135DollarMinus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\-/))
);
}

## token special_variable__S_136DollarEqual (:$sym is context<rw> = <$=>)
##      token special_variable:sym<$=> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <obs('$= variable', 'Form module')>
##      }

sub special_variable__S_136DollarEqual__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_136DollarEqual',$retree) }
sub special_variable__S_136DollarEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_136DollarEqual", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$= variable', 'Form module')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_136DollarEqual_01') {
$C->deb("Fate passed to special_variable__S_136DollarEqual_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_136DollarEqual_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_136DollarEqual_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\=/))
);
}

## token special_variable__S_137AtPlus (:$sym is context<rw> = <@+>)
##      token special_variable:sym<@+> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <obs('@+ variable', '.to method')>
##      }

sub special_variable__S_137AtPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_137AtPlus',$retree) }
sub special_variable__S_137AtPlus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_137AtPlus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('@+ variable', '.to method')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_137AtPlus_01') {
$C->deb("Fate passed to special_variable__S_137AtPlus_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_137AtPlus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_137AtPlus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\@\+/))
);
}

## token special_variable__S_138PercentPlus (:$sym is context<rw> = <%+>)
##      token special_variable:sym<%+> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <obs('%+ variable', '.to method')>
##      }

sub special_variable__S_138PercentPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_138PercentPlus',$retree) }
sub special_variable__S_138PercentPlus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_138PercentPlus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('%+ variable', '.to method')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_138PercentPlus_01') {
$C->deb("Fate passed to special_variable__S_138PercentPlus_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_138PercentPlus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_138PercentPlus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\%\+/))
);
}

## token special_variable__S_139DollarPlusBra_Ket (:$sym is context<rw> = <$+[ ]>)
##      token special_variable:sym<$+[ ]> {
##          '$+['
##          <obs('@+ variable', '.to method')>
##      }

sub special_variable__S_139DollarPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_139DollarPlusBra_Ket',$retree) }
sub special_variable__S_139DollarPlusBra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw($+[ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_139DollarPlusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('$+['))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('@+ variable', '.to method')
});
}
else {
();
}
}
);
}

## token special_variable__S_140AtPlusBra_Ket (:$sym is context<rw> = <@+[ ]>)
##      token special_variable:sym<@+[ ]> {
##          '@+['
##          <obs('@+ variable', '.to method')>
##      }

sub special_variable__S_140AtPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_140AtPlusBra_Ket',$retree) }
sub special_variable__S_140AtPlusBra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(@+[ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_140AtPlusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('@+['))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('@+ variable', '.to method')
});
}
else {
();
}
}
);
}

## token special_variable__S_141AtPlusCur_Ly (:$sym is context<rw> = <@+{ }>)
##      token special_variable:sym<@+{ }> {
##          '@+{'
##          <obs('%+ variable', '.to method')>
##      }

sub special_variable__S_141AtPlusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_141AtPlusCur_Ly',$retree) }
sub special_variable__S_141AtPlusCur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(@+{ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_141AtPlusCur_Ly", 
do {
if (my ($C) = ($C->_EXACT('@+{'))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('%+ variable', '.to method')
});
}
else {
();
}
}
);
}

## token special_variable__S_142AtMinus (:$sym is context<rw> = <@->)
##      token special_variable:sym<@-> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <obs('@- variable', '.from method')>
##      }

sub special_variable__S_142AtMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_142AtMinus',$retree) }
sub special_variable__S_142AtMinus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@-);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_142AtMinus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('@- variable', '.from method')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_142AtMinus_01') {
$C->deb("Fate passed to special_variable__S_142AtMinus_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_142AtMinus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_142AtMinus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\@\-/))
);
}

## token special_variable__S_143PercentMinus (:$sym is context<rw> = <%->)
##      token special_variable:sym<%-> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <obs('%- variable', '.from method')>
##      }

sub special_variable__S_143PercentMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_143PercentMinus',$retree) }
sub special_variable__S_143PercentMinus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%-);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_143PercentMinus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('%- variable', '.from method')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_143PercentMinus_01') {
$C->deb("Fate passed to special_variable__S_143PercentMinus_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_143PercentMinus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_143PercentMinus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\%\-/))
);
}

## token special_variable__S_144DollarMinusBra_Ket (:$sym is context<rw> = <$-[ ]>)
##      token special_variable:sym<$-[ ]> {
##          '$-['
##          <obs('@- variable', '.from method')>
##      }

sub special_variable__S_144DollarMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_144DollarMinusBra_Ket',$retree) }
sub special_variable__S_144DollarMinusBra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw($-[ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_144DollarMinusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('$-['))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('@- variable', '.from method')
});
}
else {
();
}
}
);
}

## token special_variable__S_145AtMinusBra_Ket (:$sym is context<rw> = <@-[ ]>)
##      token special_variable:sym<@-[ ]> {
##          '@-['
##          <obs('@- variable', '.from method')>
##      }

sub special_variable__S_145AtMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_145AtMinusBra_Ket',$retree) }
sub special_variable__S_145AtMinusBra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(@-[ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_145AtMinusBra_Ket", 
do {
if (my ($C) = ($C->_EXACT('@-['))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('@- variable', '.from method')
});
}
else {
();
}
}
);
}

## token special_variable__S_146PercentMinusCur_Ly (:$sym is context<rw> = <%-{ }>)
##      token special_variable:sym<%-{ }> {
##          '@-{'
##          <obs('%- variable', '.from method')>
##      }

sub special_variable__S_146PercentMinusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_146PercentMinusCur_Ly',$retree) }
sub special_variable__S_146PercentMinusCur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(%-{ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_146PercentMinusCur_Ly", 
do {
if (my ($C) = ($C->_EXACT('@-{'))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('%- variable', '.from method')
});
}
else {
();
}
}
);
}

## token special_variable__S_147DollarPlus (:$sym is context<rw> = <$+>)
##      token special_variable:sym<$+> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <obs('$+ variable', 'Form module')>
##      }

sub special_variable__S_147DollarPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_147DollarPlus',$retree) }
sub special_variable__S_147DollarPlus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_147DollarPlus", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$+ variable', 'Form module')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_147DollarPlus_01') {
$C->deb("Fate passed to special_variable__S_147DollarPlus_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_147DollarPlus_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_147DollarPlus_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\+/))
);
}

## token special_variable__S_148DollarCurCaret_Ly (:$sym is context<rw> = <${^ }>)
##      token special_variable:sym<${^ }> {
##          ( <sigil> '{^' :: (.*?) '}' )
##          <obscaret($0.text, $<sigil>, $0.{0}.text)>
##      }

sub special_variable__S_148DollarCurCaret_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_148DollarCurCaret_Ly',$retree) }
sub special_variable__S_148DollarCurCaret_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(${^ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_148DollarCurCaret_Ly", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obscaret'], sub {
my $C = shift;
do { my $M = $C;
$C->obscaret($$C{0}->text, $M->{sigil}, $$C{0}.{0}->text)
; }
})
},     $C->_SUBSUME(['1'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT('}')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_SCANf()
})}
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{^'))
}, $C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
})}
}))
);
}

# XXX should eventually rely on multi instead of nested cases here...
## method obscaret (Str $var, Str $sigil, Str $name)
sub obscaret {
my $self = shift;
my $var = shift;
my $sigil = shift;
my $name = shift;


my $repl = do { do { my $_ = $sigil; if ((0)) {}
elsif ($_ eq '$') {
do { my $_ = $name; if ((0)) {}
elsif ($_ eq 'MATCH') { '$/' }
elsif ($_ eq 'PREMATCH') { 'an explicit pattern before <(' }
elsif ($_ eq 'POSTMATCH') { 'an explicit pattern after )>' }
elsif ($_ eq 'ENCODING') { '$?ENCODING' }
elsif ($_ eq 'UNICODE') { '$?UNICODE' }  # XXX ???
elsif ($_ eq 'TAINT') { '$*TAINT' }
elsif ($_ eq 'OPEN') { 'filehandle introspection' }
elsif ($_ eq 'N') { '$-1' } # XXX ???
elsif ($_ eq 'L') { 'Form module' }
elsif ($_ eq 'A') { 'Form module' }
elsif ($_ eq 'E') { '$!.extended_os_error' }
elsif ($_ eq 'C') { 'COMPILING namespace' }
elsif ($_ eq 'D') { '$*DEBUGGING' }
elsif ($_ eq 'F') { '$*SYSTEM_FD_MAX' }
elsif ($_ eq 'H') { '$?FOO variables' }
elsif ($_ eq 'I') { '$*INPLACE' } # XXX ???
elsif ($_ eq 'O') { '$?OS or $*OS' }
elsif ($_ eq 'P') { 'whatever debugger Perl 6 comes with' }
elsif ($_ eq 'R') { 'an explicit result variable' }
elsif ($_ eq 'S') { 'the context function' } # XXX ???
elsif ($_ eq 'T') { '$*BASETIME' }
elsif ($_ eq 'V') { '$*PERL_VERSION' }
elsif ($_ eq 'W') { '$*WARNING' }
elsif ($_ eq 'X') { '$*EXECUTABLE_NAME' }
else { "a global form such as $sigil*$name" }
};
}
elsif ($_ eq '%') {
do { my $_ = $name; if ((0)) {}
elsif ($_ eq 'H') { '$?FOO variables' }
else { "a global form such as $sigil*$name" }
};
}
else { "a global form such as $sigil*$name" }
};
};
return $self->obs("$var variable", $repl);
}

## token special_variable__S_149ColonColonCur_Ly (:$sym is context<rw> = <::{ }>)
##      token special_variable:sym<::{ }> {
##          '::' <?before '{'>
##      }

sub special_variable__S_149ColonColonCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_149ColonColonCur_Ly',$retree) }
sub special_variable__S_149ColonColonCur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(::{ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_149ColonColonCur_Ly", 
do {
if (my ($C) = ($C->_EXACT('::'))) {
$C->before(sub { my $C=shift;
$C->_EXACT('{')
});
}
else {
();
}
}
);
}

## token special_variable__S_150DollarCur_Ly (:$sym is context<rw> = <${ }>)
##      token special_variable:sym<${ }> {
##          ( <[$@%]> '{' :: (.*?) '}' )
##          <obs("" ~ $0.text ~ " variable", "{" ~ $<sigil>.text ~ "}(" ~ $0.{0}.text ~ ")")>
##      }

sub special_variable__S_150DollarCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_150DollarCur_Ly',$retree) }
sub special_variable__S_150DollarCur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(${ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_150DollarCur_Ly", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
do { my $M = $C;
$C->obs("" . $$C{0}->text . " variable", "{" . $M->{sigil}->text . "}(" . $$C{0}.{0}->text . ")")
; }
})
},     $C->_SUBSUME(['1'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT('}')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_SCANf()
})}
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{'))
}, $C->_PATTERN(qr/\G[$@%]/))
})}
}))
);
}

## token special_variable__S_151DollarBra (:$sym is context<rw> = <$[>)
##      token special_variable:sym<$[> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <obs('$[ variable', 'user-defined array indices')>
##      }

sub special_variable__S_151DollarBra__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_151DollarBra',$retree) }
sub special_variable__S_151DollarBra {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($[);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_151DollarBra", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$[ variable', 'user-defined array indices')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_151DollarBra_01') {
$C->deb("Fate passed to special_variable__S_151DollarBra_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_151DollarBra_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_151DollarBra_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\[/))
);
}

## token special_variable__S_152DollarKet (:$sym is context<rw> = <$]>)
##      token special_variable:sym<$]> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <obs('$] variable', '$*PERL_VERSION')>
##      }

sub special_variable__S_152DollarKet__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_152DollarKet',$retree) }
sub special_variable__S_152DollarKet {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($]);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_152DollarKet", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$] variable', '$*PERL_VERSION')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_152DollarKet_01') {
$C->deb("Fate passed to special_variable__S_152DollarKet_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_152DollarKet_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_152DollarKet_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\]/))
);
}

## token special_variable__S_153DollarBack (:$sym is context<rw> = <$\\>)
##      token special_variable:sym<$\\> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <obs('$\\ variable', "the filehandle's :ors attribute")>
##      }

sub special_variable__S_153DollarBack__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_153DollarBack',$retree) }
sub special_variable__S_153DollarBack {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_153DollarBack", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$\\ variable', "the filehandle's :ors attribute")
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_153DollarBack_01') {
$C->deb("Fate passed to special_variable__S_153DollarBack_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_153DollarBack_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_153DollarBack_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\\/))
);
}

## token special_variable__S_154DollarVert (:$sym is context<rw> = <$|>)
##      token special_variable:sym<$|> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <obs('$| variable', 'Form module')>
##      }

sub special_variable__S_154DollarVert__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_154DollarVert',$retree) }
sub special_variable__S_154DollarVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_154DollarVert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$| variable', 'Form module')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_154DollarVert_01') {
$C->deb("Fate passed to special_variable__S_154DollarVert_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_154DollarVert_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_154DollarVert_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\|/))
);
}

## token special_variable__S_155DollarColon (:$sym is context<rw> = <$:>)
##      token special_variable:sym<$:> {
##          <sym> <?before <[\x20\t\n\],=)}]> >
##          <obs('$: variable', 'Form module')>
##      }

sub special_variable__S_155DollarColon__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_155DollarColon',$retree) }
sub special_variable__S_155DollarColon {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($:);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_155DollarColon", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\:/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\n\],=)}]/)
}))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('$: variable', 'Form module')
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token special_variable__S_156DollarSemi (:$sym is context<rw> = <$;>)
##      token special_variable:sym<$;> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <obs('$; variable', 'real multidimensional hashes')>
##      }

sub special_variable__S_156DollarSemi__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_156DollarSemi',$retree) }
sub special_variable__S_156DollarSemi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($;);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_156DollarSemi", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$; variable', 'real multidimensional hashes')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_156DollarSemi_01') {
$C->deb("Fate passed to special_variable__S_156DollarSemi_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_156DollarSemi_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_156DollarSemi_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\;/))
);
}

## token special_variable__S_157DollarSingle (:$sym is context<rw> = <$'>)
##      token special_variable:sym<$'> { #'
##          <sym> :: <?before \s | ',' | <terminator> >
##          <obs('$' ~ "'" ~ 'variable', "explicit pattern after )\x3E")>
##      }

sub special_variable__S_157DollarSingle__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_157DollarSingle',$retree) }
sub special_variable__S_157DollarSingle {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($');


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_157DollarSingle", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$' . "'" . 'variable', "explicit pattern after )\x3E")
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_157DollarSingle_01') {
$C->deb("Fate passed to special_variable__S_157DollarSingle_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_157DollarSingle_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_157DollarSingle_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\'/))
);
}

## token special_variable__S_158DollarDouble (:$sym is context<rw> = <$">)
##      token special_variable:sym<$"> {
##          <sym> :: <?before \s | ',' | '=' | <terminator> >
##          <obs('$" variable', '.join() method')>
##      }

sub special_variable__S_158DollarDouble__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_158DollarDouble',$retree) }
sub special_variable__S_158DollarDouble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($");


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_158DollarDouble", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$" variable', '.join() method')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_158DollarDouble_01') {
$C->deb("Fate passed to special_variable__S_158DollarDouble_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_158DollarDouble_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_158DollarDouble_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\"/))
);
}

## token special_variable__S_159DollarComma (:$sym is context<rw> = <$,>)
##      token special_variable:sym<$,> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <obs('$, variable', ".join() method")>
##      }

sub special_variable__S_159DollarComma__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_159DollarComma',$retree) }
sub special_variable__S_159DollarComma {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[$,];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_159DollarComma", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$, variable', ".join() method")
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_159DollarComma_01') {
$C->deb("Fate passed to special_variable__S_159DollarComma_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_159DollarComma_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_159DollarComma_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\,/))
);
}

## token special_variable__S_160DollarLt (:$sym is context<rw> = ['$<'])
##      token special_variable:sym['$<'] {
##          <sym> :: <!before \s* \w+ \s* '>' >
##          <obs('$< variable', '$*UID')>
##      }

sub special_variable__S_160DollarLt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_160DollarLt',$retree) }
sub special_variable__S_160DollarLt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // ['$<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_160DollarLt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$< variable', '$*UID')
})
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT('>')
}, $C->_PATTERN(qr/\G((?:\s)*+)/))
}, $C->_PATTERN(qr/\G((?:\w)++)/))
}, $C->_PATTERN(qr/\G((?:\s)*+)/))
})
}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\[\'\$\<\'\]/))
);
}

## token special_variable__S_161DollarGt (:$sym is context<rw> = \$>)
##      token special_variable:sym\$> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <obs("$() variable", '$*EUID')>
##      }

sub special_variable__S_161DollarGt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_161DollarGt',$retree) }
sub special_variable__S_161DollarGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['\$>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_161DollarGt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs("$() variable", '$*EUID')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_161DollarGt_01') {
$C->deb("Fate passed to special_variable__S_161DollarGt_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_161DollarGt_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_161DollarGt_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\>/))
);
}

## token special_variable__S_162DollarDot (:$sym is context<rw> = <$.>)
##      token special_variable:sym<$.> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <obs('$. variable', "filehandle's .line method")>
##      }

sub special_variable__S_162DollarDot__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_162DollarDot',$retree) }
sub special_variable__S_162DollarDot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_162DollarDot", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$. variable', "filehandle's .line method")
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_162DollarDot_01') {
$C->deb("Fate passed to special_variable__S_162DollarDot_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_162DollarDot_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_162DollarDot_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\./))
);
}

## token special_variable__S_163DollarQuestion (:$sym is context<rw> = <$?>)
##      token special_variable:sym<$?> {
##          <sym> :: <?before \s | ',' | <terminator> >
##          <obs('$? variable as child error', '$!')>
##      }

sub special_variable__S_163DollarQuestion__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_163DollarQuestion',$retree) }
sub special_variable__S_163DollarQuestion {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "special_variable__S_163DollarQuestion", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['obs'], sub {
my $C = shift;
$C->obs('$? variable as child error', '$!')
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'special_variable__S_163DollarQuestion_01') {
$C->deb("Fate passed to special_variable__S_163DollarQuestion_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'special_variable__S_163DollarQuestion_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("special_variable__S_163DollarQuestion_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_SUBSUME(['terminator'], sub {
my $C = shift;
$C->terminator
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\$\?/))
);
}

# desigilname should only follow a sigil/twigil

## token desigilname
##      token desigilname {
##          [
##          | <?before '$' > <variable>
##          | <longname>
##          ]
##      }

sub desigilname__PEEK { $_[0]->_AUTOLEXpeek('desigilname',$retree) }
sub desigilname {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "desigilname", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'desigilname_01') {
$C->deb("Fate passed to desigilname_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'desigilname_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("desigilname_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('$')
}))) {
$C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token variable
##      token variable {
##          <?before <sigil> > {}
##          [
##          || '&' <twigil>?  <sublongname> {*}                                   #= subnoun
##          || <?before '$::('> '$' <name>?
##          || '$::' <name>? # XXX
##          || '$:' <name>? # XXX
##          || [
##              | <sigil> <twigil>? <desigilname> {*}                                    #= desigilname
##                  [ <?{ my $t = $<twigil>; @$t and $t.[0].text eq '.' }>
##                      <.unsp>? <?before '('> <postcircumfix> {*}          #= methcall
##                  ]?
##              | <special_variable> {*}                                    #= special
##              | <sigil> \d+ {*}                                           #= $0
##              # Note: $() can also parse as contextualizer in an expression; should have same effect
##              | <sigil> <?before '<' | '('> <postcircumfix> {*}           #= $()
##      	| <sigil> <?{ $+IN_DECL }> {*}				    #= anondecl
##              ]
##          ]
##      }

sub variable__PEEK { $_[0]->_AUTOLEXpeek('variable',$retree) }
sub variable {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'name'} = [];
$C->{'twigil'} = [];
$C->{'postcircumfix'} = [];

$self->_MATCHIFYr($S, "variable", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['sublongname'], sub {
my $C = shift;
$C->sublongname
}))) {
$C->_REDUCE($S, 'variable_subnoun');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('$::(')
}))) {
do {
if (my ($C) = ($C->_EXACT('$'))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
});
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->_EXACT('$::'))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
});
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->_EXACT('$:'))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
});
}
else {
();
}
}} 
or
eval { push @gather, $C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'variable_08') {
$C->deb("Fate passed to variable_08: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_08', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_08 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
}))) {
do {
if (my ($C) = ($C->_REDUCE($S, 'variable_desigilname'))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  my $t = $M->{twigil}; @$t and $t->[0]->text eq '.' ;
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('(')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
$C->_REDUCE($S, 'variable_methcall');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['special_variable'], sub {
my $C = shift;
$C->special_variable
}))) {
$C->_REDUCE($S, 'variable_special');
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_REDUCE($S, 'variable_$$C{0}');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'variable_11') {
$C->deb("Fate passed to variable_11: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'variable_11', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("variable_11 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('<')
},
sub { my $C=shift;
$C->_EXACT('(')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
$C->_REDUCE($S, 'variable_$()');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$::IN_DECL 
})
}))) {
$C->_REDUCE($S, 'variable_anondecl');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

# Note, don't reduce on a bare sigil unless you don't want a twigil or
# you otherwise don't care what the longest token is.

## token sigil__S_164Dollar (:$sym is context<rw> = <$>)
##      token sigil:sym<$>  { <sym> }

sub sigil__S_164Dollar__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_164Dollar',$retree) }
sub sigil__S_164Dollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_164Dollar", 
$C->_PATTERN(qr/\G\$/)
);
}
## token sigil__S_165AtAt (:$sym is context<rw> = <@@>)
##      token sigil:sym<@@> { <sym> }

sub sigil__S_165AtAt__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_165AtAt',$retree) }
sub sigil__S_165AtAt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@@);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_165AtAt", 
$C->_PATTERN(qr/\G\@\@/)
);
}
## token sigil__S_166At (:$sym is context<rw> = <@>)
##      token sigil:sym<@>  { <sym> }

sub sigil__S_166At__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_166At',$retree) }
sub sigil__S_166At {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_166At", 
$C->_PATTERN(qr/\G\@/)
);
}
## token sigil__S_167Percent (:$sym is context<rw> = <%>)
##      token sigil:sym<%>  { <sym> }

sub sigil__S_167Percent__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_167Percent',$retree) }
sub sigil__S_167Percent {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_167Percent", 
$C->_PATTERN(qr/\G\%/)
);
}
## token sigil__S_168Amp (:$sym is context<rw> = <&>)
##      token sigil:sym<&>  { <sym> }

sub sigil__S_168Amp__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_168Amp',$retree) }
sub sigil__S_168Amp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "sigil__S_168Amp", 
$C->_PATTERN(qr/\G\&/)
);
}

## token twigil__S_169Dot (:$sym is context<rw> = <.>)
##      token twigil:sym<.> { <sym> }

sub twigil__S_169Dot__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_169Dot',$retree) }
sub twigil__S_169Dot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_169Dot", 
$C->_PATTERN(qr/\G\./)
);
}
## token twigil__S_170Bang (:$sym is context<rw> = <!>)
##      token twigil:sym<!> { <sym> }

sub twigil__S_170Bang__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_170Bang',$retree) }
sub twigil__S_170Bang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_170Bang", 
$C->_PATTERN(qr/\G\!/)
);
}
## token twigil__S_171Caret (:$sym is context<rw> = <^>)
##      token twigil:sym<^> { <sym> }

sub twigil__S_171Caret__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_171Caret',$retree) }
sub twigil__S_171Caret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_171Caret", 
$C->_PATTERN(qr/\G\^/)
);
}
## token twigil__S_172Colon (:$sym is context<rw> = <:>)
##      token twigil:sym<:> { <sym> <!before ':'> }

sub twigil__S_172Colon__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_172Colon',$retree) }
sub twigil__S_172Colon {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_172Colon", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\:/))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(':')
})
});
}
else {
();
}
}
);
}
## token twigil__S_173Star (:$sym is context<rw> = <*>)
##      token twigil:sym<*> { <sym> }

sub twigil__S_173Star__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_173Star',$retree) }
sub twigil__S_173Star {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_173Star", 
$C->_PATTERN(qr/\G\*/)
);
}
## token twigil__S_174Plus (:$sym is context<rw> = <+>)
##      token twigil:sym<+> { <sym> }

sub twigil__S_174Plus__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_174Plus',$retree) }
sub twigil__S_174Plus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_174Plus", 
$C->_PATTERN(qr/\G\+/)
);
}
## token twigil__S_175Question (:$sym is context<rw> = <?>)
##      token twigil:sym<?> { <sym> }

sub twigil__S_175Question__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_175Question',$retree) }
sub twigil__S_175Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_175Question", 
$C->_PATTERN(qr/\G\?/)
);
}
## token twigil__S_176Equal (:$sym is context<rw> = <=>)
##      token twigil:sym<=> { <sym> }

sub twigil__S_176Equal__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_176Equal',$retree) }
sub twigil__S_176Equal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "twigil__S_176Equal", 
$C->_PATTERN(qr/\G\=/)
);
}

## token deflongname
##      token deflongname {
##          :dba('name to be defined')
##          <name>
##          # XXX too soon
##          [ <colonpair>+ { $.add_macro($<name>) if $+IN_DECL; } ]?
##          { $.add_routine($<name>.text) if $+IN_DECL; }
##      }

sub deflongname__PEEK { $_[0]->_AUTOLEXpeek('deflongname',$retree) }
sub deflongname {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "deflongname", 
do {
if (my ($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
scalar(do {
my $M = $C;  $C->add_macro($M->{name}) if $::IN_DECL; ;
}, $C);
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C;  $C->add_routine($M->{name}->text) if $::IN_DECL; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token longname
##      token longname {
##          <name> <colonpair>*
##      }

sub longname__PEEK { $_[0]->_AUTOLEXpeek('longname',$retree) }
sub longname {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "longname", 
do {
if (my ($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))) {
$C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
});
}
else {
();
}
}
);
}

## token name
##      token name {
##          [
##          | <identifier> <morename>*
##          | <morename>+
##          ]
##      }

sub name__PEEK { $_[0]->_AUTOLEXpeek('name',$retree) }
sub name {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'morename'} = [];

$self->_MATCHIFYr($S, "name", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'name_01') {
$C->deb("Fate passed to name_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'name_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("name_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
$C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['morename'], sub {
my $C = shift;
$C->morename
})
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['morename'], sub {
my $C = shift;
$C->morename
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token morename
##      token morename {
##          '::'
##          [
##              <?before '(' | <alpha> >
##              [
##              | <identifier>
##              | :dba('indirect name') '(' ~ ')' <EXPR>
##              ]
##          ]?
##      }

sub morename__PEEK { $_[0]->_AUTOLEXpeek('morename',$retree) }
sub morename {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'identifier'} = [];
$C->{'EXPR'} = [];

$self->_MATCHIFY($S, "morename", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'morename_03') {
$C->deb("Fate passed to morename_03: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'morename_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("morename_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'indirect name')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'morename_02') {
$C->deb("Fate passed to morename_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'morename_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("morename_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('(')
},
sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
})
})
}, $C->_EXACT('::'))
);
}

## token subshortname
##      token subshortname {
##          [
##          | <category>
##              [ <colonpair>+ { $.add_macro($<category>) if $+IN_DECL; } ]?
##          | <desigilname> { $.add_routine($<desigilname>.text) if $+IN_DECL; }
##          ]
##      }

sub subshortname__PEEK { $_[0]->_AUTOLEXpeek('subshortname',$retree) }
sub subshortname {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'colonpair'} = [];

$self->_MATCHIFYr($S, "subshortname", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'subshortname_01') {
$C->deb("Fate passed to subshortname_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'subshortname_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("subshortname_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['category'], sub {
my $C = shift;
$C->category
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
scalar(do {
my $M = $C;  $C->add_macro($M->{category}) if $::IN_DECL; ;
}, $C);
}
else {
();
}
}
})
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
}))) {
scalar(do {
my $M = $C;  $C->add_routine($M->{desigilname}->text) if $::IN_DECL; ;
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token sublongname
##      token sublongname {
##          <subshortname> <sigterm>?
##      }

sub sublongname__PEEK { $_[0]->_AUTOLEXpeek('sublongname',$retree) }
sub sublongname {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'sigterm'} = [];

$self->_MATCHIFYr($S, "sublongname", 
do {
if (my ($C) = ($C->_SUBSUMEr(['subshortname'], sub {
my $C = shift;
$C->subshortname
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['sigterm'], sub {
my $C = shift;
$C->sigterm
})
});
}
else {
();
}
}
);
}

#token subcall {
#    # XXX should this be sublongname?
#    <subshortname> <.unsp>? '.'? '(' ~ ')' <semilist>
#    {*}
#}

#token packagevar {
#    # Note: any ::() are handled within <name>, and subscript must be final part.
#    # A bare ::($foo) is not considered a variable, but ::($foo)::<$bar> is.
#    # (The point being that we want a sigil either first or last but not both.)
#    <?before [\w+] ** '::' [ '<' | '' | '{' ]> ::
#    <name> '::' <postcircumfix> {*}                            #= FOO::<$x>
#}

## token value
##      token value {
##          [
##          | <quote>
##          | <number>
##          | <version>
##      #    | <packagevar>     # XXX see term:name for now
##      #    | <fulltypename>   # XXX see term:name for now
##          ]
##      }

sub value__PEEK { $_[0]->_AUTOLEXpeek('value',$retree) }
sub value {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "value", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'value_01') {
$C->deb("Fate passed to value_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'value_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("value_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['number'], sub {
my $C = shift;
$C->number
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token typename
##      token typename {
##          [
##          | '::?'<identifier>			# parse ::?CLASS as special case
##          | <longname>
##            <?{{
##              my $longname = $<longname>.text;
##              if substr($longname, 0, 2) eq '::' {
##                  $.add_type(substr($longname, 2));
##              }
##              else {
##                  $.is_type($longname)
##              }
##            }}>
##          ]
##          # parametric type?
##          <.unsp>? [ <?before '['> <postcircumfix> ]?
##      }

sub typename__PEEK { $_[0]->_AUTOLEXpeek('typename',$retree) }
sub typename {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'postcircumfix'} = [];

$self->_MATCHIFYr($S, "typename", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'typename_01') {
$C->deb("Fate passed to typename_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'typename_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("typename_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::?'))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C; 
my $longname = $M->{longname}->text;
if (substr($longname, 0, 2) eq '::') {
$C->add_type(substr($longname, 2));
}
else {
$C->is_type($longname)
}
;
})
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule fulltypename
##      rule fulltypename {<typename>['|'<typename>]*
##          [ of <fulltypename> ]?
##      }

sub fulltypename__PEEK { $_[0]->_AUTOLEXpeek('fulltypename',$retree) }
sub fulltypename {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'typename'} = [];
$C->{'fulltypename'} = [];

$self->_MATCHIFYr($S, "fulltypename", 
do {
if (my ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('|'))) {
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('of'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token number
##      token number {
##          [
##          | <dec_number>
##          | <integer>
##          | <rad_number>
##          ]
##      }

sub number__PEEK { $_[0]->_AUTOLEXpeek('number',$retree) }
sub number {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "number", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'number_01') {
$C->deb("Fate passed to number_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'number_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("number_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['dec_number'], sub {
my $C = shift;
$C->dec_number
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['integer'], sub {
my $C = shift;
$C->integer
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['rad_number'], sub {
my $C = shift;
$C->rad_number
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token integer
##      token integer {
##          [
##          | 0 [ b <[01]>+           [ _ <[01]>+ ]*
##              | o <[0..7]>+         [ _ <[0..7]>+ ]*
##              | x <[0..9a..fA..F]>+ [ _ <[0..9a..fA..F]>+ ]*
##              | d \d+               [ _ \d+]*
##              | \d+[_\d+]*
##                  { $.worry("Leading 0 does not indicate octal in Perl 6") }
##              ]
##          | \d+[_\d+]*
##          ]
##      }

sub integer__PEEK { $_[0]->_AUTOLEXpeek('integer',$retree) }
sub integer {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "integer", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'integer_01') {
$C->deb("Fate passed to integer_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'integer_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("integer_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('0'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'integer_02') {
$C->deb("Fate passed to integer_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'integer_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("integer_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('b'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[01])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[01])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('o'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-7])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-7])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('x'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('d'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
}))) {
scalar(do {
$C->worry("Leading 0 does not indicate octal in Perl 6") 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token radint
##      token radint {
##          [
##          | <integer>
##          | <?before ':'> <rad_number> <?{
##                              defined $<rad_number><intpart>
##                              and
##                              not defined $<rad_number><fracpart>
##                          }>
##          ]
##      }

sub radint__PEEK { $_[0]->_AUTOLEXpeek('radint',$retree) }
sub radint {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "radint", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'radint_01') {
$C->deb("Fate passed to radint_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'radint_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("radint_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['integer'], sub {
my $C = shift;
$C->integer
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT(':')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['rad_number'], sub {
my $C = shift;
$C->rad_number
}))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C; 
defined $M->{rad_number}{intpart}
and
not defined $M->{rad_number}{fracpart}
;
})
});
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token escale
##      token escale {
##          <[Ee]> <[+\-]>? \d+[_\d+]*
##      }

sub escale__PEEK { $_[0]->_AUTOLEXpeek('escale',$retree) }
sub escale {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "escale", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G[Ee]/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[+\-])?+)/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# careful to distinguish from both integer and 42.method
## token dec_number
##      token dec_number {
##          :dba('decimal number')
##          [
##          | $<coeff> = [           '.' \d+[_\d+]* ] <escale>?
##          | $<coeff> = [\d+[_\d+]* '.' \d+[_\d+]* ] <escale>?
##          | $<coeff> = [\d+[_\d+]*                ] <escale>
##          ]
##      }

sub dec_number__PEEK { $_[0]->_AUTOLEXpeek('dec_number',$retree) }
sub dec_number {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'escale'} = [];

$self->_MATCHIFYr($S, "dec_number", 
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'dec_number_01') {
$C->deb("Fate passed to dec_number_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'dec_number_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("dec_number_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:\d)++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
})
}))) {
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token rad_number
##      token rad_number {
##          ':' $<radix> = [\d+] <.unsp>?      # XXX optional dot here?
##          {}           # don't recurse in lexer
##          :dba('number in radix notation')
##          [
##          || '<'
##                  $<intpart> = [ <[ 0..9 a..z A..Z ]>+ [ _ <[ 0..9 a..z A..Z ]>+ ]* ]
##                  $<fracpart> = [ '.' <[ 0..9 a..z A..Z ]>+ [ _ <[ 0..9 a..z A..Z ]>+ ]* ]?
##                  [ '*' <base=radint> '**' <exp=radint> ]?
##             '>'
##      #      { make radcalc($<radix>, $<intpart>, $<fracpart>, $<base>, $<exp>) }
##          || <?before '['> <postcircumfix>
##          || <?before '('> <postcircumfix>
##          ]
##      }

sub rad_number__PEEK { $_[0]->_AUTOLEXpeek('rad_number',$retree) }
sub rad_number {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'exp'} = [];
$C->{'base'} = [];

$self->_MATCHIFYr($S, "rad_number", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['radix'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['intpart'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['fracpart'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-zA-Z])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
})
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('*'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['base'], sub {
my $C = shift;
$C->radint
}))) {
do {
if (my ($C) = ($C->_EXACT('**'))) {
$C->_SUBSUMEr(['exp'], sub {
my $C = shift;
$C->radint
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_EXACT('>');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('(')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token octint
##      token octint {
##          <[ 0..7 ]>+ [ _ <[ 0..7 ]>+ ]*
##      }

sub octint__PEEK { $_[0]->_AUTOLEXpeek('octint',$retree) }
sub octint {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "octint", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-7])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-7])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

## token hexint
##      token hexint {
##          <[ 0..9 a..f A..F ]>+ [ _ <[ 0..9 a..f A..F ]>+ ]*
##      }

sub hexint__PEEK { $_[0]->_AUTOLEXpeek('hexint',$retree) }
sub hexint {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "hexint", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/))) {
$C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('_'))) {
$C->_PATTERN(qr/\G((?:[0-9a-fA-F])++)/);
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}

our @herestub_queue;

{ package STD::Herestub;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_has 'delim' => (is => 'rw');    moose_has 'orignode' => (is => 'rw');    moose_has 'lang' => (is => 'rw');} ## end class

{ package STD::herestop;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##     token stopper
##          token stopper { ^^ {*} $<ws>=(\h*?) $+DELIM \h* <.unv>?? $$ \v? }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "stopper", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G((?:[\n])?+)/)
}, $C->_PATTERN(qr/\G(?m:$)/))
}, $C->_OPTf(sub { my $C=shift;
$C->unv
}))
}, $C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))
}, $C->_EXACT($::DELIM))
},     $C->_SUBSUME(['ws'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_STARf(sub { my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]/)
})
})}
}))
}, $C->_REDUCE($S, 'stopper'))
}, $C->_PATTERN(qr/\G(?m:^)/))
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: stopper
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_meta 
        a: 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        text: "^^"
      - !!perl/hash:RE_method_internal 
        args: $S, 'stopper'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 0
          nobind: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: stopper
              i: 0
              min: 1
              r: 1
              s: 0
              text: \h
            min: 0
            quant: 
              - "*"
              - "?"
              - ''
              - 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        var: ws
      - !!perl/hash:RE_var 
        a: 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        var: $+DELIM
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: stopper
          i: 0
          min: 1
          r: 1
          s: 0
          text: \h
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: stopper
          i: 0
          min: 12345
          name: unv
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - "?"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: stopper
        i: 0
        min: 0
        r: 1
        s: 0
        text: $$
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: stopper
          i: 0
          min: 1
          r: 1
          s: 0
          text: \v
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
RETREE_END
}
} ## end role

# XXX be sure to temporize @herestub_queue on reentry to new line of heredocs

## method heredoc ()
sub heredoc {
my $self = shift;


local $CTX = $self->callm if $::DEBUG & DEBUG::trace_call;
return if $self->peek;
my $here = $self;
while (my $herestub = shift @herestub_queue) {
local $DELIM =  $herestub->delim;
my $lang = $herestub->lang->mixin( 'STD::herestop' );
my $doc;
if (($doc) = $here->nibble($lang)) {
$here = $doc->trim_heredoc();
$herestub->orignode->{doc} = $doc;
}
else {
$self->panic("Ending delimiter $DELIM not found");
}
}
return $self->cursor($here->{_pos});  # return to initial type
}

#proto token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'backslash:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "backslash", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}

#proto token escape { <...> }
sub escape__PEEK { $_[0]->_AUTOLEXpeek('escape:*',$retree); }
sub escape {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'escape') {
$C->deb("Fate passed to escape: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'escape:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "escape", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}

## token starter
##      token starter { <!> }

sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter',$retree) }
sub starter {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "starter", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
## token escape__S_177none (:$sym is context<rw> = 'none')
##      token escape:none { <!> }

sub escape__S_177none__PEEK { $_[0]->_AUTOLEXpeek('escape__S_177none',$retree) }
sub escape__S_177none {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'none';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_177none", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}

## token babble ($l)
##      token babble ($l) {
##          :my $lang = $l;
##          :my $start;
##          :my $stop;
##      
##          <.ws>
##          [ <quotepair> <.ws>
##      	{
##      	    my $kv = $<quotepair>[*-1];
##      	    $lang = $lang.tweak($kv.<k>, $kv.<v>)
##                      or self.panic("Unrecognized adverb :" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');
##      	}
##          ]*
##      
##          {
##              ($start,$stop) = $.peek_delimiters();
##              $lang = $start ne $stop ?? $lang.balanced($start,$stop)
##                                      !! $lang.unbalanced($stop);
##              $<B> = [$lang,$start,$stop];
##          }
##      }

sub babble__PEEK { $_[0]->_AUTOLEXpeek('babble',$retree) }
sub babble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my $lang = $l;
my $start;
my $stop;


my $C = $self;
my $S = $C->{_pos};
$C->{'quotepair'} = [];

$self->_MATCHIFYr($S, "babble", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
}))) {
do {
if (my ($C) = ($C->ws)) {
scalar(do {
my $M = $C; 
my $kv = $M->{quotepair}[-1];
$lang = $lang->tweak($kv->{'k'}, $kv->{'v'})
or $self->panic("Unrecognized adverb :" . $kv->{'k'} . '(' . $kv->{'v'} . ')');
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C; 
($start,$stop) = $C->peek_delimiters();
$lang = $start ne $stop ? $lang->balanced($start,$stop)
: $lang->unbalanced($stop);
$M->{B} = [$lang,$start,$stop];
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quibble ($l)
##      token quibble ($l) {
##          :my ($lang, $start, $stop);
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          $start <nibble($lang)> $stop
##      
##          {{
##              if $lang<_herelang> {
##                  push @herestub_queue,
##                      STD::Herestub.new(
##                          delim => $<nibble><nibbles>[0],
##                          orignode => $,
##                          lang => $lang<_herelang>,
##                      );
##              }
##          }}
##      }

sub quibble__PEEK { $_[0]->_AUTOLEXpeek('quibble',$retree) }
sub quibble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my ($lang, $start, $stop);


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "quibble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{babble}{B}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
do {
if (my ($C) = ($C->_EXACT($stop))) {
scalar(do {
my $M = $C; 
if ($lang->{_herelang}) {
push @herestub_queue,
STD::Herestub->new(
delim => $M->{nibble}{nibbles}[0],
orignode => $C,
lang => $lang->{_herelang},
);
}
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token sibble ($l, $lang2)
##      token sibble ($l, $lang2) {
##          :my ($lang, $start, $stop);
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          $start <left=nibble($lang)> $stop 
##          [ <?{ $start ne $stop }>
##      	<.ws>
##              [ '=' || <.panic: "Missing '='"> ]
##              <.ws>
##              <right=EXPR(item %item_assignment)>
##          || 
##      	{ $lang = $lang2.unbalanced($stop); }
##      	<right=nibble($lang)> $stop
##          ]
##      }

sub sibble__PEEK { $_[0]->_AUTOLEXpeek('sibble',$retree) }
sub sibble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my $lang2 = shift;
my ($lang, $start, $stop);


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "sibble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{babble}{B}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['left'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
do {
if (my ($C) = ($C->_EXACT($stop))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$start ne $stop 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('=')} 
or
eval { push @gather, $C->panic("Missing '='")} or do { die $@ if $@ };
@gather;
}
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = (scalar(do {
$lang = $lang2->unbalanced($stop); 
}, $C))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
$C->_EXACT($stop);
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token tribble ($l, $lang2 = $l)
##      token tribble ($l, $lang2 = $l) {
##          :my ($lang, $start, $stop);
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          $start <left=nibble($lang)> $stop 
##          [ <?{ $start ne $stop }>
##      	<.ws> <quibble($lang2)>
##          || 
##      	{ $lang = $lang2.unbalanced($stop); }
##      	<right=nibble($lang)> $stop
##          ]
##      }

sub tribble__PEEK { $_[0]->_AUTOLEXpeek('tribble',$retree) }
sub tribble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my $lang2 = shift() // $l;
my ($lang, $start, $stop);


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "tribble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{babble}{B}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['left'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
do {
if (my ($C) = ($C->_EXACT($stop))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$start ne $stop 
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($lang2)
});
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = (scalar(do {
$lang = $lang2->unbalanced($stop); 
}, $C))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->nibble($lang)
}))) {
$C->_EXACT($stop);
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quasiquibble ($l)
##      token quasiquibble ($l) {
##          :my ($lang, $start, $stop);
##          <babble($l)>
##          { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }
##      
##          [
##          || <?{ $start eq '{' }> [ :lang($lang) <block> ]
##          || $start [ :lang($lang) <statementlist> ] $stop
##          ]
##      }

sub quasiquibble__PEEK { $_[0]->_AUTOLEXpeek('quasiquibble',$retree) }
sub quasiquibble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $l = shift;
my ($lang, $start, $stop);


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "quasiquibble", 
do {
if (my ($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  my $B = $M->{babble}{B}; ($lang,$start,$stop) = @$B; ;
}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
$start eq '{' 
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
});
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->_EXACT($start))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))) {
$C->_EXACT($stop);
}
else {
();
}
};
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

# note: polymorphic over many quote languages, we hope
## token nibbler
##      token nibbler {
##          :my $text = '';
##          :my @nibbles = ();
##          :my $multiline = 0;
##          :my $nibble;
##          { $<firstpos> = self.pos; }
##          [ <!before <stopper> >
##              [
##              || <starter> <nibbler> <stopper>
##                              {
##                                  my $n = $<nibbler>[*-1]<nibbles>;
##                                  my @n = @$n;
##                                  $text ~= $<starter>[*-1].text ~ shift(@n);
##                                  $text = (@n ?? pop(@n) !! '') ~ $<stopper>[*-1].text;
##                                  push @nibbles, @n;
##                              }
##              || <escape>   {
##                                  push @nibbles, $text, $<escape>[*-1];
##                                  $text = '';
##                              }
##              || .
##                              {{
##                                  my $ch = substr($ORIG, $.pos-1, 1);
##                                  $text ~= $ch;
##                                  if $ch ~~ "\n" {
##                                      $multiline++;
##                                  }
##                              }}
##              ]
##          ]*
##          {
##              push @nibbles, $text; $<nibbles> = [@nibbles];
##              $<lastpos> = $.pos;
##              $<nibbler> :delete;
##              $<escape> :delete;
##              $COMPILING::LAST_NIBBLE = $;
##              $COMPILING::LAST_NIBBLE_MULTILINE = $ if $multiline;
##          }
##      }

sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler',$retree) }
sub nibbler {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $text = '';
my @nibbles = ();
my $multiline = 0;
my $nibble;


my $C = $self;
my $S = $C->{_pos};
$C->{'nibbler'} = [];
$C->{'stopper'} = [];
$C->{'starter'} = [];
$C->{'escape'} = [];

$self->_MATCHIFYr($S, "nibbler", 
do {
if (my ($C) = (scalar(do {
my $M = $C;  $M->{firstpos} = $self->{_pos}; ;
}, $C))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
scalar(do {
my $M = $C; 
my $n = $M->{nibbler}[-1]{'nibbles'};
my @n = @$n;
$text .= $M->{starter}[-1]->text . shift(@n);
$text = (@n ? pop(@n) : '') . $M->{stopper}[-1]->text;
push @nibbles, @n;
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['escape'], sub {
my $C = shift;
$C->escape
}))) {
scalar(do {
my $M = $C; 
push @nibbles, $text, $M->{escape}[-1];
$text = '';
;
}, $C);
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->_PATTERN(qr/\G(?s:.)/))) {
scalar(do {

my $ch = substr($ORIG, $C->{_pos}-1, 1);
$text .= $ch;
if ($ch =~ "\n") {
$multiline++;
}

}, $C);
}
else {
();
}
}} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
}
})
}))) {
scalar(do {
my $M = $C; 
push @nibbles, $text; $M->{nibbles} = [@nibbles];
$M->{lastpos} = $C->{_pos};
delete $M->{nibbler};
delete $M->{escape};
$COMPILING::LAST_NIBBLE = $C;
$COMPILING::LAST_NIBBLE_MULTILINE = $C if $multiline;
;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

# and this is what makes nibbler polymorphic...
## method nibble ($lang)
sub nibble {
my $self = shift;
my $lang = shift;


my $outerlang = (ref($self)||$self);
local $LANG =  $outerlang;
$self->cursor_fresh($lang)->nibbler;
}


## token quote__S_178Single_Single (:$sym is context<rw> = <' '>)
##      token quote:sym<' '>   { "'" <nibble($.cursor_fresh( ::STD::Q ).tweak(:q).unbalanced("'"))> "'" }

sub quote__S_178Single_Single__PEEK { $_[0]->_AUTOLEXpeek('quote__S_178Single_Single',$retree) }
sub quote__S_178Single_Single {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(' ')];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_178Single_Single", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G'/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1)->unbalanced("'"))
}))) {
$C->_PATTERN(qr/\G'/);
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_179Double_Double (:$sym is context<rw> = <" ">)
##      token quote:sym<" ">   { '"' <nibble($.cursor_fresh( ::STD::Q ).tweak(:qq).unbalanced('"'))> '"' }

sub quote__S_179Double_Double__PEEK { $_[0]->_AUTOLEXpeek('quote__S_179Double_Double',$retree) }
sub quote__S_179Double_Double {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(" ")];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_179Double_Double", 
do {
if (my ($C) = ($C->_EXACT('"'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1)->unbalanced('"'))
}))) {
$C->_EXACT('"');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_180Fre_Nch (:$sym is context<rw> = < >)
##      token quote:sym< >   { '' <nibble($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('',''))> '' }

sub quote__S_180Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('quote__S_180Fre_Nch',$retree) }
sub quote__S_180Fre_Nch {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw( )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_180Fre_Nch", 
do {
if (my ($C) = ($C->_EXACT(''))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('',''))
}))) {
$C->_EXACT('');
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_181LtLt_GtGt (:$sym is context<rw> = << >>)
##      token quote:sym<< >> { '<<' <nibble($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('<<','>>'))> '>>' }

sub quote__S_181LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('quote__S_181LtLt_GtGt',$retree) }
sub quote__S_181LtLt_GtGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<','>>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_181LtLt_GtGt", 
do {
if (my ($C) = ($C->_EXACT('<<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('<<','>>'))
}))) {
$C->_EXACT('>>');
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_182Lt_Gt (:$sym is context<rw> = < >)
##      token quote:sym< >   { '<' <nibble($.cursor_fresh( ::STD::Q ).tweak(:q).tweak(:w).balanced('<','>'))> '>' }

sub quote__S_182Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('quote__S_182Lt_Gt',$retree) }
sub quote__S_182Lt_Gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<','>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_182Lt_Gt", 
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1)->tweak('w' => 1)->balanced('<','>'))
}))) {
$C->_EXACT('>');
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_183Slash_Slash (:$sym is context<rw> = </ />)
##      token quote:sym</ />   {
##          '/' <nibble( $.cursor_fresh( ::Regex ).unbalanced("/") )> [ '/' || <.panic: "Unable to parse regex; couldn't find final '/'"> ]
##          <.old_rx_mods>?
##      }

sub quote__S_183Slash_Slash__PEEK { $_[0]->_AUTOLEXpeek('quote__S_183Slash_Slash',$retree) }
sub quote__S_183Slash_Slash {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(/ /)];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_183Slash_Slash", 
do {
if (my ($C) = ($C->_EXACT('/'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble( $C->cursor_fresh( 'STD::Regex' )->unbalanced("/") )
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('/')} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find final '/'")} or do { die $@ if $@ };
@gather;
}
}))) {
$C->_OPTr(sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# handle composite forms like qww
## token quote__S_184qq (:$sym is context<rw> = 'qq')
##      token quote:qq {
##          :my $qm;
##          'qq'
##          [
##          | <quote_mod>  <!before '('> { $qm = $<quote_mod>.text } <.ws> <quibble($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak($qm => 1))>
##          |  <!before '('> <.ws> <quibble($.cursor_fresh( ::STD::Q ).tweak(:qq))>
##          ]
##      }

sub quote__S_184qq__PEEK { $_[0]->_AUTOLEXpeek('quote__S_184qq',$retree) }
sub quote__S_184qq {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qq';
my $qm;


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_184qq", 
do {
if (my ($C) = ($C->_EXACT('qq'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quote__S_184qq_01') {
$C->deb("Fate passed to quote__S_184qq_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote__S_184qq_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote__S_184qq_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $qm = $M->{quote_mod}->text ;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1)->tweak($qm => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
## token quote__S_185q (:$sym is context<rw> = 'q')
##      token quote:q {
##          :my $qm;
##          'q'
##          [
##          | <quote_mod>  <!before '('> { $qm = $<quote_mod>.text } <quibble($.cursor_fresh( ::STD::Q ).tweak(:q).tweak($qm => 1))>
##          |  <!before '('> <.ws> <quibble($.cursor_fresh( ::STD::Q ).tweak(:q))>
##          ]
##      }

sub quote__S_185q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_185q',$retree) }
sub quote__S_185q {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'q';
my $qm;


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_185q", 
do {
if (my ($C) = ($C->_EXACT('q'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quote__S_185q_01') {
$C->deb("Fate passed to quote__S_185q_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote__S_185q_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote__S_185q_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $qm = $M->{quote_mod}->text ;
}, $C))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1)->tweak($qm => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token quote__S_186Q (:$sym is context<rw> = 'Q')
##      token quote:Q {
##          :my $qm;
##          'Q'
##          [
##          | <quote_mod>  <!before '('> { $qm = $<quote_mod>.text } <quibble($.cursor_fresh( ::STD::Q ).tweak($qm => 1))>
##          |  <!before '('> <.ws> <quibble($.cursor_fresh( ::STD::Q ))>
##          ]
##      }

sub quote__S_186Q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_186Q',$retree) }
sub quote__S_186Q {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Q';
my $qm;


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_186Q", 
do {
if (my ($C) = ($C->_EXACT('Q'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quote__S_186Q_01') {
$C->deb("Fate passed to quote__S_186Q_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'quote__S_186Q_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quote__S_186Q_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $qm = $M->{quote_mod}->text ;
}, $C))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak($qm => 1))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' ))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token quote_mod__S_187w (:$sym is context<rw> = 'w')
##      token quote_mod:w  { <sym> }

sub quote_mod__S_187w__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_187w',$retree) }
sub quote_mod__S_187w {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'w';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_187w", 
$C->_PATTERN(qr/\Gw/)
);
}
## token quote_mod__S_188ww (:$sym is context<rw> = 'ww')
##      token quote_mod:ww { <sym> }

sub quote_mod__S_188ww__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_188ww',$retree) }
sub quote_mod__S_188ww {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'ww';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_188ww", 
$C->_PATTERN(qr/\Gww/)
);
}
## token quote_mod__S_189x (:$sym is context<rw> = 'x')
##      token quote_mod:x  { <sym> }

sub quote_mod__S_189x__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_189x',$retree) }
sub quote_mod__S_189x {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_189x", 
$C->_PATTERN(qr/\Gx/)
);
}
## token quote_mod__S_190to (:$sym is context<rw> = 'to')
##      token quote_mod:to { <sym> }

sub quote_mod__S_190to__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_190to',$retree) }
sub quote_mod__S_190to {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'to';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_190to", 
$C->_PATTERN(qr/\Gto/)
);
}
## token quote_mod__S_191s (:$sym is context<rw> = 's')
##      token quote_mod:s  { <sym> }

sub quote_mod__S_191s__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_191s',$retree) }
sub quote_mod__S_191s {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_191s", 
$C->_PATTERN(qr/\Gs/)
);
}
## token quote_mod__S_192a (:$sym is context<rw> = 'a')
##      token quote_mod:a  { <sym> }

sub quote_mod__S_192a__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_192a',$retree) }
sub quote_mod__S_192a {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_192a", 
$C->_PATTERN(qr/\Ga/)
);
}
## token quote_mod__S_193h (:$sym is context<rw> = 'h')
##      token quote_mod:h  { <sym> }

sub quote_mod__S_193h__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_193h',$retree) }
sub quote_mod__S_193h {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'h';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_193h", 
$C->_PATTERN(qr/\Gh/)
);
}
## token quote_mod__S_194f (:$sym is context<rw> = 'f')
##      token quote_mod:f  { <sym> }

sub quote_mod__S_194f__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_194f',$retree) }
sub quote_mod__S_194f {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_194f", 
$C->_PATTERN(qr/\Gf/)
);
}
## token quote_mod__S_195c (:$sym is context<rw> = 'c')
##      token quote_mod:c  { <sym> }

sub quote_mod__S_195c__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_195c',$retree) }
sub quote_mod__S_195c {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_195c", 
$C->_PATTERN(qr/\Gc/)
);
}
## token quote_mod__S_196b (:$sym is context<rw> = 'b')
##      token quote_mod:b  { <sym> }

sub quote_mod__S_196b__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_196b',$retree) }
sub quote_mod__S_196b {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote_mod__S_196b", 
$C->_PATTERN(qr/\Gb/)
);
}

## token quote__S_197rx (:$sym is context<rw> = 'rx')
##      token quote:rx {
##          <sym>  <!before '('>
##          <quibble( $.cursor_fresh( ::Regex ) )>
##          <!old_rx_mods>
##      }

sub quote__S_197rx__PEEK { $_[0]->_AUTOLEXpeek('quote__S_197rx',$retree) }
sub quote__S_197rx {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'rx';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_197rx", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grx/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( 'STD::Regex' ) )
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_198m (:$sym is context<rw> = 'm')
##      token quote:m  {
##          <sym>  <!before '('>
##          <quibble( $.cursor_fresh( ::Regex ) )>
##          <!old_rx_mods>
##      }

sub quote__S_198m__PEEK { $_[0]->_AUTOLEXpeek('quote__S_198m',$retree) }
sub quote__S_198m {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'm';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_198m", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gm/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( 'STD::Regex' ) )
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_199mm (:$sym is context<rw> = 'mm')
##      token quote:mm {
##          <sym>  <!before '('>
##          <quibble( $.cursor_fresh( ::Regex ).tweak(:s))>
##          <!old_rx_mods>
##      }

sub quote__S_199mm__PEEK { $_[0]->_AUTOLEXpeek('quote__S_199mm',$retree) }
sub quote__S_199mm {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mm';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_199mm", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmm/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( 'STD::Regex' )->tweak('s' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_200s (:$sym is context<rw> = 's')
##      token quote:s {
##          <sym>  <!before '('>
##          <pat=sibble( $.cursor_fresh( ::Regex ), $.cursor_fresh( ::STD::Q ).tweak(:qq))>
##          <!old_rx_mods>
##      }

sub quote__S_200s__PEEK { $_[0]->_AUTOLEXpeek('quote__S_200s',$retree) }
sub quote__S_200s {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_200s", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gs/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->sibble( $C->cursor_fresh( 'STD::Regex' ), $C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token quote__S_201ss (:$sym is context<rw> = 'ss')
##      token quote:ss {
##          <sym>  <!before '('>
##          <pat=sibble( $.cursor_fresh( ::Regex ).tweak(:s), $.cursor_fresh( ::STD::Q ).tweak(:qq))>
##          <!old_rx_mods>
##      }

sub quote__S_201ss__PEEK { $_[0]->_AUTOLEXpeek('quote__S_201ss',$retree) }
sub quote__S_201ss {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'ss';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_201ss", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gss/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->sibble( $C->cursor_fresh( 'STD::Regex' )->tweak('s' => 1), $C->cursor_fresh( 'STD::Q' )->tweak('qq' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_rx_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token quote__S_202tr (:$sym is context<rw> = 'tr')
##      token quote:tr {
##          <sym>  <!before '('> <pat=tribble( $.cursor_fresh( ::STD::Q ).tweak(:q))>
##          <!old_tr_mods>
##      }

sub quote__S_202tr__PEEK { $_[0]->_AUTOLEXpeek('quote__S_202tr',$retree) }
sub quote__S_202tr {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'tr';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_202tr", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtr/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->tribble( $C->cursor_fresh( 'STD::Q' )->tweak('q' => 1))
}))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->old_tr_mods
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token old_rx_mods
##      token old_rx_mods {
##          (< i g s m x c e ] >+) 
##          {{
##              given $0.text {
##                  $_ ~~ /i/ and $.worryobs('/i',':i');
##                  $_ ~~ /g/ and $.worryobs('/g',':g');
##                  $_ ~~ /s/ and $.worryobs('/s','^^ and $$ anchors');
##                  $_ ~~ /m/ and $.worryobs('/m','. or \N');
##                  $_ ~~ /x/ and $.worryobs('/x','normal default whitespace');
##                  $_ ~~ /c/ and $.worryobs('/c',':c or :p');
##                  $_ ~~ /e/ and $.worryobs('/e','interpolated {...} or s{} = ... form');
##                  $.obs('suffix regex modifiers','prefix adverbs');
##              }
##          }}
##      }

sub old_rx_mods__PEEK { $_[0]->_AUTOLEXpeek('old_rx_mods',$retree) }
sub old_rx_mods {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "old_rx_mods", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_ARRAY( qw< i g s m x c e ] > )
})
})}
}))) {
scalar(do {

do { my $_ = $$C{0}->text; if ((0)) {}
$_ =~ qr/i/ and $C->worryobs('/i',':i');
$_ =~ qr/g/ and $C->worryobs('/g',':g');
$_ =~ qr/s/ and $C->worryobs('/s','^^ and $$ anchors');
$_ =~ qr/m/ and $C->worryobs('/m','. or \N');
$_ =~ qr/x/ and $C->worryobs('/x','normal default whitespace');
$_ =~ qr/c/ and $C->worryobs('/c',':c or :p');
$_ =~ qr/e/ and $C->worryobs('/e','interpolated {...} or s{} = ... form');
$C->obs('suffix regex modifiers','prefix adverbs');
};

}, $C);
}
else {
();
}
}
);
}

## token old_tr_mods
##      token old_tr_mods {
##          (< c d s ] >+) 
##          {{
##              given $0.text {
##                  $_ ~~ /c/ and $.worryobs('/c',':c');
##                  $_ ~~ /d/ and $.worryobs('/g',':d');
##                  $_ ~~ /s/ and $.worryobs('/s',':s');
##                  $.obs('suffix transliteration modifiers','prefix adverbs');
##              }
##          }}
##      }

sub old_tr_mods__PEEK { $_[0]->_AUTOLEXpeek('old_tr_mods',$retree) }
sub old_tr_mods {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "old_tr_mods", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PLUSr(sub { my $C=shift;
$C->_ARRAY( qw< c d s ] > )
})
})}
}))) {
scalar(do {

do { my $_ = $$C{0}->text; if ((0)) {}
$_ =~ qr/c/ and $C->worryobs('/c',':c');
$_ =~ qr/d/ and $C->worryobs('/g',':d');
$_ =~ qr/s/ and $C->worryobs('/s',':s');
$C->obs('suffix transliteration modifiers','prefix adverbs');
};

}, $C);
}
else {
();
}
}
);
}


## token quote__S_203quasi (:$sym is context<rw> = 'quasi')
##      token quote:quasi {
##          <sym>  <!before '('> <quasiquibble($.cursor_fresh( ::STD::Quasi ))>
##      }

sub quote__S_203quasi__PEEK { $_[0]->_AUTOLEXpeek('quote__S_203quasi',$retree) }
sub quote__S_203quasi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quasi';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quote__S_203quasi", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gquasi/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('(')
})
}))) {
$C->_SUBSUMEr(['quasiquibble'], sub {
my $C = shift;
$C->quasiquibble($C->cursor_fresh( 'STD::Quasi' ))
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# XXX should eventually be derived from current Unicode tables.
our %open2close = (
"\x{0028}" => "\x{0029}", "\x{003C}" => "\x{003E}", "\x{005B}" => "\x{005D}",
"\x{007B}" => "\x{007D}", "\x{00AB}" => "\x{00BB}", "\x{0F3A}" => "\x{0F3B}",
"\x{0F3C}" => "\x{0F3D}", "\x{169B}" => "\x{169C}", "\x{2039}" => "\x{203A}",
"\x{2045}" => "\x{2046}", "\x{207D}" => "\x{207E}", "\x{208D}" => "\x{208E}",
"\x{2208}" => "\x{220B}", "\x{2209}" => "\x{220C}", "\x{220A}" => "\x{220D}",
"\x{2215}" => "\x{29F5}", "\x{223C}" => "\x{223D}", "\x{2243}" => "\x{22CD}",
"\x{2252}" => "\x{2253}", "\x{2254}" => "\x{2255}", "\x{2264}" => "\x{2265}",
"\x{2266}" => "\x{2267}", "\x{2268}" => "\x{2269}", "\x{226A}" => "\x{226B}",
"\x{226E}" => "\x{226F}", "\x{2270}" => "\x{2271}", "\x{2272}" => "\x{2273}",
"\x{2274}" => "\x{2275}", "\x{2276}" => "\x{2277}", "\x{2278}" => "\x{2279}",
"\x{227A}" => "\x{227B}", "\x{227C}" => "\x{227D}", "\x{227E}" => "\x{227F}",
"\x{2280}" => "\x{2281}", "\x{2282}" => "\x{2283}", "\x{2284}" => "\x{2285}",
"\x{2286}" => "\x{2287}", "\x{2288}" => "\x{2289}", "\x{228A}" => "\x{228B}",
"\x{228F}" => "\x{2290}", "\x{2291}" => "\x{2292}", "\x{2298}" => "\x{29B8}",
"\x{22A2}" => "\x{22A3}", "\x{22A6}" => "\x{2ADE}", "\x{22A8}" => "\x{2AE4}",
"\x{22A9}" => "\x{2AE3}", "\x{22AB}" => "\x{2AE5}", "\x{22B0}" => "\x{22B1}",
"\x{22B2}" => "\x{22B3}", "\x{22B4}" => "\x{22B5}", "\x{22B6}" => "\x{22B7}",
"\x{22C9}" => "\x{22CA}", "\x{22CB}" => "\x{22CC}", "\x{22D0}" => "\x{22D1}",
"\x{22D6}" => "\x{22D7}", "\x{22D8}" => "\x{22D9}", "\x{22DA}" => "\x{22DB}",
"\x{22DC}" => "\x{22DD}", "\x{22DE}" => "\x{22DF}", "\x{22E0}" => "\x{22E1}",
"\x{22E2}" => "\x{22E3}", "\x{22E4}" => "\x{22E5}", "\x{22E6}" => "\x{22E7}",
"\x{22E8}" => "\x{22E9}", "\x{22EA}" => "\x{22EB}", "\x{22EC}" => "\x{22ED}",
"\x{22F0}" => "\x{22F1}", "\x{22F2}" => "\x{22FA}", "\x{22F3}" => "\x{22FB}",
"\x{22F4}" => "\x{22FC}", "\x{22F6}" => "\x{22FD}", "\x{22F7}" => "\x{22FE}",
"\x{2308}" => "\x{2309}", "\x{230A}" => "\x{230B}", "\x{2329}" => "\x{232A}",
"\x{23B4}" => "\x{23B5}", "\x{2768}" => "\x{2769}", "\x{276A}" => "\x{276B}",
"\x{276C}" => "\x{276D}", "\x{276E}" => "\x{276F}", "\x{2770}" => "\x{2771}",
"\x{2772}" => "\x{2773}", "\x{2774}" => "\x{2775}", "\x{27C3}" => "\x{27C4}",
"\x{27C5}" => "\x{27C6}", "\x{27D5}" => "\x{27D6}", "\x{27DD}" => "\x{27DE}",
"\x{27E2}" => "\x{27E3}", "\x{27E4}" => "\x{27E5}", "\x{27E6}" => "\x{27E7}",
"\x{27E8}" => "\x{27E9}", "\x{27EA}" => "\x{27EB}", "\x{2983}" => "\x{2984}",
"\x{2985}" => "\x{2986}", "\x{2987}" => "\x{2988}", "\x{2989}" => "\x{298A}",
"\x{298B}" => "\x{298C}", "\x{298D}" => "\x{298E}", "\x{298F}" => "\x{2990}",
"\x{2991}" => "\x{2992}", "\x{2993}" => "\x{2994}", "\x{2995}" => "\x{2996}",
"\x{2997}" => "\x{2998}", "\x{29C0}" => "\x{29C1}", "\x{29C4}" => "\x{29C5}",
"\x{29CF}" => "\x{29D0}", "\x{29D1}" => "\x{29D2}", "\x{29D4}" => "\x{29D5}",
"\x{29D8}" => "\x{29D9}", "\x{29DA}" => "\x{29DB}", "\x{29F8}" => "\x{29F9}",
"\x{29FC}" => "\x{29FD}", "\x{2A2B}" => "\x{2A2C}", "\x{2A2D}" => "\x{2A2E}",
"\x{2A34}" => "\x{2A35}", "\x{2A3C}" => "\x{2A3D}", "\x{2A64}" => "\x{2A65}",
"\x{2A79}" => "\x{2A7A}", "\x{2A7D}" => "\x{2A7E}", "\x{2A7F}" => "\x{2A80}",
"\x{2A81}" => "\x{2A82}", "\x{2A83}" => "\x{2A84}", "\x{2A8B}" => "\x{2A8C}",
"\x{2A91}" => "\x{2A92}", "\x{2A93}" => "\x{2A94}", "\x{2A95}" => "\x{2A96}",
"\x{2A97}" => "\x{2A98}", "\x{2A99}" => "\x{2A9A}", "\x{2A9B}" => "\x{2A9C}",
"\x{2AA1}" => "\x{2AA2}", "\x{2AA6}" => "\x{2AA7}", "\x{2AA8}" => "\x{2AA9}",
"\x{2AAA}" => "\x{2AAB}", "\x{2AAC}" => "\x{2AAD}", "\x{2AAF}" => "\x{2AB0}",
"\x{2AB3}" => "\x{2AB4}", "\x{2ABB}" => "\x{2ABC}", "\x{2ABD}" => "\x{2ABE}",
"\x{2ABF}" => "\x{2AC0}", "\x{2AC1}" => "\x{2AC2}", "\x{2AC3}" => "\x{2AC4}",
"\x{2AC5}" => "\x{2AC6}", "\x{2ACD}" => "\x{2ACE}", "\x{2ACF}" => "\x{2AD0}",
"\x{2AD1}" => "\x{2AD2}", "\x{2AD3}" => "\x{2AD4}", "\x{2AD5}" => "\x{2AD6}",
"\x{2AEC}" => "\x{2AED}", "\x{2AF7}" => "\x{2AF8}", "\x{2AF9}" => "\x{2AFA}",
"\x{2E02}" => "\x{2E03}", "\x{2E04}" => "\x{2E05}", "\x{2E09}" => "\x{2E0A}",
"\x{2E0C}" => "\x{2E0D}", "\x{2E1C}" => "\x{2E1D}", "\x{3008}" => "\x{3009}",
"\x{300A}" => "\x{300B}", "\x{300C}" => "\x{300D}", "\x{300E}" => "\x{300F}",
"\x{3010}" => "\x{3011}", "\x{3014}" => "\x{3015}", "\x{3016}" => "\x{3017}",
"\x{3018}" => "\x{3019}", "\x{301A}" => "\x{301B}", "\x{301D}" => "\x{301E}",
"\x{FD3E}" => "\x{FD3F}", "\x{FE17}" => "\x{FE18}", "\x{FE35}" => "\x{FE36}",
"\x{FE37}" => "\x{FE38}", "\x{FE39}" => "\x{FE3A}", "\x{FE3B}" => "\x{FE3C}",
"\x{FE3D}" => "\x{FE3E}", "\x{FE3F}" => "\x{FE40}", "\x{FE41}" => "\x{FE42}",
"\x{FE43}" => "\x{FE44}", "\x{FE47}" => "\x{FE48}", "\x{FE59}" => "\x{FE5A}",
"\x{FE5B}" => "\x{FE5C}", "\x{FE5D}" => "\x{FE5E}", "\x{FF08}" => "\x{FF09}",
"\x{FF1C}" => "\x{FF1E}", "\x{FF3B}" => "\x{FF3D}", "\x{FF5B}" => "\x{FF5D}",
"\x{FF5F}" => "\x{FF60}", "\x{FF62}" => "\x{FF63}",
);

## token opener
##      token opener {
##        <[\x0028 \x003C \x005B
##          \x007B \x00AB \x0F3A
##          \x0F3C \x169B \x2039
##          \x2045 \x207D \x208D
##          \x2208 \x2209 \x220A
##          \x2215 \x223C \x2243
##          \x2252 \x2254 \x2264
##          \x2266 \x2268 \x226A
##          \x226E \x2270 \x2272
##          \x2274 \x2276 \x2278
##          \x227A \x227C \x227E
##          \x2280 \x2282 \x2284
##          \x2286 \x2288 \x228A
##          \x228F \x2291 \x2298
##          \x22A2 \x22A6 \x22A8
##          \x22A9 \x22AB \x22B0
##          \x22B2 \x22B4 \x22B6
##          \x22C9 \x22CB \x22D0
##          \x22D6 \x22D8 \x22DA
##          \x22DC \x22DE \x22E0
##          \x22E2 \x22E4 \x22E6
##          \x22E8 \x22EA \x22EC
##          \x22F0 \x22F2 \x22F3
##          \x22F4 \x22F6 \x22F7
##          \x2308 \x230A \x2329
##          \x23B4 \x2768 \x276A
##          \x276C \x276E \x2770
##          \x2772 \x2774 \x27C3
##          \x27C5 \x27D5 \x27DD
##          \x27E2 \x27E4 \x27E6
##          \x27E8 \x27EA \x2983
##          \x2985 \x2987 \x2989
##          \x298B \x298D \x298F
##          \x2991 \x2993 \x2995
##          \x2997 \x29C0 \x29C4
##          \x29CF \x29D1 \x29D4
##          \x29D8 \x29DA \x29F8
##          \x29FC \x2A2B \x2A2D
##          \x2A34 \x2A3C \x2A64
##          \x2A79 \x2A7D \x2A7F
##          \x2A81 \x2A83 \x2A8B
##          \x2A91 \x2A93 \x2A95
##          \x2A97 \x2A99 \x2A9B
##          \x2AA1 \x2AA6 \x2AA8
##          \x2AAA \x2AAC \x2AAF
##          \x2AB3 \x2ABB \x2ABD
##          \x2ABF \x2AC1 \x2AC3
##          \x2AC5 \x2ACD \x2ACF
##          \x2AD1 \x2AD3 \x2AD5
##          \x2AEC \x2AF7 \x2AF9
##          \x2E02 \x2E04 \x2E09
##          \x2E0C \x2E1C \x3008
##          \x300A \x300C \x300E
##          \x3010 \x3014 \x3016
##          \x3018 \x301A \x301D
##          \xFD3E \xFE17 \xFE35
##          \xFE37 \xFE39 \xFE3B
##          \xFE3D \xFE3F \xFE41
##          \xFE43 \xFE47 \xFE59
##          \xFE5B \xFE5D \xFF08
##          \xFF1C \xFF3B \xFF5B
##          \xFF5F \xFF62]>
##      }

sub opener__PEEK { $_[0]->_AUTOLEXpeek('opener',$retree) }
sub opener {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "opener", 
$C->_PATTERN(qr/\G[\x{0028}\x{003C}\x{005B}\x{007B}\x{00AB}\x{0F3A}\x{0F3C}\x{169B}\x{2039}\x{2045}\x{207D}\x{208D}\x{2208}\x{2209}\x{220A}\x{2215}\x{223C}\x{2243}\x{2252}\x{2254}\x{2264}\x{2266}\x{2268}\x{226A}\x{226E}\x{2270}\x{2272}\x{2274}\x{2276}\x{2278}\x{227A}\x{227C}\x{227E}\x{2280}\x{2282}\x{2284}\x{2286}\x{2288}\x{228A}\x{228F}\x{2291}\x{2298}\x{22A2}\x{22A6}\x{22A8}\x{22A9}\x{22AB}\x{22B0}\x{22B2}\x{22B4}\x{22B6}\x{22C9}\x{22CB}\x{22D0}\x{22D6}\x{22D8}\x{22DA}\x{22DC}\x{22DE}\x{22E0}\x{22E2}\x{22E4}\x{22E6}\x{22E8}\x{22EA}\x{22EC}\x{22F0}\x{22F2}\x{22F3}\x{22F4}\x{22F6}\x{22F7}\x{2308}\x{230A}\x{2329}\x{23B4}\x{2768}\x{276A}\x{276C}\x{276E}\x{2770}\x{2772}\x{2774}\x{27C3}\x{27C5}\x{27D5}\x{27DD}\x{27E2}\x{27E4}\x{27E6}\x{27E8}\x{27EA}\x{2983}\x{2985}\x{2987}\x{2989}\x{298B}\x{298D}\x{298F}\x{2991}\x{2993}\x{2995}\x{2997}\x{29C0}\x{29C4}\x{29CF}\x{29D1}\x{29D4}\x{29D8}\x{29DA}\x{29F8}\x{29FC}\x{2A2B}\x{2A2D}\x{2A34}\x{2A3C}\x{2A64}\x{2A79}\x{2A7D}\x{2A7F}\x{2A81}\x{2A83}\x{2A8B}\x{2A91}\x{2A93}\x{2A95}\x{2A97}\x{2A99}\x{2A9B}\x{2AA1}\x{2AA6}\x{2AA8}\x{2AAA}\x{2AAC}\x{2AAF}\x{2AB3}\x{2ABB}\x{2ABD}\x{2ABF}\x{2AC1}\x{2AC3}\x{2AC5}\x{2ACD}\x{2ACF}\x{2AD1}\x{2AD3}\x{2AD5}\x{2AEC}\x{2AF7}\x{2AF9}\x{2E02}\x{2E04}\x{2E09}\x{2E0C}\x{2E1C}\x{3008}\x{300A}\x{300C}\x{300E}\x{3010}\x{3014}\x{3016}\x{3018}\x{301A}\x{301D}\x{FD3E}\x{FE17}\x{FE35}\x{FE37}\x{FE39}\x{FE3B}\x{FE3D}\x{FE3F}\x{FE41}\x{FE43}\x{FE47}\x{FE59}\x{FE5B}\x{FE5D}\x{FF08}\x{FF1C}\x{FF3B}\x{FF5B}\x{FF5F}\x{FF62}]/)
);
}

# assumes whitespace is eaten already

## method peek_delimiters
sub peek_delimiters {
my $self = shift;


my $pos = $self->{_pos};
my $startpos = $pos;
my $char = substr($ORIG,$pos++,1);
if ($char =~ qr/^\s$/) {
$self->panic("Whitespace not allowed as delimiter");
}

# XXX not defined yet
#    <?before <+isPe> > {
#        self.panic("Use a closing delimiter for an opener is reserved");
#    }

my $rightbrack = $open2close{$char};
if (not defined $rightbrack) {
return $char, $char;
}
while (substr($ORIG,$pos,1) eq $char) {
$pos++;
}
my $len = $pos - $startpos;
my $start = $char x $len;
my $stop = $rightbrack x $len;
return $start, $stop;
}

{ package STD::startstop;
sub __instantiate__ { my $self = shift;
my ($start,$stop) = @_;
my $mangle = ::mangle($start,$stop);
my $mixin = "STD::startstop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("		instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub _PARAMS { { '$start' => $start,'$stop' => $stop } }
##     token starter
##          token starter { $start }

sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter',$retree) }
sub starter {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "starter", 
$C->_EXACT($start)
);
}
##     token stopper
##          token stopper { $stop }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT($stop)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
starter: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: starter
    i: 0
    min: 0
    r: 1
    s: 0
    var: $start
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: stopper
    i: 0
    min: 0
    r: 1
    s: 0
    var: $stop
RETREE_END
}
};
eval $eval;
return $mixin;
}
}
## end role

{ package STD::stop;
sub __instantiate__ { my $self = shift;
my ($stop) = @_;
my $mangle = ::mangle($stop);
my $mixin = "STD::stop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("		instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub _PARAMS { { '$stop' => $stop } }
##     token starter
##          token starter { <!> }

sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter',$retree) }
sub starter {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "starter", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
##     token stopper
##          token stopper { $stop }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT($stop)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
starter: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: starter
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: stopper
    i: 0
    min: 0
    r: 1
    s: 0
    var: $stop
RETREE_END
}
};
eval $eval;
return $mixin;
}
}
## end role

{ package STD::unitstop;
sub __instantiate__ { my $self = shift;
my ($stop) = @_;
my $mangle = ::mangle($stop);
my $mixin = "STD::unitstop::" . $mangle;
return $mixin if $INSTANTIATED{$mixin}++;
::deb("		instantiating $mixin") if $::DEBUG & DEBUG::mixins;
my $eval = "package $mixin" . q{;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub _PARAMS { { '$stop' => $stop } }
##     token unitstopper
##          token unitstopper { $stop }

sub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper',$retree) }
sub unitstopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "unitstopper", 
$C->_EXACT($stop)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
unitstopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_var 
    a: 0
    dba: unitstopper
    i: 0
    min: 0
    r: 1
    s: 0
    var: $stop
RETREE_END
}
};
eval $eval;
return $mixin;
}
}
## end role
## token unitstopper
##      } # end role
##      
##      token unitstopper { $ }

sub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper',$retree) }
sub unitstopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "unitstopper", 
$C->_PATTERN(qr/\G\z/)
);
}

## method balanced ($start,$stop)
sub balanced {
my $self = shift;
my $start = shift;
my $stop = shift;

$self->mixin( 'STD::startstop'->__instantiate__($start,$stop) ); }
## method unbalanced ($stop)
sub unbalanced {
my $self = shift;
my $stop = shift;

$self->mixin( 'STD::stop'->__instantiate__($stop) ); }
## method unitstop ($stop)
sub unitstop {
my $self = shift;
my $stop = shift;

$self->mixin( 'STD::unitstop'->__instantiate__($stop) ); }

## token codepoint
##      token codepoint {
##          '[' {} ( [<!before ']'> .]*? ) ']'
##      }

sub codepoint__PEEK { $_[0]->_AUTOLEXpeek('codepoint',$retree) }
sub codepoint {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "codepoint", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_EXACT(']')
},     $C->_SUBSUME(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_STARf(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G(?s:.)/)
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(']')
})
}))
})
})
})}
}))
}, scalar(do {

}, $C))
}, $C->_EXACT('['))
);
}

## method truly ($bool,$opt)
sub truly {
my $self = shift;
my $bool = shift;
my $opt = shift;


return $self if $bool;
$self->panic("Can't negate $opt adverb");
}

{ package STD::Q;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));
{ package STD::Q::b1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_204Back (:$sym is context<rw> = <\\>)
##              token escape:sym<\\> { <sym> <item=backslash> }

sub escape__S_204Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_204Back',$retree) }
sub escape__S_204Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_204Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}
##         token backslash__S_205qq (:$sym is context<rw> = 'qq')
##              token backslash:qq { <?before 'q'> { $<quote> = $.cursor_fresh($+LANG).quote(); } }

sub backslash__S_205qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_205qq',$retree) }
sub backslash__S_205qq {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qq';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_205qq", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('q')
}))) {
scalar(do {
my $M = $C;  $M->{quote} = $C->cursor_fresh($::LANG)->quote(); ;
}, $C);
}
else {
();
}
}
);
}
##         token backslash__S_206Back (:$sym is context<rw> = <\\>)
##              token backslash:sym<\\> { <text=sym> }

sub backslash__S_206Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_206Back',$retree) }
sub backslash__S_206Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_206Back", 
$C->_PATTERN(qr/\G\\/)
);
}
##         token backslash__S_207stopper (:$sym is context<rw> = 'stopper')
##              token backslash:stopper { <text=stopper> }

sub backslash__S_207stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_207stopper',$retree) }
sub backslash__S_207stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'stopper';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_207stopper", 
$C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
})
);
}
##         token backslash__S_208a (:$sym is context<rw> = 'a')
##              token backslash:a { <sym> }

sub backslash__S_208a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_208a',$retree) }
sub backslash__S_208a {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_208a", 
$C->_PATTERN(qr/\Ga/)
);
}
##         token backslash__S_209b (:$sym is context<rw> = 'b')
##              token backslash:b { <sym> }

sub backslash__S_209b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_209b',$retree) }
sub backslash__S_209b {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_209b", 
$C->_PATTERN(qr/\Gb/)
);
}
##         token backslash__S_210c (:$sym is context<rw> = 'c')
##              token backslash:c { <sym>
##                  [
##                  | <codepoint>
##                  | \d+
##                  | [ <[ ?.._ ]> || <.panic: "Unrecognized \\c character"> ]
##                  ]
##              }

sub backslash__S_210c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_210c',$retree) }
sub backslash__S_210c {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_210c", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gc/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_210c_01') {
$C->deb("Fate passed to backslash__S_210c_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_210c_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_210c_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['codepoint'], sub {
my $C = shift;
$C->codepoint
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G[?-_]/)} 
or
eval { push @gather, $C->panic("Unrecognized \\c character")} or do { die $@ if $@ };
@gather;
}
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##         token backslash__S_211e (:$sym is context<rw> = 'e')
##              token backslash:e { <sym> }

sub backslash__S_211e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_211e',$retree) }
sub backslash__S_211e {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_211e", 
$C->_PATTERN(qr/\Ge/)
);
}
##         token backslash__S_212f (:$sym is context<rw> = 'f')
##              token backslash:f { <sym> }

sub backslash__S_212f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_212f',$retree) }
sub backslash__S_212f {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_212f", 
$C->_PATTERN(qr/\Gf/)
);
}
##         token backslash__S_213n (:$sym is context<rw> = 'n')
##              token backslash:n { <sym> }

sub backslash__S_213n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_213n',$retree) }
sub backslash__S_213n {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'n';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_213n", 
$C->_PATTERN(qr/\Gn/)
);
}
##         token backslash__S_214o (:$sym is context<rw> = 'o')
##              token backslash:o { <sym> [ <octint> | '[' <octint>**',' ']' ] }

sub backslash__S_214o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_214o',$retree) }
sub backslash__S_214o {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'o';


my $C = $self;
my $S = $C->{_pos};
$C->{'octint'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_214o", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Go/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_214o_01') {
$C->deb("Fate passed to backslash__S_214o_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_214o_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_214o_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
}))) {
$C->_EXACT(']');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##         token backslash__S_215r (:$sym is context<rw> = 'r')
##              token backslash:r { <sym> }

sub backslash__S_215r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_215r',$retree) }
sub backslash__S_215r {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'r';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_215r", 
$C->_PATTERN(qr/\Gr/)
);
}
##         token backslash__S_216t (:$sym is context<rw> = 't')
##              token backslash:t { <sym> }

sub backslash__S_216t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_216t',$retree) }
sub backslash__S_216t {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 't';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_216t", 
$C->_PATTERN(qr/\Gt/)
);
}
##         token backslash__S_217x (:$sym is context<rw> = 'x')
##              token backslash:x { <sym> [ <hexint> | '[' [<.ws><hexint><.ws> ] ** ',' ']' ] }

sub backslash__S_217x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_217x',$retree) }
sub backslash__S_217x {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{_pos};
$C->{'hexint'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_217x", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gx/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_217x_01') {
$C->deb("Fate passed to backslash__S_217x_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_217x_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_217x_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT(',')
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_EXACT(']');
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##         token backslash__S_2180 (:$sym is context<rw> = <0>)
##              token backslash:sym<0> { <sym> }

sub backslash__S_2180__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_2180',$retree) }
sub backslash__S_2180 {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(0);


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "backslash__S_2180", 
$C->_PATTERN(qr/\G0/)
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
backslash__S_205qq: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_205qq
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_205qq
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: backslash__S_205qq
              i: 0
              min: 1
              r: 1
              s: 0
              text: q
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_205qq
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<quote> = $.cursor_fresh($+LANG).quote(); "
backslash__S_206Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_206Back
      i: 0
      min: 12345
      name: sym
      nobind: 1
      r: 1
      rest: ''
      s: 0
      sym: \
    dba: backslash__S_206Back
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_207stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_207stopper
      i: 0
      min: 12345
      name: stopper
      nobind: 1
      r: 1
      rest: ''
      s: 0
    dba: backslash__S_207stopper
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_208a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_208a
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: a
backslash__S_209b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_209b
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
backslash__S_210c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_210c
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_210c
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: c
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &2 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_210c_01
          dba: backslash__S_210c
          i: 0
          min: 0
          name: backslash__S_210c_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_210c_01 0
              dba: backslash__S_210c
              i: 0
              min: 12345
              name: codepoint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              alt: backslash__S_210c_01 1
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: backslash__S_210c
                i: 0
                min: 1
                r: 1
                s: 0
                text: \d
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
            - !!perl/hash:RE_bracket 
              alt: backslash__S_210c_01 2
              decl: []

              min: 0
              re: !!perl/hash:RE_first 
                a: 0
                dba: backslash__S_210c
                i: 0
                min: 0
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_cclass 
                    a: 0
                    dba: backslash__S_210c
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "[ ?.._ ]"
                  - !!perl/hash:RE_method 
                    min: 0
                    name: panic
                    nobind: 1
                    rest: ("Unrecognized \\c character")
backslash__S_210c_01: *2
backslash__S_211e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_211e
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: e
backslash__S_212f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_212f
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
backslash__S_213n: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_213n
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 'n'
backslash__S_214o: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_214o
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_214o
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: o
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_214o_01
          dba: backslash__S_214o
          i: 0
          min: 12345
          name: backslash__S_214o_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_214o_01 0
              dba: backslash__S_214o
              i: 0
              min: 12345
              name: octint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_214o_01 1
              dba: backslash__S_214o
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_214o
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: backslash__S_214o
                    i: 0
                    min: 12345
                    name: octint
                    r: 1
                    rest: ''
                    s: 0
                  min: 12345
                  quant: 
                    - "**"
                    - ":"
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: backslash__S_214o
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ","
                    - 1
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_214o
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "]"
backslash__S_214o_01: *1
backslash__S_215r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_215r
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: r
backslash__S_216t: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_216t
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: t
backslash__S_217x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_217x
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_217x
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: x
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &3 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_217x_01
          dba: backslash__S_217x
          i: 0
          min: 12345
          name: backslash__S_217x_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_217x_01 0
              dba: backslash__S_217x
              i: 0
              min: 12345
              name: hexint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_217x_01 1
              dba: backslash__S_217x
              i: 0
              min: 37037
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_217x
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 37035
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: backslash__S_217x
                      i: 0
                      min: 37035
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_217x
                          i: 0
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_217x
                          i: 0
                          min: 12345
                          name: hexint
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_217x
                          i: 0
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                  min: 37035
                  quant: 
                    - "**"
                    - ":"
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: backslash__S_217x
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ","
                    - 1
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_217x
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "]"
backslash__S_217x_01: *3
backslash__S_2180: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_2180
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 0
escape__S_204Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_204Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: escape__S_204Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: escape__S_204Back
          i: 0
          min: 12345
          name: backslash
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: escape__S_204Back
        i: 0
        min: 12345
        r: 1
        s: 0
        var: item
RETREE_END
}
} ## end role

{ package STD::Q::b0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_219Back (:$sym is context<rw> = <\\>)
##              token escape:sym<\\> { <!> }

sub escape__S_219Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_219Back',$retree) }
sub escape__S_219Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_219Back", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_219Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_219Back
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::c1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_220Cur_Ly (:$sym is context<rw> = <{ }>)
##              token escape:sym<{ }> { <?before '{'> [ :lang($+LANG) <block> ] }

sub escape__S_220Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('escape__S_220Cur_Ly',$retree) }
sub escape__S_220Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_220Cur_Ly", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_220Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_220Cur_Ly
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_220Cur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_220Cur_Ly
              i: 0
              min: 1
              r: 1
              s: 0
              text: "{"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: escape__S_220Cur_Ly
          i: 0
          lang: ($+LANG)
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: escape__S_220Cur_Ly
              i: 0
              lang: ($+LANG)
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($+LANG);  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: escape__S_220Cur_Ly
              i: 0
              lang: ($+LANG)
              min: 12345
              name: block
              r: 1
              rest: ''
              s: 0
RETREE_END
}
} ## end role

{ package STD::Q::c0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_221Cur_Ly (:$sym is context<rw> = <{ }>)
##              token escape:sym<{ }> { <!> }

sub escape__S_221Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('escape__S_221Cur_Ly',$retree) }
sub escape__S_221Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_221Cur_Ly", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_221Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_221Cur_Ly
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::s1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_222Dollar (:$sym is context<rw> = <$>)
##              token escape:sym<$> { <?before '$'> [ :lang($+LANG) <variable> <extrapost>? ] || <.panic: "Non-variable \$ must be backslashed"> }

sub escape__S_222Dollar__PEEK { $_[0]->_AUTOLEXpeek('escape__S_222Dollar',$retree) }
sub escape__S_222Dollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{_pos};
$C->{'extrapost'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_222Dollar", 
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('$')
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['extrapost'], sub {
my $C = shift;
$C->extrapost
})
});
}
else {
();
}
}
});
}
else {
();
}
}} 
or
eval { push @gather, $C->panic("Non-variable \$ must be backslashed")} or do { die $@ if $@ };
@gather;
}
);
}
##         token special_variable__S_223DollarDouble (:$sym is context<rw> = <$">)
##              token special_variable:sym<$"> {
##                  '$' <stopper>
##                  <.panic: "Can't use a \$ in the last position of an interpolating string">
##              }

sub special_variable__S_223DollarDouble__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_223DollarDouble',$retree) }
sub special_variable__S_223DollarDouble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($");


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_223DollarDouble", 
do {
if (my ($C) = ($C->_EXACT('$'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
$C->panic("Can't use a \$ in the last position of an interpolating string");
}
else {
();
}
};
}
else {
();
}
}
);
}

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_222Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: escape__S_222Dollar
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: escape__S_222Dollar
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_assertion 
            assert: "?"
            min: 0
            re: !!perl/hash:RE_method_re 
              a: 0
              dba: escape__S_222Dollar
              i: 0
              min: 0
              name: before
              nobind: 1
              r: 1
              re: !!perl/hash:RE 
                decl: []

                min: 1
                re: !!perl/hash:RE_string 
                  a: 0
                  dba: escape__S_222Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: $
              s: 0
          - !!perl/hash:RE_bracket 
            decl: []

            min: 12345
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: escape__S_222Dollar
              i: 0
              lang: ($+LANG)
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_222Dollar
                  i: 0
                  lang: ($+LANG)
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($+LANG);  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: escape__S_222Dollar
                  i: 0
                  lang: ($+LANG)
                  min: 12345
                  name: variable
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: escape__S_222Dollar
                    i: 0
                    lang: ($+LANG)
                    min: 12345
                    name: extrapost
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Non-variable \$ must be backslashed")
special_variable__S_223DollarDouble: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_223DollarDouble
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_223DollarDouble
        i: 0
        min: 1
        r: 1
        s: 0
        text: $
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_223DollarDouble
        i: 0
        min: 12345
        name: stopper
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Can't use a \$ in the last position of an interpolating string")
RETREE_END
}
} ## end role

{ package STD::Q::s0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_224Dollar (:$sym is context<rw> = <$>)
##              token escape:sym<$> { <!> }

sub escape__S_224Dollar__PEEK { $_[0]->_AUTOLEXpeek('escape__S_224Dollar',$retree) }
sub escape__S_224Dollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_224Dollar", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
##         token special_variable__S_225DollarDouble (:$sym is context<rw> = <$">)
##              token special_variable:sym<$"> { <!> }

sub special_variable__S_225DollarDouble__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_225DollarDouble',$retree) }
sub special_variable__S_225DollarDouble {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($");


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "special_variable__S_225DollarDouble", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_224Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_224Dollar
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
special_variable__S_225DollarDouble: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: special_variable__S_225DollarDouble
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::a1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_226At (:$sym is context<rw> = <@>)
##              token escape:sym<@> { <?before '@'> [ :lang($+LANG) <variable> <extrapost> | <!> ] }

sub escape__S_226At__PEEK { $_[0]->_AUTOLEXpeek('escape__S_226At',$retree) }
sub escape__S_226At {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_226At", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('@')
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'escape__S_226At_02') {
$C->deb("Fate passed to escape__S_226At_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::a1', 'escape__S_226At_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape__S_226At_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
$C->_SUBSUMEr(['extrapost'], sub {
my $C = shift;
$C->extrapost
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
} # trap ABORTBRANCH from variable's ::
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_226At: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_226At
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_226At
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_226At
              i: 0
              min: 1
              r: 1
              s: 0
              text: "@"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: escape__S_226At_02
          dba: escape__S_226At
          i: 0
          lang: ($+LANG)
          min: 0
          name: escape__S_226At_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: escape__S_226At_02 0
              dba: escape__S_226At
              i: 0
              lang: ($+LANG)
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_226At
                  i: 0
                  lang: ($+LANG)
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($+LANG);  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: escape__S_226At
                  i: 0
                  lang: ($+LANG)
                  min: 12345
                  name: variable
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: escape__S_226At
                  i: 0
                  lang: ($+LANG)
                  min: 12345
                  name: extrapost
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_assertion 
              alt: escape__S_226At_02 1
              assert: "!"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: escape__S_226At
                i: 0
                lang: ($+LANG)
                min: 0
                nobind: 1
                r: 1
                s: 0
escape__S_226At_02: *1
RETREE_END
}
} ## end role

{ package STD::Q::a0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_227At (:$sym is context<rw> = <@>)
##              token escape:sym<@> { <!> }

sub escape__S_227At__PEEK { $_[0]->_AUTOLEXpeek('escape__S_227At',$retree) }
sub escape__S_227At {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(@);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_227At", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_227At: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_227At
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::h1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_228Percent (:$sym is context<rw> = <%>)
##              token escape:sym<%> { <?before '%'> [ :lang($+LANG) <variable> <extrapost> | <!> ] }

sub escape__S_228Percent__PEEK { $_[0]->_AUTOLEXpeek('escape__S_228Percent',$retree) }
sub escape__S_228Percent {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_228Percent", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('%')
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'escape__S_228Percent_02') {
$C->deb("Fate passed to escape__S_228Percent_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::h1', 'escape__S_228Percent_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape__S_228Percent_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
$C->_SUBSUMEr(['extrapost'], sub {
my $C = shift;
$C->extrapost
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_228Percent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_228Percent
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_228Percent
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_228Percent
              i: 0
              min: 1
              r: 1
              s: 0
              text: "%"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: escape__S_228Percent_02
          dba: escape__S_228Percent
          i: 0
          lang: ($+LANG)
          min: 0
          name: escape__S_228Percent_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: escape__S_228Percent_02 0
              dba: escape__S_228Percent
              i: 0
              lang: ($+LANG)
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_228Percent
                  i: 0
                  lang: ($+LANG)
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($+LANG);  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: escape__S_228Percent
                  i: 0
                  lang: ($+LANG)
                  min: 12345
                  name: variable
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: escape__S_228Percent
                  i: 0
                  lang: ($+LANG)
                  min: 12345
                  name: extrapost
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_assertion 
              alt: escape__S_228Percent_02 1
              assert: "!"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: escape__S_228Percent
                i: 0
                lang: ($+LANG)
                min: 0
                nobind: 1
                r: 1
                s: 0
escape__S_228Percent_02: *1
RETREE_END
}
} ## end role

{ package STD::Q::h0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_229Percent (:$sym is context<rw> = <%>)
##              token escape:sym<%> { <!> }

sub escape__S_229Percent__PEEK { $_[0]->_AUTOLEXpeek('escape__S_229Percent',$retree) }
sub escape__S_229Percent {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_229Percent", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_229Percent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_229Percent
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::f1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_230Amp (:$sym is context<rw> = <&>)
##              token escape:sym<&> { <?before '&'> [ :lang($+LANG) <variable> <extrapost> | <!> ] }

sub escape__S_230Amp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_230Amp',$retree) }
sub escape__S_230Amp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_230Amp", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('&')
}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'escape__S_230Amp_02') {
$C->deb("Fate passed to escape__S_230Amp_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::f1', 'escape__S_230Amp_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("escape__S_230Amp_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
my $newlang = ($::LANG);  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
$C->_SUBSUMEr(['extrapost'], sub {
my $C = shift;
$C->extrapost
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_230Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_230Amp
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: escape__S_230Amp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: escape__S_230Amp
              i: 0
              min: 1
              r: 1
              s: 0
              text: "&"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: escape__S_230Amp_02
          dba: escape__S_230Amp
          i: 0
          lang: ($+LANG)
          min: 0
          name: escape__S_230Amp_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: escape__S_230Amp_02 0
              dba: escape__S_230Amp
              i: 0
              lang: ($+LANG)
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_decl 
                  a: 0
                  dba: escape__S_230Amp
                  i: 0
                  lang: ($+LANG)
                  max: 0
                  min: 0
                  noquant: 1
                  r: 1
                  s: 0
                  text: "my $newlang = ($+LANG);  $C = $C->cursor_fresh($newlang); "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: escape__S_230Amp
                  i: 0
                  lang: ($+LANG)
                  min: 12345
                  name: variable
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: escape__S_230Amp
                  i: 0
                  lang: ($+LANG)
                  min: 12345
                  name: extrapost
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_assertion 
              alt: escape__S_230Amp_02 1
              assert: "!"
              min: 0
              re: !!perl/hash:RE_noop 
                a: 0
                dba: escape__S_230Amp
                i: 0
                lang: ($+LANG)
                min: 0
                nobind: 1
                r: 1
                s: 0
escape__S_230Amp_02: *1
RETREE_END
}
} ## end role

{ package STD::Q::f0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token escape__S_231Amp (:$sym is context<rw> = <&>)
##              token escape:sym<&> { <!> }

sub escape__S_231Amp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_231Amp',$retree) }
sub escape__S_231Amp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_231Amp", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
escape__S_231Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_231Amp
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
RETREE_END
}
} ## end role

{ package STD::Q::w1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->comb }
} ## end role

{ package STD::Q::w0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::ww1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->comb }
} ## end role

{ package STD::Q::ww0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::x1;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s->run }
} ## end role

{ package STD::Q::x0;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         method postprocess ($s)
sub postprocess {
my $self = shift;
my $s = shift;

$s }
} ## end role

{ package STD::Q::q;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
##         token stopper
##              token stopper { \' }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT('\'')
);
}

##         token escape__S_232Back (:$sym is context<rw> = <\\>)
##              token escape:sym<\\> { <sym> <item=backslash> }

sub escape__S_232Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_232Back',$retree) }
sub escape__S_232Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "escape__S_232Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}

##         token backslash__S_233qq (:$sym is context<rw> = 'qq')
##              token backslash:qq { <?before 'q'> { $<quote> = $.cursor_fresh($+LANG).quote(); } }

sub backslash__S_233qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_233qq',$retree) }
sub backslash__S_233qq {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qq';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_233qq", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('q')
}))) {
scalar(do {
my $M = $C;  $M->{quote} = $C->cursor_fresh($::LANG)->quote(); ;
}, $C);
}
else {
();
}
}
);
}
##         token backslash__S_234Back (:$sym is context<rw> = <\\>)
##              token backslash:sym<\\> { <text=sym> }

sub backslash__S_234Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_234Back',$retree) }
sub backslash__S_234Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_234Back", 
$C->_PATTERN(qr/\G\\/)
);
}
##         token backslash__S_235stopper (:$sym is context<rw> = 'stopper')
##              token backslash:stopper { <text=stopper> }

sub backslash__S_235stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_235stopper',$retree) }
sub backslash__S_235stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'stopper';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_235stopper", 
$C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
})
);
}

# in single quotes, keep backslash on random character by default
##         token backslash__S_236misc (:$sym is context<rw> = 'misc')
##              token backslash:misc { {} (.) { $<text> = "\\" ~ $0.text; } }

sub backslash__S_236misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_236misc',$retree) }
sub backslash__S_236misc {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_236misc", 
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G(?s:.)/)
})}
}))) {
scalar(do {
my $M = $C;  $M->{text} = "\\" . $$C{0}->text; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->panic("Too late for :q") }
elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->panic("Too late for :qq") }
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
backslash__S_233qq: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_233qq
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_233qq
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: backslash__S_233qq
              i: 0
              min: 1
              r: 1
              s: 0
              text: q
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_233qq
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<quote> = $.cursor_fresh($+LANG).quote(); "
backslash__S_234Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_234Back
      i: 0
      min: 12345
      name: sym
      nobind: 1
      r: 1
      rest: ''
      s: 0
      sym: \
    dba: backslash__S_234Back
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_235stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_method 
      a: 0
      dba: backslash__S_235stopper
      i: 0
      min: 12345
      name: stopper
      nobind: 1
      r: 1
      rest: ''
      s: 0
    dba: backslash__S_235stopper
    i: 0
    min: 12345
    r: 1
    s: 0
    var: text
backslash__S_236misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_236misc
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_236misc
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_meta 
            a: 0
            dba: backslash__S_236misc
            i: 0
            min: 1
            r: 1
            s: 0
            text: .
        min: 1
        var: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_236misc
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<text> = \"\\\\\" ~ $0.text; "
escape__S_232Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escape__S_232Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: escape__S_232Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: escape__S_232Back
          i: 0
          min: 12345
          name: backslash
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: escape__S_232Back
        i: 0
        min: 12345
        r: 1
        s: 0
        var: item
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: stopper
    i: 0
    min: 1
    r: 1
    s: 0
    text: "'"
RETREE_END
}
} ## end role

{ package STD::Q::qq;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
moose_with(qw(STD::Q::b1 STD::Q::c1 STD::Q::s1 STD::Q::a1 STD::Q::h1 STD::Q::f1));
##         token stopper
##              token stopper { \" }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "stopper", 
$C->_EXACT('"')
);
}
# in double quotes, omit backslash on random \W backslash by default
##         token backslash__S_237misc (:$sym is context<rw> = 'misc')
##              token backslash:misc { {} [ (\W) { $<text> = $0.text; } | $<x>=(\w) <.panic("Unrecognized backslash sequence: '\\" ~ $<x>.text ~ "'")> ] }

sub backslash__S_237misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_237misc',$retree) }
sub backslash__S_237misc {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_237misc", 
do {
if (my ($C) = (scalar(do {

}, $C))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_237misc_01') {
$C->deb("Fate passed to backslash__S_237misc_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Q::qq', 'backslash__S_237misc_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_237misc_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
})}
}))) {
scalar(do {
my $M = $C;  $M->{text} = $$C{0}->text; ;
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['x'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})}
}))) {
do { my $M = $C;
$C->panic("Unrecognized backslash sequence: '\\" . $M->{x}->text . "'")
; };
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->panic("Too late for :q") }
elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->panic("Too late for :qq") }
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
backslash__S_237misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_237misc
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: backslash__S_237misc
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_237misc_01
          dba: backslash__S_237misc
          i: 0
          min: 1
          name: backslash__S_237misc_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_237misc_01 0
              dba: backslash__S_237misc
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_meta 
                      a: 0
                      dba: backslash__S_237misc
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \W
                  min: 1
                  var: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: backslash__S_237misc
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<text> = $0.text; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_237misc_01 1
              dba: backslash__S_237misc
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_meta 
                      a: 0
                      dba: backslash__S_237misc
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \w
                  dba: backslash__S_237misc
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: x
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: "(\"Unrecognized backslash sequence: '\\\\\" ~ $<x>.text ~ \"'\")"
backslash__S_237misc_01: *1
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: stopper
    i: 0
    min: 1
    r: 1
    s: 0
    text: "\""
RETREE_END
}
} ## end role

{ package STD::Q::p5;
use Moose::Role ':all' => { -prefix => "moose_" };
my $retree;
sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'g') {
my $g = $v;  $self }
elsif ($k eq 'i') {
my $i = $v;  $self }
elsif ($k eq 'm') {
my $m = $v;  $self }
elsif ($k eq 's') {
my $s = $v;  $self }
elsif ($k eq 'x') {
my $x = $v;  $self }
elsif ($k eq 'p') {
my $p = $v;  $self }
elsif ($k eq 'c') {
my $c = $v;  $self }
else { die 'NOMATCH' }
} # end tweaks
} ## end role

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}

elsif ($k eq 'single' or $k eq 'q') {
my $q = $v;  $self->truly($q,':q'); $self->mixin( 'STD::Q::q' ); }

elsif ($k eq 'double' or $k eq 'qq') {
my $qq = $v;  $self->truly($qq, ':qq'); $self->mixin( 'STD::Q::qq' ); }

elsif ($k eq 'backslash' or $k eq 'b') {
my $b = $v;  $self->mixin($b ? 'STD::Q::b1' : 'STD::Q::b0') }
elsif ($k eq 'scalar' or $k eq 's') {
my $s = $v;  $self->mixin($s ? 'STD::Q::s1' : 'STD::Q::s0') }
elsif ($k eq 'array' or $k eq 'a') {
my $a = $v;  $self->mixin($a ? 'STD::Q::a1' : 'STD::Q::a0') }
elsif ($k eq 'hash' or $k eq 'h') {
my $h = $v;  $self->mixin($h ? 'STD::Q::h1' : 'STD::Q::h0') }
elsif ($k eq 'function' or $k eq 'f') {
my $f = $v;  $self->mixin($f ? 'STD::Q::f1' : 'STD::Q::f0') }
elsif ($k eq 'closure' or $k eq 'c') {
my $c = $v;  $self->mixin($c ? 'STD::Q::c1' : 'STD::Q::c0') }

elsif ($k eq 'exec' or $k eq 'x') {
my $x = $v;  $self->mixin($x ? 'STD::Q::x1' : 'STD::Q::x0') }
elsif ($k eq 'words' or $k eq 'w') {
my $w = $v;  $self->mixin($w ? 'STD::Q::w1' : 'STD::Q::w0') }
elsif ($k eq 'quotewords' or $k eq 'ww') {
my $ww = $v;  $self->mixin($ww ? 'STD::Q::ww1' : 'STD::Q::ww0') }

elsif ($k eq 'heredoc' or $k eq 'to') {
my $to = $v;  $self->truly($to, ':to'); $self->cursor_herelang; }

elsif ($k eq 'regex') {
my $regex = $v; 
return 'STD::Q::Regex';
}

elsif ($k eq 'trans') {
my $trans = $v; 
return 'STD::Q::Trans';
}

elsif (1) {
my %x = ($k, $v); 
my @k = keys(%x);
$self->panic("Unrecognized quote modifier: " . @k);
}
else { die 'NOMATCH' }
} # end tweaks


} ## end grammar

{ package STD::Quasi;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));##     token term__S_238unquote (:$sym is context<rw> = 'unquote')
##          token term:unquote {
##              <starter><starter><starter> <statementlist> <stopper><stopper><stopper>
##          }

sub term__S_238unquote__PEEK { $_[0]->_AUTOLEXpeek('term__S_238unquote',$retree) }
sub term__S_238unquote {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'unquote';


my $C = $self;
my $S = $C->{_pos};
$C->{'stopper'} = [];
$C->{'starter'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_238unquote", 
do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'ast') {
my $ast = $v;  $self; } # XXX some transformer operating on the normal AST?
elsif ($k eq 'lang') {
my $lang = $v;  $self->cursor_fresh( $lang ); }
elsif ($k eq 'unquote') {
my $unquote = $v;  $self; } # XXX needs to override unquote
elsif ($k eq 'COMPILING') {
my $COMPILING = $v;  $self; } # XXX needs to lazify the lexical lookups somehow

elsif (1) {
my %x = ($k, $v); 
my @k = keys(%x);
$self->panic("Unrecognized quasiquote modifier: " . @k);
}
else { die 'NOMATCH' }
} # end tweaks

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
term__S_238unquote: !!perl/hash:RE 
  decl: []

  kind: token
  min: 86415
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_238unquote
    i: 0
    min: 86415
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_238unquote
        i: 0
        min: 12345
        name: starter
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_238unquote
        i: 0
        min: 12345
        name: starter
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_238unquote
        i: 0
        min: 12345
        name: starter
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_238unquote
        i: 0
        min: 12345
        name: statementlist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_238unquote
        i: 0
        min: 12345
        name: stopper
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_238unquote
        i: 0
        min: 12345
        name: stopper
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_238unquote
        i: 0
        min: 12345
        name: stopper
        r: 1
        rest: ''
        s: 0
RETREE_END
}
} ## end grammar

# Note, backtracks!  So POST must not commit to anything permanent.
## regex extrapost
##      regex extrapost {
##          :my $inquote is context = 1;
##          <POST>*
##          # XXX Shouldn't need a backslash on anything but the right square here
##          <?after <[ \] } > ) ]> > 
##      }

sub extrapost__PEEK { $_[0]->_AUTOLEXpeek('extrapost',$retree) }
sub extrapost {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $inquote =  1;


my $C = $self;
my $S = $C->{_pos};
$C->{'POST'} = [];

$self->_MATCHIFY($S, "extrapost", 
Cursor::lazymap(sub { my $C=$_[0];
$C->before( sub { my $C=shift;
$C->after(sub { my $C=shift;
$C->_PATTERN(qr/\G(?<=[\]}>)])/)
})
})
}, $C->_STARg(sub { my $C=shift;
$C->_SUBSUME(['POST'], sub {
my $C = shift;
$C->POST
})
}))
);
}

## rule multisig
##      rule multisig {
##          [
##      	':'?'(' ~ ')' <signature>
##          ]
##          ** '|'
##      }

sub multisig__PEEK { $_[0]->_AUTOLEXpeek('multisig',$retree) }
sub multisig {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'signature'} = [];

$self->_MATCHIFY($S, "multisig", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_REPSEPr(  sub { my $C=shift;
$C->_EXACT('|')
}, sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')', 'multisig')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')'))
}, $C->ws)
}, $C->_EXACT('('))
}, $C->_OPTr(sub { my $C=shift;
$C->_EXACT(':')
}))
}, $C->ws)
})
}))
}, $C->ws)
);
}

## rule routine_def
##      rule routine_def {
##          :my $IN_DECL is context<rw> = 1;
##          [ '&'<deflongname>? | <deflongname> ]? [ <multisig> | <trait> ]*
##          <!{
##              $ = $+PARSER.bless($);
##              $IN_DECL = 0;
##          }>
##          <block>:!s
##      }

sub routine_def__PEEK { $_[0]->_AUTOLEXpeek('routine_def',$retree) }
sub routine_def {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $IN_DECL =  1;


my $C = $self;
my $S = $C->{_pos};
$C->{'deflongname'} = [];
$C->{'multisig'} = [];
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "routine_def", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'routine_def_01') {
$C->deb("Fate passed to routine_def_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'routine_def_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("routine_def_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'routine_def_02') {
$C->deb("Fate passed to routine_def_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'routine_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("routine_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {

$C = $::PARSER->bless($C);
$IN_DECL = 0;

})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule method_def
##      rule method_def {
##          [
##          | '!'?<longname> [ <multisig> | <trait> ]*
##          | <sigil> '.'
##              :dba('subscript signature')
##              [
##              | '(' ~ ')' <signature>
##              | '[' ~ ']' <signature>
##              | '{' ~ '}' <signature>
##              | <?before '<'> <postcircumfix>
##              ]
##              <trait>*
##          | <?>
##          ]
##          <block>:!s
##      }

sub method_def__PEEK { $_[0]->_AUTOLEXpeek('method_def',$retree) }
sub method_def {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'multisig'} = [];
$C->{'trait'} = [];

$self->_MATCHIFY($S, "method_def", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['block'], sub {
my $C = shift;
$C->block
})
}, $C->ws)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'method_def_01') {
$C->deb("Fate passed to method_def_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'method_def_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("method_def_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('!')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'method_def_02') {
$C->deb("Fate passed to method_def_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'method_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("method_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_STARr(sub { my $C=shift;
$C->_SUBSUME(['trait'], sub {
my $C = shift;
$C->trait
})
}))
}, $C->ws)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'method_def_03') {
$C->deb("Fate passed to method_def_03: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'method_def_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("method_def_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')', 'subscript signature')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')'))
}, $C->ws)
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']', 'subscript signature')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']'))
}, $C->ws)
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->FAILGOAL('}', 'subscript signature')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = '}'))
}, $C->ws)
}, $C->_EXACT('{'))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
}, $C->ws)
}, $C->before(sub { my $C=shift;
$C->_EXACT('<')
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->ws)
}, $C->ws)
}, $C->_EXACT('.'))
}, $C->ws)
}, $C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->before( sub { my $C=shift;
$C
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->ws)
);
}

## rule regex_def
##      rule regex_def {
##          :my $IN_DECL is context<rw> = 1;
##          [ '&'<deflongname>? | <deflongname> ]?
##          [ [ ':'?'(' <signature> ')'] | <trait> ]*
##          { $IN_DECL = 0; }
##          <regex_block>:!s
##      }

sub regex_def__PEEK { $_[0]->_AUTOLEXpeek('regex_def',$retree) }
sub regex_def {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $IN_DECL =  1;


my $C = $self;
my $S = $C->{_pos};
$C->{'deflongname'} = [];
$C->{'signature'} = [];
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "regex_def", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'regex_def_01') {
$C->deb("Fate passed to regex_def_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_def_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_def_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'regex_def_02') {
$C->deb("Fate passed to regex_def_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'regex_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("regex_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT(':')
}))) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
$IN_DECL = 0; 
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['regex_block'], sub {
my $C = shift;
$C->regex_block
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule macro_def
##      rule macro_def {
##          :my $IN_DECL is context<rw> = 1;
##          [ '&'<deflongname>? | <deflongname> ]? [ <multisig> | <trait> ]*
##          <!{
##              $ = $+PARSER.bless($);
##              $IN_DECL = 0;
##          }>
##          <block>:!s
##      }

sub macro_def__PEEK { $_[0]->_AUTOLEXpeek('macro_def',$retree) }
sub macro_def {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $IN_DECL =  1;


my $C = $self;
my $S = $C->{_pos};
$C->{'deflongname'} = [];
$C->{'multisig'} = [];
$C->{'trait'} = [];

$self->_MATCHIFYr($S, "macro_def", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'macro_def_01') {
$C->deb("Fate passed to macro_def_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'macro_def_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("macro_def_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('&'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'macro_def_02') {
$C->deb("Fate passed to macro_def_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'macro_def_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("macro_def_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {

$C = $::PARSER->bless($C);
$IN_DECL = 0;

})
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule trait
##      rule trait {
##          [
##          | <trait_verb>
##          | <trait_auxiliary>
##          | <colonpair>
##          ]
##      }

sub trait__PEEK { $_[0]->_AUTOLEXpeek('trait',$retree) }
sub trait {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "trait", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'trait_01') {
$C->deb("Fate passed to trait_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'trait_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("trait_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['trait_verb'], sub {
my $C = shift;
$C->trait_verb
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['trait_auxiliary'], sub {
my $C = shift;
$C->trait_auxiliary
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token trait_auxiliary__S_239is (:$endsym is context = 'spacey', :$sym is context<rw> = 'is')
##      token trait_auxiliary:is {
##          <sym> <.ws> <longname><postcircumfix>?
##      }

sub trait_auxiliary__S_239is__PEEK { $_[0]->_AUTOLEXpeek('trait_auxiliary__S_239is',$retree) }
sub trait_auxiliary__S_239is {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'is';


my $C = $self;
my $S = $C->{_pos};
$C->{'postcircumfix'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_auxiliary__S_239is", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gis/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token trait_auxiliary__S_240does (:$endsym is context = 'spacey', :$sym is context<rw> = 'does')
##      token trait_auxiliary:does {
##          :my $PKGDECL is context = 'role';
##          <sym> <.ws> <module_name>
##      }

sub trait_auxiliary__S_240does__PEEK { $_[0]->_AUTOLEXpeek('trait_auxiliary__S_240does',$retree) }
sub trait_auxiliary__S_240does {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'does';
local $PKGDECL =  'role';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_auxiliary__S_240does", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdoes/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token trait_auxiliary__S_241will (:$endsym is context = 'spacey', :$sym is context<rw> = 'will')
##      token trait_auxiliary:will {
##          <sym> <.ws> <identifier> <.ws> <block>
##      }

sub trait_auxiliary__S_241will__PEEK { $_[0]->_AUTOLEXpeek('trait_auxiliary__S_241will',$retree) }
sub trait_auxiliary__S_241will {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'will';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_auxiliary__S_241will", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gwill/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule trait_verb__S_242of (:$endsym is context = 'spacey', :$sym is context<rw> = 'of')
##      rule trait_verb:of      {<sym> <fulltypename> }

sub trait_verb__S_242of__PEEK { $_[0]->_AUTOLEXpeek('trait_verb__S_242of',$retree) }
sub trait_verb__S_242of {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'of';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_verb__S_242of", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gof/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule trait_verb__S_243as (:$endsym is context = 'spacey', :$sym is context<rw> = 'as')
##      rule trait_verb:as      {<sym> <fulltypename> }

sub trait_verb__S_243as__PEEK { $_[0]->_AUTOLEXpeek('trait_verb__S_243as',$retree) }
sub trait_verb__S_243as {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'as';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_verb__S_243as", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gas/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule trait_verb__S_244returns (:$endsym is context = 'spacey', :$sym is context<rw> = 'returns')
##      rule trait_verb:returns {<sym> <fulltypename> }

sub trait_verb__S_244returns__PEEK { $_[0]->_AUTOLEXpeek('trait_verb__S_244returns',$retree) }
sub trait_verb__S_244returns {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'returns';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_verb__S_244returns", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Greturns/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## rule trait_verb__S_245handles (:$endsym is context = 'spacey', :$sym is context<rw> = 'handles')
##      rule trait_verb:handles {<sym> <EXPR> }

sub trait_verb__S_245handles__PEEK { $_[0]->_AUTOLEXpeek('trait_verb__S_245handles',$retree) }
sub trait_verb__S_245handles {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $endsym = $args{endsym} // 'spacey';
local $sym = $args{sym} // 'handles';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "trait_verb__S_245handles", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ghandles/))) {
do {
if (my ($C) = ($C->spacey)) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token capterm
##      token capterm {
##          '\\'
##          [
##          | '(' <capture>? ')'
##          | <?before \S> <termish>
##          ]
##      }

sub capterm__PEEK { $_[0]->_AUTOLEXpeek('capterm',$retree) }
sub capterm {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'capture'} = [];

$self->_MATCHIFYr($S, "capterm", 
do {
if (my ($C) = ($C->_EXACT('\\'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'capterm_01') {
$C->deb("Fate passed to capterm_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'capterm_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("capterm_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['capture'], sub {
my $C = shift;
$C->capture
})
}))) {
$C->_EXACT(')');
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
})
}))) {
$C->_SUBSUMEr(['termish'], sub {
my $C = shift;
$C->termish
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## rule capture
##      rule capture {
##          <EXPR>
##      }

sub capture__PEEK { $_[0]->_AUTOLEXpeek('capture',$retree) }
sub capture {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "capture", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token sigterm
##      token sigterm {
##          ':(' ~ ')' <signature>
##      }

sub sigterm__PEEK { $_[0]->_AUTOLEXpeek('sigterm',$retree) }
sub sigterm {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "sigterm", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'sigterm')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT(':('))
);
}

## rule param_sep
##      rule param_sep { [','|':'|';'|';;'] }

sub param_sep__PEEK { $_[0]->_AUTOLEXpeek('param_sep',$retree) }
sub param_sep {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "param_sep", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'param_sep_01') {
$C->deb("Fate passed to param_sep_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'param_sep_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("param_sep_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(',')
},
sub { my $C=shift;
$C->_EXACT(':')
},
sub { my $C=shift;
$C->_EXACT(';')
},
sub { my $C=shift;
$C->_EXACT(';;')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## token signature
##      token signature {
##          # XXX incorrectly scopes &infix:<x> parameters to outside following block
##          :my $IN_DECL is context<rw> = 1;
##          :my $zone is context<rw> = 'posreq';
##          <.ws>
##          [
##          | <?before '-->' | ')' | '{' >
##          | <parameter>
##          ] ** <param_sep>
##          <.ws>
##          [ '-->' <.ws> <fulltypename> ]?
##          { $IN_DECL = 0; }
##      }

sub signature__PEEK { $_[0]->_AUTOLEXpeek('signature',$retree) }
sub signature {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $IN_DECL =  1;
local $zone =  'posreq';


my $C = $self;
my $S = $C->{_pos};
$C->{'parameter'} = [];
$C->{'param_sep'} = [];
$C->{'fulltypename'} = [];

$self->_MATCHIFYr($S, "signature", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_SUBSUMEr(['param_sep'], sub {
my $C = shift;
$C->param_sep
})
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'signature_01') {
$C->deb("Fate passed to signature_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'signature_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("signature_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'signature_02') {
$C->deb("Fate passed to signature_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'signature_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("signature_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('-->')
},
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT('{')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
},
sub { my $C=shift;
$C->_SUBSUMEr(['parameter'], sub {
my $C = shift;
$C->parameter
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('-->'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
});
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
scalar(do {
$IN_DECL = 0; 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token type_declarator__S_246subset (:$sym is context<rw> = 'subset')
##      token type_declarator:subset {
##          <sym> :s
##          <longname> { $.add_type($<longname>.text); }
##          [ of <fulltypename> ]?
##          [where <EXPR(item %chaining)> ]?	# (EXPR can parse multiple where clauses)
##      }

sub type_declarator__S_246subset__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_246subset',$retree) }
sub type_declarator__S_246subset {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'subset';


my $C = $self;
my $S = $C->{_pos};
$C->{'fulltypename'} = [];
$C->{'EXPR'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "type_declarator__S_246subset", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsubset/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $C->add_type($M->{longname}->text); ;
}, $C))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('of'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('where'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token type_declarator__S_247enum (:$sym is context<rw> = 'enum')
##      token type_declarator:enum {
##          :my $l;
##          <sym> <.ws>
##          [ $l = <longname> :: { $.add_type($l.text); } <.ws> ]?
##          <EXPR> <.ws>
##      }

sub type_declarator__S_247enum__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_247enum',$retree) }
sub type_declarator__S_247enum {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'enum';
my $l;


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "type_declarator__S_247enum", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_SUBSUME(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, scalar(do {
$C->add_type($l->text); 
}, $C))
}, $C->_COMMITBRANCH())
}, ($l = $C->longname))
})
}))
}, $C->ws)
}, $C->_PATTERN(qr/\Genum/))
);
}

## rule type_constraint
##      rule type_constraint {
##          [
##          | <value>
##          | <fulltypename>
##          | where <EXPR(item %chaining)>
##          ]
##      }

sub type_constraint__PEEK { $_[0]->_AUTOLEXpeek('type_constraint',$retree) }
sub type_constraint {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "type_constraint", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'type_constraint_01') {
$C->deb("Fate passed to type_constraint_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'type_constraint_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("type_constraint_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['value'], sub {
my $C = shift;
$C->value
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['fulltypename'], sub {
my $C = shift;
$C->fulltypename
}))) {
$C->ws;
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('where'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule post_constraint
##      rule post_constraint {
##          [
##          | '[' ~ ']' <signature>
##          | '(' ~ ')' <signature>
##          | where <EXPR(item %chaining)>
##          ]
##      }

sub post_constraint__PEEK { $_[0]->_AUTOLEXpeek('post_constraint',$retree) }
sub post_constraint {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "post_constraint", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'post_constraint_01') {
$C->deb("Fate passed to post_constraint_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'post_constraint_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("post_constraint_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']', 'post_constraint')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']'))
}, $C->ws)
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')', 'post_constraint')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')'))
}, $C->ws)
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->ws
}, $C->_SUBSUME(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
}))
}, $C->ws)
}, $C->_EXACT('where'))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
}, $C->ws)
);
}

## token named_param
##      token named_param {
##          :my $GOAL is context = ')';
##          ':'
##          [
##          | <name=identifier> '(' <.ws>
##      	[ <named_param> | <param_var> <.ws> ]
##      	[ ')' || <.panic: "Unable to parse named parameter; couldn't find right parenthesis"> ]
##          | <param_var>
##          ]
##      }

sub named_param__PEEK { $_[0]->_AUTOLEXpeek('named_param',$retree) }
sub named_param {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $GOAL =  ')';


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "named_param", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'named_param_01') {
$C->deb("Fate passed to named_param_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'named_param_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("named_param_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'named_param_02') {
$C->deb("Fate passed to named_param_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'named_param_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("named_param_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
$C->ws;
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->panic("Unable to parse named parameter; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

## token param_var
##      token param_var {
##          [
##          | '[' ~ ']' <signature>
##          | '(' ~ ')' <signature>
##          | <sigil> <twigil>?
##              [
##                  # Is it a longname declaration?
##              || <?{ $<sigil>.text eq '&' }> <?ident> {}
##                  <identifier=sublongname>
##      
##              ||  # Is it a shaped array or hash declaration?
##                  <?{ $<sigil>.text eq '@' || $<sigil>.text eq '%' }>
##                  <identifier>?
##                  <?before <[ \< \( \[ \{ ]> >
##                  <postcircumfix>
##      
##                  # ordinary parameter name
##              || <identifier>
##      
##                  # bare sigil?
##              ]?
##          ]
##      }

sub param_var__PEEK { $_[0]->_AUTOLEXpeek('param_var',$retree) }
sub param_var {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'identifier'} = [];
$C->{'twigil'} = [];
$C->{'postcircumfix'} = [];

$self->_MATCHIFY($S, "param_var", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'param_var_01') {
$C->deb("Fate passed to param_var_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'param_var_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("param_var_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'param_var')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'param_var')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['signature'], sub {
my $C = shift;
$C->signature
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['identifier'], sub {
my $C = shift;
$C->sublongname
})
}, scalar(do {

}, $C))
}, $C->before( sub { my $C=shift;
$C->ident
}))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{sigil}->text eq '&' ;
})
}))} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[\<\(\[\{]/)
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['identifier'], sub {
my $C = shift;
$C->identifier
})
}))
}, $C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C;  $M->{sigil}->text eq '@' || $M->{sigil}->text eq '%' ;
})
}))} 
or
eval { push @gather, $C->_SUBSUME(['identifier'], sub {
my $C = shift;
$C->identifier
})} or do { die $@ if $@ };
@gather;
}
})
})
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
}, $C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
}))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

## token parameter
##      token parameter {
##          :my $kind;
##          :my $quant = '';
##          :my $q;
##      
##          # XXX fake out LTM till we get * working right
##          <?before
##              [
##              | <type_constraint>
##              | <param_var>
##              | '*' <param_var>
##              | '|' <param_var>
##              | <named_param>
##              ]
##          >
##      
##          <type_constraint>*
##          [
##          | '*' <param_var>   { $quant = '*'; $kind = '*'; }
##          | '|' <param_var>   { $quant = '|'; $kind = '*'; }
##          |   [
##              | <param_var>   { $quant = ''; $kind = '!'; }
##      	| <named_param> { $quant = ''; $kind = '*'; }
##              ]
##              [
##              | '?'           { $quant = '?'; $kind = '?' }
##              | '!'           { $quant = '!'; $kind = '!' }
##              | <?>
##              ]
##          | <?>               { $quant = ''; $kind = '!'; }
##          ]
##      
##          <trait>*
##      
##          <post_constraint>*
##      
##          [
##              <default_value> {{
##                  given $quant {
##                    when '!' { $.panic("Can't put a default on a required parameter") }
##                    when '*' { $.panic("Can't put a default on a slurpy parameter") }
##                    when '|' { $.panic("Can't put a default on a capture parameter") }
##                  }
##                  $kind = '?';
##              }}
##          ]?
##      
##          {
##              $<quant> = $quant;
##              $<kind> = $kind;
##          }
##      
##          # enforce zone constraints
##          {{
##              given $kind {
##                  when '!' {
##                      given $+zone {
##                          when 'posopt' {
##      $.panic("Can't put required parameter after optional parameters");
##                          }
##                          when 'var' {
##      $.panic("Can't put required parameter after variadic parameters");
##                          }
##                      }
##                  }
##                  when '?' {
##                      given $+zone {
##                          when 'posreq' { $+zone = 'posopt' }
##                          when 'var' {
##      $.panic("Can't put optional positional parameter after variadic parameters");
##                          }
##                      }
##                  }
##                  when '*' {
##                      $+zone = 'var';
##                  }
##              }
##          }}
##      }

sub parameter__PEEK { $_[0]->_AUTOLEXpeek('parameter',$retree) }
sub parameter {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $kind;
my $quant = '';
my $q;


my $C = $self;
my $S = $C->{_pos};
$C->{'trait'} = [];
$C->{'default_value'} = [];
$C->{'post_constraint'} = [];
$C->{'type_constraint'} = [];

$self->_MATCHIFYr($S, "parameter", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'parameter_02') {
$C->deb("Fate passed to parameter_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['type_constraint'], sub {
my $C = shift;
$C->type_constraint
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('*'))) {
$C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('|'))) {
$C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['type_constraint'], sub {
my $C = shift;
$C->type_constraint
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'parameter_03') {
$C->deb("Fate passed to parameter_03: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('*'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '*'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('|'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '|'; $kind = '*'; 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'parameter_04') {
$C->deb("Fate passed to parameter_04: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = ''; $kind = '!'; 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
}))) {
scalar(do {
$quant = ''; $kind = '*'; 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'parameter_05') {
$C->deb("Fate passed to parameter_05: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'parameter_05', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("parameter_05 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('?'))) {
scalar(do {
$quant = '?'; $kind = '?' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
scalar(do {
$quant = '!'; $kind = '!' 
}, $C);
}
else {
();
}
}
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->before( sub { my $C=shift;
$C
}))) {
scalar(do {
$quant = ''; $kind = '!'; 
}, $C);
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_SUBSUMEr(['post_constraint'], sub {
my $C = shift;
$C->post_constraint
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['default_value'], sub {
my $C = shift;
$C->default_value
}))) {
scalar(do {

do { my $_ = $quant; if ((0)) {}
elsif ($_ eq '!') { $C->panic("Can't put a default on a required parameter") }
elsif ($_ eq '*') { $C->panic("Can't put a default on a slurpy parameter") }
elsif ($_ eq '|') { $C->panic("Can't put a default on a capture parameter") }
};
$kind = '?';

}, $C);
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C; 
$M->{quant} = $quant;
$M->{kind} = $kind;
;
}, $C))) {
scalar(do {

do { my $_ = $kind; if ((0)) {}
elsif ($_ eq '!') {
do { my $_ = $::zone; if ((0)) {}
elsif ($_ eq 'posopt') {
$C->panic("Can't put required parameter after optional parameters");
}
elsif ($_ eq 'var') {
$C->panic("Can't put required parameter after variadic parameters");
}
};
}
elsif ($_ eq '?') {
do { my $_ = $::zone; if ((0)) {}
elsif ($_ eq 'posreq') { $::zone = 'posopt' }
elsif ($_ eq 'var') {
$C->panic("Can't put optional positional parameter after variadic parameters");
}
};
}
elsif ($_ eq '*') {
$::zone = 'var';
}
};

}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## rule default_value
##      rule default_value {
##          '=' <EXPR(item %item_assignment)>
##      }

sub default_value__PEEK { $_[0]->_AUTOLEXpeek('default_value',$retree) }
sub default_value {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "default_value", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token statement_prefix__S_248do (:$sym is context<rw> = 'do')
##      token statement_prefix:do      { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_248do__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_248do',$retree) }
sub statement_prefix__S_248do {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'do';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_248do", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gdo/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_249try (:$sym is context<rw> = 'try')
##      token statement_prefix:try     { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_249try__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_249try',$retree) }
sub statement_prefix__S_249try {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'try';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_249try", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtry/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_250gather (:$sym is context<rw> = 'gather')
##      token statement_prefix:gather  { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_250gather__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_250gather',$retree) }
sub statement_prefix__S_250gather {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'gather';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_250gather", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggather/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_251contend (:$sym is context<rw> = 'contend')
##      token statement_prefix:contend { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_251contend__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_251contend',$retree) }
sub statement_prefix__S_251contend {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'contend';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_251contend", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gcontend/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_252async (:$sym is context<rw> = 'async')
##      token statement_prefix:async   { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_252async__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_252async',$retree) }
sub statement_prefix__S_252async {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'async';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_252async", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gasync/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_253maybe (:$sym is context<rw> = 'maybe')
##      token statement_prefix:maybe   { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_253maybe__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_253maybe',$retree) }
sub statement_prefix__S_253maybe {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'maybe';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_253maybe", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gmaybe/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
## token statement_prefix__S_254lazy (:$sym is context<rw> = 'lazy')
##      token statement_prefix:lazy    { <sym> <?before \s> <.ws> <statement> }

sub statement_prefix__S_254lazy__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_254lazy',$retree) }
sub statement_prefix__S_254lazy {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'lazy';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "statement_prefix__S_254lazy", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Glazy/))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## term

## token term__S_255ColonColonQuestionIDENT (  :$sym is context<rw> = <::?IDENT> --> Term)
##      token term:sym<::?IDENT> ( --> Term) {
##          $<sym> = [ '::?' <identifier> ] 
##      }

sub term__S_255ColonColonQuestionIDENT__PEEK { $_[0]->_AUTOLEXpeek('term__S_255ColonColonQuestionIDENT',$retree) }
sub term__S_255ColonColonQuestionIDENT {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(::?IDENT);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_255ColonColonQuestionIDENT",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::?'))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
})
}))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
);
}

## token term__S_256undef (  :$sym is context<rw> = <undef> --> Term)
##      token term:sym<undef> ( --> Term) {
##          <sym> 
##          [ <?before \h*'$/' >
##              <obs('$/ variable as input record separator',
##                   "the filehandle's .slurp method")>
##          ]?
##          [ <?before \h*<variable> >
##              <obs('undef as a verb', 'undefine function')>
##          ]?
##      }

sub term__S_256undef__PEEK { $_[0]->_AUTOLEXpeek('term__S_256undef',$retree) }
sub term__S_256undef {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(undef);


my $C = $self;
my $S = $C->{_pos};
$C->{'variable'} = [];
$C->{'obs'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_256undef",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gundef/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
$C->_EXACT('$/');
}
else {
();
}
}
}))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('$/ variable as input record separator',
"the filehandle's .slurp method")
});
}
else {
();
}
}
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])*+)/))) {
$C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
});
}
else {
();
}
}
}))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('undef as a verb', 'undefine function')
});
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_257next (  :$sym is context<rw> = <next> --> Term)
##      token term:sym<next> ( --> Term)
##          { <sym>  <.ws> [<!stdstopper> <termish>]? }

sub term__S_257next__PEEK { $_[0]->_AUTOLEXpeek('term__S_257next',$retree) }
sub term__S_257next {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(next);


my $C = $self;
my $S = $C->{_pos};
$C->{'termish'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_257next",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gnext/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
$C->_SUBSUMEr(['termish'], sub {
my $C = shift;
$C->termish
});
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_258last (  :$sym is context<rw> = <last> --> Term)
##      token term:sym<last> ( --> Term)
##          { <sym>  <.ws> [<!stdstopper> <termish>]? }

sub term__S_258last__PEEK { $_[0]->_AUTOLEXpeek('term__S_258last',$retree) }
sub term__S_258last {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(last);


my $C = $self;
my $S = $C->{_pos};
$C->{'termish'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_258last",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Glast/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
$C->_SUBSUMEr(['termish'], sub {
my $C = shift;
$C->termish
});
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_259redo (  :$sym is context<rw> = <redo> --> Term)
##      token term:sym<redo> ( --> Term)
##          { <sym>  <.ws> [<!stdstopper> <termish>]? }

sub term__S_259redo__PEEK { $_[0]->_AUTOLEXpeek('term__S_259redo',$retree) }
sub term__S_259redo {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(redo);


my $C = $self;
my $S = $C->{_pos};
$C->{'termish'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_259redo",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gredo/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
$C->_SUBSUMEr(['termish'], sub {
my $C = shift;
$C->termish
});
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_260break (  :$sym is context<rw> = <break> --> Term)
##      token term:sym<break> ( --> Term)
##          { <sym>  <.ws> [<!stdstopper> <termish>]? }

sub term__S_260break__PEEK { $_[0]->_AUTOLEXpeek('term__S_260break',$retree) }
sub term__S_260break {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(break);


my $C = $self;
my $S = $C->{_pos};
$C->{'termish'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_260break",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gbreak/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
$C->_SUBSUMEr(['termish'], sub {
my $C = shift;
$C->termish
});
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_261continue (  :$sym is context<rw> = <continue> --> Term)
##      token term:sym<continue> ( --> Term)
##          { <sym>  }

sub term__S_261continue__PEEK { $_[0]->_AUTOLEXpeek('term__S_261continue',$retree) }
sub term__S_261continue {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(continue);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_261continue",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gcontinue\b/)
);
}

## token term__S_262goto (  :$sym is context<rw> = <goto> --> Term)
##      token term:sym<goto> ( --> Term)
##          { <sym>  <.ws> <termish> }

sub term__S_262goto__PEEK { $_[0]->_AUTOLEXpeek('term__S_262goto',$retree) }
sub term__S_262goto {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(goto);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_262goto",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ggoto/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['termish'], sub {
my $C = shift;
$C->termish
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_263self (  :$sym is context<rw> = <self> --> Term)
##      token term:sym<self> ( --> Term)
##          { <sym>  }

sub term__S_263self__PEEK { $_[0]->_AUTOLEXpeek('term__S_263self',$retree) }
sub term__S_263self {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(self);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_263self",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gself\b/)
);
}

## token term__S_264defer (  :$sym is context<rw> = <defer> --> Term)
##      token term:sym<defer> ( --> Term)
##          { <sym>  }

sub term__S_264defer__PEEK { $_[0]->_AUTOLEXpeek('term__S_264defer',$retree) }
sub term__S_264defer {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(defer);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_264defer",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gdefer\b/)
);
}

## token term__S_265rand (  :$sym is context<rw> = 'rand' --> Term)
##      token term:rand ( --> Term)
##          { <sym>  [ <?before \h+ [\d|'$']> <.obs('rand(N)', 'N.rand or (1..N).pick')> ]? }

sub term__S_265rand__PEEK { $_[0]->_AUTOLEXpeek('term__S_265rand',$retree) }
sub term__S_265rand {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'rand';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_265rand",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Grand/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:[\x20\t\r])++)/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'term__S_265rand_03') {
$C->deb("Fate passed to term__S_265rand_03: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term__S_265rand_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term__S_265rand_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\d/)
},
sub { my $C=shift;
$C->_EXACT('$')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
}))) {
$C->obs('rand(N)', 'N.rand or (1..N).pick');
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_266e (  :$sym is context<rw> = 'e' --> Term)
##      token term:e ( --> Term)
##          { <sym>  }

sub term__S_266e__PEEK { $_[0]->_AUTOLEXpeek('term__S_266e',$retree) }
sub term__S_266e {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_266e",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Ge\b/)
);
}

## token term__S_267i (  :$sym is context<rw> = 'i' --> Term)
##      token term:i ( --> Term)
##          { <sym>  }

sub term__S_267i__PEEK { $_[0]->_AUTOLEXpeek('term__S_267i',$retree) }
sub term__S_267i {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'i';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_267i",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gi\b/)
);
}

## token term__S_268pi (  :$sym is context<rw> = 'pi' --> Term)
##      token term:pi ( --> Term)
##          { <sym>  }

sub term__S_268pi__PEEK { $_[0]->_AUTOLEXpeek('term__S_268pi',$retree) }
sub term__S_268pi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'pi';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_268pi",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\Gpi\b/)
);
}

## token term__S_269Inf (  :$sym is context<rw> = 'Inf' --> Term)
##      token term:Inf ( --> Term)
##          { <sym>  }

sub term__S_269Inf__PEEK { $_[0]->_AUTOLEXpeek('term__S_269Inf',$retree) }
sub term__S_269Inf {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Inf';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_269Inf",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\GInf\b/)
);
}

## token term__S_270NaN (  :$sym is context<rw> = 'NaN' --> Term)
##      token term:NaN ( --> Term)
##          { <sym>  }

sub term__S_270NaN__PEEK { $_[0]->_AUTOLEXpeek('term__S_270NaN',$retree) }
sub term__S_270NaN {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'NaN';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_270NaN",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\GNaN\b/)
);
}

## token term__S_271Star (  :$sym is context<rw> = <*> --> Term)
##      token term:sym<*> ( --> Term)
##          { <sym> }

sub term__S_271Star__PEEK { $_[0]->_AUTOLEXpeek('term__S_271Star',$retree) }
sub term__S_271Star {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_271Star",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\G\*/)
);
}

## token term__S_272StarStar (  :$sym is context<rw> = <**> --> Term)
##      token term:sym<**> ( --> Term)
##          { <sym> }

sub term__S_272StarStar__PEEK { $_[0]->_AUTOLEXpeek('term__S_272StarStar',$retree) }
sub term__S_272StarStar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(**);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_272StarStar",  map { STD::Term->coerce($_) } 
$C->_PATTERN(qr/\G\*\*/)
);
}

## token circumfix__S_273sigil (  :$sym is context<rw> = 'sigil' --> Term)
##      token circumfix:sigil ( --> Term)
##          { :dba('contextualizer') <sigil> '(' ~ ')' <semilist> }

sub circumfix__S_273sigil__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_273sigil',$retree) }
sub circumfix__S_273sigil {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigil';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "circumfix__S_273sigil",  Cursor::lazymap sub { STD::Term->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'contextualizer')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
}, $C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
);
}

#token circumfix:typecast ( --> Term)
#    { <typename> '(' ~ ')' <semilist> }

## token circumfix__S_274Paren_Thesis (  :$sym is context<rw> = <( )> --> Term)
##      token circumfix:sym<( )> ( --> Term)
##          { :dba('parenthesized expression') '(' ~ ')' <semilist> }

sub circumfix__S_274Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_274Paren_Thesis',$retree) }
sub circumfix__S_274Paren_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "circumfix__S_274Paren_Thesis",  Cursor::lazymap sub { STD::Term->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'parenthesized expression')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
);
}

## token circumfix__S_275Bra_Ket (  :$sym is context<rw> = <[ ]> --> Term)
##      token circumfix:sym<[ ]> ( --> Term)
##          { :dba('array composer') '[' ~ ']' <semilist> }

sub circumfix__S_275Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_275Bra_Ket',$retree) }
sub circumfix__S_275Bra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "circumfix__S_275Bra_Ket",  Cursor::lazymap sub { STD::Term->coerce($_[0]) }, 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->FAILGOAL(']' , 'array composer')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ']' ))
}, $C->_EXACT('['))
);
}

## methodcall

## token infix__S_276Dot (:$sym is context<rw> = <.>)
##      token infix:sym<.> ()
##          { '.' <[\]\)\},:\s\$"']> <obs('. to concatenate strings', '~')> }

sub infix__S_276Dot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_276Dot',$retree) }
sub infix__S_276Dot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_276Dot", 
do {
if (my ($C) = ($C->_EXACT('.'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G[\]\)\},:\s\$"']/))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('. to concatenate strings', '~')
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token postfix__S_277MinusGt (:$sym is context<rw> = ['->'])
##      token postfix:sym['->'] ()
##          { '->' <obs('-> to call a method', '.')> }

sub postfix__S_277MinusGt__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_277MinusGt',$retree) }
sub postfix__S_277MinusGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // ['->'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_277MinusGt", 
do {
if (my ($C) = ($C->_EXACT('->'))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('-> to call a method', '.')
});
}
else {
();
}
}
);
}

## autoincrement
## token postfix__S_278PlusPlus (  :$sym is context<rw> = <++> --> Autoincrement)
##      token postfix:sym<++> ( --> Autoincrement)
##          { <sym> }

sub postfix__S_278PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_278PlusPlus',$retree) }
sub postfix__S_278PlusPlus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(++);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_278PlusPlus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\+\+/)
);
}

## token postfix__S_279MinusMinus (  :$sym is context<rw> = <--> --> Autoincrement)
##      token postfix:sym<--> ( --> Autoincrement)
##          { <sym> }

sub postfix__S_279MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_279MinusMinus',$retree) }
sub postfix__S_279MinusMinus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(--);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_279MinusMinus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\-\-/)
);
}

## token prefix__S_280PlusPlus (  :$sym is context<rw> = <++> --> Autoincrement)
##      token prefix:sym<++> ( --> Autoincrement)
##          { <sym> }

sub prefix__S_280PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_280PlusPlus',$retree) }
sub prefix__S_280PlusPlus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(++);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_280PlusPlus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\+\+/)
);
}

## token prefix__S_281MinusMinus (  :$sym is context<rw> = <--> --> Autoincrement)
##      token prefix:sym<--> ( --> Autoincrement)
##          { <sym> }

sub prefix__S_281MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_281MinusMinus',$retree) }
sub prefix__S_281MinusMinus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(--);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_281MinusMinus",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\G\-\-/)
);
}

## token postfix__S_282i (  :$sym is context<rw> = <i> --> Autoincrement)
##      token postfix:sym<i> ( --> Autoincrement)
##          { <sym>  }

sub postfix__S_282i__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_282i',$retree) }
sub postfix__S_282i {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(i);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "postfix__S_282i",  map { STD::Autoincrement->coerce($_) } 
$C->_PATTERN(qr/\Gi\b/)
);
}

## exponentiation
## token infix__S_283StarStar (  :$sym is context<rw> = <**> --> Exponentiation)
##      token infix:sym<**> ( --> Exponentiation)
##          { <sym> }

sub infix__S_283StarStar__PEEK { $_[0]->_AUTOLEXpeek('infix__S_283StarStar',$retree) }
sub infix__S_283StarStar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(**);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_283StarStar",  map { STD::Exponentiation->coerce($_) } 
$C->_PATTERN(qr/\G\*\*/)
);
}

## symbolic unary
## token prefix__S_284Bang (  :$sym is context<rw> = <!> --> Symbolic_unary)
##      token prefix:sym<!> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_284Bang__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_284Bang',$retree) }
sub prefix__S_284Bang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_284Bang",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\!/)
);
}

## token prefix__S_285Plus (  :$sym is context<rw> = <+> --> Symbolic_unary)
##      token prefix:sym<+> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_285Plus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_285Plus',$retree) }
sub prefix__S_285Plus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_285Plus",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\+/)
);
}

## token prefix__S_286Minus (  :$sym is context<rw> = <-> --> Symbolic_unary)
##      token prefix:sym<-> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_286Minus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_286Minus',$retree) }
sub prefix__S_286Minus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(-);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_286Minus",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\-/)
);
}

## token prefix__S_287Tilde (  :$sym is context<rw> = <~> --> Symbolic_unary)
##      token prefix:sym<~> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_287Tilde__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_287Tilde',$retree) }
sub prefix__S_287Tilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_287Tilde",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\~/)
);
}

## token prefix__S_288Question (  :$sym is context<rw> = <?> --> Symbolic_unary)
##      token prefix:sym<?> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_288Question__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_288Question',$retree) }
sub prefix__S_288Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_288Question",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\?/)
);
}

## token prefix__S_289Equal (  :$sym is context<rw> = <=> --> Symbolic_unary)
##      token prefix:sym<=> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_289Equal__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_289Equal',$retree) }
sub prefix__S_289Equal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_289Equal",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\=/)
);
}

## token prefix__S_290TildeCaret (  :$sym is context<rw> = <~^> --> Symbolic_unary)
##      token prefix:sym<~^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_290TildeCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_290TildeCaret',$retree) }
sub prefix__S_290TildeCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_290TildeCaret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\~\^/)
);
}

## token prefix__S_291PlusCaret (  :$sym is context<rw> = <+^> --> Symbolic_unary)
##      token prefix:sym<+^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_291PlusCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_291PlusCaret',$retree) }
sub prefix__S_291PlusCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_291PlusCaret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\+\^/)
);
}

## token prefix__S_292QuestionCaret (  :$sym is context<rw> = <?^> --> Symbolic_unary)
##      token prefix:sym<?^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_292QuestionCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_292QuestionCaret',$retree) }
sub prefix__S_292QuestionCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_292QuestionCaret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\?\^/)
);
}

## token prefix__S_293Caret (  :$sym is context<rw> = <^> --> Symbolic_unary)
##      token prefix:sym<^> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_293Caret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_293Caret',$retree) }
sub prefix__S_293Caret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_293Caret",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\^/)
);
}

## token prefix__S_294Vert (  :$sym is context<rw> = <|> --> Symbolic_unary)
##      token prefix:sym<|> ( --> Symbolic_unary)
##          { <sym> }

sub prefix__S_294Vert__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_294Vert',$retree) }
sub prefix__S_294Vert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_294Vert",  map { STD::Symbolic_unary->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}


## multiplicative
## token infix__S_295Star (  :$sym is context<rw> = <*> --> Multiplicative)
##      token infix:sym<*> ( --> Multiplicative)
##          { <sym> }

sub infix__S_295Star__PEEK { $_[0]->_AUTOLEXpeek('infix__S_295Star',$retree) }
sub infix__S_295Star {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_295Star",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\*/)
);
}

## token infix__S_296Slash (  :$sym is context<rw> = </> --> Multiplicative)
##      token infix:sym</> ( --> Multiplicative)
##          { <sym> }

sub infix__S_296Slash__PEEK { $_[0]->_AUTOLEXpeek('infix__S_296Slash',$retree) }
sub infix__S_296Slash {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(/);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_296Slash",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\//)
);
}

## token infix__S_297Percent (  :$sym is context<rw> = <%> --> Multiplicative)
##      token infix:sym<%> ( --> Multiplicative)
##          { <sym> }

sub infix__S_297Percent__PEEK { $_[0]->_AUTOLEXpeek('infix__S_297Percent',$retree) }
sub infix__S_297Percent {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(%);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_297Percent",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\%/)
);
}

## token infix__S_298PlusAmp (  :$sym is context<rw> = <+&> --> Multiplicative)
##      token infix:sym<+&> ( --> Multiplicative)
##          { <sym> }

sub infix__S_298PlusAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_298PlusAmp',$retree) }
sub infix__S_298PlusAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_298PlusAmp",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\+\&/)
);
}

## token infix__S_299PlusLt (  :$sym is context<rw> =  +<  --> Multiplicative)
##      token infix:sym +<  ( --> Multiplicative)
##          { <sym> }

sub infix__S_299PlusLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_299PlusLt',$retree) }
sub infix__S_299PlusLt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['+<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_299PlusLt",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\+\</)
);
}

## token infix__S_300LtLt (  :$sym is context<rw> =  <<  --> Multiplicative)
##      token infix:sym <<  ( --> Multiplicative)
##          { <sym> <obs('<< to do left shift', '+< or ~<')> }

sub infix__S_300LtLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_300LtLt',$retree) }
sub infix__S_300LtLt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_300LtLt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\<\</))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('<< to do left shift', '+< or ~<')
});
}
else {
();
}
}
);
}

## token infix__S_301GtGt (  :$sym is context<rw> =  >>  --> Multiplicative)
##      token infix:sym >>  ( --> Multiplicative)
##          { <sym> <obs('>> to do right shift', '+> or ~>')> }

sub infix__S_301GtGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_301GtGt',$retree) }
sub infix__S_301GtGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_301GtGt",  map { STD::Multiplicative->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\>\>/))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('>> to do right shift', '+> or ~>')
});
}
else {
();
}
}
);
}

## token infix__S_302PlusGt (  :$sym is context<rw> =  +>  --> Multiplicative)
##      token infix:sym +>  ( --> Multiplicative)
##          { <sym> }

sub infix__S_302PlusGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_302PlusGt',$retree) }
sub infix__S_302PlusGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['+>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_302PlusGt",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\+\>/)
);
}

## token infix__S_303TildeAmp (  :$sym is context<rw> = <~&> --> Multiplicative)
##      token infix:sym<~&> ( --> Multiplicative)
##          { <sym> }

sub infix__S_303TildeAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_303TildeAmp',$retree) }
sub infix__S_303TildeAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_303TildeAmp",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\~\&/)
);
}

## token infix__S_304QuestionAmp (  :$sym is context<rw> = <?&> --> Multiplicative)
##      token infix:sym<?&> ( --> Multiplicative)
##          { <sym> }

sub infix__S_304QuestionAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_304QuestionAmp',$retree) }
sub infix__S_304QuestionAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_304QuestionAmp",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\?\&/)
);
}

## token infix__S_305TildeLt (  :$sym is context<rw> =  ~<  --> Multiplicative)
##      token infix:sym ~<  ( --> Multiplicative)
##          { <sym> }

sub infix__S_305TildeLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_305TildeLt',$retree) }
sub infix__S_305TildeLt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['~<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_305TildeLt",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\~\</)
);
}

## token infix__S_306TildeGt (  :$sym is context<rw> =  ~>  --> Multiplicative)
##      token infix:sym ~>  ( --> Multiplicative)
##          { <sym> }

sub infix__S_306TildeGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_306TildeGt',$retree) }
sub infix__S_306TildeGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['~>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_306TildeGt",  map { STD::Multiplicative->coerce($_) } 
$C->_PATTERN(qr/\G\~\>/)
);
}


## additive
## token infix__S_307Plus (  :$sym is context<rw> = <+> --> Additive)
##      token infix:sym<+> ( --> Additive)
##          { <sym> }

sub infix__S_307Plus__PEEK { $_[0]->_AUTOLEXpeek('infix__S_307Plus',$retree) }
sub infix__S_307Plus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_307Plus",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\+/)
);
}

## token infix__S_308Minus (  :$sym is context<rw> = <-> --> Additive)
##      token infix:sym<-> ( --> Additive)
##          { <sym> }

sub infix__S_308Minus__PEEK { $_[0]->_AUTOLEXpeek('infix__S_308Minus',$retree) }
sub infix__S_308Minus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(-);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_308Minus",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\-/)
);
}

## token infix__S_309PlusVert (  :$sym is context<rw> = <+|> --> Additive)
##      token infix:sym<+|> ( --> Additive)
##          { <sym> }

sub infix__S_309PlusVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_309PlusVert',$retree) }
sub infix__S_309PlusVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_309PlusVert",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\+\|/)
);
}

## token infix__S_310PlusCaret (  :$sym is context<rw> = <+^> --> Additive)
##      token infix:sym<+^> ( --> Additive)
##          { <sym> }

sub infix__S_310PlusCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_310PlusCaret',$retree) }
sub infix__S_310PlusCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_310PlusCaret",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\+\^/)
);
}

## token infix__S_311TildeVert (  :$sym is context<rw> = <~|> --> Additive)
##      token infix:sym<~|> ( --> Additive)
##          { <sym> }

sub infix__S_311TildeVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_311TildeVert',$retree) }
sub infix__S_311TildeVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_311TildeVert",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\~\|/)
);
}

## token infix__S_312TildeCaret (  :$sym is context<rw> = <~^> --> Additive)
##      token infix:sym<~^> ( --> Additive)
##          { <sym> }

sub infix__S_312TildeCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_312TildeCaret',$retree) }
sub infix__S_312TildeCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_312TildeCaret",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\~\^/)
);
}

## token infix__S_313QuestionVert (  :$sym is context<rw> = <?|> --> Additive)
##      token infix:sym<?|> ( --> Additive)
##          { <sym> }

sub infix__S_313QuestionVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_313QuestionVert',$retree) }
sub infix__S_313QuestionVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_313QuestionVert",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\?\|/)
);
}

## token infix__S_314QuestionCaret (  :$sym is context<rw> = <?^> --> Additive)
##      token infix:sym<?^> ( --> Additive)
##          { <sym> }

sub infix__S_314QuestionCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_314QuestionCaret',$retree) }
sub infix__S_314QuestionCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_314QuestionCaret",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\?\^/)
);
}

## replication
# Note: no word boundary check after x, relies on longest token for x2 xx2 etc
## token infix__S_315x (  :$sym is context<rw> = <x> --> Replication)
##      token infix:sym<x> ( --> Replication)
##          { <sym> }

sub infix__S_315x__PEEK { $_[0]->_AUTOLEXpeek('infix__S_315x',$retree) }
sub infix__S_315x {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(x);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_315x",  map { STD::Replication->coerce($_) } 
$C->_PATTERN(qr/\Gx/)
);
}

## token infix__S_316xx (  :$sym is context<rw> = <xx> --> Replication)
##      token infix:sym<xx> ( --> Replication)
##          { <sym> }

sub infix__S_316xx__PEEK { $_[0]->_AUTOLEXpeek('infix__S_316xx',$retree) }
sub infix__S_316xx {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(xx);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_316xx",  map { STD::Replication->coerce($_) } 
$C->_PATTERN(qr/\Gxx/)
);
}

## concatenation
## token infix__S_317Tilde (  :$sym is context<rw> = <~> --> Concatenation)
##      token infix:sym<~> ( --> Concatenation)
##          { <sym> }

sub infix__S_317Tilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_317Tilde',$retree) }
sub infix__S_317Tilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_317Tilde",  map { STD::Concatenation->coerce($_) } 
$C->_PATTERN(qr/\G\~/)
);
}


## junctive and (all)
## token infix__S_318Amp (  :$sym is context<rw> = <&> --> Junctive_and)
##      token infix:sym<&> ( --> Junctive_and)
##          { <sym> }

sub infix__S_318Amp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_318Amp',$retree) }
sub infix__S_318Amp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_318Amp",  map { STD::Junctive_and->coerce($_) } 
$C->_PATTERN(qr/\G\&/)
);
}

## token infix__S_319also (  :$sym is context<rw> = <also> --> Junctive_and)
##      token infix:sym<also> ( --> Junctive_and)
##          { <sym> }

sub infix__S_319also__PEEK { $_[0]->_AUTOLEXpeek('infix__S_319also',$retree) }
sub infix__S_319also {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(also);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_319also",  map { STD::Junctive_and->coerce($_) } 
$C->_PATTERN(qr/\Galso/)
);
}


## junctive or (any)
## token infix__S_320Vert (  :$sym is context<rw> = <|> --> Junctive_or)
##      token infix:sym<|> ( --> Junctive_or)
##          { <sym> }

sub infix__S_320Vert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_320Vert',$retree) }
sub infix__S_320Vert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_320Vert",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}

## token infix__S_321Caret (  :$sym is context<rw> = <^> --> Junctive_or)
##      token infix:sym<^> ( --> Junctive_or)
##          { <sym> }

sub infix__S_321Caret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_321Caret',$retree) }
sub infix__S_321Caret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_321Caret",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\^/)
);
}


## named unary examples
# (need \s* to win LTM battle with listops)
## token prefix__S_322sleep (  :$sym is context<rw> = 'sleep' --> Named_unary)
##      token prefix:sleep ( --> Named_unary)
##          { <sym>  <?before \s*> }

sub prefix__S_322sleep__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_322sleep',$retree) }
sub prefix__S_322sleep {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sleep';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_322sleep",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gsleep/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token prefix__S_323abs (  :$sym is context<rw> = 'abs' --> Named_unary)
##      token prefix:abs ( --> Named_unary)
##          { <sym>  <?before \s*> }

sub prefix__S_323abs__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_323abs',$retree) }
sub prefix__S_323abs {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'abs';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_323abs",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gabs/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token prefix__S_324int (  :$sym is context<rw> = 'int' --> Named_unary)
##      token prefix:int ( --> Named_unary)
##          { <sym>  <?before \s*> }

sub prefix__S_324int__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_324int',$retree) }
sub prefix__S_324int {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'int';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_324int",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gint/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token prefix__S_325let (  :$sym is context<rw> = 'let' --> Named_unary)
##      token prefix:let ( --> Named_unary)
##          { <sym>  <?before \s*> }

sub prefix__S_325let__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_325let',$retree) }
sub prefix__S_325let {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'let';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_325let",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Glet/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token prefix__S_326temp (  :$sym is context<rw> = 'temp' --> Named_unary)
##      token prefix:temp ( --> Named_unary)
##          { <sym>  <?before \s*> }

sub prefix__S_326temp__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_326temp',$retree) }
sub prefix__S_326temp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'temp';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_326temp",  map { STD::Named_unary->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gtemp/))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\s)*+)/)
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## nonchaining binary
## token infix__S_327LtEqualGt (  :$sym is context<rw> =  <=>  --> Nonchaining)
##      token infix:sym <=>  ( --> Nonchaining)
##          { <sym> }

sub infix__S_327LtEqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_327LtEqualGt',$retree) }
sub infix__S_327LtEqualGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<=>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_327LtEqualGt",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\<\=\>/)
);
}

## token infix__S_328cmp (  :$sym is context<rw> = 'cmp' --> Nonchaining)
##      token infix:cmp ( --> Nonchaining)
##          { <sym> }

sub infix__S_328cmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_328cmp',$retree) }
sub infix__S_328cmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'cmp';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_328cmp",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\Gcmp/)
);
}

## token infix__S_329leg (  :$sym is context<rw> = 'leg' --> Nonchaining)
##      token infix:leg ( --> Nonchaining)
##          { <sym> }

sub infix__S_329leg__PEEK { $_[0]->_AUTOLEXpeek('infix__S_329leg',$retree) }
sub infix__S_329leg {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'leg';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_329leg",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\Gleg/)
);
}

## token infix__S_330but (  :$sym is context<rw> = 'but' --> Nonchaining)
##      token infix:but ( --> Nonchaining)
##          { <sym> }

sub infix__S_330but__PEEK { $_[0]->_AUTOLEXpeek('infix__S_330but',$retree) }
sub infix__S_330but {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'but';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_330but",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\Gbut/)
);
}

## token infix__S_331does (  :$sym is context<rw> = 'does' --> Nonchaining)
##      token infix:does ( --> Nonchaining)
##          { <sym> }

sub infix__S_331does__PEEK { $_[0]->_AUTOLEXpeek('infix__S_331does',$retree) }
sub infix__S_331does {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'does';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_331does",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\Gdoes/)
);
}

## token infix__S_332DotDot (  :$sym is context<rw> = <..> --> Nonchaining)
##      token infix:sym<..> ( --> Nonchaining)
##          { <sym> }

sub infix__S_332DotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_332DotDot',$retree) }
sub infix__S_332DotDot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(..);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_332DotDot",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\.\./)
);
}

## token infix__S_333CaretDotDot (  :$sym is context<rw> = <^..> --> Nonchaining)
##      token infix:sym<^..> ( --> Nonchaining)
##          { <sym> }

sub infix__S_333CaretDotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_333CaretDotDot',$retree) }
sub infix__S_333CaretDotDot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^..);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_333CaretDotDot",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\^\.\./)
);
}

## token infix__S_334DotDotCaret (  :$sym is context<rw> = <..^> --> Nonchaining)
##      token infix:sym<..^> ( --> Nonchaining)
##          { <sym> }

sub infix__S_334DotDotCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_334DotDotCaret',$retree) }
sub infix__S_334DotDotCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(..^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_334DotDotCaret",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\.\.\^/)
);
}

## token infix__S_335CaretDotDotCaret (  :$sym is context<rw> = <^..^> --> Nonchaining)
##      token infix:sym<^..^> ( --> Nonchaining)
##          { <sym> }

sub infix__S_335CaretDotDotCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_335CaretDotDotCaret',$retree) }
sub infix__S_335CaretDotDotCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^..^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_335CaretDotDotCaret",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\^\.\.\^/)
);
}

## token infix__S_336ff (  :$sym is context<rw> = <ff> --> Nonchaining)
##      token infix:sym<ff> ( --> Nonchaining)
##          { <sym> }

sub infix__S_336ff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_336ff',$retree) }
sub infix__S_336ff {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ff);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_336ff",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\Gff/)
);
}

## token infix__S_337Caretff (  :$sym is context<rw> = <^ff> --> Nonchaining)
##      token infix:sym<^ff> ( --> Nonchaining)
##          { <sym> }

sub infix__S_337Caretff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_337Caretff',$retree) }
sub infix__S_337Caretff {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^ff);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_337Caretff",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\^ff/)
);
}

## token infix__S_338ffCaret (  :$sym is context<rw> = <ff^> --> Nonchaining)
##      token infix:sym<ff^> ( --> Nonchaining)
##          { <sym> }

sub infix__S_338ffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_338ffCaret',$retree) }
sub infix__S_338ffCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ff^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_338ffCaret",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\Gff\^/)
);
}

## token infix__S_339CaretffCaret (  :$sym is context<rw> = <^ff^> --> Nonchaining)
##      token infix:sym<^ff^> ( --> Nonchaining)
##          { <sym> }

sub infix__S_339CaretffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_339CaretffCaret',$retree) }
sub infix__S_339CaretffCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^ff^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_339CaretffCaret",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\^ff\^/)
);
}

## token infix__S_340fff (  :$sym is context<rw> = <fff> --> Nonchaining)
##      token infix:sym<fff> ( --> Nonchaining)
##          { <sym> }

sub infix__S_340fff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_340fff',$retree) }
sub infix__S_340fff {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(fff);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_340fff",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\Gfff/)
);
}

## token infix__S_341Caretfff (  :$sym is context<rw> = <^fff> --> Nonchaining)
##      token infix:sym<^fff> ( --> Nonchaining)
##          { <sym> }

sub infix__S_341Caretfff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_341Caretfff',$retree) }
sub infix__S_341Caretfff {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^fff);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_341Caretfff",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\^fff/)
);
}

## token infix__S_342fffCaret (  :$sym is context<rw> = <fff^> --> Nonchaining)
##      token infix:sym<fff^> ( --> Nonchaining)
##          { <sym> }

sub infix__S_342fffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_342fffCaret',$retree) }
sub infix__S_342fffCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(fff^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_342fffCaret",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\Gfff\^/)
);
}

## token infix__S_343CaretfffCaret (  :$sym is context<rw> = <^fff^> --> Nonchaining)
##      token infix:sym<^fff^> ( --> Nonchaining)
##          { <sym> }

sub infix__S_343CaretfffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_343CaretfffCaret',$retree) }
sub infix__S_343CaretfffCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^fff^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_343CaretfffCaret",  map { STD::Nonchaining->coerce($_) } 
$C->_PATTERN(qr/\G\^fff\^/)
);
}


## chaining binary
## token infix__S_344EqualEqual (  :$sym is context<rw> = <==> --> Chaining)
##      token infix:sym<==> ( --> Chaining)
##          { <sym> }

sub infix__S_344EqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_344EqualEqual',$retree) }
sub infix__S_344EqualEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(==);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_344EqualEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\=\=/)
);
}

## token infix__S_345BangEqual (  :$sym is context<rw> = <!=> --> Chaining)
##      token infix:sym<!=> ( --> Chaining)
##          { <sym> }

sub infix__S_345BangEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_345BangEqual',$retree) }
sub infix__S_345BangEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_345BangEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\!\=/)
);
}

## token infix__S_346Lt (  :$sym is context<rw> =  <  --> Chaining)
##      token infix:sym <  ( --> Chaining)
##          { <sym> }

sub infix__S_346Lt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_346Lt',$retree) }
sub infix__S_346Lt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_346Lt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\</)
);
}

## token infix__S_347LtEqual (  :$sym is context<rw> =  <=  --> Chaining)
##      token infix:sym <=  ( --> Chaining)
##          { <sym> }

sub infix__S_347LtEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_347LtEqual',$retree) }
sub infix__S_347LtEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<='];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_347LtEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\<\=/)
);
}

## token infix__S_348Gt (  :$sym is context<rw> =  >  --> Chaining)
##      token infix:sym >  ( --> Chaining)
##          { <sym> }

sub infix__S_348Gt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_348Gt',$retree) }
sub infix__S_348Gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_348Gt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\>/)
);
}

## token infix__S_349GtEqual (  :$sym is context<rw> =  >=  --> Chaining)
##      token infix:sym >=  ( --> Chaining)
##          { <sym> }

sub infix__S_349GtEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_349GtEqual',$retree) }
sub infix__S_349GtEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>='];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_349GtEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\>\=/)
);
}

## token infix__S_350TildeTilde (  :$sym is context<rw> = <~~> --> Chaining)
##      token infix:sym<~~> ( --> Chaining)
##          { <sym> }

sub infix__S_350TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_350TildeTilde',$retree) }
sub infix__S_350TildeTilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_350TildeTilde",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\~\~/)
);
}

## token infix__S_351BangTilde (  :$sym is context<rw> = <!~> --> Chaining)
##      token infix:sym<!~> ( --> Chaining)
##          { <sym> <obs('!~ to do negated pattern matching', '!~~')> }

sub infix__S_351BangTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_351BangTilde',$retree) }
sub infix__S_351BangTilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_351BangTilde",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\~/))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('!~ to do negated pattern matching', '!~~')
});
}
else {
();
}
}
);
}

## token infix__S_352EqualTilde (  :$sym is context<rw> = <=~> --> Chaining)
##      token infix:sym<=~> ( --> Chaining)
##          { <sym> <obs('=~ to do pattern matching', '~~')> }

sub infix__S_352EqualTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_352EqualTilde',$retree) }
sub infix__S_352EqualTilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_352EqualTilde",  map { STD::Chaining->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\~/))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('=~ to do pattern matching', '~~')
});
}
else {
();
}
}
);
}

## token infix__S_353eq (  :$sym is context<rw> = <eq> --> Chaining)
##      token infix:sym<eq> ( --> Chaining)
##          { <sym> }

sub infix__S_353eq__PEEK { $_[0]->_AUTOLEXpeek('infix__S_353eq',$retree) }
sub infix__S_353eq {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(eq);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_353eq",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Geq/)
);
}

## token infix__S_354ne (  :$sym is context<rw> = <ne> --> Chaining)
##      token infix:sym<ne> ( --> Chaining)
##          { <sym> }

sub infix__S_354ne__PEEK { $_[0]->_AUTOLEXpeek('infix__S_354ne',$retree) }
sub infix__S_354ne {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ne);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_354ne",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gne/)
);
}

## token infix__S_355lt (  :$sym is context<rw> = <lt> --> Chaining)
##      token infix:sym<lt> ( --> Chaining)
##          { <sym> }

sub infix__S_355lt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_355lt',$retree) }
sub infix__S_355lt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(lt);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_355lt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Glt/)
);
}

## token infix__S_356le (  :$sym is context<rw> = <le> --> Chaining)
##      token infix:sym<le> ( --> Chaining)
##          { <sym> }

sub infix__S_356le__PEEK { $_[0]->_AUTOLEXpeek('infix__S_356le',$retree) }
sub infix__S_356le {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(le);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_356le",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gle/)
);
}

## token infix__S_357gt (  :$sym is context<rw> = <gt> --> Chaining)
##      token infix:sym<gt> ( --> Chaining)
##          { <sym> }

sub infix__S_357gt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_357gt',$retree) }
sub infix__S_357gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(gt);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_357gt",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Ggt/)
);
}

## token infix__S_358ge (  :$sym is context<rw> = <ge> --> Chaining)
##      token infix:sym<ge> ( --> Chaining)
##          { <sym> }

sub infix__S_358ge__PEEK { $_[0]->_AUTOLEXpeek('infix__S_358ge',$retree) }
sub infix__S_358ge {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(ge);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_358ge",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Gge/)
);
}

## token infix__S_359EqualColonEqual (  :$sym is context<rw> = <=:=> --> Chaining)
##      token infix:sym<=:=> ( --> Chaining)
##          { <sym> }

sub infix__S_359EqualColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_359EqualColonEqual',$retree) }
sub infix__S_359EqualColonEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=:=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_359EqualColonEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\=\:\=/)
);
}

## token infix__S_360EqualEqualEqual (  :$sym is context<rw> = <===> --> Chaining)
##      token infix:sym<===> ( --> Chaining)
##          { <sym> }

sub infix__S_360EqualEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_360EqualEqualEqual',$retree) }
sub infix__S_360EqualEqualEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(===);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_360EqualEqualEqual",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\G\=\=\=/)
);
}

## token infix__S_361eqv (  :$sym is context<rw> = <eqv> --> Chaining)
##      token infix:sym<eqv> ( --> Chaining)
##          { <sym> }

sub infix__S_361eqv__PEEK { $_[0]->_AUTOLEXpeek('infix__S_361eqv',$retree) }
sub infix__S_361eqv {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(eqv);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_361eqv",  map { STD::Chaining->coerce($_) } 
$C->_PATTERN(qr/\Geqv/)
);
}


## tight and
## token infix__S_362AmpAmp (  :$sym is context<rw> = <&&> --> Tight_and)
##      token infix:sym<&&> ( --> Tight_and)
##          { <sym> }

sub infix__S_362AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_362AmpAmp',$retree) }
sub infix__S_362AmpAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_362AmpAmp",  map { STD::Tight_and->coerce($_) } 
$C->_PATTERN(qr/\G\&\&/)
);
}


## tight or
## token infix__S_363VertVert (  :$sym is context<rw> = <||> --> Tight_or)
##      token infix:sym<||> ( --> Tight_or)
##          { <sym> }

sub infix__S_363VertVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_363VertVert',$retree) }
sub infix__S_363VertVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(||);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_363VertVert",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\|\|/)
);
}

## token infix__S_364CaretCaret (  :$sym is context<rw> = <^^> --> Tight_or)
##      token infix:sym<^^> ( --> Tight_or)  {
##          <sym>
##          { $<O><assoc> := 'list' }  # override Tight_or's 'left' associativity
##      }

sub infix__S_364CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_364CaretCaret',$retree) }
sub infix__S_364CaretCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_364CaretCaret",  map { STD::Tight_or->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\^\^/))) {
scalar(do {
my $M = $C;  $M->{O}{assoc} = 'list' ;
}, $C);
}
else {
();
}
}
);
}

## token infix__S_365SlashSlash (  :$sym is context<rw> = <//> --> Tight_or)
##      token infix:sym<//> ( --> Tight_or)
##          { <sym> }

sub infix__S_365SlashSlash__PEEK { $_[0]->_AUTOLEXpeek('infix__S_365SlashSlash',$retree) }
sub infix__S_365SlashSlash {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(//);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_365SlashSlash",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\/\//)
);
}

## token infix__S_366min (  :$sym is context<rw> = <min> --> Tight_or)
##      token infix:sym<min> ( --> Tight_or)
##          { <sym> }

sub infix__S_366min__PEEK { $_[0]->_AUTOLEXpeek('infix__S_366min',$retree) }
sub infix__S_366min {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(min);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_366min",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\Gmin/)
);
}

## token infix__S_367max (  :$sym is context<rw> = <max> --> Tight_or)
##      token infix:sym<max> ( --> Tight_or)
##          { <sym> }

sub infix__S_367max__PEEK { $_[0]->_AUTOLEXpeek('infix__S_367max',$retree) }
sub infix__S_367max {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(max);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_367max",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\Gmax/)
);
}


## conditional
## token infix__S_368QuestionQuestion_BangBang (  :$sym is context<rw> = <?? !!> --> Conditional)
##      token infix:sym<?? !!> ( --> Conditional) {
##          :my $GOAL is context = '!!';
##          '??'
##          <.ws>
##          <EXPR(item %item_assignment)>
##          [ '!!' ||
##              [
##              || <?before '='> <.panic: "Assignment not allowed within ??!!">
##              || <?before '::'> <.panic: "Please use !! rather than ::">
##              || <?before <infix>>    # Note: a tight infix would have parsed right
##                  <.panic: "Precedence too loose within ??!!; use ??()!! instead ">
##              || <.panic: "Found ?? but no !!; possible precedence problem">
##              ]
##          ]
##      }

sub infix__S_368QuestionQuestion_BangBang__PEEK { $_[0]->_AUTOLEXpeek('infix__S_368QuestionQuestion_BangBang',$retree) }
sub infix__S_368QuestionQuestion_BangBang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(?? !!)];
local $GOAL =  '!!';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_368QuestionQuestion_BangBang",  map { STD::Conditional->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('??'))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('!!')} 
or
eval { push @gather, $C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('=')
}))) {
$C->panic("Assignment not allowed within ??!!");
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('::')
}))) {
$C->panic("Please use !! rather than ::");
}
else {
();
}
}} 
or
eval { push @gather, do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['infix'], sub {
my $C = shift;
$C->infix
})
}))) {
$C->panic("Precedence too loose within ??!!; use ??()!! instead ");
}
else {
();
}
}} 
or
eval { push @gather, $C->panic("Found ?? but no !!; possible precedence problem")} or do { die $@ if $@ };
@gather;
}
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_369Question (  :$sym is context<rw> = <?> --> Conditional)
##      token infix:sym<?> ( --> Conditional)
##          { <sym> <obs('?: for the conditional operator', '??!!')> }

sub infix__S_369Question__PEEK { $_[0]->_AUTOLEXpeek('infix__S_369Question',$retree) }
sub infix__S_369Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_369Question",  map { STD::Conditional->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('?: for the conditional operator', '??!!')
});
}
else {
();
}
}
);
}

## assignment
# There is no "--> type" because assignment may be coerced to either
# item assignment or list assignment at "make" time.

## token infix__S_370Equal (:$sym is context<rw> = <=>)
##      token infix:sym<=> ()
##      {
##          <sym>
##          { $ = (self.<SIGIL> // self.<sigil> // '') eq '$' 
##              ?? STD::Item_assignment.coerce($)
##              !! STD::List_assignment.coerce($);
##          }
##      }

sub infix__S_370Equal__PEEK { $_[0]->_AUTOLEXpeek('infix__S_370Equal',$retree) }
sub infix__S_370Equal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_370Equal", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=/))) {
scalar(do {
$C = ($self->{'SIGIL'} // $self->{'sigil'} // '') eq '$' 
? STD::Item_assignment->coerce($C)
: STD::List_assignment->coerce($C);

}, $C);
}
else {
();
}
}
);
}

## token infix__S_371ColonEqual (  :$sym is context<rw> = <:=> --> Item_assignment)
##      token infix:sym<:=> ( --> Item_assignment)
##          { <sym> }

sub infix__S_371ColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_371ColonEqual',$retree) }
sub infix__S_371ColonEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_371ColonEqual",  map { STD::Item_assignment->coerce($_) } 
$C->_PATTERN(qr/\G\:\=/)
);
}

## token infix__S_372ColonColonEqual (  :$sym is context<rw> = <::=> --> Item_assignment)
##      token infix:sym<::=> ( --> Item_assignment)
##          { <sym> }

sub infix__S_372ColonColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_372ColonColonEqual',$retree) }
sub infix__S_372ColonColonEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(::=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_372ColonColonEqual",  map { STD::Item_assignment->coerce($_) } 
$C->_PATTERN(qr/\G\:\:\=/)
);
}

## token infix__S_373DotEqual (  :$sym is context<rw> = <.=> --> Item_assignment)
##      token infix:sym<.=> ( --> Item_assignment) {
##          <sym> <.ws>
##          [ <?before \w+';' | 'new'|'sort'|'subst'|'trans'|'reverse'|'uniq'|'map'|'samecase'|'substr' > || <worryobs('.= as append operator', '~=')> ]
##          { $<O><nextterm> = 'dottyop' }
##      }

sub infix__S_373DotEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_373DotEqual',$retree) }
sub infix__S_373DotEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_373DotEqual",  map { STD::Item_assignment->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\.\=/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infix__S_373DotEqual_02') {
$C->deb("Fate passed to infix__S_373DotEqual_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infix__S_373DotEqual_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infix__S_373DotEqual_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
$C->_EXACT(';');
}
else {
();
}
}
},
sub { my $C=shift;
$C->_EXACT('new')
},
sub { my $C=shift;
$C->_EXACT('sort')
},
sub { my $C=shift;
$C->_EXACT('subst')
},
sub { my $C=shift;
$C->_EXACT('trans')
},
sub { my $C=shift;
$C->_EXACT('reverse')
},
sub { my $C=shift;
$C->_EXACT('uniq')
},
sub { my $C=shift;
$C->_EXACT('map')
},
sub { my $C=shift;
$C->_EXACT('samecase')
},
sub { my $C=shift;
$C->_EXACT('substr')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})} 
or
eval { push @gather, $C->_SUBSUMEr(['worryobs'], sub {
my $C = shift;
$C->worryobs('.= as append operator', '~=')
})} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{O}{nextterm} = 'dottyop' ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token infix__S_374EqualGt (  :$sym is context<rw> =  =>  --> Item_assignment)
##      token infix:sym =>  ( --> Item_assignment)
##          { <sym> }

sub infix__S_374EqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_374EqualGt',$retree) }
sub infix__S_374EqualGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['=>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_374EqualGt",  map { STD::Item_assignment->coerce($_) } 
$C->_PATTERN(qr/\G\=\>/)
);
}

# Note, other assignment ops generated by infix_postfix_meta_operator rule

## loose unary
## token prefix__S_375true (  :$sym is context<rw> = <true> --> Loose_unary)
##      token prefix:sym<true> ( --> Loose_unary)
##          { <sym>  }

sub prefix__S_375true__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_375true',$retree) }
sub prefix__S_375true {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(true);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_375true",  map { STD::Loose_unary->coerce($_) } 
$C->_PATTERN(qr/\Gtrue\b/)
);
}

## token prefix__S_376not (  :$sym is context<rw> = <not> --> Loose_unary)
##      token prefix:sym<not> ( --> Loose_unary)
##          { <sym>  }

sub prefix__S_376not__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_376not',$retree) }
sub prefix__S_376not {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(not);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "prefix__S_376not",  map { STD::Loose_unary->coerce($_) } 
$C->_PATTERN(qr/\Gnot\b/)
);
}

## list item separator
## token infix__S_377Comma (  :$sym is context<rw> = <,> --> Comma)
##      token infix:sym<,> ( --> Comma)
##          { <sym> }

sub infix__S_377Comma__PEEK { $_[0]->_AUTOLEXpeek('infix__S_377Comma',$retree) }
sub infix__S_377Comma {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[,];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_377Comma",  map { STD::Comma->coerce($_) } 
$C->_PATTERN(qr/\G\,/)
);
}

## token infix__S_378Colon (  :$sym is context<rw> = <:> --> Comma)
##      token infix:sym<:> ( --> Comma)
##          { <sym> }

sub infix__S_378Colon__PEEK { $_[0]->_AUTOLEXpeek('infix__S_378Colon',$retree) }
sub infix__S_378Colon {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_378Colon",  map { STD::Comma->coerce($_) } 
$C->_PATTERN(qr/\G\:/)
);
}

## token infix__S_379p5EqualGt (  :$sym is context<rw> =  p5=>  --> Comma)
##      token infix:sym p5=>  ( --> Comma)
##          { <sym> }

sub infix__S_379p5EqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_379p5EqualGt',$retree) }
sub infix__S_379p5EqualGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['p5=>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_379p5EqualGt",  map { STD::Comma->coerce($_) } 
$C->_PATTERN(qr/\Gp5\=\>/)
);
}

## list infix
## token infix__S_380X (  :$sym is context<rw> = <X> --> List_infix)
##      token infix:sym<X> ( --> List_infix)
##          { <sym> }

sub infix__S_380X__PEEK { $_[0]->_AUTOLEXpeek('infix__S_380X',$retree) }
sub infix__S_380X {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(X);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_380X",  map { STD::List_infix->coerce($_) } 
$C->_PATTERN(qr/\GX/)
);
}

## token infix__S_381Z (  :$sym is context<rw> = <Z> --> List_infix)
##      token infix:sym<Z> ( --> List_infix)
##          { <sym> }

sub infix__S_381Z__PEEK { $_[0]->_AUTOLEXpeek('infix__S_381Z',$retree) }
sub infix__S_381Z {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(Z);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_381Z",  map { STD::List_infix->coerce($_) } 
$C->_PATTERN(qr/\GZ/)
);
}

## token infix__S_382minmax (  :$sym is context<rw> = <minmax> --> List_infix)
##      token infix:sym<minmax> ( --> List_infix)
##          { <sym> }

sub infix__S_382minmax__PEEK { $_[0]->_AUTOLEXpeek('infix__S_382minmax',$retree) }
sub infix__S_382minmax {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(minmax);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_382minmax",  map { STD::List_infix->coerce($_) } 
$C->_PATTERN(qr/\Gminmax/)
);
}

## token infix__S_383DotDotDot (  :$sym is context<rw> = <...> --> List_infix)
##      token infix:sym<...> ( --> List_infix)
##          { <sym> }

sub infix__S_383DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_383DotDotDot',$retree) }
sub infix__S_383DotDotDot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(...);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_383DotDotDot",  map { STD::List_infix->coerce($_) } 
$C->_PATTERN(qr/\G\.\.\./)
);
}

## token term__S_384DotDotDot (  :$sym is context<rw> = <...> --> List_prefix)
##      token term:sym<...> ( --> List_prefix)
##          { <sym> <args>? }

sub term__S_384DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('term__S_384DotDotDot',$retree) }
sub term__S_384DotDotDot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(...);


my $C = $self;
my $S = $C->{_pos};
$C->{'args'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_384DotDotDot",  map { STD::List_prefix->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\.\.\./))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
});
}
else {
();
}
}
);
}

## token term__S_385QuestionQuestionQuestion (  :$sym is context<rw> = <???> --> List_prefix)
##      token term:sym<???> ( --> List_prefix)
##          { <sym> <args>? }

sub term__S_385QuestionQuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('term__S_385QuestionQuestionQuestion',$retree) }
sub term__S_385QuestionQuestionQuestion {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(???);


my $C = $self;
my $S = $C->{_pos};
$C->{'args'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_385QuestionQuestionQuestion",  map { STD::List_prefix->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?\?\?/))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
});
}
else {
();
}
}
);
}

## token term__S_386BangBangBang (  :$sym is context<rw> = <!!!> --> List_prefix)
##      token term:sym<!!!> ( --> List_prefix)
##          { <sym> <args>? }

sub term__S_386BangBangBang__PEEK { $_[0]->_AUTOLEXpeek('term__S_386BangBangBang',$retree) }
sub term__S_386BangBangBang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!!!);


my $C = $self;
my $S = $C->{_pos};
$C->{'args'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_386BangBangBang",  map { STD::List_prefix->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\!\!/))) {
$C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
});
}
else {
();
}
}
);
}

## token term__S_387sigil (  :$sym is context<rw> = 'sigil' --> List_prefix)
##      token term:sigil ( --> List_prefix)
##      {
##          <sigil> <?before \s> <arglist>
##          { $<sym> = $<sigil>.item; }
##      }

sub term__S_387sigil__PEEK { $_[0]->_AUTOLEXpeek('term__S_387sigil',$retree) }
sub term__S_387sigil {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigil';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_387sigil",  map { STD::List_prefix->coerce($_) } 
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
}))) {
scalar(do {
my $M = $C;  $M->{sym} = $M->{sigil}->item; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

# token term:typecast ( --> List_prefix)
#     { <typename> <?spacey> <arglist> { $<sym> = $<typename>.item; } }

# force identifier(), identifier.(), etc. to be a function call always
## token term__S_388identifier (  :$sym is context<rw> = 'identifier' --> Term )
##      token term:identifier ( --> Term )
##      {
##          :my $t;
##          <identifier> <?before ['.'?'(']?>
##          { $t = $<identifier>.text; }
##          <args( $.is_type($t) )>
##          {{
##              %ROUTINES{$t} ~= $.lineof($.pos) ~ ' ' unless $.is_routine($t);
##          }}
##      }

sub term__S_388identifier__PEEK { $_[0]->_AUTOLEXpeek('term__S_388identifier',$retree) }
sub term__S_388identifier {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'identifier';
my $t;


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_388identifier",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('.')
}))) {
$C->_EXACT('(');
}
else {
();
}
}
})
})
}))) {
do {
if (my ($C) = (scalar(do {
my $M = $C;  $t = $M->{identifier}->text; ;
}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args( $C->is_type($t) )
}))) {
scalar(do {

$ROUTINES{$t} .= $C->lineof($C->{_pos}) . ' ' unless $C->is_routine($t);

}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

## token term__S_389opfunc (  :$sym is context<rw> = 'opfunc' --> Term )
##      token term:opfunc ( --> Term )
##      {
##          <category> <colonpair>+ <args>
##      }

sub term__S_389opfunc__PEEK { $_[0]->_AUTOLEXpeek('term__S_389opfunc',$retree) }
sub term__S_389opfunc {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'opfunc';


my $C = $self;
my $S = $C->{_pos};
$C->{'colonpair'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_389opfunc",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_SUBSUMEr(['category'], sub {
my $C = shift;
$C->category
}))) {
do {
if (my ($C) = ($C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
});
}
else {
();
}
};
}
else {
();
}
}
);
}

## token args ($istype = 0)
##      token args ($istype = 0) {
##          :my $listopish = 0;
##          :my $GOAL is context = '';
##          [
##          | :dba('argument list') '.(' ~ ')' <semilist> {*}             #= func args
##          | :dba('argument list') '(' ~ ')' <semilist> {*}              #= func args
##          | :dba('argument list') <.unsp> '.'? '(' ~ ')' <semilist> {*} #= func args
##          | {} [<?before \s> <!{ $istype }> <.ws> <!infixstopper> <listopargs=arglist> { $listopish = 1 }]?
##          ]
##      
##          :dba('extra arglist after (...):')
##          [
##          || <?{ $listopish }>
##          || ':' <?before \s> <listopargs=arglist>    # either switch to listopiness
##          || {{ $<O> = {}; }}   # or allow adverbs (XXX needs hoisting?)
##          ]
##      }

sub args__PEEK { $_[0]->_AUTOLEXpeek('args',$retree) }
sub args {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my $istype = shift() // 0;
my $listopish = 0;
local $GOAL =  '';


my $C = $self;
my $S = $C->{_pos};
$C->{'listopargs'} = [];

$self->_MATCHIFY($S, "args", 
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
$listopish 
})
})} 
or
eval { push @gather, Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['listopargs'], sub {
my $C = shift;
$C->arglist
})
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))
}, $C->_EXACT(':'))} 
or
eval { push @gather, scalar(do {
my $M = $C;  $M->{O} = {}; ;
}, $C)} or do { die $@ if $@ };
@gather;
}
})
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'args_01') {
$C->deb("Fate passed to args_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'args_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("args_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'args_func_args')
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'argument list')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('.('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'args_func_args')
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'argument list')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_REDUCE($S, 'args_func_args')
}, $C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'argument list')} or do { die $@ if $@ };
@gather;
}
}))
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
}, $C->_OPTr(sub { my $C=shift;
$C->_EXACT('.')
}))
}, $C->unsp)
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
$listopish = 1 
}, $C)
},     $C->_SUBSUME(['listopargs'], sub {
my $C = shift;
$C->arglist
}))
}, $C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))
}, $C->ws)
}, $C->_NOTBEFORE( sub { my $C=shift;
(($C) x !!do {
$istype 
})
}))
}, $C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))
})
})
}, scalar(do {

}, $C))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
);
}

# names containing :: may or may not be function calls
# bare identifier without parens also handled here if no other rule parses it
## token term__S_390name (  :$sym is context<rw> = 'name' --> Term)
##      token term:name ( --> Term)
##      {
##          <longname>
##          [
##          ||  <?{
##                  $.is_type($<longname>.text) or substr($<longname>.text,0,2) eq '::'
##              }>
##              # parametric type?
##              <.unsp>? [ <?before '['> <postcircumfix> ]?
##              :dba('type parameter')
##              [
##                  '::'
##                  <?before [ '' | '<' | '{' | '<<' ] > <postcircumfix>
##                  {*}                                                 #= packagevar 
##              ]?
##              {*}                                                     #= typename
##      
##          # unrecognized names are assumed to be post-declared listops.
##          || <args>?
##          ]
##      }

sub term__S_390name__PEEK { $_[0]->_AUTOLEXpeek('term__S_390name',$retree) }
sub term__S_390name {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'name';


my $C = $self;
my $S = $C->{_pos};
$C->{'args'} = [];
$C->{'postcircumfix'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "term__S_390name",  map { STD::Term->coerce($_) } 
do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, do {
if (my ($C) = ($C->before( sub { my $C=shift;
(($C) x !!do {
my $M = $C; 
$C->is_type($M->{longname}->text) or substr($M->{longname}->text,0,2) eq '::'
;
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->unsp
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('[')
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
});
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('::'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'term__S_390name_06') {
$C->deb("Fate passed to term__S_390name_06: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'term__S_390name_06', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("term__S_390name_06 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('')
},
sub { my $C=shift;
$C->_EXACT('<')
},
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_EXACT('<<')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
$C->_REDUCE($S, 'term__S_390name_packagevar_');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_REDUCE($S, 'term__S_390name_typename');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}} 
or
eval { push @gather, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
})} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
}
);
}

## loose and
## token infix__S_391and (  :$sym is context<rw> = <and> --> Loose_and)
##      token infix:sym<and> ( --> Loose_and)
##          { <sym> }

sub infix__S_391and__PEEK { $_[0]->_AUTOLEXpeek('infix__S_391and',$retree) }
sub infix__S_391and {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(and);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_391and",  map { STD::Loose_and->coerce($_) } 
$C->_PATTERN(qr/\Gand/)
);
}

## token infix__S_392andthen (  :$sym is context<rw> = <andthen> --> Loose_and)
##      token infix:sym<andthen> ( --> Loose_and)
##          { <sym> }

sub infix__S_392andthen__PEEK { $_[0]->_AUTOLEXpeek('infix__S_392andthen',$retree) }
sub infix__S_392andthen {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(andthen);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_392andthen",  map { STD::Loose_and->coerce($_) } 
$C->_PATTERN(qr/\Gandthen/)
);
}

## token infix__S_393andthen (  :$sym is context<rw> = <andthen> --> Loose_and)
##      token infix:sym<andthen> ( --> Loose_and)
##          { <sym> }

sub infix__S_393andthen__PEEK { $_[0]->_AUTOLEXpeek('infix__S_393andthen',$retree) }
sub infix__S_393andthen {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(andthen);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_393andthen",  map { STD::Loose_and->coerce($_) } 
$C->_PATTERN(qr/\Gandthen/)
);
}

## loose or
## token infix__S_394or (  :$sym is context<rw> = <or> --> Loose_or)
##      token infix:sym<or> ( --> Loose_or)
##          { <sym> }

sub infix__S_394or__PEEK { $_[0]->_AUTOLEXpeek('infix__S_394or',$retree) }
sub infix__S_394or {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(or);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_394or",  map { STD::Loose_or->coerce($_) } 
$C->_PATTERN(qr/\Gor/)
);
}

## token infix__S_395orelse (  :$sym is context<rw> = <orelse> --> Loose_or)
##      token infix:sym<orelse> ( --> Loose_or)
##          { <sym> }

sub infix__S_395orelse__PEEK { $_[0]->_AUTOLEXpeek('infix__S_395orelse',$retree) }
sub infix__S_395orelse {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(orelse);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_395orelse",  map { STD::Loose_or->coerce($_) } 
$C->_PATTERN(qr/\Gorelse/)
);
}

## token infix__S_396xor (  :$sym is context<rw> = <xor> --> Loose_or)
##      token infix:sym<xor> ( --> Loose_or)
##          { <sym> }

sub infix__S_396xor__PEEK { $_[0]->_AUTOLEXpeek('infix__S_396xor',$retree) }
sub infix__S_396xor {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(xor);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_396xor",  map { STD::Loose_or->coerce($_) } 
$C->_PATTERN(qr/\Gxor/)
);
}

## token infix__S_397orelse (  :$sym is context<rw> = <orelse> --> Loose_or)
##      token infix:sym<orelse> ( --> Loose_or)
##           { <sym> }

sub infix__S_397orelse__PEEK { $_[0]->_AUTOLEXpeek('infix__S_397orelse',$retree) }
sub infix__S_397orelse {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(orelse);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_397orelse",  map { STD::Loose_or->coerce($_) } 
$C->_PATTERN(qr/\Gorelse/)
);
}

## token infix__S_398Semi (  :$sym is context<rw> = <;> --> Sequencer)
##      token infix:sym<;> ( --> Sequencer)
##          { <sym> }

sub infix__S_398Semi__PEEK { $_[0]->_AUTOLEXpeek('infix__S_398Semi',$retree) }
sub infix__S_398Semi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(;);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_398Semi",  map { STD::Sequencer->coerce($_) } 
$C->_PATTERN(qr/\G\;/)
);
}

## token infix__S_399LtEqualEqual (  :$sym is context<rw> =  <==  --> Sequencer)
##      token infix:sym <==  ( --> Sequencer)
##          { <sym> }

sub infix__S_399LtEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_399LtEqualEqual',$retree) }
sub infix__S_399LtEqualEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<=='];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_399LtEqualEqual",  map { STD::Sequencer->coerce($_) } 
$C->_PATTERN(qr/\G\<\=\=/)
);
}

## token infix__S_400EqualEqualGt (  :$sym is context<rw> =  ==>  --> Sequencer)
##      token infix:sym ==>  ( --> Sequencer)
##          { <sym> {*} }

sub infix__S_400EqualEqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_400EqualEqualGt',$retree) }
sub infix__S_400EqualEqualGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['==>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_400EqualEqualGt",  map { STD::Sequencer->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\=\>/))) {
$C->_REDUCE($S, 'infix__S_400EqualEqualGt');
}
else {
();
}
}
);
}              #'

## token infix__S_401LtLtEqualEqual (  :$sym is context<rw> =  <<==  --> Sequencer)
##      token infix:sym <<==  ( --> Sequencer)
##          { <sym> }

sub infix__S_401LtLtEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_401LtLtEqualEqual',$retree) }
sub infix__S_401LtLtEqualEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<=='];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_401LtLtEqualEqual",  map { STD::Sequencer->coerce($_) } 
$C->_PATTERN(qr/\G\<\<\=\=/)
);
}

## token infix__S_402EqualEqualGtGt (  :$sym is context<rw> =  ==>>  --> Sequencer)
##      token infix:sym ==>>  ( --> Sequencer)
##          { <sym> {*} }

sub infix__S_402EqualEqualGtGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_402EqualEqualGtGt',$retree) }
sub infix__S_402EqualEqualGtGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['==>>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "infix__S_402EqualEqualGtGt",  map { STD::Sequencer->coerce($_) } 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=\=\>\>/))) {
$C->_REDUCE($S, 'infix__S_402EqualEqualGtGt');
}
else {
();
}
}
);
}              #'

## expression terminator
# Note: must always be called as <?terminator> or <?before ...<terminator>...>

## token terminator__S_403Semi (  :$sym is context<rw> = <;> --> Terminator)
##      token terminator:sym<;> ( --> Terminator)
##          { ';' }

sub terminator__S_403Semi__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_403Semi',$retree) }
sub terminator__S_403Semi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(;);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_403Semi",  map { STD::Terminator->coerce($_) } 
$C->_EXACT(';')
);
}

## token terminator__S_404if (  :$sym is context<rw> = <if> --> Terminator)
##      token terminator:sym<if> ( --> Terminator)
##          { 'if'  }

sub terminator__S_404if__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_404if',$retree) }
sub terminator__S_404if {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(if);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_404if",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('if'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
);
}

## token terminator__S_405unless (  :$sym is context<rw> = <unless> --> Terminator)
##      token terminator:sym<unless> ( --> Terminator)
##          { 'unless'  }

sub terminator__S_405unless__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_405unless',$retree) }
sub terminator__S_405unless {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(unless);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_405unless",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('unless'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
);
}

## token terminator__S_406while (  :$sym is context<rw> = <while> --> Terminator)
##      token terminator:sym<while> ( --> Terminator)
##          { 'while'  }

sub terminator__S_406while__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_406while',$retree) }
sub terminator__S_406while {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(while);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_406while",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('while'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
);
}

## token terminator__S_407until (  :$sym is context<rw> = <until> --> Terminator)
##      token terminator:sym<until> ( --> Terminator)
##          { 'until'  }

sub terminator__S_407until__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_407until',$retree) }
sub terminator__S_407until {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(until);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_407until",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('until'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
);
}

## token terminator__S_408for (  :$sym is context<rw> = <for> --> Terminator)
##      token terminator:sym<for> ( --> Terminator)
##          { 'for'  }

sub terminator__S_408for__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_408for',$retree) }
sub terminator__S_408for {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(for);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_408for",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('for'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
);
}

## token terminator__S_409given (  :$sym is context<rw> = <given> --> Terminator)
##      token terminator:sym<given> ( --> Terminator)
##          { 'given'  }

sub terminator__S_409given__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_409given',$retree) }
sub terminator__S_409given {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(given);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_409given",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('given'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
);
}

## token terminator__S_410when (  :$sym is context<rw> = <when> --> Terminator)
##      token terminator:sym<when> ( --> Terminator)
##          { 'when'  }

sub terminator__S_410when__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_410when',$retree) }
sub terminator__S_410when {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(when);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_410when",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('when'))) {
$C->_PATTERN(qr/\G\b/);
}
else {
();
}
}
);
}

## token terminator__S_411MinusMinusGt (  :$sym is context<rw> =  -->  --> Terminator)
##      token terminator:sym -->  ( --> Terminator)
##          { '-->' {*} }

sub terminator__S_411MinusMinusGt__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_411MinusMinusGt',$retree) }
sub terminator__S_411MinusMinusGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['-->'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_411MinusMinusGt",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('-->'))) {
$C->_REDUCE($S, 'terminator__S_411MinusMinusGt');
}
else {
();
}
}
);
}              #'

## token terminator__S_412Thesis (  :$sym is context<rw> = <)> --> Terminator)
##      token terminator:sym<)> ( --> Terminator)
##          { <sym> }

sub terminator__S_412Thesis__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_412Thesis',$retree) }
sub terminator__S_412Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[)];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_412Thesis",  map { STD::Terminator->coerce($_) } 
$C->_PATTERN(qr/\G\)/)
);
}

## token terminator__S_413Ket (  :$sym is context<rw> = <]> --> Terminator)
##      token terminator:sym<]> ( --> Terminator)
##          { ']' }

sub terminator__S_413Ket__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_413Ket',$retree) }
sub terminator__S_413Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(]);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_413Ket",  map { STD::Terminator->coerce($_) } 
$C->_EXACT(']')
);
}

## token terminator__S_414Ly (  :$sym is context<rw> = <}> --> Terminator)
##      token terminator:sym<}> ( --> Terminator)
##          { '}' }

sub terminator__S_414Ly__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_414Ly',$retree) }
sub terminator__S_414Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(});


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_414Ly",  map { STD::Terminator->coerce($_) } 
$C->_EXACT('}')
);
}

## token terminator__S_415BangBang (  :$sym is context<rw> = <!!> --> Terminator)
##      token terminator:sym<!!> ( --> Terminator)
##          { '!!' <?{ $+GOAL eq '!!' }> }

sub terminator__S_415BangBang__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_415BangBang',$retree) }
sub terminator__S_415BangBang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "terminator__S_415BangBang",  map { STD::Terminator->coerce($_) } 
do {
if (my ($C) = ($C->_EXACT('!!'))) {
$C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL eq '!!' 
})
});
}
else {
();
}
}
);
}

## regex infixstopper
##      regex infixstopper {
##          :dba('infix stopper')
##          [
##          | <?before <stopper> >
##          | <?before '!!' > <?{ $+GOAL eq '!!' }>
##          | <?before '{' | <lambda> > <?{ ($+GOAL eq '{' or $+GOAL eq 'endargs') and @+MEMOS[$.pos]<ws> }>
##          | <?{ $+GOAL eq 'endargs' and @+MEMOS[$.pos]<endargs> }>
##          ]
##      }

sub infixstopper__PEEK { $_[0]->_AUTOLEXpeek('infixstopper',$retree) }
sub infixstopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "infixstopper", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infixstopper_01') {
$C->deb("Fate passed to infixstopper_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infixstopper_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixstopper_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_SUBSUME(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL eq '!!' 
})
})
}, $C->before(sub { my $C=shift;
$C->_EXACT('!!')
}))
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->before( sub { my $C=shift;
(($C) x !!do {
($::GOAL eq '{' or $::GOAL eq 'endargs') and $MEMOS[$C->{_pos}]{'ws'} 
})
})
}, $C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'infixstopper_04') {
$C->deb("Fate passed to infixstopper_04: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'infixstopper_04', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("infixstopper_04 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('{')
},
sub { my $C=shift;
$C->_SUBSUME(['lambda'], sub {
my $C = shift;
$C->lambda
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
(($C) x !!do {
$::GOAL eq 'endargs' and $MEMOS[$C->{_pos}]{'endargs'} 
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# overridden in subgrammars
## token stopper
##      token stopper { <!> }

sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper',$retree) }
sub stopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "stopper", 
$C->_NOTBEFORE( sub { my $C=shift;
$C
})
);
}

# hopefully we can include these tokens in any outer LTM matcher
## regex stdstopper
##      regex stdstopper {
##          :my @stub = return self if @+MEMOS[self.pos]<endstmt> :exists;
##          :dba('standard stopper')
##          [
##          | <?terminator>
##          | <?unitstopper>
##          | $					# unlikely, check last (normal LTM behavior)
##          ]
##          { @+MEMOS[$.pos]<endstmt> ||= 1; }
##      }

sub stdstopper__PEEK { $_[0]->_AUTOLEXpeek('stdstopper',$retree) }
sub stdstopper {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my @stub = return $self if exists $MEMOS[$self->{_pos}]{'endstmt'};


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "stdstopper", 
Cursor::lazymap(sub { my $C=$_[0];
scalar(do {
$MEMOS[$C->{_pos}]{'endstmt'} ||= 1; 
}, $C)
}, $C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'stdstopper_01') {
$C->deb("Fate passed to stdstopper_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD', 'stdstopper_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("stdstopper_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->terminator
})
},
sub { my $C=shift;
$C->before( sub { my $C=shift;
$C->unitstopper
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))
);
}

# A fairly complete operator precedence parser

## method EXPR ($preclvl)
sub EXPR {
my $self = shift;
my $preclvl = shift;


local $CTX = $self->callm if $::DEBUG & DEBUG::trace_call;
if ($self->peek) {
return $self->_AUTOLEXpeek('EXPR', $retree);
}
my $preclim = $preclvl ? $preclvl->{'prec'} // $LOOSEST : $LOOSEST;
local $inquote =  0;
my @termstack;
my @opstack;
my $termish = 'termish';

push @opstack, { 'O' => \%terminator, 'sym' => '' };         # (just a sentinel value)

my $here = $self;
my $S = $here->{_pos};
$self->deb("In EXPR, at $S") if $::DEBUG & DEBUG::EXPR;

my $reduce = sub {
$self->deb("entering reduce, termstack == ", 0+@termstack, " opstack == ", 0+@opstack) if $::DEBUG & DEBUG::EXPR;
my $op = pop @opstack;
my $sym = $op->{sym};
do { my $_ = $op->{O}{assoc} // 'unary'; if ((0)) {}
elsif ($_ eq 'chain') {
$self->deb("reducing chain") if $::DEBUG & DEBUG::EXPR;
my @chain;
push @chain, pop(@termstack);
push @chain, $op;
while (@opstack) {
last if $op->{O}{prec} ne $opstack[-1]{'O'}{'prec'};
push @chain, pop(@termstack);
push @chain, pop(@opstack);
}
push @chain, pop(@termstack);
@chain = reverse @chain if @chain > 1;
my $startpos = $chain[0]->{_pos};
my $nop = $op->cursor_fresh();
$nop->{chain} = [@chain];
$nop->{_arity} = 'CHAIN';
push @termstack, $nop->_REDUCE($startpos, 'EXPR');
}
elsif ($_ eq 'list') {
$self->deb("reducing list") if $::DEBUG & DEBUG::EXPR;
my @list;
my @delims = $op;
push @list, pop(@termstack);
while (@opstack) {
$self->deb($sym . " vs " . $opstack[-1]{'sym'}) if $::DEBUG & DEBUG::EXPR;
last if $sym ne $opstack[-1]{'sym'};
if (@termstack and defined $termstack[0]) {
push @list, pop(@termstack);
}
else {
$self->worry("Missing term in " . $sym . " list");
}
push @delims, pop(@opstack);
}
if (@termstack and defined $termstack[0]) {
push @list, pop(@termstack);
}
elsif ($sym ne ',') {
$self->worry("Missing final term in '" . $sym . "' list");
}
@list = reverse @list if @list > 1;
my $startpos = $list[0]->{_pos};
@delims = reverse @delims if @delims > 1;
my $nop = $op->cursor_fresh();
$nop->{sym} = $sym;
$nop->{O} = $op->{O};
$nop->{list} = [@list];
$nop->{delims} = [@delims];
$nop->{_arity} = 'LIST';
push @termstack, $nop->_REDUCE($startpos, 'EXPR');
}
elsif ($_ eq 'unary') {
$self->deb("reducing") if $::DEBUG & DEBUG::EXPR;
my @list;
$self->deb("Termstack size: ", 0+@termstack) if $::DEBUG & DEBUG::EXPR;

$self->deb($op->dump) if $::DEBUG & DEBUG::EXPR;
$op->{arg} = (pop @termstack);
if (($op->{arg}{_from} < $op->{_from})) {
$op->{_from} = $op->{arg}{_from};
}
if (($op->{arg}{_pos} > $op->{_pos})) {
$op->{_pos} = $op->{arg}{_pos};
}
$op->{_arity} = 'UNARY';
push @termstack, $op->_REDUCE($op->{_from}, 'EXPR');
}
else {
$self->deb("reducing") if $::DEBUG & DEBUG::EXPR;
my @list;
$self->deb("Termstack size: ", 0+@termstack) if $::DEBUG & DEBUG::EXPR;

$op->{right} = (pop @termstack);
$op->{left} = (pop @termstack);
$op->{_from} = $op->{left}{_from};
$op->{_pos} = $op->{right}{_pos};
$op->{_arity} = 'BINARY';
$self->deb($op->dump) if $::DEBUG & DEBUG::EXPR;
push @termstack, $op->_REDUCE($op->{_from}, 'EXPR');
}
};
};

TERM:
for (;;) {
$self->deb("In loop, at ", $here->{_pos}) if $::DEBUG & DEBUG::EXPR;
my $oldpos = $here->{_pos};
$here = $here->cursor_fresh();
my @t = $here->$termish;

if (not @t or not $here = $t[0] or ($here->{_pos} == $oldpos and $termish eq 'termish')) {
return ();
# $here->panic("Failed to parse a required term");
}
$termish = 'termish';

# interleave prefix and postfix, pretend they're infixish
my $M = $here;

# note that we push loose stuff onto opstack before tight stuff
my @pre;
my $tmp;
@pre = @$tmp if $tmp = ( delete $M->{PRE} );
my @post;
@post = reverse @$tmp if $tmp = ( delete $M->{POST} );
while (@pre and @post) {
if ($post[0]{'O'}{'prec'} le $pre[0]{'O'}{'prec'}) {
push @opstack, shift @post;
}
else {
push @opstack, shift @pre;
}
}
push @opstack, @pre,@post;

push @termstack, $here;
$self->deb("after push: " . (0+@termstack)) if $::DEBUG & DEBUG::EXPR;

for (;;) {     # while we see adverbs
$oldpos = $here->{_pos};
last TERM if ($MEMOS[$oldpos]{'endstmt'} // 0) == 2;
$here = $here->cursor_fresh->ws;
my @infix = $here->cursor_fresh->infixish();
last TERM unless @infix;
my $infix = $infix[0];
last TERM unless $infix->{_pos} > $oldpos;

if (not $infix->{sym}) {
die $infix->dump if $::DEBUG & DEBUG::EXPR;
}

my $inO = $infix->{O};
my $inprec = $inO->{prec};
if (not defined $inprec) {
$self->deb("No prec given in infix!") if $::DEBUG & DEBUG::EXPR;
die $infix->dump if $::DEBUG & DEBUG::EXPR;
$inprec = $terminator{prec};
}

last TERM unless $inprec gt $preclim;

$here = $infix->cursor_fresh->ws();

# substitute precedence for listops
$inO->{prec} = $inO->{sub} if $inO->{sub};

# Does new infix (or terminator) force any reductions?
while ($opstack[-1]{'O'}{'prec'} gt $inprec) {
$reduce->();
}

# Not much point in reducing the sentinels...
last if $inprec lt $LOOSEST;

# Equal precedence, so use associativity to decide.
if ($opstack[-1]{'O'}{'prec'} eq $inprec) {
do { my $_ = $inO->{assoc}; if ((0)) {}
elsif ($_ eq 'non') { $here->panic("\"$infix\" is not associative") }
elsif ($_ eq 'left') { $reduce->() }   # reduce immediately
elsif ($_ eq 'right') { }            # just shift
elsif ($_ eq 'chain') { }            # just shift
elsif ($_ eq 'list') {              # if op differs reduce else shift
$reduce->() if $infix->{sym} ne $opstack[-1]{'sym'};
}
else { $here->panic("Unknown associativity \"$_\" for \"$infix\"") }
};
}
if ($infix->{fake}) {
my $adverbs = $termstack[-1]{'ADV'} ||= [];
push @$adverbs, $infix->{colonpair};
next;  # not really an infix, so keep trying
}
else {
$termish = $inO->{nextterm} if $inO->{nextterm};
push @opstack, $infix;
last;
}
}
}
$reduce->() while 0+@opstack > 1;
if (@termstack) {
0+@termstack == 1 or $here->panic("Internal operator parser error, termstack == " . (+@termstack));
$termstack[0]{'_from'} = $self->{_pos};
$termstack[0]{'_pos'} = $here->{_pos};
}
$self->_MATCHIFYr($S, "EXPR", @termstack);
}

#################################################
## Regex
#################################################

{ package STD::Regex;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));
sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'Perl5' or $k eq 'P5') {
my $P5 = $v;  $self->cursor_fresh( 'STD::Q' )->mixin( 'STD::Q::q' )->mixin( 'STD::Q::p5' ) }
elsif ($k eq 'overlap' or $k eq 'ov') {
my $ov = $v;  $self }
elsif ($k eq 'exhaustive' or $k eq 'ex') {
my $ex = $v;  $self }
elsif ($k eq 'continue' or $k eq 'c') {
my $c = $v;  $self }
elsif ($k eq 'pos' or $k eq 'p') {
my $p = $v;  $self }
elsif ($k eq 'sigspace' or $k eq 's') {
my $s = $v;  $self }
elsif ($k eq 'ratchet' or $k eq 'r') {
my $r = $v;  $self }
elsif ($k eq 'global' or $k eq 'g') {
my $g = $v;  $self }
elsif ($k eq 'ignorecase' or $k eq 'i') {
my $i = $v;  $self }
elsif ($k eq 'ignoreaccent' or $k eq 'a') {
my $a = $v;  $self }
elsif ($k eq 'samecase' or $k eq 'ii') {
my $ii = $v;  $self }
elsif ($k eq 'sameaccent' or $k eq 'aa') {
my $aa = $v;  $self }
elsif ($k eq 'nth') {
my $nth = $v;  $self }
elsif ($k eq 'st' or $k eq 'nd') {
my $nd = $v;  $self }
elsif ($k eq 'rd' or $k eq 'th') {
my $th = $v;  $self }
elsif ($k eq 'x') {
my $x = $v;  $self }
elsif ($k eq 'bytes') {
my $bytes = $v;  $self }
elsif ($k eq 'codes') {
my $codes = $v;  $self }
elsif ($k eq 'graphs') {
my $graphs = $v;  $self }
elsif ($k eq 'chars') {
my $chars = $v;  $self }
elsif ($k eq 'rw') {
my $rw = $v;  $self->panic(":rw not implemented") }
elsif ($k eq 'keepall') {
my $keepall = $v;  $self->panic(":keepall not implemented") }
elsif ($k eq 'panic') {
my $panic = $v;  $self->panic(":panic not implemented") }
else { die 'NOMATCH' }
} # end tweaks

##     token category__S_416metachar (:$sym is context<rw> = 'metachar')
##          token category:metachar { <sym> }

sub category__S_416metachar__PEEK { $_[0]->_AUTOLEXpeek('category__S_416metachar',$retree) }
sub category__S_416metachar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'metachar';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_416metachar", 
$C->_PATTERN(qr/\Gmetachar/)
);
}
#proto token metachar { <...> }
sub metachar__PEEK { $_[0]->_AUTOLEXpeek('metachar:*',$retree); }
sub metachar {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'metachar') {
$C->deb("Fate passed to metachar: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'metachar:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "metachar", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_417backslash (:$sym is context<rw> = 'backslash')
##          token category:backslash { <sym> }

sub category__S_417backslash__PEEK { $_[0]->_AUTOLEXpeek('category__S_417backslash',$retree) }
sub category__S_417backslash {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'backslash';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_417backslash", 
$C->_PATTERN(qr/\Gbackslash/)
);
}
#proto token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "backslash", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_418assertion (:$sym is context<rw> = 'assertion')
##          token category:assertion { <sym> }

sub category__S_418assertion__PEEK { $_[0]->_AUTOLEXpeek('category__S_418assertion',$retree) }
sub category__S_418assertion {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'assertion';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_418assertion", 
$C->_PATTERN(qr/\Gassertion/)
);
}
#proto token assertion { <...> }
sub assertion__PEEK { $_[0]->_AUTOLEXpeek('assertion:*',$retree); }
sub assertion {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'assertion') {
$C->deb("Fate passed to assertion: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "assertion", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_419quantifier (:$sym is context<rw> = 'quantifier')
##          token category:quantifier { <sym> }

sub category__S_419quantifier__PEEK { $_[0]->_AUTOLEXpeek('category__S_419quantifier',$retree) }
sub category__S_419quantifier {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quantifier';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_419quantifier", 
$C->_PATTERN(qr/\Gquantifier/)
);
}
#proto token quantifier { <...> }
sub quantifier__PEEK { $_[0]->_AUTOLEXpeek('quantifier:*',$retree); }
sub quantifier {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'quantifier') {
$C->deb("Fate passed to quantifier: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quantifier", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_420mod_internal (:$sym is context<rw> = 'mod_internal')
##          token category:mod_internal { <sym> }

sub category__S_420mod_internal__PEEK { $_[0]->_AUTOLEXpeek('category__S_420mod_internal',$retree) }
sub category__S_420mod_internal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod_internal';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_420mod_internal", 
$C->_PATTERN(qr/\Gmod_internal/)
);
}
#proto token mod_internal { <...> }
sub mod_internal__PEEK { $_[0]->_AUTOLEXpeek('mod_internal:*',$retree); }
sub mod_internal {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'mod_internal') {
$C->deb("Fate passed to mod_internal: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "mod_internal", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


#proto token rxinfix { <...> }
sub rxinfix__PEEK { $_[0]->_AUTOLEXpeek('rxinfix:*',$retree); }
sub rxinfix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'rxinfix') {
$C->deb("Fate passed to rxinfix: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'rxinfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("rxinfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "rxinfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token ws
##          token ws {
##              <?{ $+sigspace }>
##      	|| [ <?before \s | '#'> <nextsame> ]?   # still get all the pod goodness, hopefully
##          }

sub ws__PEEK { '' }
sub ws {
my $self = shift;
my @origargs = @_;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'nextsame'} = [];

$self->_MATCHIFYr($S, "ws", 
do { my @gather;
eval { push @gather, $C->before( sub { my $C=shift;
(($C) x !!do {
$::sigspace 
})
})} 
or
eval { push @gather, $C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'ws_03') {
$C->deb("Fate passed to ws_03: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'ws_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("ws_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_SUBSUMEr(['nextsame'], sub {
my $C = shift;
$self->SUPER::ws(@origargs)
});
}
else {
();
}
}
})
})} or do { die $@ if $@ };
@gather;
}
);
}

##     token sigspace
##          token sigspace {
##      	<?before \s | '#'> [ :lang($.cursor_fresh($+LANG)) <.ws> ]
##          }

sub sigspace__PEEK { $_[0]->_AUTOLEXpeek('sigspace',$retree) }
sub sigspace {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "sigspace", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'sigspace_01') {
$C->deb("Fate passed to sigspace_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'sigspace_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("sigspace_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('#')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->ws
});
}
else {
();
}
}
);
}

# suppress fancy end-of-line checking
##     token codeblock
##          token codeblock {
##              :my $GOAL is context = '}';
##              '{' :: [ :lang($.cursor_fresh($+LANG)) <statementlist> ]
##              [ '}' || <.panic: "Unable to parse statement list; couldn't find right brace"> ]
##          }

sub codeblock__PEEK { $_[0]->_AUTOLEXpeek('codeblock',$retree) }
sub codeblock {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $GOAL =  '}';


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "codeblock", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->panic("Unable to parse statement list; couldn't find right brace")} or do { die $@ if $@ };
@gather;
}
})
}, $C->_BRACKET( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUME(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{'))
);
}

##     rule nibbler
##          rule nibbler {
##              :my $sigspace    is context<rw> = $+sigspace    // 0;
##              :my $ratchet     is context<rw> = $+ratchet     // 0;
##              :my $ignorecase is context<rw> = $+ignorecase // 0;
##              :my $ignoreaccent    is context<rw> = $+ignoreaccent    // 0;
##              [ \s* < || | && & > ]?
##              <EXPR>
##          }

sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler',$retree) }
sub nibbler {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $sigspace =  $::sigspace    // 0;
local $ratchet =  $::ratchet     // 0;
local $ignorecase =  $::ignorecase // 0;
local $ignoreaccent =  $::ignoreaccent    // 0;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "nibbler", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\s)*+)/))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_ARRAY( qw< || | && & > ))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token termish
##          token termish {
##      	<.ws>
##              <quantified_atom>+
##          }

sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish',$retree) }
sub termish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'quantified_atom'} = [];

$self->_MATCHIFYr($S, "termish", 
do {
if (my ($C) = ($C->ws)) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
});
}
else {
();
}
}
);
}
##     token infixish
##          token infixish {
##              <!infixstopper>
##              <!stdstopper>
##              <rxinfix>
##              {
##                  $<O> = $<rxinfix><O>;
##                  $<sym> = $<rxinfix><sym>;
##              }
##          }

sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish',$retree) }
sub infixish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "infixish", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['rxinfix'], sub {
my $C = shift;
$C->rxinfix
}))) {
scalar(do {
my $M = $C; 
$M->{O} = $M->{rxinfix}{O};
$M->{sym} = $M->{rxinfix}{sym};
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token rxinfix__S_421VertVert (  :$sym is context<rw> = <||> --> Tight_or )
##          token rxinfix:sym<||> ( --> Tight_or ) { <sym> }

sub rxinfix__S_421VertVert__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_421VertVert',$retree) }
sub rxinfix__S_421VertVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(||);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_421VertVert",  map { STD::Tight_or->coerce($_) } 
$C->_PATTERN(qr/\G\|\|/)
);
}
##     token rxinfix__S_422AmpAmp (  :$sym is context<rw> = <&&> --> Tight_and )
##          token rxinfix:sym<&&> ( --> Tight_and ) { <sym> }

sub rxinfix__S_422AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_422AmpAmp',$retree) }
sub rxinfix__S_422AmpAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_422AmpAmp",  map { STD::Tight_and->coerce($_) } 
$C->_PATTERN(qr/\G\&\&/)
);
}
##     token rxinfix__S_423Vert (  :$sym is context<rw> = <|> --> Junctive_or )
##          token rxinfix:sym<|> ( --> Junctive_or ) { <sym> }

sub rxinfix__S_423Vert__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_423Vert',$retree) }
sub rxinfix__S_423Vert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_423Vert",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}
##     token rxinfix__S_424Amp (  :$sym is context<rw> = <&> --> Junctive_and )
##          token rxinfix:sym<&> ( --> Junctive_and ) { <sym> }

sub rxinfix__S_424Amp__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_424Amp',$retree) }
sub rxinfix__S_424Amp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_424Amp",  map { STD::Junctive_and->coerce($_) } 
$C->_PATTERN(qr/\G\&/)
);
}
##     token rxinfix__S_425Tilde (  :$sym is context<rw> = <~> --> Additive )
##          token rxinfix:sym<~> ( --> Additive ) { <sym> }

sub rxinfix__S_425Tilde__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_425Tilde',$retree) }
sub rxinfix__S_425Tilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_425Tilde",  map { STD::Additive->coerce($_) } 
$C->_PATTERN(qr/\G\~/)
);
}

##     token quantified_atom
##          token quantified_atom {
##              <!stopper>
##              <!rxinfix>
##              <atom>
##              [ <.ws> <quantifier>
##      #            <?{ $<atom>.max_width }>
##      #                || <.panic: "Can't quantify zero-width atom">
##              ]?
##      	<.ws>
##          }

sub quantified_atom__PEEK { $_[0]->_AUTOLEXpeek('quantified_atom',$retree) }
sub quantified_atom {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'quantifier'} = [];

$self->_MATCHIFYr($S, "quantified_atom", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->rxinfix
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['atom'], sub {
my $C = shift;
$C->atom
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
});
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token atom
##          token atom {
##              :dba('regex atom')
##              [
##              | \w
##              | <metachar> ::
##              | <.panic: "Unrecognized regex metacharacter">
##              ]
##          }

sub atom__PEEK { $_[0]->_AUTOLEXpeek('atom',$retree) }
sub atom {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "atom", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'atom_01') {
$C->deb("Fate passed to atom_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'atom_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("atom_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_COMMITBRANCH()
}, $C->_SUBSUMEr(['metachar'], sub {
my $C = shift;
$C->metachar
}))
},
sub { my $C=shift;
$C->panic("Unrecognized regex metacharacter")
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# sequence stoppers
##     token metachar__S_426Gt (:$sym is context<rw> =  > )
##          token metachar:sym >  { '>'  :: <fail> }

sub metachar__S_426Gt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_426Gt',$retree) }
sub metachar__S_426Gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_426Gt", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('>'))
);
}
##     token metachar__S_427AmpAmp (:$sym is context<rw> = <&&>)
##          token metachar:sym<&&>  { '&&' :: <fail> }

sub metachar__S_427AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_427AmpAmp',$retree) }
sub metachar__S_427AmpAmp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_427AmpAmp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('&&'))
);
}
##     token metachar__S_428Amp (:$sym is context<rw> = <&>)
##          token metachar:sym<&>   { '&'  :: <fail> }

sub metachar__S_428Amp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_428Amp',$retree) }
sub metachar__S_428Amp {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(&);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_428Amp", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('&'))
);
}
##     token metachar__S_429VertVert (:$sym is context<rw> = <||>)
##          token metachar:sym<||>  { '||' :: <fail> }

sub metachar__S_429VertVert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_429VertVert',$retree) }
sub metachar__S_429VertVert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(||);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_429VertVert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('||'))
);
}
##     token metachar__S_430Vert (:$sym is context<rw> = <|>)
##          token metachar:sym<|>   { '|'  :: <fail> }

sub metachar__S_430Vert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_430Vert',$retree) }
sub metachar__S_430Vert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_430Vert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('|'))
);
}
##     token metachar__S_431Ket (:$sym is context<rw> = <]>)
##          token metachar:sym<]>   { ']'  :: <fail> }

sub metachar__S_431Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_431Ket',$retree) }
sub metachar__S_431Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(]);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_431Ket", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT(']'))
);
}
##     token metachar__S_432Thesis (:$sym is context<rw> = <)>)
##          token metachar:sym<)>   { ')'  :: <fail> }

sub metachar__S_432Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_432Thesis',$retree) }
sub metachar__S_432Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[)];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_432Thesis", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT(')'))
);
}

##     token metachar__S_433quant (:$sym is context<rw> = 'quant')
##          token metachar:quant { <quantifier> <.panic: "quantifier quantifies nothing"> }

sub metachar__S_433quant__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_433quant',$retree) }
sub metachar__S_433quant {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quant';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_433quant", 
do {
if (my ($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))) {
$C->panic("quantifier quantifies nothing");
}
else {
();
}
}
);
}

# "normal" metachars

##     token metachar__S_434sigwhite (:$sym is context<rw> = 'sigwhite')
##          token metachar:sigwhite {
##      	<sigspace>
##          }

sub metachar__S_434sigwhite__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_434sigwhite',$retree) }
sub metachar__S_434sigwhite {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'sigwhite';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_434sigwhite", 
$C->_SUBSUMEr(['sigspace'], sub {
my $C = shift;
$C->sigspace
})
);
}

##     token metachar__S_435Cur_Ly (:$sym is context<rw> = <{ }>)
##          token metachar:sym<{ }> {
##              <?before '{'>
##              <codeblock>
##              {{ $/<sym> := <{ }> }}
##          }

sub metachar__S_435Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_435Cur_Ly',$retree) }
sub metachar__S_435Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_435Cur_Ly", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('{')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw({ })] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_436mod (:$sym is context<rw> = 'mod')
##          token metachar:mod {
##              <mod_internal>
##              { $/<sym> := $<mod_internal><sym> }
##          }

sub metachar__S_436mod__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_436mod',$retree) }
sub metachar__S_436mod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_436mod", 
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_internal'], sub {
my $C = shift;
$C->mod_internal
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = $M->{mod_internal}{sym} ;
}, $C);
}
else {
();
}
}
);
}

##     token metachar__S_437Colon (:$sym is context<rw> = <:>)
##          token metachar:sym<:> {
##              <sym>
##          }

sub metachar__S_437Colon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_437Colon',$retree) }
sub metachar__S_437Colon {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_437Colon", 
$C->_PATTERN(qr/\G\:/)
);
}

##     token metachar__S_438ColonColon (:$sym is context<rw> = <::>)
##          token metachar:sym<::> {
##              <sym>
##          }

sub metachar__S_438ColonColon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_438ColonColon',$retree) }
sub metachar__S_438ColonColon {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(::);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_438ColonColon", 
$C->_PATTERN(qr/\G\:\:/)
);
}

##     token metachar__S_439ColonColonColon (:$sym is context<rw> = <:::>)
##          token metachar:sym<:::> {
##              <sym>
##          }

sub metachar__S_439ColonColonColon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_439ColonColonColon',$retree) }
sub metachar__S_439ColonColonColon {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:::);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_439ColonColonColon", 
$C->_PATTERN(qr/\G\:\:\:/)
);
}

##     token metachar__S_440Bra_Ket (:$sym is context<rw> = <[ ]>)
##          token metachar:sym<[ ]> {
##              '[' {} [:lang(self.unbalanced(']')) <nibbler>]
##              [ ']' || <.panic: "Unable to parse regex; couldn't find right bracket"> ]
##              { $/<sym> := <[ ]> }
##          }

sub metachar__S_440Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_440Bra_Ket',$retree) }
sub metachar__S_440Bra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_440Bra_Ket", 
do {
if (my ($C) = ($C->_EXACT('['))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($self->unbalanced(']'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(']')} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find right bracket")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw([ ])] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_441Paren_Thesis (:$sym is context<rw> = <( )>)
##          token metachar:sym<( )> {
##              '(' {} [:lang(self.unbalanced(')')) <nibbler>]
##              [ ')' || <.panic: "Unable to parse regex; couldn't find right parenthesis"> ]
##              { $/<sym> := <( )> }
##          }

sub metachar__S_441Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_441Paren_Thesis',$retree) }
sub metachar__S_441Paren_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_441Paren_Thesis", 
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->panic("Unable to parse regex; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw[( )]] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_442LtParen (:$sym is context<rw> =  <( )
##          token metachar:sym <(  { '<(' }

sub metachar__S_442LtParen__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_442LtParen',$retree) }
sub metachar__S_442LtParen {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<('];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_442LtParen", 
$C->_EXACT('<(')
);
}
##     token metachar__S_443ThesisGt (:$sym is context<rw> =  )> )
##          token metachar:sym )>  { ')>' }

sub metachar__S_443ThesisGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_443ThesisGt',$retree) }
sub metachar__S_443ThesisGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //[')>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_443ThesisGt", 
$C->_EXACT(')>')
);
}

##     token metachar__S_444LtLt (:$sym is context<rw> =  << )
##          token metachar:sym <<  { '<<' }

sub metachar__S_444LtLt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_444LtLt',$retree) }
sub metachar__S_444LtLt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_444LtLt", 
$C->_EXACT('<<')
);
}
##     token metachar__S_445GtGt (:$sym is context<rw> =  >> )
##          token metachar:sym >>  { '>>' }

sub metachar__S_445GtGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_445GtGt',$retree) }
sub metachar__S_445GtGt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_445GtGt", 
$C->_EXACT('>>')
);
}
##     token metachar__S_446Fre (:$sym is context<rw> = <  >)
##          token metachar:sym<  > { '' }

sub metachar__S_446Fre__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_446Fre',$retree) }
sub metachar__S_446Fre {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(  )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_446Fre", 
$C->_EXACT('')
);
}
##     token metachar__S_447Nch (:$sym is context<rw> = <  >)
##          token metachar:sym<  > { '' }

sub metachar__S_447Nch__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_447Nch',$retree) }
sub metachar__S_447Nch {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(  )];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_447Nch", 
$C->_EXACT('')
);
}

##     token metachar__S_448qw (:$sym is context<rw> = 'qw')
##          token metachar:qw {
##              <?before '<' \s >  # (note required whitespace)
##              <quote>
##          }

sub metachar__S_448qw__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_448qw',$retree) }
sub metachar__S_448qw {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'qw';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_448qw", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('<'))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
}))) {
$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
});
}
else {
();
}
}
);
}

##     token metachar__S_449Lt_Gt (:$sym is context<rw> = < >)
##          token metachar:sym< > {
##              '<' <unsp>? {} <assertion>
##              [ '>' || <.panic: "regex assertion not terminated by angle bracket"> ]
##          }

sub metachar__S_449Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_449Lt_Gt',$retree) }
sub metachar__S_449Lt_Gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<','>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'unsp'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_449Lt_Gt", 
do {
if (my ($C) = ($C->_EXACT('<'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['unsp'], sub {
my $C = shift;
$C->unsp
})
}))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('>')} 
or
eval { push @gather, $C->panic("regex assertion not terminated by angle bracket")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_450Back (:$sym is context<rw> = <\\>)
##          token metachar:sym<\\> { <sym> <backslash> }

sub metachar__S_450Back__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_450Back',$retree) }
sub metachar__S_450Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_450Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['backslash'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}
##     token metachar__S_451Dot (:$sym is context<rw> = <.>)
##          token metachar:sym<.>  { <sym> }

sub metachar__S_451Dot__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_451Dot',$retree) }
sub metachar__S_451Dot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_451Dot", 
$C->_PATTERN(qr/\G\./)
);
}
##     token metachar__S_452CaretCaret (:$sym is context<rw> = <^^>)
##          token metachar:sym<^^> { <sym> }

sub metachar__S_452CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_452CaretCaret',$retree) }
sub metachar__S_452CaretCaret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_452CaretCaret", 
$C->_PATTERN(qr/\G\^\^/)
);
}
##     token metachar__S_453Caret (:$sym is context<rw> = <^>)
##          token metachar:sym<^>  { <sym> }

sub metachar__S_453Caret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_453Caret',$retree) }
sub metachar__S_453Caret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_453Caret", 
$C->_PATTERN(qr/\G\^/)
);
}
##     token metachar__S_454DollarDollar (:$sym is context<rw> = <$$>)
##          token metachar:sym<$$> {
##              <sym>
##              [ (\w+) <obs("\$\$" ~ $0.text ~ " to deref var inside a regex", "\$(\$" ~ $0.text ~ ")")> ]?
##          }

sub metachar__S_454DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_454DollarDollar',$retree) }
sub metachar__S_454DollarDollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($$);


my $C = $self;
my $S = $C->{_pos};
$C->{'0'} = [];
$C->{'obs'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_454DollarDollar", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\$\$/))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\w)++)/)
})}
}))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs("\$\$" . $$C{0}->text . " to deref var inside a regex", "\$(\$" . $$C{0}->text . ")")
});
}
else {
();
}
}
})
});
}
else {
();
}
}
);
}
##     token metachar__S_455Dollar (:$sym is context<rw> = <$>)
##          token metachar:sym<$>  {
##              '$'
##              <?before
##              | \s
##              | '|'
##              | '&'
##              | ')'
##              | ']'
##              | '>'
##              | $
##      	| <stopper>
##              >
##          }

sub metachar__S_455Dollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_455Dollar',$retree) }
sub metachar__S_455Dollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_455Dollar", 
do {
if (my ($C) = ($C->_EXACT('$'))) {
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'metachar__S_455Dollar_01') {
$C->deb("Fate passed to metachar__S_455Dollar_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'metachar__S_455Dollar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar__S_455Dollar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub { my $C=shift;
$C->_EXACT('|')
},
sub { my $C=shift;
$C->_EXACT('&')
},
sub { my $C=shift;
$C->_EXACT(')')
},
sub { my $C=shift;
$C->_EXACT(']')
},
sub { my $C=shift;
$C->_EXACT('>')
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token metachar__S_456Single_Single (:$sym is context<rw> = <' '>)
##          token metachar:sym<' '> { <?before "'"> [:lang($.cursor_fresh($+LANG)) <quote>] }

sub metachar__S_456Single_Single__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_456Single_Single',$retree) }
sub metachar__S_456Single_Single {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(' ')];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_456Single_Single", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G'/)
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
});
}
else {
();
}
}
);
}
##     token metachar__S_457Double_Double (:$sym is context<rw> = <" ">)
##          token metachar:sym<" "> { <?before '"'> [:lang($.cursor_fresh($+LANG)) <quote>] }

sub metachar__S_457Double_Double__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_457Double_Double',$retree) }
sub metachar__S_457Double_Double {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw(" ")];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_457Double_Double", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_EXACT('"')
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
});
}
else {
();
}
}
);
}

##     token metachar__S_458var (:$sym is context<rw> = 'var')
##          token metachar:var {
##              <!before '$$'>
##              <?before <sigil>>
##              [:lang($.cursor_fresh($+LANG)) <variable> <.ws> ]
##              $<binding> = ( <.ws> '=' <.ws> <quantified_atom> )?
##              { $<sym> = $<variable>.item; }
##          }

sub metachar__S_458var__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_458var',$retree) }
sub metachar__S_458var {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'var';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_458var", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('$$')
})
}))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
$C->ws;
}
else {
();
}
}
}))) {
do {
if (my ($C) = (    $C->_OPTr(sub { my $C=shift;
$C->_SUBSUMEr(['binding'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_EXACT('='))) {
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
})}
})
}))) {
scalar(do {
my $M = $C;  $M->{sym} = $M->{variable}->item; ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token backslash__S_459unspace (:$sym is context<rw> = 'unspace')
##          token backslash:unspace { <?before \s> <.SUPER::ws> }

sub backslash__S_459unspace__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_459unspace',$retree) }
sub backslash__S_459unspace {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'unspace';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_459unspace", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) {
$C->SUPER::ws;
}
else {
();
}
}
);
}

##     token backslash__S_4600 (:$sym is context<rw> = <0>)
##          token backslash:sym<0> { '0' <!before <[0..7]> > }

sub backslash__S_4600__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_4600',$retree) }
sub backslash__S_4600 {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(0);


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "backslash__S_4600", 
do {
if (my ($C) = ($C->_EXACT('0'))) {
$C->_NOTBEFORE( sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[0-7]/)
})
});
}
else {
();
}
}
);
}

##     token backslash__S_461A (:$sym is context<rw> = 'A')
##          token backslash:A { <sym> <.obs('\\A as beginning-of-string matcher', '^')> }

sub backslash__S_461A__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_461A',$retree) }
sub backslash__S_461A {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'A';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_461A", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GA/))) {
$C->obs('\\A as beginning-of-string matcher', '^');
}
else {
();
}
}
);
}
##     token backslash__S_462a (:$sym is context<rw> = 'a')
##          token backslash:a { <sym> <.panic: "\\a is allowed only in strings, not regexes"> }

sub backslash__S_462a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_462a',$retree) }
sub backslash__S_462a {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_462a", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Ga/))) {
$C->panic("\\a is allowed only in strings, not regexes");
}
else {
();
}
}
);
}
##     token backslash__S_463b (:$sym is context<rw> = 'b')
##          token backslash:b { :i <sym> }

sub backslash__S_463b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_463b',$retree) }
sub backslash__S_463b {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_463b", 
$C->_PATTERN(qr/\G(?i:b)/)
);
}
##     token backslash__S_464c (:$sym is context<rw> = 'c')
##          token backslash:c { :i <sym>
##              [
##              | <codepoint>
##              | \d+
##              | [ <[ ?.._ ]> || <.panic: "Unrecognized \\c character"> ]
##              ]
##          }

sub backslash__S_464c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_464c',$retree) }
sub backslash__S_464c {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_464c", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:c)/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_464c_01') {
$C->deb("Fate passed to backslash__S_464c_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_464c_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_464c_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['codepoint'], sub {
my $C = shift;
$C->codepoint
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?i:[?-_])/)} 
or
eval { push @gather, $C->panic("Unrecognized \\c character")} or do { die $@ if $@ };
@gather;
}
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token backslash__S_465d (:$sym is context<rw> = 'd')
##          token backslash:d { :i <sym> }

sub backslash__S_465d__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_465d',$retree) }
sub backslash__S_465d {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'd';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_465d", 
$C->_PATTERN(qr/\G(?i:d)/)
);
}
##     token backslash__S_466e (:$sym is context<rw> = 'e')
##          token backslash:e { :i <sym> }

sub backslash__S_466e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_466e',$retree) }
sub backslash__S_466e {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_466e", 
$C->_PATTERN(qr/\G(?i:e)/)
);
}
##     token backslash__S_467f (:$sym is context<rw> = 'f')
##          token backslash:f { :i <sym> }

sub backslash__S_467f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_467f',$retree) }
sub backslash__S_467f {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_467f", 
$C->_PATTERN(qr/\G(?i:f)/)
);
}
##     token backslash__S_468h (:$sym is context<rw> = 'h')
##          token backslash:h { :i <sym> }

sub backslash__S_468h__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_468h',$retree) }
sub backslash__S_468h {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'h';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_468h", 
$C->_PATTERN(qr/\G(?i:h)/)
);
}
##     token backslash__S_469n (:$sym is context<rw> = 'n')
##          token backslash:n { :i <sym> }

sub backslash__S_469n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_469n',$retree) }
sub backslash__S_469n {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'n';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_469n", 
$C->_PATTERN(qr/\G(?i:n)/)
);
}
##     token backslash__S_470o (:$sym is context<rw> = 'o')
##          token backslash:o { :i <sym> [ <octint> | '['<octint>[','<octint>]*']' ] }

sub backslash__S_470o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_470o',$retree) }
sub backslash__S_470o {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'o';


my $C = $self;
my $S = $C->{_pos};
$C->{'octint'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_470o", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:o)/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_470o_01') {
$C->deb("Fate passed to backslash__S_470o_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_470o_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_470o_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:\[)/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:\,)/))) {
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
});
}
else {
();
}
}
})
}))) {
$C->_PATTERN(qr/\G(?i:\])/);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token backslash__S_471Q (:$sym is context<rw> = 'Q')
##          token backslash:Q { <sym> <obs('\\Q as quotemeta', 'quotes or literal variable match')> }

sub backslash__S_471Q__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_471Q',$retree) }
sub backslash__S_471Q {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Q';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_471Q", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GQ/))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('\\Q as quotemeta', 'quotes or literal variable match')
});
}
else {
();
}
}
);
}
##     token backslash__S_472r (:$sym is context<rw> = 'r')
##          token backslash:r { :i <sym> }

sub backslash__S_472r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_472r',$retree) }
sub backslash__S_472r {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'r';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_472r", 
$C->_PATTERN(qr/\G(?i:r)/)
);
}
##     token backslash__S_473s (:$sym is context<rw> = 's')
##          token backslash:s { :i <sym> }

sub backslash__S_473s__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_473s',$retree) }
sub backslash__S_473s {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_473s", 
$C->_PATTERN(qr/\G(?i:s)/)
);
}
##     token backslash__S_474t (:$sym is context<rw> = 't')
##          token backslash:t { :i <sym> }

sub backslash__S_474t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_474t',$retree) }
sub backslash__S_474t {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 't';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_474t", 
$C->_PATTERN(qr/\G(?i:t)/)
);
}
##     token backslash__S_475v (:$sym is context<rw> = 'v')
##          token backslash:v { :i <sym> }

sub backslash__S_475v__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_475v',$retree) }
sub backslash__S_475v {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'v';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_475v", 
$C->_PATTERN(qr/\G(?i:v)/)
);
}
##     token backslash__S_476w (:$sym is context<rw> = 'w')
##          token backslash:w { :i <sym> }

sub backslash__S_476w__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_476w',$retree) }
sub backslash__S_476w {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'w';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_476w", 
$C->_PATTERN(qr/\G(?i:w)/)
);
}
##     token backslash__S_477x (:$sym is context<rw> = 'x')
##          token backslash:x { :i <sym> [ <hexint> | '[' [<.ws><hexint><.ws> ] ** ',' ']' ] }

sub backslash__S_477x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_477x',$retree) }
sub backslash__S_477x {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{_pos};
$C->{'hexint'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_477x", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:x)/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_477x_01') {
$C->deb("Fate passed to backslash__S_477x_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'backslash__S_477x_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_477x_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:\[)/))) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_PATTERN(qr/\G(?i:\,)/)
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_PATTERN(qr/\G(?i:\])/);
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token backslash__S_478z (:$sym is context<rw> = 'z')
##          token backslash:z { <sym> <obs('\\z as end-of-string matcher', '$')> }

sub backslash__S_478z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_478z',$retree) }
sub backslash__S_478z {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'z';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_478z", 
do {
if (my ($C) = ($C->_PATTERN(qr/\Gz/))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('\\z as end-of-string matcher', '$')
});
}
else {
();
}
}
);
}
##     token backslash__S_479Z (:$sym is context<rw> = 'Z')
##          token backslash:Z { <sym> <obs('\\Z as end-of-string matcher', '\\n?$')> }

sub backslash__S_479Z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_479Z',$retree) }
sub backslash__S_479Z {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Z';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_479Z", 
do {
if (my ($C) = ($C->_PATTERN(qr/\GZ/))) {
$C->_SUBSUMEr(['obs'], sub {
my $C = shift;
$C->obs('\\Z as end-of-string matcher', '\\n?$')
});
}
else {
();
}
}
);
}
##     token backslash__S_480misc (:$sym is context<rw> = 'misc')
##          token backslash:misc { $<litchar>=(\W) }

sub backslash__S_480misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_480misc',$retree) }
sub backslash__S_480misc {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_480misc", 
$C->_SUBSUMEr(['litchar'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
})}
})
);
}
##     token backslash__S_481oops (:$sym is context<rw> = 'oops')
##          token backslash:oops { <.panic: "Unrecognized regex backslash sequence"> }

sub backslash__S_481oops__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_481oops',$retree) }
sub backslash__S_481oops {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'oops';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_481oops", 
$C->panic("Unrecognized regex backslash sequence")
);
}

##     token assertion__S_482DotDotDot (:$sym is context<rw> = <...>)
##          token assertion:sym<...> { <sym> }

sub assertion__S_482DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_482DotDotDot',$retree) }
sub assertion__S_482DotDotDot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(...);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_482DotDotDot", 
$C->_PATTERN(qr/\G\.\.\./)
);
}
##     token assertion__S_483QuestionQuestionQuestion (:$sym is context<rw> = <???>)
##          token assertion:sym<???> { <sym> }

sub assertion__S_483QuestionQuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_483QuestionQuestionQuestion',$retree) }
sub assertion__S_483QuestionQuestionQuestion {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(???);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_483QuestionQuestionQuestion", 
$C->_PATTERN(qr/\G\?\?\?/)
);
}
##     token assertion__S_484BangBangBang (:$sym is context<rw> = <!!!>)
##          token assertion:sym<!!!> { <sym> }

sub assertion__S_484BangBangBang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_484BangBangBang',$retree) }
sub assertion__S_484BangBangBang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!!!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_484BangBangBang", 
$C->_PATTERN(qr/\G\!\!\!/)
);
}

##     token assertion__S_485Question (:$sym is context<rw> = <?>)
##          token assertion:sym<?> { <sym> [ <?before '>'> | <assertion> ] }

sub assertion__S_485Question__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_485Question',$retree) }
sub assertion__S_485Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_485Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_485Question_01') {
$C->deb("Fate passed to assertion__S_485Question_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_485Question_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_485Question_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_486Bang (:$sym is context<rw> = <!>)
##          token assertion:sym<!> { <sym> [ <?before '>'> | <assertion> ] }

sub assertion__S_486Bang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_486Bang',$retree) }
sub assertion__S_486Bang {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_486Bang", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_486Bang_01') {
$C->deb("Fate passed to assertion__S_486Bang_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_486Bang_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_486Bang_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_487Star (:$sym is context<rw> = <*>)
##          token assertion:sym<*> { <sym> [ <?before '>'> | <.ws> <nibbler> ] }

sub assertion__S_487Star__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_487Star',$retree) }
sub assertion__S_487Star {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_487Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_487Star_01') {
$C->deb("Fate passed to assertion__S_487Star_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_487Star_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_487Star_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_488Cur_Ly (:$sym is context<rw> = <{ }>)
##          token assertion:sym<{ }> { <codeblock> }

sub assertion__S_488Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_488Cur_Ly',$retree) }
sub assertion__S_488Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_488Cur_Ly", 
$C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
})
);
}

##     token assertion__S_489variable (:$sym is context<rw> = 'variable')
##          token assertion:variable {
##              <?before <sigil>>  # note: semantics must be determined per-sigil
##              [:lang($.cursor_fresh($+LANG).unbalanced('>')) <variable=EXPR(item %LOOSEST)>]
##          }

sub assertion__S_489variable__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_489variable',$retree) }
sub assertion__S_489variable {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'variable';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_489variable", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;    $C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->EXPR(\%LOOSEST)
})
});
}
else {
();
}
}
);
}

##     token assertion__S_490method (:$sym is context<rw> = 'method')
##          token assertion:method {
##              '.' [
##                  | <?before <alpha> > <assertion>
##                  | [ :lang($.cursor_fresh($+LANG).unbalanced('>')) <dottyop> ]
##                  ]
##          }

sub assertion__S_490method__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_490method',$retree) }
sub assertion__S_490method {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'method';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_490method", 
do {
if (my ($C) = ($C->_EXACT('.'))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_490method_01') {
$C->deb("Fate passed to assertion__S_490method_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_490method_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_490method_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->before(sub { my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
});
}
else {
();
}
}
},
sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
})
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_491identifier (:$sym is context<rw> = 'identifier')
##          token assertion:identifier { <identifier> [               # is qq right here?
##                                          | <?before '>' >
##                                          | <.ws> <nibbler>
##                                          | '=' <assertion>
##                                          | ':' <.ws>
##                                              [ :lang($.cursor_fresh($+LANG).unbalanced('>')) <arglist> ]
##                                          | '(' {}
##      					[ :lang($.cursor_fresh($+LANG)) <arglist> ]
##      					[ ')' || <.panic: "Assertion call missing right parenthesis"> ]
##                                          ]?
##          }

sub assertion__S_491identifier__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_491identifier',$retree) }
sub assertion__S_491identifier {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'identifier';


my $C = $self;
my $S = $C->{_pos};
$C->{'arglist'} = [];
$C->{'nibbler'} = [];
$C->{'assertion'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_491identifier", 
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_491identifier_01') {
$C->deb("Fate passed to assertion__S_491identifier_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_491identifier_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_491identifier_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('='))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->panic("Assertion call missing right parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
}
);
}

# stupid special case
##     token assertion__S_492name (:$sym is context<rw> = 'name')
##          token assertion:name { <?before \w*'::('> [ :lang($.cursor_fresh($+LANG).unbalanced('>')) <name> ]
##                                          [
##                                          | <?before '>' >
##                                          | <.ws> <nibbler>
##                                          | '=' <assertion>
##                                          | ':' <.ws>
##                                              [ :lang($.cursor_fresh($+LANG).unbalanced('>')) <arglist> ]
##                                          | '(' {}
##      					[ :lang($.cursor_fresh($+LANG)) <arglist> ]
##      					[ ')' || <.panic: "Assertion call missing right parenthesis"> ]
##                                          ]?
##          }

sub assertion__S_492name__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_492name',$retree) }
sub assertion__S_492name {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'name';


my $C = $self;
my $S = $C->{_pos};
$C->{'arglist'} = [];
$C->{'nibbler'} = [];
$C->{'assertion'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_492name", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)*+)/))) {
$C->_EXACT('::(');
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_492name_03') {
$C->deb("Fate passed to assertion__S_492name_03: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_492name_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_492name_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('='))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
});
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->ws)) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
});
}
else {
();
}
};
}
else {
();
}
}
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->panic("Assertion call missing right parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token assertion__S_493Bra (:$sym is context<rw> = <[>)
##          token assertion:sym<[> { <before '[' > <cclass_elem> ** < + - > }

sub assertion__S_493Bra__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_493Bra',$retree) }
sub assertion__S_493Bra {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q([);


my $C = $self;
my $S = $C->{_pos};
$C->{'cclass_elem'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_493Bra", 
do {
if (my ($C) = ($C->_SUBSUMEr(['before'], sub {
my $C = shift;
$C->before(sub { my $C=shift;
$C->_EXACT('[')
})
}))) {
$C->_REPSEPr(  sub { my $C=shift;
$C->_ARRAY( qw< + - > )
}, sub { my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
});
}
else {
();
}
}
);
}
##     token assertion__S_494Plus (:$sym is context<rw> = <+>)
##          token assertion:sym<+> { <sym> <cclass_elem> ** < + - > }

sub assertion__S_494Plus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_494Plus',$retree) }
sub assertion__S_494Plus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{_pos};
$C->{'cclass_elem'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_494Plus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+/))) {
$C->_REPSEPr(  sub { my $C=shift;
$C->_ARRAY( qw< + - > )
}, sub { my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
});
}
else {
();
}
}
);
}
##     token assertion__S_495Minus (:$sym is context<rw> = <->)
##          token assertion:sym<-> { <sym> <cclass_elem> ** < + - > }

sub assertion__S_495Minus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_495Minus',$retree) }
sub assertion__S_495Minus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(-);


my $C = $self;
my $S = $C->{_pos};
$C->{'cclass_elem'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_495Minus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\-/))) {
$C->_REPSEPr(  sub { my $C=shift;
$C->_ARRAY( qw< + - > )
}, sub { my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
});
}
else {
();
}
}
);
}
##     token assertion__S_496Dot (:$sym is context<rw> = <.>)
##          token assertion:sym<.> { <sym> }

sub assertion__S_496Dot__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_496Dot',$retree) }
sub assertion__S_496Dot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_496Dot", 
$C->_PATTERN(qr/\G\./)
);
}
##     token assertion__S_497Comma (:$sym is context<rw> = <,>)
##          token assertion:sym<,> { <sym> }

sub assertion__S_497Comma__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_497Comma',$retree) }
sub assertion__S_497Comma {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[,];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_497Comma", 
$C->_PATTERN(qr/\G\,/)
);
}
##     token assertion__S_498TildeTilde (:$sym is context<rw> = <~~>)
##          token assertion:sym<~~> { <sym> [ <?before '>'> | \d+ | <desigilname> ] }

sub assertion__S_498TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_498TildeTilde',$retree) }
sub assertion__S_498TildeTilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_498TildeTilde", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\~\~/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_498TildeTilde_01') {
$C->deb("Fate passed to assertion__S_498TildeTilde_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'assertion__S_498TildeTilde_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_498TildeTilde_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT('>')
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token assertion__S_499bogus (:$sym is context<rw> = 'bogus')
##          token assertion:bogus { <.panic: "Unrecognized regex assertion"> }

sub assertion__S_499bogus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_499bogus',$retree) }
sub assertion__S_499bogus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'bogus';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_499bogus", 
$C->panic("Unrecognized regex assertion")
);
}

##     token cclass_elem
##          token cclass_elem {
##      	<.ws>
##              :dba('character class element')
##              [
##              | <name>
##              | <before '['> <quibble($.cursor_fresh( ::STD::Q ).tweak(:q))> # XXX parse as q[] for now
##              ]
##      	<.ws>
##          }

sub cclass_elem__PEEK { $_[0]->_AUTOLEXpeek('cclass_elem',$retree) }
sub cclass_elem {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "cclass_elem", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'cclass_elem_01') {
$C->deb("Fate passed to cclass_elem_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'cclass_elem_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("cclass_elem_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['before'], sub {
my $C = shift;
$C->before(sub { my $C=shift;
$C->_EXACT('[')
})
}))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1))
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_arg
##          token mod_arg { :dba('modifier argument') '(' ~ ')' <semilist> }

sub mod_arg__PEEK { $_[0]->_AUTOLEXpeek('mod_arg',$retree) }
sub mod_arg {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "mod_arg", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->FAILGOAL(')' , 'modifier argument')} or do { die $@ if $@ };
@gather;
}
})
}, $C->_SUBSUME(['semilist'], sub {
my $C = shift;
$C->semilist
}))
}, $C->_COMMITBRANCH(local $::GOAL = ')' ))
}, $C->_EXACT('('))
);
}

##     token mod_internal__S_500Colonmy (:$sym is context<rw> = <:my>)
##          token mod_internal:sym<:my>    { ':' <?before 'my' \s > [:lang($.cursor_fresh($+LANG)) <statement> <eat_terminator> ] }

sub mod_internal__S_500Colonmy__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_500Colonmy',$retree) }
sub mod_internal__S_500Colonmy {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:my);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_500Colonmy", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('my'))) {
$C->_PATTERN(qr/\G\s/);
}
else {
();
}
}
}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
$C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
});
}
else {
();
}
}
});
}
else {
();
}
};
}
else {
();
}
}
);
}

# XXX needs some generalization

##     token mod_internal__S_501Coloni (:$sym is context<rw> = <:i>)
##          token mod_internal:sym<:i>    { $<sym>=[':i'|':ignorecase']  { $+ignorecase = 1 } }

sub mod_internal__S_501Coloni__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_501Coloni',$retree) }
sub mod_internal__S_501Coloni {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:i);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_501Coloni", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_501Coloni_01') {
$C->deb("Fate passed to mod_internal__S_501Coloni_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_501Coloni_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_501Coloni_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':i')
},
sub { my $C=shift;
$C->_EXACT(':ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignorecase = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_502ColonBangi (:$sym is context<rw> = <:!i>)
##          token mod_internal:sym<:!i>   { $<sym>=[':!i'|':!ignorecase']  { $+ignorecase = 0 } }

sub mod_internal__S_502ColonBangi__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_502ColonBangi',$retree) }
sub mod_internal__S_502ColonBangi {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!i);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_502ColonBangi", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_502ColonBangi_01') {
$C->deb("Fate passed to mod_internal__S_502ColonBangi_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_502ColonBangi_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_502ColonBangi_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':!i')
},
sub { my $C=shift;
$C->_EXACT(':!ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignorecase = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_503ColoniParen_Thesis (:$sym is context<rw> = <:i( )>)
##          token mod_internal:sym<:i( )> { $<sym>=[':i'|':ignorecase'] <mod_arg> { $+ignorecase = eval $<mod_arg>.text } }

sub mod_internal__S_503ColoniParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_503ColoniParen_Thesis',$retree) }
sub mod_internal__S_503ColoniParen_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:i( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_503ColoniParen_Thesis", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_503ColoniParen_Thesis_01') {
$C->deb("Fate passed to mod_internal__S_503ColoniParen_Thesis_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_503ColoniParen_Thesis_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_503ColoniParen_Thesis_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':i')
},
sub { my $C=shift;
$C->_EXACT(':ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::ignorecase = eval $M->{mod_arg}->text ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_504Colon0i (:$sym is context<rw> = <:0i>)
##          token mod_internal:sym<:0i>   { ':' (\d+) ['i'|'ignorecase'] { $+ignorecase = $0 } }

sub mod_internal__S_504Colon0i__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_504Colon0i',$retree) }
sub mod_internal__S_504Colon0i {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0i);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_504Colon0i", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_504Colon0i_02') {
$C->deb("Fate passed to mod_internal__S_504Colon0i_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_504Colon0i_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_504Colon0i_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('i')
},
sub { my $C=shift;
$C->_EXACT('ignorecase')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
$::ignorecase = $$C{0} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_505Colona (:$sym is context<rw> = <:a>)
##          token mod_internal:sym<:a>    { $<sym>=[':a'|':ignoreaccent']  { $+ignoreaccent = 1 } }

sub mod_internal__S_505Colona__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_505Colona',$retree) }
sub mod_internal__S_505Colona {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:a);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_505Colona", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_505Colona_01') {
$C->deb("Fate passed to mod_internal__S_505Colona_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_505Colona_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_505Colona_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':a')
},
sub { my $C=shift;
$C->_EXACT(':ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignoreaccent = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_506ColonBanga (:$sym is context<rw> = <:!a>)
##          token mod_internal:sym<:!a>   { $<sym>=[':!a'|':!ignoreaccent']  { $+ignoreaccent = 0 } }

sub mod_internal__S_506ColonBanga__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_506ColonBanga',$retree) }
sub mod_internal__S_506ColonBanga {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!a);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_506ColonBanga", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_506ColonBanga_01') {
$C->deb("Fate passed to mod_internal__S_506ColonBanga_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_506ColonBanga_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_506ColonBanga_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':!a')
},
sub { my $C=shift;
$C->_EXACT(':!ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ignoreaccent = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_507ColonaParen_Thesis (:$sym is context<rw> = <:a( )>)
##          token mod_internal:sym<:a( )> { $<sym>=[':a'|':ignoreaccent'] <mod_arg> { $+ignoreaccent = eval $<mod_arg>.text } }

sub mod_internal__S_507ColonaParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_507ColonaParen_Thesis',$retree) }
sub mod_internal__S_507ColonaParen_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:a( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_507ColonaParen_Thesis", 
do {
if (my ($C) = (    $C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_507ColonaParen_Thesis_01') {
$C->deb("Fate passed to mod_internal__S_507ColonaParen_Thesis_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_507ColonaParen_Thesis_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_507ColonaParen_Thesis_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':a')
},
sub { my $C=shift;
$C->_EXACT(':ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::ignoreaccent = eval $M->{mod_arg}->text ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_508Colon0a (:$sym is context<rw> = <:0a>)
##          token mod_internal:sym<:0a>   { ':' (\d+) ['a'|'ignoreaccent'] { $+ignoreaccent = $0 } }

sub mod_internal__S_508Colon0a__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_508Colon0a',$retree) }
sub mod_internal__S_508Colon0a {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0a);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_508Colon0a", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_508Colon0a_02') {
$C->deb("Fate passed to mod_internal__S_508Colon0a_02: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_508Colon0a_02', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_508Colon0a_02 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('a')
},
sub { my $C=shift;
$C->_EXACT('ignoreaccent')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
scalar(do {
$::ignoreaccent = $$C{0} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_509Colons (:$sym is context<rw> = <:s>)
##          token mod_internal:sym<:s>    { ':s' 'igspace'?  { $+sigspace = 1 } }

sub mod_internal__S_509Colons__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_509Colons',$retree) }
sub mod_internal__S_509Colons {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:s);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_509Colons", 
do {
if (my ($C) = ($C->_EXACT(':s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::sigspace = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_510ColonBangs (:$sym is context<rw> = <:!s>)
##          token mod_internal:sym<:!s>   { ':!s' 'igspace'?  { $+sigspace = 0 } }

sub mod_internal__S_510ColonBangs__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_510ColonBangs',$retree) }
sub mod_internal__S_510ColonBangs {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!s);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_510ColonBangs", 
do {
if (my ($C) = ($C->_EXACT(':!s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::sigspace = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_511ColonsParen_Thesis (:$sym is context<rw> = <:s( )>)
##          token mod_internal:sym<:s( )> { ':s' 'igspace'? <mod_arg> { $+sigspace = eval $<mod_arg>.text } }

sub mod_internal__S_511ColonsParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_511ColonsParen_Thesis',$retree) }
sub mod_internal__S_511ColonsParen_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:s( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_511ColonsParen_Thesis", 
do {
if (my ($C) = ($C->_EXACT(':s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::sigspace = eval $M->{mod_arg}->text ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_512Colon0s (:$sym is context<rw> = <:0s>)
##          token mod_internal:sym<:0s>   { ':' (\d+) 's' 'igspace'?  { $+sigspace = $0 } }

sub mod_internal__S_512Colon0s__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_512Colon0s',$retree) }
sub mod_internal__S_512Colon0s {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0s);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_512Colon0s", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_EXACT('s'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('igspace')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::sigspace = $$C{0} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_513Colonr (:$sym is context<rw> = <:r>)
##          token mod_internal:sym<:r>    { ':r' 'atchet'?  { $+ratchet = 1 } }

sub mod_internal__S_513Colonr__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_513Colonr',$retree) }
sub mod_internal__S_513Colonr {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:r);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_513Colonr", 
do {
if (my ($C) = ($C->_EXACT(':r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ratchet = 1 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_514ColonBangr (:$sym is context<rw> = <:!r>)
##          token mod_internal:sym<:!r>   { ':!r' 'atchet'?  { $+ratchet = 0 } }

sub mod_internal__S_514ColonBangr__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_514ColonBangr',$retree) }
sub mod_internal__S_514ColonBangr {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:!r);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_514ColonBangr", 
do {
if (my ($C) = ($C->_EXACT(':!r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ratchet = 0 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_515ColonrParen_Thesis (:$sym is context<rw> = <:r( )>)
##          token mod_internal:sym<:r( )> { ':r' 'atchet'?  <mod_arg> { $+ratchet = eval $<mod_arg>.text } }

sub mod_internal__S_515ColonrParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_515ColonrParen_Thesis',$retree) }
sub mod_internal__S_515ColonrParen_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[:r( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_515ColonrParen_Thesis", 
do {
if (my ($C) = ($C->_EXACT(':r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;  $::ratchet = eval $M->{mod_arg}->text ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token mod_internal__S_516Colon0r (:$sym is context<rw> = <:0r>)
##          token mod_internal:sym<:0r>   { ':' (\d+) 'r' 'atchet'?  { $+ratchet = $0 } }

sub mod_internal__S_516Colon0r__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_516Colon0r',$retree) }
sub mod_internal__S_516Colon0r {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:0r);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_516Colon0r", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = (    $C->_SUBSUMEr(['0'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
})}
}))) {
do {
if (my ($C) = ($C->_EXACT('r'))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT('atchet')
}))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::ratchet = $$C{0} 
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_517ColonPerl5 (:$sym is context<rw> = <:Perl5>)
##          token mod_internal:sym<:Perl5>    { [':Perl5' | ':P5'] [ :lang( $.cursor_fresh( ::STD::P5Regex ).unbalanced($+GOAL) ) <nibbler> ] }

sub mod_internal__S_517ColonPerl5__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_517ColonPerl5',$retree) }
sub mod_internal__S_517ColonPerl5 {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(:Perl5);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_517ColonPerl5", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'mod_internal__S_517ColonPerl5_01') {
$C->deb("Fate passed to mod_internal__S_517ColonPerl5_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_517ColonPerl5_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal__S_517ColonPerl5_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT(':Perl5')
},
sub { my $C=shift;
$C->_EXACT(':P5')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_BRACKETr( sub { my $C=shift;
my $newlang = ( $C->cursor_fresh( 'STD::P5Regex' )->unbalanced($::GOAL) );  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
});
}
else {
();
}
}
);
}

##     token mod_internal__S_518adv (:$sym is context<rw> = 'adv')
##          token mod_internal:adv {
##              <?before ':' <identifier> > [ :lang($.cursor_fresh($+LANG)) <quotepair> ] { $/<sym> := : $<quotepair><key> }
##          }

sub mod_internal__S_518adv__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_518adv',$retree) }
sub mod_internal__S_518adv {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'adv';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_518adv", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
});
}
else {
();
}
}
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
})
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} =[':','$<quotepair><key>'] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token mod_internal__S_519oops (:$sym is context<rw> = 'oops')
##          token mod_internal:oops { ':'\w+ <.panic: "Unrecognized regex modifier"> }

sub mod_internal__S_519oops__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_519oops',$retree) }
sub mod_internal__S_519oops {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'oops';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "mod_internal__S_519oops", 
do {
if (my ($C) = ($C->_EXACT(':'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\w)++)/))) {
$C->panic("Unrecognized regex modifier");
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quantifier__S_520Star (:$sym is context<rw> = <*>)
##          token quantifier:sym<*>  { <sym> <quantmod> }

sub quantifier__S_520Star__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_520Star',$retree) }
sub quantifier__S_520Star {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_520Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_521Plus (:$sym is context<rw> = <+>)
##          token quantifier:sym<+>  { <sym> <quantmod> }

sub quantifier__S_521Plus__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_521Plus',$retree) }
sub quantifier__S_521Plus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_521Plus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_522Question (:$sym is context<rw> = <?>)
##          token quantifier:sym<?>  { <sym> <quantmod> }

sub quantifier__S_522Question__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_522Question',$retree) }
sub quantifier__S_522Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_522Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_523StarStar (:$sym is context<rw> = <**>)
##          token quantifier:sym<**> { <sym> :: <sigspace>? <quantmod> <sigspace>?
##              [
##              | \d+ [ '..' [ \d+ | '*' ] ]?
##              | <codeblock>
##              | <quantified_atom>
##              ]
##          }

sub quantifier__S_523StarStar__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_523StarStar',$retree) }
sub quantifier__S_523StarStar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(**);


my $C = $self;
my $S = $C->{_pos};
$C->{'sigspace'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "quantifier__S_523StarStar", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quantifier__S_523StarStar_01') {
$C->deb("Fate passed to quantifier__S_523StarStar_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_523StarStar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier__S_523StarStar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_OPTr(sub { my $C=shift;
$C->_BRACKET( sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quantifier__S_523StarStar_03') {
$C->deb("Fate passed to quantifier__S_523StarStar_03: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_523StarStar_03', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier__S_523StarStar_03 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G((?:\d)++)/)
},
sub { my $C=shift;
$C->_EXACT('*')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_EXACT('..'))
})
})
}, $C->_PATTERN(qr/\G((?:\d)++)/))
},
sub { my $C=shift;
$C->_SUBSUME(['codeblock'], sub {
my $C = shift;
$C->codeblock
})
},
sub { my $C=shift;
$C->_SUBSUME(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['sigspace'], sub {
my $C = shift;
$C->sigspace
})
}))
}, $C->_SUBSUME(['quantmod'], sub {
my $C = shift;
$C->quantmod
}))
}, $C->_OPTr(sub { my $C=shift;
$C->_SUBSUME(['sigspace'], sub {
my $C = shift;
$C->sigspace
})
}))
}, $C->_COMMITBRANCH())
}, $C->_PATTERN(qr/\G\*\*/))
);
}

##     token quantifier__S_524TildeTilde (:$sym is context<rw> = <~~>)
##          token quantifier:sym<~~> {
##              [
##              | '!' <sym>
##              | <sym>
##              ]
##              <sigspace> <quantified_atom> }

sub quantifier__S_524TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_524TildeTilde',$retree) }
sub quantifier__S_524TildeTilde {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(~~);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_524TildeTilde", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quantifier__S_524TildeTilde_01') {
$C->deb("Fate passed to quantifier__S_524TildeTilde_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_524TildeTilde_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier__S_524TildeTilde_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('!'))) {
$C->_PATTERN(qr/\G\~\~/);
}
else {
();
}
}
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\~\~/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['sigspace'], sub {
my $C = shift;
$C->sigspace
}))) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quantmod
##          token quantmod { ':'? [ '?' | '!' | '+' ]? }

sub quantmod__PEEK { $_[0]->_AUTOLEXpeek('quantmod',$retree) }
sub quantmod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "quantmod", 
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_EXACT(':')
}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quantmod_01') {
$C->deb("Fate passed to quantmod_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::Regex', 'quantmod_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantmod_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('?')
},
sub { my $C=shift;
$C->_EXACT('!')
},
sub { my $C=shift;
$C->_EXACT('+')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
}
);
}

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
assertion__S_482DotDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_482DotDotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ...
assertion__S_483QuestionQuestionQuestion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_483QuestionQuestionQuestion
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ???
assertion__S_484BangBangBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_484BangBangBang
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "!!!"
assertion__S_485Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_485Question
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_485Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &21 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_485Question_01
          dba: assertion__S_485Question
          i: 0
          min: 0
          name: assertion__S_485Question_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_485Question_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_485Question
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_485Question
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_485Question_01 1
              dba: assertion__S_485Question
              i: 0
              min: 12345
              name: assertion
              r: 1
              rest: ''
              s: 0
assertion__S_485Question_01: *21
assertion__S_486Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_486Bang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_486Bang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &19 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_486Bang_01
          dba: assertion__S_486Bang
          i: 0
          min: 0
          name: assertion__S_486Bang_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_486Bang_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_486Bang
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_486Bang
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_486Bang_01 1
              dba: assertion__S_486Bang
              i: 0
              min: 12345
              name: assertion
              r: 1
              rest: ''
              s: 0
assertion__S_486Bang_01: *19
assertion__S_487Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_487Star
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_487Star
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "*"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &23 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_487Star_01
          dba: assertion__S_487Star
          i: 0
          min: 0
          name: assertion__S_487Star_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_487Star_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_487Star
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_487Star
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: assertion__S_487Star_01 1
              dba: assertion__S_487Star
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: assertion__S_487Star
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: assertion__S_487Star
                  i: 0
                  min: 12345
                  name: nibbler
                  r: 1
                  rest: ''
                  s: 0
assertion__S_487Star_01: *23
assertion__S_488Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_488Cur_Ly
    i: 0
    min: 12345
    name: codeblock
    r: 1
    rest: ''
    s: 0
assertion__S_489variable: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_489variable
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_489variable
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_method 
              a: 0
              dba: assertion__S_489variable
              i: 0
              min: 12345
              name: sigil
              r: 1
              rest: ''
              s: 0
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: assertion__S_489variable
          i: 0
          lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: assertion__S_489variable
              i: 0
              lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_bindnamed 
              a: 0
              atom: !!perl/hash:RE_method 
                min: 0
                name: EXPR
                nobind: 1
                rest: (item %LOOSEST)
              dba: assertion__S_489variable
              i: 0
              lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
              min: 0
              r: 1
              s: 0
              var: variable
assertion__S_490method: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_490method
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: assertion__S_490method
        i: 0
        min: 1
        r: 1
        s: 0
        text: .
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &1 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_490method_01
          dba: assertion__S_490method
          i: 0
          min: 12345
          name: assertion__S_490method_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: assertion__S_490method_01 0
              dba: assertion__S_490method
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: assertion__S_490method
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 12345
                      re: !!perl/hash:RE_method 
                        a: 0
                        dba: assertion__S_490method
                        i: 0
                        min: 12345
                        name: alpha
                        r: 1
                        rest: ''
                        s: 0
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: assertion__S_490method
                  i: 0
                  min: 12345
                  name: assertion
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_bracket 
              alt: assertion__S_490method_01 1
              decl: []

              min: 12345
              re: !!perl/hash:RE_sequence 
                a: 0
                dba: assertion__S_490method
                i: 0
                lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_decl 
                    a: 0
                    dba: assertion__S_490method
                    i: 0
                    lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
                    max: 0
                    min: 0
                    noquant: 1
                    r: 1
                    s: 0
                    text: "my $newlang = ($C->cursor_fresh($+LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_490method
                    i: 0
                    lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
                    min: 12345
                    name: dottyop
                    r: 1
                    rest: ''
                    s: 0
assertion__S_490method_01: *1
assertion__S_491identifier: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_491identifier
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_491identifier
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: &16 !!perl/hash:RE_any 
            a: 0
            altname: assertion__S_491identifier_01
            dba: assertion__S_491identifier
            i: 0
            min: 0
            name: assertion__S_491identifier_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                alt: assertion__S_491identifier_01 0
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: assertion__S_491identifier
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: assertion__S_491identifier
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ">"
                  s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_491identifier_01 1
                dba: assertion__S_491identifier
                i: 0
                min: 24690
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_491identifier
                    i: 0
                    min: 12345
                    name: ws
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_491identifier
                    i: 0
                    min: 12345
                    name: nibbler
                    r: 1
                    rest: ''
                    s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_491identifier_01 2
                dba: assertion__S_491identifier
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_491identifier
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: =
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_491identifier
                    i: 0
                    min: 12345
                    name: assertion
                    r: 1
                    rest: ''
                    s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_491identifier_01 3
                dba: assertion__S_491identifier
                i: 0
                min: 24691
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_491identifier
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ":"
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_491identifier
                    i: 0
                    min: 12345
                    name: ws
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: assertion__S_491identifier
                      i: 0
                      lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_decl 
                          a: 0
                          dba: assertion__S_491identifier
                          i: 0
                          lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
                          max: 0
                          min: 0
                          noquant: 1
                          r: 1
                          s: 0
                          text: "my $newlang = ($C->cursor_fresh($+LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: assertion__S_491identifier
                          i: 0
                          lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
                          min: 12345
                          name: arglist
                          r: 1
                          rest: ''
                          s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_491identifier_01 4
                dba: assertion__S_491identifier
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_491identifier
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: (
                  - !!perl/hash:RE_block 
                    a: 0
                    context: void
                    dba: assertion__S_491identifier
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    text: ''
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: assertion__S_491identifier
                      i: 0
                      lang: ($C->cursor_fresh($+LANG))
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_decl 
                          a: 0
                          dba: assertion__S_491identifier
                          i: 0
                          lang: ($C->cursor_fresh($+LANG))
                          max: 0
                          min: 0
                          noquant: 1
                          r: 1
                          s: 0
                          text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: assertion__S_491identifier
                          i: 0
                          lang: ($C->cursor_fresh($+LANG))
                          min: 12345
                          name: arglist
                          r: 1
                          rest: ''
                          s: 0
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 0
                    re: !!perl/hash:RE_first 
                      a: 0
                      dba: assertion__S_491identifier
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: assertion__S_491identifier
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_method 
                          min: 0
                          name: panic
                          nobind: 1
                          rest: ("Assertion call missing right parenthesis")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
assertion__S_491identifier_01: *16
assertion__S_492name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_492name
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_492name
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 3
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: assertion__S_492name
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: assertion__S_492name
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \w
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: assertion__S_492name
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  text: ::(
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: assertion__S_492name
          i: 0
          lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: assertion__S_492name
              i: 0
              lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: assertion__S_492name
              i: 0
              lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
              min: 12345
              name: name
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: &24 !!perl/hash:RE_any 
            a: 0
            altname: assertion__S_492name_03
            dba: assertion__S_492name
            i: 0
            min: 0
            name: assertion__S_492name_03
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                alt: assertion__S_492name_03 0
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: assertion__S_492name
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: assertion__S_492name
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: ">"
                  s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_492name_03 1
                dba: assertion__S_492name
                i: 0
                min: 24690
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_492name
                    i: 0
                    min: 12345
                    name: ws
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_492name
                    i: 0
                    min: 12345
                    name: nibbler
                    r: 1
                    rest: ''
                    s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_492name_03 2
                dba: assertion__S_492name
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_492name
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: =
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_492name
                    i: 0
                    min: 12345
                    name: assertion
                    r: 1
                    rest: ''
                    s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_492name_03 3
                dba: assertion__S_492name
                i: 0
                min: 24691
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_492name
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ":"
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: assertion__S_492name
                    i: 0
                    min: 12345
                    name: ws
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: assertion__S_492name
                      i: 0
                      lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_decl 
                          a: 0
                          dba: assertion__S_492name
                          i: 0
                          lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
                          max: 0
                          min: 0
                          noquant: 1
                          r: 1
                          s: 0
                          text: "my $newlang = ($C->cursor_fresh($+LANG)->unbalanced('>'));  $C = $C->cursor_fresh($newlang); "
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: assertion__S_492name
                          i: 0
                          lang: ($C->cursor_fresh($+LANG)->unbalanced('>'))
                          min: 12345
                          name: arglist
                          r: 1
                          rest: ''
                          s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: assertion__S_492name_03 4
                dba: assertion__S_492name
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_492name
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: (
                  - !!perl/hash:RE_block 
                    a: 0
                    context: void
                    dba: assertion__S_492name
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    text: ''
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: assertion__S_492name
                      i: 0
                      lang: ($C->cursor_fresh($+LANG))
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_decl 
                          a: 0
                          dba: assertion__S_492name
                          i: 0
                          lang: ($C->cursor_fresh($+LANG))
                          max: 0
                          min: 0
                          noquant: 1
                          r: 1
                          s: 0
                          text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: assertion__S_492name
                          i: 0
                          lang: ($C->cursor_fresh($+LANG))
                          min: 12345
                          name: arglist
                          r: 1
                          rest: ''
                          s: 0
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 0
                    re: !!perl/hash:RE_first 
                      a: 0
                      dba: assertion__S_492name
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: assertion__S_492name
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_method 
                          min: 0
                          name: panic
                          nobind: 1
                          rest: ("Assertion call missing right parenthesis")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
assertion__S_492name_03: *24
assertion__S_493Bra: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_493Bra
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method_re 
        a: 0
        dba: assertion__S_493Bra
        i: 0
        min: 0
        name: before
        r: 1
        re: !!perl/hash:RE 
          decl: []

          min: 1
          re: !!perl/hash:RE_string 
            a: 0
            dba: assertion__S_493Bra
            i: 0
            min: 1
            r: 1
            s: 0
            text: "["
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: assertion__S_493Bra
          i: 0
          min: 12345
          name: cclass_elem
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_qw 
            a: 0
            dba: assertion__S_493Bra
            i: 0
            min: 1
            r: 1
            s: 0
            text: < + - >
          - 1
assertion__S_494Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_494Plus
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_494Plus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: assertion__S_494Plus
          i: 0
          min: 12345
          name: cclass_elem
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_qw 
            a: 0
            dba: assertion__S_494Plus
            i: 0
            min: 1
            r: 1
            s: 0
            text: < + - >
          - 1
assertion__S_495Minus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_495Minus
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_495Minus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "-"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: assertion__S_495Minus
          i: 0
          min: 12345
          name: cclass_elem
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_qw 
            a: 0
            dba: assertion__S_495Minus
            i: 0
            min: 1
            r: 1
            s: 0
            text: < + - >
          - 1
assertion__S_496Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_496Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
assertion__S_497Comma: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_497Comma
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ","
assertion__S_498TildeTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_498TildeTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_498TildeTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ~~
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &27 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_498TildeTilde_01
          dba: assertion__S_498TildeTilde
          i: 0
          min: 0
          name: assertion__S_498TildeTilde_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_498TildeTilde_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_498TildeTilde
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_498TildeTilde
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ">"
                s: 0
            - !!perl/hash:RE_quantified_atom 
              alt: assertion__S_498TildeTilde_01 1
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: assertion__S_498TildeTilde
                i: 0
                min: 1
                r: 1
                s: 0
                text: \d
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_498TildeTilde_01 2
              dba: assertion__S_498TildeTilde
              i: 0
              min: 12345
              name: desigilname
              r: 1
              rest: ''
              s: 0
assertion__S_498TildeTilde_01: *27
assertion__S_499bogus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized regex assertion")
atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: &18 !!perl/hash:RE_any 
      a: 0
      altname: atom_01
      dba: regex atom
      i: 0
      min: 0
      name: atom_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_meta 
          a: 0
          alt: atom_01 0
          dba: regex atom
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        - !!perl/hash:RE_sequence 
          a: 0
          alt: atom_01 1
          dba: regex atom
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: regex atom
              i: 0
              min: 12345
              name: metachar
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_meta 
              a: 0
              dba: regex atom
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
        - !!perl/hash:RE_method 
          alt: atom_01 2
          min: 0
          name: panic
          nobind: 1
          rest: ("Unrecognized regex metacharacter")
atom_01: *18
backslash__S_459unspace: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_459unspace
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_459unspace
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: backslash__S_459unspace
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_459unspace
        i: 0
        min: 12345
        name: SUPER::ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
backslash__S_4600: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_4600
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: backslash__S_4600
        i: 0
        min: 1
        r: 1
        s: 0
        text: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: backslash__S_4600
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: backslash__S_4600
              i: 0
              min: 1
              r: 1
              s: 0
              text: "[0..7]"
          s: 0
backslash__S_461A: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_461A
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_461A
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: A
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        nobind: 1
        rest: ('\\A as beginning-of-string matcher', '^')
backslash__S_462a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_462a
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_462a
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: a
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("\\a is allowed only in strings, not regexes")
backslash__S_463b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_463b
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
backslash__S_464c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_464c
    i: 1
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_464c
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: c
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &12 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_464c_01
          dba: backslash__S_464c
          i: 1
          min: 0
          name: backslash__S_464c_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_464c_01 0
              dba: backslash__S_464c
              i: 1
              min: 12345
              name: codepoint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              alt: backslash__S_464c_01 1
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: backslash__S_464c
                i: 1
                min: 1
                r: 1
                s: 0
                text: \d
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
            - !!perl/hash:RE_bracket 
              alt: backslash__S_464c_01 2
              decl: []

              min: 0
              re: !!perl/hash:RE_first 
                a: 0
                dba: backslash__S_464c
                i: 1
                min: 0
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_cclass 
                    a: 0
                    dba: backslash__S_464c
                    i: 1
                    min: 1
                    r: 1
                    s: 0
                    text: "[ ?.._ ]"
                  - !!perl/hash:RE_method 
                    min: 0
                    name: panic
                    nobind: 1
                    rest: ("Unrecognized \\c character")
backslash__S_464c_01: *12
backslash__S_465d: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_465d
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: d
backslash__S_466e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_466e
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: e
backslash__S_467f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_467f
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
backslash__S_468h: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_468h
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: h
backslash__S_469n: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_469n
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 'n'
backslash__S_470o: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_470o
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_470o
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: o
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &13 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_470o_01
          dba: backslash__S_470o
          i: 1
          min: 12345
          name: backslash__S_470o_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_470o_01 0
              dba: backslash__S_470o
              i: 1
              min: 12345
              name: octint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_470o_01 1
              dba: backslash__S_470o
              i: 1
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_470o
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_method 
                  a: 0
                  dba: backslash__S_470o
                  i: 1
                  min: 12345
                  name: octint
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12346
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: backslash__S_470o
                      i: 1
                      min: 12346
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: backslash__S_470o
                          i: 1
                          min: 1
                          r: 1
                          s: 0
                          text: ","
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_470o
                          i: 1
                          min: 12345
                          name: octint
                          r: 1
                          rest: ''
                          s: 0
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_470o
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "]"
backslash__S_470o_01: *13
backslash__S_471Q: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_471Q
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_471Q
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: Q
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('\\Q as quotemeta', 'quotes or literal variable match')
backslash__S_472r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_472r
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: r
backslash__S_473s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_473s
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: s
backslash__S_474t: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_474t
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: t
backslash__S_475v: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_475v
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: v
backslash__S_476w: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_476w
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: w
backslash__S_477x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_477x
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_477x
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: x
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &28 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_477x_01
          dba: backslash__S_477x
          i: 1
          min: 12345
          name: backslash__S_477x_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_477x_01 0
              dba: backslash__S_477x
              i: 1
              min: 12345
              name: hexint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_477x_01 1
              dba: backslash__S_477x
              i: 1
              min: 37037
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_477x
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "["
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 37035
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: backslash__S_477x
                      i: 1
                      min: 37035
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_477x
                          i: 1
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_477x
                          i: 1
                          min: 12345
                          name: hexint
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_477x
                          i: 1
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                  min: 37035
                  quant: 
                    - "**"
                    - ":"
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: backslash__S_477x
                      i: 1
                      min: 1
                      r: 1
                      s: 0
                      text: ","
                    - 1
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_477x
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "]"
backslash__S_477x_01: *28
backslash__S_478z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_478z
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_478z
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: z
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('\\z as end-of-string matcher', '$')
backslash__S_479Z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_479Z
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_479Z
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: Z
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('\\Z as end-of-string matcher', '\\n?$')
backslash__S_480misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_paren 
      decl: []

      min: 1
      nobind: 1
      re: !!perl/hash:RE_meta 
        a: 0
        dba: backslash__S_480misc
        i: 0
        min: 1
        r: 1
        s: 0
        text: \W
    dba: backslash__S_480misc
    i: 0
    min: 1
    r: 1
    s: 0
    var: litchar
backslash__S_481oops: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized regex backslash sequence")
category__S_416metachar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_416metachar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: metachar
category__S_417backslash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_417backslash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: backslash
category__S_418assertion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_418assertion
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: assertion
category__S_419quantifier: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_419quantifier
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quantifier
category__S_420mod_internal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_420mod_internal
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: mod_internal
cclass_elem: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: character class element
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: cclass_elem
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &26 !!perl/hash:RE_any 
          a: 0
          altname: cclass_elem_01
          dba: character class element
          i: 0
          min: 0
          name: cclass_elem_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: cclass_elem_01 0
              dba: character class element
              i: 0
              min: 12345
              name: name
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: cclass_elem_01 1
              dba: character class element
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method_re 
                  a: 0
                  dba: character class element
                  i: 0
                  min: 0
                  name: before
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: character class element
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "["
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ).tweak(:q))
      - !!perl/hash:RE_method 
        a: 0
        dba: character class element
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
cclass_elem_01: *26
codeblock: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: codeblock
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '}'
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: codeblock
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: codeblock
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_meta 
        a: 0
        dba: codeblock
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: codeblock
          i: 0
          lang: ($C->cursor_fresh($+LANG))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: statementlist
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: codeblock
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: codeblock
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse statement list; couldn't find right brace")
infixish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infixish
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: infixstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: infixish
        i: 0
        min: 12345
        name: rxinfix
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infixish
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n            $<O> = $<rxinfix><O>;\n            $<sym> = $<rxinfix><sym>;\n        "
metachar__S_426Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_426Gt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_426Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: ">"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_426Gt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_426Gt
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_427AmpAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_427AmpAmp
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_427AmpAmp
        i: 0
        min: 2
        r: 1
        s: 0
        text: "&&"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_427AmpAmp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_427AmpAmp
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_428Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_428Amp
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_428Amp
        i: 0
        min: 1
        r: 1
        s: 0
        text: "&"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_428Amp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_428Amp
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_429VertVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_429VertVert
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_429VertVert
        i: 0
        min: 2
        r: 1
        s: 0
        text: "||"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_429VertVert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_429VertVert
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_430Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_430Vert
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_430Vert
        i: 0
        min: 1
        r: 1
        s: 0
        text: "|"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_430Vert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_430Vert
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_431Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_431Ket
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_431Ket
        i: 0
        min: 1
        r: 1
        s: 0
        text: "]"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_431Ket
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_431Ket
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_432Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_432Thesis
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_432Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: )
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_432Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_432Thesis
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_433quant: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_433quant
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_433quant
        i: 0
        min: 12345
        name: quantifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("quantifier quantifies nothing")
metachar__S_434sigwhite: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_434sigwhite
    i: 0
    min: 12345
    name: sigspace
    r: 1
    rest: ''
    s: 0
metachar__S_435Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_435Cur_Ly
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_435Cur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_435Cur_Ly
              i: 0
              min: 1
              r: 1
              s: 0
              text: "{"
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_435Cur_Ly
        i: 0
        min: 12345
        name: codeblock
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_435Cur_Ly
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <{ }> "
metachar__S_436mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_436mod
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_436mod
        i: 0
        min: 12345
        name: mod_internal
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_436mod
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := $<mod_internal><sym> "
metachar__S_437Colon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_437Colon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ":"
metachar__S_438ColonColon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_438ColonColon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "::"
metachar__S_439ColonColonColon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_439ColonColonColon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ":::"
metachar__S_440Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_440Bra_Ket
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_440Bra_Ket
        i: 0
        min: 1
        r: 1
        s: 0
        text: "["
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_440Bra_Ket
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_440Bra_Ket
          i: 0
          lang: ($self->unbalanced(']'))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_440Bra_Ket
              i: 0
              lang: ($self->unbalanced(']'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($self->unbalanced(']'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_440Bra_Ket
              i: 0
              lang: ($self->unbalanced(']'))
              min: 12345
              name: nibbler
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_440Bra_Ket
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_440Bra_Ket
              i: 0
              min: 1
              r: 1
              s: 0
              text: "]"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find right bracket")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_440Bra_Ket
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <[ ]> "
metachar__S_441Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_441Paren_Thesis
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_441Paren_Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_441Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_441Paren_Thesis
          i: 0
          lang: ($self->unbalanced(')'))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_441Paren_Thesis
              i: 0
              lang: ($self->unbalanced(')'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_441Paren_Thesis
              i: 0
              lang: ($self->unbalanced(')'))
              min: 12345
              name: nibbler
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_441Paren_Thesis
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_441Paren_Thesis
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find right parenthesis")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_441Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <( )> "
metachar__S_442LtParen: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_442LtParen
    i: 0
    min: 2
    r: 1
    s: 0
    text: <(
metachar__S_443ThesisGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_443ThesisGt
    i: 0
    min: 2
    r: 1
    s: 0
    text: )>
metachar__S_444LtLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_444LtLt
    i: 0
    min: 2
    r: 1
    s: 0
    text: <<
metachar__S_445GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_445GtGt
    i: 0
    min: 2
    r: 1
    s: 0
    text: ">>"
metachar__S_446Fre: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_446Fre
    i: 0
    min: 1
    r: 1
    s: 0
    text: 
metachar__S_447Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: metachar__S_447Nch
    i: 0
    min: 1
    r: 1
    s: 0
    text: 
metachar__S_448qw: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_448qw
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_448qw
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 2
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: metachar__S_448qw
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: metachar__S_448qw
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: <
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: metachar__S_448qw
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_448qw
        i: 0
        min: 12345
        name: quote
        r: 1
        rest: ''
        s: 0
metachar__S_449Lt_Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_449Lt_Gt
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_449Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: <
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: metachar__S_449Lt_Gt
          i: 0
          min: 12345
          name: unsp
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_449Lt_Gt
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_449Lt_Gt
        i: 0
        min: 12345
        name: assertion
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_449Lt_Gt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_449Lt_Gt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ">"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("regex assertion not terminated by angle bracket")
metachar__S_450Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_450Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_450Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_450Back
        i: 0
        min: 12345
        name: backslash
        r: 1
        rest: ''
        s: 0
metachar__S_451Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_451Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
metachar__S_452CaretCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_452CaretCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^^"
metachar__S_453Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_453Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
metachar__S_454DollarDollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_454DollarDollar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_454DollarDollar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $$
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: metachar__S_454DollarDollar
            i: 0
            min: 1
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_bindpos 
                atom: !!perl/hash:RE_paren 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_meta 
                      a: 0
                      dba: metachar__S_454DollarDollar
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: \w
                    min: 1
                    quant: 
                      - +
                      - ":"
                      - ''
                      - 1
                min: 1
                var: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                rest: ("\$\$" ~ $0.text ~ " to deref var inside a regex", "\$(\$" ~ $0.text ~ ")")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
metachar__S_455Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_455Dollar
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_455Dollar
        i: 0
        min: 1
        r: 1
        s: 0
        text: $
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_455Dollar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: &9 !!perl/hash:RE_any 
              a: 0
              altname: metachar__S_455Dollar_01
              dba: metachar__S_455Dollar
              i: 0
              min: 0
              name: metachar__S_455Dollar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_455Dollar_01 0
                  dba: metachar__S_455Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_455Dollar_01 1
                  dba: metachar__S_455Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "|"
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_455Dollar_01 2
                  dba: metachar__S_455Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "&"
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_455Dollar_01 3
                  dba: metachar__S_455Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: )
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_455Dollar_01 4
                  dba: metachar__S_455Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "]"
                - !!perl/hash:RE_string 
                  a: 0
                  alt: metachar__S_455Dollar_01 5
                  dba: metachar__S_455Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ">"
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_455Dollar_01 6
                  dba: metachar__S_455Dollar
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $
                - !!perl/hash:RE_method 
                  a: 0
                  alt: metachar__S_455Dollar_01 7
                  dba: metachar__S_455Dollar
                  i: 0
                  min: 12345
                  name: stopper
                  r: 1
                  rest: ''
                  s: 0
          s: 0
metachar__S_455Dollar_01: *9
metachar__S_456Single_Single: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_456Single_Single
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_456Single_Single
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_double 
              a: 0
              dba: metachar__S_456Single_Single
              i: 0
              min: 1
              r: 1
              s: 0
              text: "'"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_456Single_Single
          i: 0
          lang: ($C->cursor_fresh($+LANG))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_456Single_Single
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_456Single_Single
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: quote
              r: 1
              rest: ''
              s: 0
metachar__S_457Double_Double: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_457Double_Double
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_457Double_Double
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_457Double_Double
              i: 0
              min: 1
              r: 1
              s: 0
              text: "\""
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_457Double_Double
          i: 0
          lang: ($C->cursor_fresh($+LANG))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_457Double_Double
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_457Double_Double
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: quote
              r: 1
              rest: ''
              s: 0
metachar__S_458var: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_458var
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_458var
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 2
            re: !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_458var
              i: 0
              min: 2
              r: 1
              s: 0
              text: $$
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_458var
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_458var
              i: 0
              min: 12345
              name: sigil
              r: 1
              rest: ''
              s: 0
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 24690
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_458var
          i: 0
          lang: ($C->cursor_fresh($+LANG))
          min: 24690
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_458var
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_458var
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: variable
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_458var
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_quantified_atom 
          atom: !!perl/hash:RE_paren 
            decl: []

            min: 37036
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: metachar__S_458var
              i: 0
              min: 37036
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_458var
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: metachar__S_458var
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_458var
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_458var
                  i: 0
                  min: 12345
                  name: quantified_atom
                  r: 1
                  rest: ''
                  s: 0
          min: 0
          nobind: 1
          quant: 
            - "?"
            - ":"
            - ''
            - 0
        dba: metachar__S_458var
        i: 0
        min: 0
        r: 1
        s: 0
        var: binding
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_458var
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<sym> = $<variable>.item; "
mod_arg: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: modifier argument
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: modifier argument
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: modifier argument
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: modifier argument
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: modifier argument
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: modifier argument
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'modifier argument')
mod_internal__S_500Colonmy: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_500Colonmy
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_500Colonmy
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: mod_internal__S_500Colonmy
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 3
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: mod_internal__S_500Colonmy
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: mod_internal__S_500Colonmy
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: my
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: mod_internal__S_500Colonmy
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 24690
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: mod_internal__S_500Colonmy
          i: 0
          lang: ($C->cursor_fresh($+LANG))
          min: 24690
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: mod_internal__S_500Colonmy
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_500Colonmy
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: statement
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_500Colonmy
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: eat_terminator
              r: 1
              rest: ''
              s: 0
mod_internal__S_501Coloni: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_501Coloni
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &8 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_501Coloni_01
            dba: mod_internal__S_501Coloni
            i: 0
            min: 2
            name: mod_internal__S_501Coloni_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_501Coloni_01 0
                dba: mod_internal__S_501Coloni
                i: 0
                min: 2
                r: 1
                s: 0
                text: :i
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_501Coloni_01 1
                dba: mod_internal__S_501Coloni
                i: 0
                min: 11
                r: 1
                s: 0
                text: :ignorecase
        dba: mod_internal__S_501Coloni
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_501Coloni
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_501Coloni
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ignorecase = 1 "
mod_internal__S_501Coloni_01: *8
mod_internal__S_502ColonBangi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_502ColonBangi
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 3
          nobind: 1
          re: &4 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_502ColonBangi_01
            dba: mod_internal__S_502ColonBangi
            i: 0
            min: 3
            name: mod_internal__S_502ColonBangi_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_502ColonBangi_01 0
                dba: mod_internal__S_502ColonBangi
                i: 0
                min: 3
                r: 1
                s: 0
                text: :!i
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_502ColonBangi_01 1
                dba: mod_internal__S_502ColonBangi
                i: 0
                min: 12
                r: 1
                s: 0
                text: :!ignorecase
        dba: mod_internal__S_502ColonBangi
        i: 0
        min: 3
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_502ColonBangi
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_502ColonBangi
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ignorecase = 0 "
mod_internal__S_502ColonBangi_01: *4
mod_internal__S_503ColoniParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_503ColoniParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &2 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_503ColoniParen_Thesis_01
            dba: mod_internal__S_503ColoniParen_Thesis
            i: 0
            min: 2
            name: mod_internal__S_503ColoniParen_Thesis_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_503ColoniParen_Thesis_01 0
                dba: mod_internal__S_503ColoniParen_Thesis
                i: 0
                min: 2
                r: 1
                s: 0
                text: :i
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_503ColoniParen_Thesis_01 1
                dba: mod_internal__S_503ColoniParen_Thesis
                i: 0
                min: 11
                r: 1
                s: 0
                text: :ignorecase
        dba: mod_internal__S_503ColoniParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_503ColoniParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_503ColoniParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ignorecase = eval $<mod_arg>.text "
mod_internal__S_503ColoniParen_Thesis_01: *2
mod_internal__S_504Colon0i: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_504Colon0i
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_504Colon0i
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_504Colon0i
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &20 !!perl/hash:RE_any 
          a: 0
          altname: mod_internal__S_504Colon0i_02
          dba: mod_internal__S_504Colon0i
          i: 0
          min: 1
          name: mod_internal__S_504Colon0i_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_504Colon0i_02 0
              dba: mod_internal__S_504Colon0i
              i: 0
              min: 1
              r: 1
              s: 0
              text: i
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_504Colon0i_02 1
              dba: mod_internal__S_504Colon0i
              i: 0
              min: 10
              r: 1
              s: 0
              text: ignorecase
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_504Colon0i
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ignorecase = $0 "
mod_internal__S_504Colon0i_02: *20
mod_internal__S_505Colona: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_505Colona
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &25 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_505Colona_01
            dba: mod_internal__S_505Colona
            i: 0
            min: 2
            name: mod_internal__S_505Colona_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_505Colona_01 0
                dba: mod_internal__S_505Colona
                i: 0
                min: 2
                r: 1
                s: 0
                text: :a
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_505Colona_01 1
                dba: mod_internal__S_505Colona
                i: 0
                min: 13
                r: 1
                s: 0
                text: :ignoreaccent
        dba: mod_internal__S_505Colona
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_505Colona
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_505Colona
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ignoreaccent = 1 "
mod_internal__S_505Colona_01: *25
mod_internal__S_506ColonBanga: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_506ColonBanga
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 3
          nobind: 1
          re: &10 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_506ColonBanga_01
            dba: mod_internal__S_506ColonBanga
            i: 0
            min: 3
            name: mod_internal__S_506ColonBanga_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_506ColonBanga_01 0
                dba: mod_internal__S_506ColonBanga
                i: 0
                min: 3
                r: 1
                s: 0
                text: :!a
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_506ColonBanga_01 1
                dba: mod_internal__S_506ColonBanga
                i: 0
                min: 14
                r: 1
                s: 0
                text: :!ignoreaccent
        dba: mod_internal__S_506ColonBanga
        i: 0
        min: 3
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_506ColonBanga
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_506ColonBanga
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ignoreaccent = 0 "
mod_internal__S_506ColonBanga_01: *10
mod_internal__S_507ColonaParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_507ColonaParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          nobind: 1
          re: &15 !!perl/hash:RE_any 
            a: 0
            altname: mod_internal__S_507ColonaParen_Thesis_01
            dba: mod_internal__S_507ColonaParen_Thesis
            i: 0
            min: 2
            name: mod_internal__S_507ColonaParen_Thesis_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_507ColonaParen_Thesis_01 0
                dba: mod_internal__S_507ColonaParen_Thesis
                i: 0
                min: 2
                r: 1
                s: 0
                text: :a
              - !!perl/hash:RE_string 
                a: 0
                alt: mod_internal__S_507ColonaParen_Thesis_01 1
                dba: mod_internal__S_507ColonaParen_Thesis
                i: 0
                min: 13
                r: 1
                s: 0
                text: :ignoreaccent
        dba: mod_internal__S_507ColonaParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_507ColonaParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_507ColonaParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ignoreaccent = eval $<mod_arg>.text "
mod_internal__S_507ColonaParen_Thesis_01: *15
mod_internal__S_508Colon0a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_508Colon0a
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_508Colon0a
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_508Colon0a
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &17 !!perl/hash:RE_any 
          a: 0
          altname: mod_internal__S_508Colon0a_02
          dba: mod_internal__S_508Colon0a
          i: 0
          min: 1
          name: mod_internal__S_508Colon0a_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_508Colon0a_02 0
              dba: mod_internal__S_508Colon0a
              i: 0
              min: 1
              r: 1
              s: 0
              text: a
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_508Colon0a_02 1
              dba: mod_internal__S_508Colon0a
              i: 0
              min: 12
              r: 1
              s: 0
              text: ignoreaccent
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_508Colon0a
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ignoreaccent = $0 "
mod_internal__S_508Colon0a_02: *17
mod_internal__S_509Colons: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_509Colons
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_509Colons
        i: 0
        min: 2
        r: 1
        s: 0
        text: :s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_509Colons
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_509Colons
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_509Colons
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+sigspace = 1 "
mod_internal__S_510ColonBangs: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_510ColonBangs
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_510ColonBangs
        i: 0
        min: 3
        r: 1
        s: 0
        text: :!s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_510ColonBangs
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_510ColonBangs
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_510ColonBangs
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+sigspace = 0 "
mod_internal__S_511ColonsParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_511ColonsParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_511ColonsParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        text: :s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_511ColonsParen_Thesis
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_511ColonsParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_511ColonsParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+sigspace = eval $<mod_arg>.text "
mod_internal__S_512Colon0s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_512Colon0s
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_512Colon0s
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_512Colon0s
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_512Colon0s
        i: 0
        min: 1
        r: 1
        s: 0
        text: s
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_512Colon0s
          i: 0
          min: 7
          r: 1
          s: 0
          text: igspace
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_512Colon0s
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_512Colon0s
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+sigspace = $0 "
mod_internal__S_513Colonr: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_513Colonr
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_513Colonr
        i: 0
        min: 2
        r: 1
        s: 0
        text: :r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_513Colonr
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_513Colonr
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_513Colonr
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ratchet = 1 "
mod_internal__S_514ColonBangr: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_514ColonBangr
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_514ColonBangr
        i: 0
        min: 3
        r: 1
        s: 0
        text: :!r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_514ColonBangr
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_514ColonBangr
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_514ColonBangr
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ratchet = 0 "
mod_internal__S_515ColonrParen_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_515ColonrParen_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_515ColonrParen_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        text: :r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_515ColonrParen_Thesis
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_515ColonrParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: mod_internal__S_515ColonrParen_Thesis
        i: 0
        min: 12345
        name: mod_arg
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_515ColonrParen_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ratchet = eval $<mod_arg>.text "
mod_internal__S_516Colon0r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_516Colon0r
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_516Colon0r
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: mod_internal__S_516Colon0r
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_516Colon0r
        i: 0
        min: 1
        r: 1
        s: 0
        text: r
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: mod_internal__S_516Colon0r
          i: 0
          min: 6
          r: 1
          s: 0
          text: atchet
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: mod_internal__S_516Colon0r
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_516Colon0r
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $+ratchet = $0 "
mod_internal__S_517ColonPerl5: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_517ColonPerl5
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 3
        re: &3 !!perl/hash:RE_any 
          a: 0
          altname: mod_internal__S_517ColonPerl5_01
          dba: mod_internal__S_517ColonPerl5
          i: 0
          min: 3
          name: mod_internal__S_517ColonPerl5_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_517ColonPerl5_01 0
              dba: mod_internal__S_517ColonPerl5
              i: 0
              min: 6
              r: 1
              s: 0
              text: :Perl5
            - !!perl/hash:RE_string 
              a: 0
              alt: mod_internal__S_517ColonPerl5_01 1
              dba: mod_internal__S_517ColonPerl5
              i: 0
              min: 3
              r: 1
              s: 0
              text: :P5
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: mod_internal__S_517ColonPerl5
          i: 0
          lang: ( $C->cursor_fresh( 'STD::P5Regex' )->unbalanced($+GOAL) )
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: mod_internal__S_517ColonPerl5
              i: 0
              lang: ( $C->cursor_fresh( 'STD::P5Regex' )->unbalanced($+GOAL) )
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ( $C->cursor_fresh( 'STD::P5Regex' )->unbalanced($+GOAL) );  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_517ColonPerl5
              i: 0
              lang: ( $C->cursor_fresh( 'STD::P5Regex' )->unbalanced($+GOAL) )
              min: 12345
              name: nibbler
              r: 1
              rest: ''
              s: 0
mod_internal__S_517ColonPerl5_01: *3
mod_internal__S_518adv: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_518adv
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: mod_internal__S_518adv
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12346
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: mod_internal__S_518adv
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: mod_internal__S_518adv
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ":"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: mod_internal__S_518adv
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: mod_internal__S_518adv
          i: 0
          lang: ($C->cursor_fresh($+LANG))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: mod_internal__S_518adv
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: mod_internal__S_518adv
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: quotepair
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: mod_internal__S_518adv
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := : $<quotepair><key> "
mod_internal__S_519oops: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: mod_internal__S_519oops
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: mod_internal__S_519oops
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: mod_internal__S_519oops
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Unrecognized regex modifier")
nibbler: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $sigspace    is context<rw> = $+sigspace    // 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ratchet     is context<rw> = $+ratchet     // 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ignorecase is context<rw> = $+ignorecase // 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ignoreaccent    is context<rw> = $+ignoreaccent    // 0
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: nibbler
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: nibbler
            i: 0
            min: 1
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_meta 
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: \s
                min: 0
                quant: 
                  - "*"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_qw 
                a: 0
                dba: nibbler
                i: 0
                min: 1
                r: 1
                s: 1
                text: < || | && & >
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: nibbler
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
quantified_atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantified_atom
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: stopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: rxinfix
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: atom
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quantified_atom
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: quantifier
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
quantifier__S_520Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_520Star
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_520Star
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "*"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_520Star
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_521Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_521Plus
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_521Plus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_521Plus
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_522Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_522Question
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_522Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_522Question
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_523StarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_523StarStar
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_523StarStar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "**"
      - !!perl/hash:RE_meta 
        a: 0
        dba: quantifier__S_523StarStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: quantifier__S_523StarStar
          i: 0
          min: 12345
          name: sigspace
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_523StarStar
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: quantifier__S_523StarStar
          i: 0
          min: 12345
          name: sigspace
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &5 !!perl/hash:RE_any 
          a: 0
          altname: quantifier__S_523StarStar_01
          dba: quantifier__S_523StarStar
          i: 0
          min: 1
          name: quantifier__S_523StarStar_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quantifier__S_523StarStar_01 0
              dba: quantifier__S_523StarStar
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: quantifier__S_523StarStar
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \d
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 3
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: quantifier__S_523StarStar
                      i: 0
                      min: 3
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: quantifier__S_523StarStar
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: ..
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          re: &11 !!perl/hash:RE_any 
                            a: 0
                            altname: quantifier__S_523StarStar_03
                            dba: quantifier__S_523StarStar
                            i: 0
                            min: 1
                            name: quantifier__S_523StarStar_03
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_quantified_atom 
                                alt: quantifier__S_523StarStar_03 0
                                atom: !!perl/hash:RE_meta 
                                  a: 0
                                  dba: quantifier__S_523StarStar
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: \d
                                min: 1
                                quant: 
                                  - +
                                  - ":"
                                  - ''
                                  - 1
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: quantifier__S_523StarStar_03 1
                                dba: quantifier__S_523StarStar
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: "*"
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_method 
              a: 0
              alt: quantifier__S_523StarStar_01 1
              dba: quantifier__S_523StarStar
              i: 0
              min: 12345
              name: codeblock
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: quantifier__S_523StarStar_01 2
              dba: quantifier__S_523StarStar
              i: 0
              min: 12345
              name: quantified_atom
              r: 1
              rest: ''
              s: 0
quantifier__S_523StarStar_01: *5
quantifier__S_523StarStar_03: *11
quantifier__S_524TildeTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_524TildeTilde
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &14 !!perl/hash:RE_any 
          a: 0
          altname: quantifier__S_524TildeTilde_01
          dba: quantifier__S_524TildeTilde
          i: 0
          min: 12345
          name: quantifier__S_524TildeTilde_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quantifier__S_524TildeTilde_01 0
              dba: quantifier__S_524TildeTilde
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: quantifier__S_524TildeTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quantifier__S_524TildeTilde
                  i: 0
                  min: 12345
                  name: sym
                  r: 1
                  rest: ''
                  s: 0
                  sym: ~~
            - !!perl/hash:RE_method 
              a: 0
              alt: quantifier__S_524TildeTilde_01 1
              dba: quantifier__S_524TildeTilde
              i: 0
              min: 12345
              name: sym
              r: 1
              rest: ''
              s: 0
              sym: ~~
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_524TildeTilde
        i: 0
        min: 12345
        name: sigspace
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_524TildeTilde
        i: 0
        min: 12345
        name: quantified_atom
        r: 1
        rest: ''
        s: 0
quantifier__S_524TildeTilde_01: *14
quantmod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantmod
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: quantmod
          i: 0
          min: 1
          r: 1
          s: 0
          text: ":"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: &6 !!perl/hash:RE_any 
            a: 0
            altname: quantmod_01
            dba: quantmod
            i: 0
            min: 1
            name: quantmod_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                alt: quantmod_01 0
                dba: quantmod
                i: 0
                min: 1
                r: 1
                s: 0
                text: "?"
              - !!perl/hash:RE_string 
                a: 0
                alt: quantmod_01 1
                dba: quantmod
                i: 0
                min: 1
                r: 1
                s: 0
                text: "!"
              - !!perl/hash:RE_string 
                a: 0
                alt: quantmod_01 2
                dba: quantmod
                i: 0
                min: 1
                r: 1
                s: 0
                text: +
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
quantmod_01: *6
rxinfix__S_421VertVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_421VertVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "||"
rxinfix__S_422AmpAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_422AmpAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&&"
rxinfix__S_423Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_423Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
rxinfix__S_424Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_424Amp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&"
rxinfix__S_425Tilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_425Tilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '~'
sigspace: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: sigspace
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: sigspace
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &7 !!perl/hash:RE_any 
              a: 0
              altname: sigspace_01
              dba: sigspace
              i: 0
              min: 1
              name: sigspace_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: sigspace_01 0
                  dba: sigspace
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: sigspace_01 1
                  dba: sigspace
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "#"
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: sigspace
          i: 0
          lang: ($C->cursor_fresh($+LANG))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: sigspace
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: sigspace
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
sigspace_01: *7
termish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: termish
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: termish
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: termish
          i: 0
          min: 12345
          name: quantified_atom
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
ws: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: ws
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: ws
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $+sigspace "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: ws
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: ws
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &22 !!perl/hash:RE_any 
                      a: 0
                      altname: ws_03
                      dba: ws
                      i: 0
                      min: 1
                      name: ws_03
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_meta 
                          a: 0
                          alt: ws_03 0
                          dba: ws
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \s
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: ws_03 1
                          dba: ws
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "#"
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: ws
                i: 0
                min: 12345
                name: nextsame
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
ws_03: *22
RETREE_END
}
} ## end grammar

{ package STD::P5Regex;
use Moose ':all' => { -prefix => "moose_" };
my $retree;
moose_extends(qw(STD));
sub multitweak { # begin tweaks
my $self = shift;
my ($k, $v) = @_;

if (0) {}
elsif ($k eq 'global' or $k eq 'g') {
my $g = $v;  $self }
elsif ($k eq 'ignorecase' or $k eq 'i') {
my $i = $v;  $self }
else { die 'NOMATCH' }
} # end tweaks

##     token category__S_525metachar (:$sym is context<rw> = 'metachar')
##          token category:metachar { <sym> }

sub category__S_525metachar__PEEK { $_[0]->_AUTOLEXpeek('category__S_525metachar',$retree) }
sub category__S_525metachar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'metachar';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_525metachar", 
$C->_PATTERN(qr/\Gmetachar/)
);
}
#proto token metachar { <...> }
sub metachar__PEEK { $_[0]->_AUTOLEXpeek('metachar:*',$retree); }
sub metachar {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'metachar') {
$C->deb("Fate passed to metachar: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'metachar:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "metachar", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_526backslash (:$sym is context<rw> = 'backslash')
##          token category:backslash { <sym> }

sub category__S_526backslash__PEEK { $_[0]->_AUTOLEXpeek('category__S_526backslash',$retree) }
sub category__S_526backslash {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'backslash';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_526backslash", 
$C->_PATTERN(qr/\Gbackslash/)
);
}
#proto token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'backslash') {
$C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "backslash", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_527assertion (:$sym is context<rw> = 'assertion')
##          token category:assertion { <sym> }

sub category__S_527assertion__PEEK { $_[0]->_AUTOLEXpeek('category__S_527assertion',$retree) }
sub category__S_527assertion {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'assertion';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_527assertion", 
$C->_PATTERN(qr/\Gassertion/)
);
}
#proto token assertion { <...> }
sub assertion__PEEK { $_[0]->_AUTOLEXpeek('assertion:*',$retree); }
sub assertion {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'assertion') {
$C->deb("Fate passed to assertion: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "assertion", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_528quantifier (:$sym is context<rw> = 'quantifier')
##          token category:quantifier { <sym> }

sub category__S_528quantifier__PEEK { $_[0]->_AUTOLEXpeek('category__S_528quantifier',$retree) }
sub category__S_528quantifier {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quantifier';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_528quantifier", 
$C->_PATTERN(qr/\Gquantifier/)
);
}
#proto token quantifier { <...> }
sub quantifier__PEEK { $_[0]->_AUTOLEXpeek('quantifier:*',$retree); }
sub quantifier {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'quantifier') {
$C->deb("Fate passed to quantifier: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'quantifier:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantifier trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "quantifier", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


##     token category__S_529mod_internal (:$sym is context<rw> = 'mod_internal')
##          token category:mod_internal { <sym> }

sub category__S_529mod_internal__PEEK { $_[0]->_AUTOLEXpeek('category__S_529mod_internal',$retree) }
sub category__S_529mod_internal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'mod_internal';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "category__S_529mod_internal", 
$C->_PATTERN(qr/\Gmod_internal/)
);
}
#proto token mod_internal { <...> }
sub mod_internal__PEEK { $_[0]->_AUTOLEXpeek('mod_internal:*',$retree); }
sub mod_internal {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'mod_internal') {
$C->deb("Fate passed to mod_internal: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'mod_internal:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("mod_internal trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "mod_internal", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


#proto token rxinfix { <...> }
sub rxinfix__PEEK { $_[0]->_AUTOLEXpeek('rxinfix:*',$retree); }
sub rxinfix {
my $self = shift;
my $subs;

local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self;
my $S = $C->{_pos};

my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;
if (my $fate = $C->{_fate}) {
if ($fate->[1] eq 'rxinfix') {
$C->deb("Fate passed to rxinfix: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'rxinfix:*', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("rxinfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, $C->$try(@_);
last if @gather;
}
$self->_MATCHIFY($S, "rxinfix", @gather);
};
if ($@) {
return () if $@ =~ /^ABORTRULE/;
die $@;
}
@result;
}


# suppress fancy end-of-line checking
##     token codeblock
##          token codeblock {
##              :my $GOAL is context = '}';
##              '{' :: [ :lang($.cursor_fresh($+LANG)) <statementlist> ]
##              [ '}' || <.panic: "Unable to parse statement list; couldn't find right brace"> ]
##          }

sub codeblock__PEEK { $_[0]->_AUTOLEXpeek('codeblock',$retree) }
sub codeblock {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $GOAL =  '}';


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "codeblock", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_BRACKET( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT('}')} 
or
eval { push @gather, $C->panic("Unable to parse statement list; couldn't find right brace")} or do { die $@ if $@ };
@gather;
}
})
}, $C->_BRACKET( sub { my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUME(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))
}, $C->_COMMITBRANCH())
}, $C->_EXACT('{'))
);
}

##     rule nibbler
##          rule nibbler {
##              :my $ignorecase is context<rw> = $+ignorecase // 0;
##              <EXPR>
##          }

sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler',$retree) }
sub nibbler {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
local $ignorecase =  $::ignorecase // 0;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "nibbler", 
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token termish
##          token termish {
##      	<.ws>  # XXX assuming old /x here?
##              <quantified_atom>+
##          }

sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish',$retree) }
sub termish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'quantified_atom'} = [];

$self->_MATCHIFYr($S, "termish", 
do {
if (my ($C) = ($C->ws)) {
$C->_PLUSr(sub { my $C=shift;
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
});
}
else {
();
}
}
);
}
##     token infixish
##          token infixish {
##              <!infixstopper>
##              <!stdstopper>
##              <rxinfix>
##              {
##                  $<O> = $<rxinfix><O>;
##                  $<sym> = $<rxinfix><sym>;
##              }
##          }

sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish',$retree) }
sub infixish {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "infixish", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->infixstopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stdstopper
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['rxinfix'], sub {
my $C = shift;
$C->rxinfix
}))) {
scalar(do {
my $M = $C; 
$M->{O} = $M->{rxinfix}{O};
$M->{sym} = $M->{rxinfix}{sym};
;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token rxinfix__S_530Vert (  :$sym is context<rw> = <|> --> Junctive_or )
##          token rxinfix:sym<|> ( --> Junctive_or ) { <sym> }

sub rxinfix__S_530Vert__PEEK { $_[0]->_AUTOLEXpeek('rxinfix__S_530Vert',$retree) }
sub rxinfix__S_530Vert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "rxinfix__S_530Vert",  map { STD::Junctive_or->coerce($_) } 
$C->_PATTERN(qr/\G\|/)
);
}

##     token quantified_atom
##          token quantified_atom {
##              <!stopper>
##              <!rxinfix>
##              <atom>
##              [ <.ws> <quantifier>
##      #            <?{ $<atom>.max_width }>
##      #                || <.panic: "Can't quantify zero-width atom">
##              ]?
##      	<.ws>
##          }

sub quantified_atom__PEEK { $_[0]->_AUTOLEXpeek('quantified_atom',$retree) }
sub quantified_atom {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};
$C->{'quantifier'} = [];

$self->_MATCHIFYr($S, "quantified_atom", 
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->stopper
}))) {
do {
if (my ($C) = ($C->_NOTBEFORE( sub { my $C=shift;
$C->rxinfix
}))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['atom'], sub {
my $C = shift;
$C->atom
}))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
});
}
else {
();
}
}
})
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token atom
##          token atom {
##              [
##              | \w
##              | <metachar>
##      	| '\\' :: .
##              ]
##          }

sub atom__PEEK { $_[0]->_AUTOLEXpeek('atom',$retree) }
sub atom {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFY($S, "atom", 
$C->_BRACKET( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'atom_01') {
$C->deb("Fate passed to atom_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'atom_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("atom_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
},
sub { my $C=shift;
$C->_SUBSUMEr(['metachar'], sub {
my $C = shift;
$C->metachar
})
},
sub { my $C=shift;
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_PATTERN(qr/\G(?s:.)/)
}, $C->_COMMITBRANCH())
}, $C->_EXACT('\\'))
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
);
}

# sequence stoppers
##     token metachar__S_531Vert (:$sym is context<rw> = <|>)
##          token metachar:sym<|>   { '|'  :: <fail> }

sub metachar__S_531Vert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_531Vert',$retree) }
sub metachar__S_531Vert {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(|);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_531Vert", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT('|'))
);
}
##     token metachar__S_532Thesis (:$sym is context<rw> = <)>)
##          token metachar:sym<)>   { ')'  :: <fail> }

sub metachar__S_532Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_532Thesis',$retree) }
sub metachar__S_532Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q[)];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFY($S, "metachar__S_532Thesis", 
Cursor::lazymap(sub { my $C=$_[0];
Cursor::lazymap(sub { my $C=$_[0];
$C->_SUBSUME(['fail'], sub {
my $C = shift;
$C->fail
})
}, $C->_COMMITBRANCH())
}, $C->_EXACT(')'))
);
}

##     token metachar__S_533quant (:$sym is context<rw> = 'quant')
##          token metachar:quant { <quantifier> <.panic: "quantifier quantifies nothing"> }

sub metachar__S_533quant__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_533quant',$retree) }
sub metachar__S_533quant {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'quant';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_533quant", 
do {
if (my ($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))) {
$C->panic("quantifier quantifies nothing");
}
else {
();
}
}
);
}

# "normal" metachars

##     token metachar__S_534Bra_Ket (:$sym is context<rw> = <[ ]>)
##          token metachar:sym<[ ]> {
##      	<before '['> <quibble($.cursor_fresh( ::STD::Q ).tweak(:q))> # XXX parse as q[] for now
##          }

sub metachar__S_534Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_534Bra_Ket',$retree) }
sub metachar__S_534Bra_Ket {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw([ ])];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_534Bra_Ket", 
do {
if (my ($C) = ($C->_SUBSUMEr(['before'], sub {
my $C = shift;
$C->before(sub { my $C=shift;
$C->_EXACT('[')
})
}))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( 'STD::Q' )->tweak('q' => 1))
});
}
else {
();
}
}
);
}

##     token metachar__S_535ParenQuestion_Thesis (:$sym is context<rw> = (? ))
##          token metachar:sym(? ) {
##              '(?' {} <assertion>
##              [ ')' || <.panic: "Perl 5 regex assertion not terminated by parenthesis"> ]
##          }

sub metachar__S_535ParenQuestion_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_535ParenQuestion_Thesis',$retree) }
sub metachar__S_535ParenQuestion_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['(?',')'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_535ParenQuestion_Thesis", 
do {
if (my ($C) = ($C->_EXACT('(?'))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->panic("Perl 5 regex assertion not terminated by parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_536Paren_Thesis (:$sym is context<rw> = <( )>)
##          token metachar:sym<( )> {
##              '(' {} [:lang(self.unbalanced(')')) <nibbler>]
##              [ ')' || <.panic: "Unable to parse Perl 5 regex; couldn't find right parenthesis"> ]
##              { $/<sym> := <( )> }
##          }

sub metachar__S_536Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_536Paren_Thesis',$retree) }
sub metachar__S_536Paren_Thesis {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw[( )]];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_536Paren_Thesis", 
do {
if (my ($C) = ($C->_EXACT('('))) {
do {
if (my ($C) = (scalar(do {

}, $C))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->panic("Unable to parse Perl 5 regex; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
}))) {
scalar(do {
my $M = $C;  $M->{'sym'} = [qw[( )]] ;
}, $C);
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token metachar__S_537Back (:$sym is context<rw> = <\\>)
##          token metachar:sym<\\> { <sym> <backslash> }

sub metachar__S_537Back__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_537Back',$retree) }
sub metachar__S_537Back {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(\\);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_537Back", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\\/))) {
$C->_SUBSUMEr(['backslash'], sub {
my $C = shift;
$C->backslash
});
}
else {
();
}
}
);
}
##     token metachar__S_538Dot (:$sym is context<rw> = <.>)
##          token metachar:sym<.>  { <sym> }

sub metachar__S_538Dot__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_538Dot',$retree) }
sub metachar__S_538Dot {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(.);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_538Dot", 
$C->_PATTERN(qr/\G\./)
);
}
##     token metachar__S_539Caret (:$sym is context<rw> = <^>)
##          token metachar:sym<^>  { <sym> }

sub metachar__S_539Caret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_539Caret',$retree) }
sub metachar__S_539Caret {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(^);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_539Caret", 
$C->_PATTERN(qr/\G\^/)
);
}
##     token metachar__S_540Dollar (:$sym is context<rw> = <$>)
##          token metachar:sym<$>  {
##              '$' <?before \W | $>
##          }

sub metachar__S_540Dollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_540Dollar',$retree) }
sub metachar__S_540Dollar {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q($);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_540Dollar", 
do {
if (my ($C) = ($C->_EXACT('$'))) {
$C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'metachar__S_540Dollar_01') {
$C->deb("Fate passed to metachar__S_540Dollar_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'metachar__S_540Dollar_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("metachar__S_540Dollar_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
},
sub { my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}

##     token metachar__S_541var (:$sym is context<rw> = 'var')
##          token metachar:var {
##              <?before <sigil>\w>
##      	<.panic: "Can't interpolate variable in Perl 5 regex">
##          }

sub metachar__S_541var__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_541var',$retree) }
sub metachar__S_541var {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'var';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "metachar__S_541var", 
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
$C->_PATTERN(qr/\G\w/);
}
else {
();
}
}
}))) {
$C->panic("Can't interpolate variable in Perl 5 regex");
}
else {
();
}
}
);
}

##     token backslash__S_542A (:$sym is context<rw> = 'A')
##          token backslash:A { <sym> }

sub backslash__S_542A__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_542A',$retree) }
sub backslash__S_542A {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'A';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_542A", 
$C->_PATTERN(qr/\GA/)
);
}
##     token backslash__S_543a (:$sym is context<rw> = 'a')
##          token backslash:a { <sym> }

sub backslash__S_543a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_543a',$retree) }
sub backslash__S_543a {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'a';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_543a", 
$C->_PATTERN(qr/\Ga/)
);
}
##     token backslash__S_544b (:$sym is context<rw> = 'b')
##          token backslash:b { :i <sym> }

sub backslash__S_544b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_544b',$retree) }
sub backslash__S_544b {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'b';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_544b", 
$C->_PATTERN(qr/\G(?i:b)/)
);
}
##     token backslash__S_545c (:$sym is context<rw> = 'c')
##          token backslash:c { :i <sym>
##              <[ ?.._ ]> || <.panic: "Unrecognized \\c character">
##          }

sub backslash__S_545c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_545c',$retree) }
sub backslash__S_545c {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'c';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_545c", 
do { my @gather;
eval { push @gather, $C->_PATTERN(qr/\G(?i:c)(?i:[?-_])/)} 
or
eval { push @gather, $C->panic("Unrecognized \\c character")} or do { die $@ if $@ };
@gather;
}
);
}
##     token backslash__S_546d (:$sym is context<rw> = 'd')
##          token backslash:d { :i <sym> }

sub backslash__S_546d__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_546d',$retree) }
sub backslash__S_546d {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'd';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_546d", 
$C->_PATTERN(qr/\G(?i:d)/)
);
}
##     token backslash__S_547e (:$sym is context<rw> = 'e')
##          token backslash:e { :i <sym> }

sub backslash__S_547e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_547e',$retree) }
sub backslash__S_547e {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'e';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_547e", 
$C->_PATTERN(qr/\G(?i:e)/)
);
}
##     token backslash__S_548f (:$sym is context<rw> = 'f')
##          token backslash:f { :i <sym> }

sub backslash__S_548f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_548f',$retree) }
sub backslash__S_548f {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'f';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_548f", 
$C->_PATTERN(qr/\G(?i:f)/)
);
}
##     token backslash__S_549h (:$sym is context<rw> = 'h')
##          token backslash:h { :i <sym> }

sub backslash__S_549h__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_549h',$retree) }
sub backslash__S_549h {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'h';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_549h", 
$C->_PATTERN(qr/\G(?i:h)/)
);
}
##     token backslash__S_550l (:$sym is context<rw> = 'l')
##          token backslash:l { :i <sym> }

sub backslash__S_550l__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_550l',$retree) }
sub backslash__S_550l {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'l';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_550l", 
$C->_PATTERN(qr/\G(?i:l)/)
);
}
##     token backslash__S_551n (:$sym is context<rw> = 'n')
##          token backslash:n { :i <sym> }

sub backslash__S_551n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_551n',$retree) }
sub backslash__S_551n {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'n';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_551n", 
$C->_PATTERN(qr/\G(?i:n)/)
);
}
##     token backslash__S_552o (:$sym is context<rw> = 'o')
##          token backslash:o { '0' [ <octint> | '{'<octint>[','<octint>]*'}' ]? }

sub backslash__S_552o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_552o',$retree) }
sub backslash__S_552o {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'o';


my $C = $self;
my $S = $C->{_pos};
$C->{'octint'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_552o", 
do {
if (my ($C) = ($C->_EXACT('0'))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_552o_01') {
$C->deb("Fate passed to backslash__S_552o_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash__S_552o_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_552o_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = ($C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
}))) {
do {
if (my ($C) = ($C->_STARr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(','))) {
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
});
}
else {
();
}
}
})
}))) {
$C->_EXACT('}');
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
});
}
else {
();
}
}
);
}
##     token backslash__S_553Q (:$sym is context<rw> = 'Q')
##          token backslash:Q { <sym> }

sub backslash__S_553Q__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_553Q',$retree) }
sub backslash__S_553Q {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'Q';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_553Q", 
$C->_PATTERN(qr/\GQ/)
);
}
##     token backslash__S_554r (:$sym is context<rw> = 'r')
##          token backslash:r { :i <sym> }

sub backslash__S_554r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_554r',$retree) }
sub backslash__S_554r {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'r';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_554r", 
$C->_PATTERN(qr/\G(?i:r)/)
);
}
##     token backslash__S_555s (:$sym is context<rw> = 's')
##          token backslash:s { :i <sym> }

sub backslash__S_555s__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_555s',$retree) }
sub backslash__S_555s {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 's';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_555s", 
$C->_PATTERN(qr/\G(?i:s)/)
);
}
##     token backslash__S_556t (:$sym is context<rw> = 't')
##          token backslash:t { :i <sym> }

sub backslash__S_556t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_556t',$retree) }
sub backslash__S_556t {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 't';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_556t", 
$C->_PATTERN(qr/\G(?i:t)/)
);
}
##     token backslash__S_557u (:$sym is context<rw> = 'u')
##          token backslash:u { :i <sym> }

sub backslash__S_557u__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_557u',$retree) }
sub backslash__S_557u {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'u';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_557u", 
$C->_PATTERN(qr/\G(?i:u)/)
);
}
##     token backslash__S_558v (:$sym is context<rw> = 'v')
##          token backslash:v { :i <sym> }

sub backslash__S_558v__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_558v',$retree) }
sub backslash__S_558v {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'v';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_558v", 
$C->_PATTERN(qr/\G(?i:v)/)
);
}
##     token backslash__S_559w (:$sym is context<rw> = 'w')
##          token backslash:w { :i <sym> }

sub backslash__S_559w__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_559w',$retree) }
sub backslash__S_559w {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'w';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_559w", 
$C->_PATTERN(qr/\G(?i:w)/)
);
}
##     token backslash__S_560x (:$sym is context<rw> = 'x')
##          token backslash:x { :i <sym> [ <hexint> | '{' [<.ws><hexint><.ws> ] ** ',' '}' ] }

sub backslash__S_560x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_560x',$retree) }
sub backslash__S_560x {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'x';


my $C = $self;
my $S = $C->{_pos};
$C->{'hexint'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_560x", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:x)/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'backslash__S_560x_01') {
$C->deb("Fate passed to backslash__S_560x_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'backslash__S_560x_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("backslash__S_560x_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:\{)/))) {
do {
if (my ($C) = ($C->_REPSEPr(  sub { my $C=shift;
$C->_PATTERN(qr/\G(?i:\,)/)
}, sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
do {
if (my ($C) = ($C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
}))) {
$C->ws;
}
else {
();
}
};
}
else {
();
}
}
})
}))) {
$C->_PATTERN(qr/\G(?i:\})/);
}
else {
();
}
};
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token backslash__S_561z (:$sym is context<rw> = 'z')
##          token backslash:z { :i <sym> }

sub backslash__S_561z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_561z',$retree) }
sub backslash__S_561z {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'z';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_561z", 
$C->_PATTERN(qr/\G(?i:z)/)
);
}
##     token backslash__S_562misc (:$sym is context<rw> = 'misc')
##          token backslash:misc { $<litchar>=(\W) }

sub backslash__S_562misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_562misc',$retree) }
sub backslash__S_562misc {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'misc';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_562misc", 
$C->_SUBSUMEr(['litchar'], sub {
my $C = shift;
do { $C->_PAREN( sub { my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_PATTERN(qr/\G\w/)
})
})}
})
);
}
##     token backslash__S_563oops (:$sym is context<rw> = 'oops')
##          token backslash:oops { <.panic: "Unrecognized Perl 5 regex backslash sequence"> }

sub backslash__S_563oops__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_563oops',$retree) }
sub backslash__S_563oops {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'oops';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "backslash__S_563oops", 
$C->panic("Unrecognized Perl 5 regex backslash sequence")
);
}

##     token assertion__S_564Question (:$sym is context<rw> = <?>)
##          token assertion:sym<?> { <sym> <codeblock> }

sub assertion__S_564Question__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_564Question',$retree) }
sub assertion__S_564Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_564Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
});
}
else {
();
}
}
);
}
##     token assertion__S_565Cur_Ly (:$sym is context<rw> = <{ }>)
##          token assertion:sym<{ }> { <codeblock> }

sub assertion__S_565Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_565Cur_Ly',$retree) }
sub assertion__S_565Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_565Cur_Ly", 
$C->_SUBSUMEr(['codeblock'], sub {
my $C = shift;
$C->codeblock
})
);
}

##     token assertion__S_566Lt (:$sym is context<rw> = <)
##          token assertion:sym< { <sym> <?before '=' | '!'> <assertion> }

sub assertion__S_566Lt__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_566Lt',$retree) }
sub assertion__S_566Lt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['<'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_566Lt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\</))) {
do {
if (my ($C) = ($C->before(sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_566Lt_01') {
$C->deb("Fate passed to assertion__S_566Lt_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_566Lt_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_566Lt_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('=')
},
sub { my $C=shift;
$C->_EXACT('!')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
});
}
else {
();
}
};
}
else {
();
}
}
);
}
##     token assertion__S_567Equal (:$sym is context<rw> = <=>)
##          token assertion:sym<=> { <sym> [ <?before ')'> | <rx> ] }

sub assertion__S_567Equal__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_567Equal',$retree) }
sub assertion__S_567Equal {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_567Equal", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\=/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_567Equal_01') {
$C->deb("Fate passed to assertion__S_567Equal_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_567Equal_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_567Equal_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(')')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_568BangEqual (:$sym is context<rw> = <!=>)
##          token assertion:sym<!=> { <sym> [ <?before ')'> | <rx> ] }

sub assertion__S_568BangEqual__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_568BangEqual',$retree) }
sub assertion__S_568BangEqual {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(!=);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_568BangEqual", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\!\=/))) {
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_568BangEqual_01') {
$C->deb("Fate passed to assertion__S_568BangEqual_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_568BangEqual_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_568BangEqual_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(')')
})
},
sub { my $C=shift;
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
})
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

});
}
else {
();
}
}
);
}
##     token assertion__S_569Gt (:$sym is context<rw> = >)
##          token assertion:sym> { <sym> <rx> }

sub assertion__S_569Gt__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_569Gt',$retree) }
sub assertion__S_569Gt {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} //['>'];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_569Gt", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\>/))) {
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
});
}
else {
();
}
}
);
}

##     token rx
##          token rx {
##              [:lang(self.unbalanced(')')) <nibbler>]
##              [ ')' || <.panic: "Unable to parse Perl 5 regex; couldn't find right parenthesis"> ]
##          }

sub rx__PEEK { $_[0]->_AUTOLEXpeek('rx',$retree) }
sub rx {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "rx", 
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); ;$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
}))) {
$C->_BRACKETr( sub { my $C=shift;
do { my @gather;
eval { push @gather, $C->_EXACT(')')} 
or
eval { push @gather, $C->panic("Unable to parse Perl 5 regex; couldn't find right parenthesis")} or do { die $@ if $@ };
@gather;
}
});
}
else {
();
}
}
);
}

##     token assertion__S_570identifier (:$sym is context<rw> = 'identifier')
##          token assertion:identifier { <identifier> [               # is qq right here?
##                                          | <?before ')' >
##                                          | <.ws> <nibbler>
##      				    ]
##      				    [ ':' <rx> ]?
##          }

sub assertion__S_570identifier__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_570identifier',$retree) }
sub assertion__S_570identifier {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'identifier';


my $C = $self;
my $S = $C->{_pos};
$C->{'rx'} = [];
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_570identifier", 
do {
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
do {
if (my ($C) = ($C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'assertion__S_570identifier_01') {
$C->deb("Fate passed to assertion__S_570identifier_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'assertion__S_570identifier_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("assertion__S_570identifier_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->before(sub { my $C=shift;
$C->_EXACT(')')
})
},
sub { my $C=shift;
do {
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
});
}
else {
();
}
}
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

}))) {
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(':'))) {
$C->_SUBSUMEr(['rx'], sub {
my $C = shift;
$C->rx
});
}
else {
();
}
}
})
});
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token assertion__S_571bogus (:$sym is context<rw> = 'bogus')
##          token assertion:bogus { <.panic: "Unrecognized Perl 5 regex assertion"> }

sub assertion__S_571bogus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_571bogus',$retree) }
sub assertion__S_571bogus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // 'bogus';


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "assertion__S_571bogus", 
$C->panic("Unrecognized Perl 5 regex assertion")
);
}

##     token quantifier__S_572Star (:$sym is context<rw> = <*>)
##          token quantifier:sym<*>  { <sym> <quantmod> }

sub quantifier__S_572Star__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_572Star',$retree) }
sub quantifier__S_572Star {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(*);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_572Star", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\*/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_573Plus (:$sym is context<rw> = <+>)
##          token quantifier:sym<+>  { <sym> <quantmod> }

sub quantifier__S_573Plus__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_573Plus',$retree) }
sub quantifier__S_573Plus {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(+);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_573Plus", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\+/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_574Question (:$sym is context<rw> = <?>)
##          token quantifier:sym<?>  { <sym> <quantmod> }

sub quantifier__S_574Question__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_574Question',$retree) }
sub quantifier__S_574Question {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // q(?);


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_574Question", 
do {
if (my ($C) = ($C->_PATTERN(qr/\G\?/))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
}
);
}
##     token quantifier__S_575Cur_Ly (:$sym is context<rw> = <{ }>)
##          token quantifier:sym<{ }> { '{' \d+ [','\d*]? '}' <quantmod> }

sub quantifier__S_575Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_575Cur_Ly',$retree) }
sub quantifier__S_575Cur_Ly {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;
my %args = @_;
local $sym = $args{sym} // [qw({ })];


my $C = $self;
my $S = $C->{_pos};
$C->{'sym'} = $sym;

$self->_MATCHIFYr($S, "quantifier__S_575Cur_Ly", 
do {
if (my ($C) = ($C->_EXACT('{'))) {
do {
if (my ($C) = ($C->_PATTERN(qr/\G((?:\d)++)/))) {
do {
if (my ($C) = ($C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
if (my ($C) = ($C->_EXACT(','))) {
$C->_PATTERN(qr/\G((?:\d)*+)/);
}
else {
();
}
}
})
}))) {
do {
if (my ($C) = ($C->_EXACT('}'))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
});
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
};
}
else {
();
}
}
);
}

##     token quantmod
##          token quantmod { [ '?' | '+' ]? }

sub quantmod__PEEK { $_[0]->_AUTOLEXpeek('quantmod',$retree) }
sub quantmod {
my $self = shift;
local $CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;


my $C = $self;
my $S = $C->{_pos};

$self->_MATCHIFYr($S, "quantmod", 
$C->_OPTr(sub { my $C=shift;
$C->_BRACKETr( sub { my $C=shift;
do {
my @result = eval {
my $trystate;
my ($tag, $try);
my @try;
my $relex;

my $fate;
if ($fate = $C->{_fate} and $fate->[1] eq 'quantmod_01') {
$C->deb("Fate passed to quantmod_01: ", ::fatestr($fate)) if $DEBUG & DEBUG::fates;
($C->{_fate}, $tag, $try) = @$fate;
@try = ($try);
}

my @gather = ();
for (;;) {
if (not @try) {
$relex //= $C->cursor_fate('STD::P5Regex', 'quantmod_01', $retree);
@try = $relex->($C, $trystate);
}
last unless @try;
$try = shift(@try) // next;

if (ref $try eq 'ARRAY') {
($C->{_fate}, $tag, $try) = @$try;	# next candidate fate
}

$C->deb("quantmod_01 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
push @gather, ((
sub { my $C=shift;
$C->_EXACT('?')
},
sub { my $C=shift;
$C->_EXACT('+')
},
)[$try])->($C);
last if @gather;
}
@gather;
};
if (@result) {
@result;
}
elsif ($@) {
my ($first) = $@ =~ /(^.*)/;
$self->deb("CAUGHT $first") if $::DEBUG & DEBUG::trace_call;
die $@ if $@ !~ /^ABORTBRANCH/;
();
}
else {
();
}
}

})
})
);
}

BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
assertion__S_564Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_564Question
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_564Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_564Question
        i: 0
        min: 12345
        name: codeblock
        r: 1
        rest: ''
        s: 0
assertion__S_565Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: assertion__S_565Cur_Ly
    i: 0
    min: 12345
    name: codeblock
    r: 1
    rest: ''
    s: 0
assertion__S_566Lt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_566Lt
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_566Lt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: <
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: assertion__S_566Lt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &8 !!perl/hash:RE_any 
              a: 0
              altname: assertion__S_566Lt_01
              dba: assertion__S_566Lt
              i: 0
              min: 1
              name: assertion__S_566Lt_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  alt: assertion__S_566Lt_01 0
                  dba: assertion__S_566Lt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_string 
                  a: 0
                  alt: assertion__S_566Lt_01 1
                  dba: assertion__S_566Lt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_566Lt
        i: 0
        min: 12345
        name: assertion
        r: 1
        rest: ''
        s: 0
assertion__S_566Lt_01: *8
assertion__S_567Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_567Equal
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_567Equal
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: =
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &5 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_567Equal_01
          dba: assertion__S_567Equal
          i: 0
          min: 0
          name: assertion__S_567Equal_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_567Equal_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_567Equal
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_567Equal
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_567Equal_01 1
              dba: assertion__S_567Equal
              i: 0
              min: 12345
              name: rx
              r: 1
              rest: ''
              s: 0
assertion__S_567Equal_01: *5
assertion__S_568BangEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_568BangEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_568BangEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!="
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &9 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_568BangEqual_01
          dba: assertion__S_568BangEqual
          i: 0
          min: 0
          name: assertion__S_568BangEqual_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_568BangEqual_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_568BangEqual
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_568BangEqual
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: assertion__S_568BangEqual_01 1
              dba: assertion__S_568BangEqual
              i: 0
              min: 12345
              name: rx
              r: 1
              rest: ''
              s: 0
assertion__S_568BangEqual_01: *9
assertion__S_569Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_569Gt
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_569Gt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ">"
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_569Gt
        i: 0
        min: 12345
        name: rx
        r: 1
        rest: ''
        s: 0
assertion__S_570identifier: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: assertion__S_570identifier
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: assertion__S_570identifier
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &2 !!perl/hash:RE_any 
          a: 0
          altname: assertion__S_570identifier_01
          dba: assertion__S_570identifier
          i: 0
          min: 0
          name: assertion__S_570identifier_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: assertion__S_570identifier_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: assertion__S_570identifier
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: assertion__S_570identifier
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: assertion__S_570identifier_01 1
              dba: assertion__S_570identifier
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: assertion__S_570identifier
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: assertion__S_570identifier
                  i: 0
                  min: 12345
                  name: nibbler
                  r: 1
                  rest: ''
                  s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12346
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: assertion__S_570identifier
            i: 0
            min: 12346
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: assertion__S_570identifier
                i: 0
                min: 1
                r: 1
                s: 0
                text: ":"
              - !!perl/hash:RE_method 
                a: 0
                dba: assertion__S_570identifier
                i: 0
                min: 12345
                name: rx
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
assertion__S_570identifier_01: *2
assertion__S_571bogus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized Perl 5 regex assertion")
atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 1
    re: &3 !!perl/hash:RE_any 
      a: 0
      altname: atom_01
      dba: atom
      i: 0
      min: 1
      name: atom_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_meta 
          a: 0
          alt: atom_01 0
          dba: atom
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        - !!perl/hash:RE_method 
          a: 0
          alt: atom_01 1
          dba: atom
          i: 0
          min: 12345
          name: metachar
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: atom_01 2
          dba: atom
          i: 0
          min: 2
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: atom
              i: 0
              min: 1
              r: 1
              s: 0
              text: \
            - !!perl/hash:RE_meta 
              a: 0
              dba: atom
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_meta 
              a: 0
              dba: atom
              i: 0
              min: 1
              r: 1
              s: 0
              text: .
atom_01: *3
backslash__S_542A: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_542A
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: A
backslash__S_543a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_543a
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: a
backslash__S_544b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_544b
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
backslash__S_545c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: backslash__S_545c
    i: 1
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        dba: backslash__S_545c
        i: 1
        min: 12346
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: backslash__S_545c
            i: 1
            min: 12345
            name: sym
            r: 1
            rest: ''
            s: 0
            sym: c
          - !!perl/hash:RE_cclass 
            a: 0
            dba: backslash__S_545c
            i: 1
            min: 1
            r: 1
            s: 0
            text: "[ ?.._ ]"
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Unrecognized \\c character")
backslash__S_546d: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_546d
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: d
backslash__S_547e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_547e
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: e
backslash__S_548f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_548f
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
backslash__S_549h: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_549h
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: h
backslash__S_550l: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_550l
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: l
backslash__S_551n: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_551n
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: 'n'
backslash__S_552o: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_552o
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: backslash__S_552o
        i: 0
        min: 1
        r: 1
        s: 0
        text: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: &7 !!perl/hash:RE_any 
            a: 0
            altname: backslash__S_552o_01
            dba: backslash__S_552o
            i: 0
            min: 12345
            name: backslash__S_552o_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                alt: backslash__S_552o_01 0
                dba: backslash__S_552o
                i: 0
                min: 12345
                name: octint
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: backslash__S_552o_01 1
                dba: backslash__S_552o
                i: 0
                min: 12347
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: backslash__S_552o
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "{"
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: backslash__S_552o
                    i: 0
                    min: 12345
                    name: octint
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_bracket 
                      decl: []

                      min: 12346
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: backslash__S_552o
                        i: 0
                        min: 12346
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: backslash__S_552o
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: ","
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: backslash__S_552o
                            i: 0
                            min: 12345
                            name: octint
                            r: 1
                            rest: ''
                            s: 0
                    min: 0
                    quant: 
                      - "*"
                      - ":"
                      - ''
                      - 0
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: backslash__S_552o
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "}"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
backslash__S_552o_01: *7
backslash__S_553Q: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_553Q
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: Q
backslash__S_554r: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_554r
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: r
backslash__S_555s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_555s
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: s
backslash__S_556t: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_556t
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: t
backslash__S_557u: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_557u
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: u
backslash__S_558v: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_558v
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: v
backslash__S_559w: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_559w
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: w
backslash__S_560x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: backslash__S_560x
    i: 1
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: backslash__S_560x
        i: 1
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: x
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &6 !!perl/hash:RE_any 
          a: 0
          altname: backslash__S_560x_01
          dba: backslash__S_560x
          i: 1
          min: 12345
          name: backslash__S_560x_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: backslash__S_560x_01 0
              dba: backslash__S_560x
              i: 1
              min: 12345
              name: hexint
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: backslash__S_560x_01 1
              dba: backslash__S_560x
              i: 1
              min: 37037
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_560x
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "{"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 37035
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: backslash__S_560x
                      i: 1
                      min: 37035
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_560x
                          i: 1
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_560x
                          i: 1
                          min: 12345
                          name: hexint
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: backslash__S_560x
                          i: 1
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                  min: 37035
                  quant: 
                    - "**"
                    - ":"
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: backslash__S_560x
                      i: 1
                      min: 1
                      r: 1
                      s: 0
                      text: ","
                    - 1
                - !!perl/hash:RE_string 
                  a: 0
                  dba: backslash__S_560x
                  i: 1
                  min: 1
                  r: 1
                  s: 0
                  text: "}"
backslash__S_560x_01: *6
backslash__S_561z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: backslash__S_561z
    i: 1
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: z
backslash__S_562misc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bindnamed 
    a: 0
    atom: !!perl/hash:RE_paren 
      decl: []

      min: 1
      nobind: 1
      re: !!perl/hash:RE_meta 
        a: 0
        dba: backslash__S_562misc
        i: 0
        min: 1
        r: 1
        s: 0
        text: \W
    dba: backslash__S_562misc
    i: 0
    min: 1
    r: 1
    s: 0
    var: litchar
backslash__S_563oops: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_method 
    min: 0
    name: panic
    nobind: 1
    rest: ("Unrecognized Perl 5 regex backslash sequence")
category__S_525metachar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_525metachar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: metachar
category__S_526backslash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_526backslash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: backslash
category__S_527assertion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_527assertion
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: assertion
category__S_528quantifier: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_528quantifier
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quantifier
category__S_529mod_internal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_529mod_internal
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: mod_internal
codeblock: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: codeblock
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '}'
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: codeblock
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: codeblock
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_meta 
        a: 0
        dba: codeblock
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: codeblock
          i: 0
          lang: ($C->cursor_fresh($+LANG))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($C->cursor_fresh($+LANG));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: codeblock
              i: 0
              lang: ($C->cursor_fresh($+LANG))
              min: 12345
              name: statementlist
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: codeblock
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: codeblock
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse statement list; couldn't find right brace")
infixish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infixish
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: infixstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: infixish
        i: 0
        min: 12345
        name: rxinfix
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infixish
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n            $<O> = $<rxinfix><O>;\n            $<sym> = $<rxinfix><sym>;\n        "
metachar__S_531Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_531Vert
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_531Vert
        i: 0
        min: 1
        r: 1
        s: 0
        text: "|"
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_531Vert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_531Vert
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_532Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_532Thesis
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_532Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: )
      - !!perl/hash:RE_meta 
        a: 0
        dba: metachar__S_532Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_532Thesis
        i: 0
        min: 12345
        name: fail
        r: 1
        rest: ''
        s: 0
metachar__S_533quant: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_533quant
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_533quant
        i: 0
        min: 12345
        name: quantifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("quantifier quantifies nothing")
metachar__S_534Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_534Bra_Ket
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method_re 
        a: 0
        dba: metachar__S_534Bra_Ket
        i: 0
        min: 0
        name: before
        r: 1
        re: !!perl/hash:RE 
          decl: []

          min: 1
          re: !!perl/hash:RE_string 
            a: 0
            dba: metachar__S_534Bra_Ket
            i: 0
            min: 1
            r: 1
            s: 0
            text: "["
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:q))
metachar__S_535ParenQuestion_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_535ParenQuestion_Thesis
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_535ParenQuestion_Thesis
        i: 0
        min: 2
        r: 1
        s: 0
        text: (?
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_535ParenQuestion_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_535ParenQuestion_Thesis
        i: 0
        min: 12345
        name: assertion
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_535ParenQuestion_Thesis
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_535ParenQuestion_Thesis
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Perl 5 regex assertion not terminated by parenthesis")
metachar__S_536Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_536Paren_Thesis
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_536Paren_Thesis
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_536Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: metachar__S_536Paren_Thesis
          i: 0
          lang: ($self->unbalanced(')'))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: metachar__S_536Paren_Thesis
              i: 0
              lang: ($self->unbalanced(')'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: metachar__S_536Paren_Thesis
              i: 0
              lang: ($self->unbalanced(')'))
              min: 12345
              name: nibbler
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: metachar__S_536Paren_Thesis
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: metachar__S_536Paren_Thesis
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse Perl 5 regex; couldn't find right parenthesis")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: metachar__S_536Paren_Thesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $/<sym> := <( )> "
metachar__S_537Back: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_537Back
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_537Back
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: \
      - !!perl/hash:RE_method 
        a: 0
        dba: metachar__S_537Back
        i: 0
        min: 12345
        name: backslash
        r: 1
        rest: ''
        s: 0
metachar__S_538Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_538Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
metachar__S_539Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: metachar__S_539Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
metachar__S_540Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_540Dollar
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: metachar__S_540Dollar
        i: 0
        min: 1
        r: 1
        s: 0
        text: $
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_540Dollar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: &4 !!perl/hash:RE_any 
              a: 0
              altname: metachar__S_540Dollar_01
              dba: metachar__S_540Dollar
              i: 0
              min: 0
              name: metachar__S_540Dollar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_540Dollar_01 0
                  dba: metachar__S_540Dollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \W
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: metachar__S_540Dollar_01 1
                  dba: metachar__S_540Dollar
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $
          s: 0
metachar__S_540Dollar_01: *4
metachar__S_541var: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: metachar__S_541var
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: metachar__S_541var
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12346
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: metachar__S_541var
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: metachar__S_541var
                  i: 0
                  min: 12345
                  name: sigil
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: metachar__S_541var
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \w
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: panic
        nobind: 1
        rest: ("Can't interpolate variable in Perl 5 regex")
nibbler: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $ignorecase is context<rw> = $+ignorecase // 0
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: nibbler
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: nibbler
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
quantified_atom: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantified_atom
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: stopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quantified_atom
          i: 0
          min: 12345
          name: rxinfix
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: atom
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quantified_atom
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: quantified_atom
                i: 0
                min: 12345
                name: quantifier
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: quantified_atom
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
quantifier__S_572Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_572Star
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_572Star
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "*"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_572Star
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_573Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_573Plus
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_573Plus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: +
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_573Plus
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_574Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_574Question
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_574Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_574Question
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantifier__S_575Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quantifier__S_575Cur_Ly
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quantifier__S_575Cur_Ly
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: quantifier__S_575Cur_Ly
          i: 0
          min: 1
          r: 1
          s: 0
          text: \d
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: quantifier__S_575Cur_Ly
            i: 0
            min: 1
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: quantifier__S_575Cur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: ","
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_meta 
                  a: 0
                  dba: quantifier__S_575Cur_Ly
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \d
                min: 0
                quant: 
                  - "*"
                  - ":"
                  - ''
                  - 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_string 
        a: 0
        dba: quantifier__S_575Cur_Ly
        i: 0
        min: 1
        r: 1
        s: 0
        text: "}"
      - !!perl/hash:RE_method 
        a: 0
        dba: quantifier__S_575Cur_Ly
        i: 0
        min: 12345
        name: quantmod
        r: 1
        rest: ''
        s: 0
quantmod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_bracket 
      decl: []

      min: 1
      re: &1 !!perl/hash:RE_any 
        a: 0
        altname: quantmod_01
        dba: quantmod
        i: 0
        min: 1
        name: quantmod_01
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_string 
            a: 0
            alt: quantmod_01 0
            dba: quantmod
            i: 0
            min: 1
            r: 1
            s: 0
            text: "?"
          - !!perl/hash:RE_string 
            a: 0
            alt: quantmod_01 1
            dba: quantmod
            i: 0
            min: 1
            r: 1
            s: 0
            text: +
    min: 0
    quant: 
      - "?"
      - ":"
      - ''
      - 0
quantmod_01: *1
rx: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: rx
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_sequence 
          a: 0
          dba: rx
          i: 0
          lang: ($self->unbalanced(')'))
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_decl 
              a: 0
              dba: rx
              i: 0
              lang: ($self->unbalanced(')'))
              max: 0
              min: 0
              noquant: 1
              r: 1
              s: 0
              text: "my $newlang = ($self->unbalanced(')'));  $C = $C->cursor_fresh($newlang); "
            - !!perl/hash:RE_method 
              a: 0
              dba: rx
              i: 0
              lang: ($self->unbalanced(')'))
              min: 12345
              name: nibbler
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: rx
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: rx
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse Perl 5 regex; couldn't find right parenthesis")
rxinfix__S_530Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: rxinfix__S_530Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
termish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: termish
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: termish
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: termish
          i: 0
          min: 12345
          name: quantified_atom
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
RETREE_END
}
} ## end grammar

# The <panic: "message"> rule is called for syntax errors.
# If there are any <suppose> points, backtrack and retry parse
# with a different supposition.  If it gets farther than the
# panic point, print out the supposition ("Looks like you
# used a Perl5-style shift operator (<<) at line 42.  Maybe
# you wanted +< or |< instead.")  Or some such...
# In any event, this is only for better diagnostics, and
# further compilation is suppressed by the <commit><fail>.

# token panic (Str $s) { <commit> <fail($s)> }

## method panic (Str $s)
sub panic {
my $self = shift;
my $s = shift;


my $m;
my $here = $self;

# Have we backed off recently?
my $highvalid = $self->{_pos} <= $::HIGHWATER;

$here = $self->cursor($::HIGHWATER) if $highvalid;

my $first = $here->lineof($COMPILING::LAST_NIBBLE->{'firstpos'});
my $last = $here->lineof($COMPILING::LAST_NIBBLE->{'lastpos'});
if ($here->lineof($here->{_pos}) == $last and $first != $last) {
$m .= "\n(Possible runaway string from line $first)";
}
else {
$first = $here->lineof($COMPILING::LAST_NIBBLE_MULTILINE->{'firstpos'});
$last = $here->lineof($COMPILING::LAST_NIBBLE_MULTILINE->{'lastpos'});
# the bigger the string (in lines), the further back we suspect it
if ($here->lineof($here->{_pos}) - $last < $last - $first ) {
$m .= "\n(Possible runaway string from line $first to line $last)";
}
}

$m .= "\n" . $s;

if ($highvalid) {
$m .= $::HIGHMESS if $::HIGHMESS;
$::HIGHMESS = $m;
}
else {
# not in backoff, so at "bleeding edge", as it were... therefore probably
# the exception will be caught and re-panicked later, so remember message
$::HIGHMESS .= "\n" . $s;
}

$m .= $here->locmess;

if ($highvalid and %$::HIGHEXPECT) {
my @keys = sort keys %$::HIGHEXPECT;
if (@keys > 1) {
$m .= "\n    expecting any of:\n\t" . join("\n\t", sort keys %$::HIGHEXPECT);
}
else {
$m .= "\n    expecting @keys";
}
}

if (@COMPILING::WORRIES) {
$m .= "\nOther potential difficulties:\n  " . join( "\n  ", @COMPILING::WORRIES);
}

die "############# PARSE FAILED #############" . $m . "\n";
}

## method worry (Str $s)
sub worry {
my $self = shift;
my $s = shift;


push @COMPILING::WORRIES, $s . $self->locmess;
}

## method locmess ()
sub locmess {
my $self = shift;


my $pre = substr($::ORIG, 0, $self->{_pos});
my $line = $self->lineof($self->{_pos});
$pre = substr($pre, -40, 40);
1 while $pre =~ s!.*\n!!;
my $post = substr($::ORIG, $self->{_pos}, 40);
1 while $post =~ s!(\n.*)!!;
" at " . $COMPILING::FILE . " line $line:\n------> " . $Cursor::GREEN . $pre . $Cursor::RED . 
"$post$Cursor::CLEAR";
}

## method lineof ($p)
sub lineof {
my $self = shift;
my $p = shift;


return 1 unless defined $p;
my $line = $MEMOS[$p]{'L'};
return $line if $line;
$line = 1;
my $pos = 0;
my @text = split(qr/^/,$::ORIG);
for (@text) {
$MEMOS[$pos++]{'L'} = $line
for 1 .. length($_);
$line++;
}
return $MEMOS[$p]{'L'} // 0;
}

## method SETGOAL
sub SETGOAL {
my $self = shift;

}
## method FAILGOAL (Str $stop, Str $name)
sub FAILGOAL {
my $self = shift;
my $stop = shift;
my $name = shift;


$self->panic("Unable to parse $name; couldn't find final '$stop'");
}

# "when" arg assumes more things will become obsolete after Perl 6 comes out...
## method obs (Str $old, Str $new, Str $when = ' in Perl 6')
sub obs {
my $self = shift;
my $old = shift;
my $new = shift;
my $when = shift() // ' in Perl 6';


$self->panic("Obsolete use of $old;$when please use $new instead");
}

## method worryobs (Str $old, Str $new, Str $when = ' in Perl 6')
sub worryobs {
my $self = shift;
my $old = shift;
my $new = shift;
my $when = shift() // ' in Perl 6';


$self->worry("Possible obsolete use of $old;$when please use $new instead");
$self;
}

## vim: expandtab sw=4 ft=perl6
BEGIN {
$retree = YAML::Syck::Load(<<'RETREE_END');
--- 
POST: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: POST
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: POST
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " @+MEMOS[$.pos]<ws> "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: &18 !!perl/hash:RE_any 
            a: 0
            altname: POST_01
            dba: POST
            i: 0
            min: 1
            name: POST_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                alt: POST_01 0
                dba: POST
                i: 0
                min: 12345
                name: unsp
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_sequence 
                a: 0
                alt: POST_01 1
                dba: POST
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: POST
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \
                  - !!perl/hash:RE_assertion 
                    assert: "?"
                    min: 0
                    re: !!perl/hash:RE_method_re 
                      a: 0
                      dba: POST
                      i: 0
                      min: 0
                      name: before
                      nobind: 1
                      r: 1
                      re: !!perl/hash:RE 
                        decl: []

                        min: 1
                        re: !!perl/hash:RE_string 
                          a: 0
                          dba: POST
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: .
                      s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: POST
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: POST
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: POST
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: .
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_method 
                          a: 0
                          dba: POST
                          i: 0
                          min: 12345
                          name: unsp
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        min: 0
                        quant: 
                          - "?"
                          - ":"
                          - ''
                          - 0
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_method 
                a: 0
                dba: POST
                i: 0
                min: 12345
                name: postfix_prefix_meta_operator
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: POST
                  i: 0
                  min: 12345
                  name: unsp
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &19 !!perl/hash:RE_any 
          a: 0
          altname: POST_05
          dba: postfix
          i: 0
          min: 12345
          name: POST_05
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: POST_05 0
              dba: postfix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: postfix
                  i: 0
                  min: 12345
                  name: dotty
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: postfix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<dotty><O> "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: POST_05 1
              dba: postfix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: postfix
                  i: 0
                  min: 12345
                  name: privop
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: postfix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<privop><O> "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: POST_05 2
              dba: postfix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: postfix
                  i: 0
                  min: 12345
                  name: postop
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: postfix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<postop><O> "
POST_01: *18
POST_05: *19
PRE: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix or meta-prefix
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &67 !!perl/hash:RE_any 
          a: 0
          altname: PRE_01
          dba: prefix or meta-prefix
          i: 0
          min: 12345
          name: PRE_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: PRE_01 0
              dba: prefix or meta-prefix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: prefix or meta-prefix
                  i: 0
                  min: 12345
                  name: prefix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: prefix or meta-prefix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<prefix><O>; $<sym> = $<prefix><sym> "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'PRE_prefix'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: PRE_01 1
              dba: prefix or meta-prefix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: prefix or meta-prefix
                  i: 0
                  min: 12345
                  name: prefix_circumfix_meta_operator
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: prefix or meta-prefix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<prefix_circumfix_meta_operator><O>; $<sym> = $<prefix_circumfix_meta_operator>.text "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'PRE_precircum'
                  max: 0
                  min: 0
                  name: _REDUCE
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: prefix or meta-prefix
          i: 0
          min: 12345
          name: prefix_postfix_meta_operator
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method_internal 
        args: $S, 'PRE_prepost'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix or meta-prefix
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
PRE_01: *67
apostrophe: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_cclass 
    a: 0
    dba: apostrophe
    i: 0
    min: 1
    r: 1
    s: 0
    text: "[ ' \\- ]"
arglist: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: arglist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my StrPos $endargs is context<rw> = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: arglist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = 'endargs'
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: argument list
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: arglist
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &28 !!perl/hash:RE_any 
          a: 0
          altname: arglist_01
          dba: argument list
          i: 0
          min: 0
          name: arglist_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: arglist_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: argument list
                i: 0
                min: 12345
                name: stdstopper
                nobind: 1
                r: 1
                rest: ''
                s: 0
            - !!perl/hash:RE_method 
              alt: arglist_01 1
              min: 0
              name: EXPR
              rest: (item %list_prefix)
arglist_01: *28
args: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: args
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $listopish = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: args
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = ''
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: "extra arglist after (...):"
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &103 !!perl/hash:RE_any 
          a: 0
          altname: args_01
          dba: argument list
          i: 0
          min: 0
          name: args_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: args_01 0
              dba: argument list
              i: 0
              min: 12348
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: .(
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: argument list
                  extra: "local $::GOAL = ')' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: semilist
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: argument list
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: argument list
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')' , 'argument list')
                - !!perl/hash:RE_method_internal 
                  args: $S, 'args_func_args'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: args_01 1
              dba: argument list
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: argument list
                  extra: "local $::GOAL = ')' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: semilist
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: argument list
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: argument list
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')' , 'argument list')
                - !!perl/hash:RE_method_internal 
                  args: $S, 'args_func_args'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: args_01 2
              dba: argument list
              i: 0
              min: 24692
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: unsp
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_string 
                    a: 0
                    dba: argument list
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: argument list
                  extra: "local $::GOAL = ')' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: argument list
                  i: 0
                  min: 12345
                  name: semilist
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: argument list
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: argument list
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')' , 'argument list')
                - !!perl/hash:RE_method_internal 
                  args: $S, 'args_func_args'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: args_01 3
              dba: argument list
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: argument list
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24690
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: argument list
                      i: 0
                      min: 24690
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: argument list
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_meta 
                                a: 0
                                dba: argument list
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \s
                            s: 0
                        - !!perl/hash:RE_assertion 
                          assert: "!"
                          min: 0
                          re: !!perl/hash:RE_block 
                            a: 0
                            context: bool
                            dba: argument list
                            i: 0
                            min: 0
                            nobind: 1
                            r: 1
                            s: 0
                            text: " $istype "
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: argument list
                          i: 0
                          min: 12345
                          name: ws
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_assertion 
                          assert: "!"
                          min: 0
                          re: !!perl/hash:RE_method 
                            a: 0
                            dba: argument list
                            i: 0
                            min: 12345
                            name: infixstopper
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: argument list
                            i: 0
                            min: 12345
                            name: arglist
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          dba: argument list
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          var: listopargs
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: argument list
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: " $listopish = 1 "
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: "extra arglist after (...):"
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: "extra arglist after (...):"
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: " $listopish "
            - !!perl/hash:RE_sequence 
              a: 0
              dba: "extra arglist after (...):"
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: "extra arglist after (...):"
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ":"
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: "extra arglist after (...):"
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: "extra arglist after (...):"
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \s
                    s: 0
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: "extra arglist after (...):"
                    i: 0
                    min: 12345
                    name: arglist
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  dba: "extra arglist after (...):"
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: listopargs
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: "extra arglist after (...):"
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $<O> = {}; "
args_01: *103
babble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: babble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $lang = $l
    - !!perl/hash:RE_decl 
      a: 0
      dba: babble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $start
    - !!perl/hash:RE_decl 
      a: 0
      dba: babble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $stop
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: babble
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: babble
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: babble
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: babble
                i: 0
                min: 12345
                name: quotepair
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: babble
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: babble
                i: 0
                min: 0
                r: 1
                s: 0
                text: "\n\t    my $kv = $<quotepair>[*-1];\n\t    $lang = $lang.tweak($kv.<k>, $kv.<v>)\n                or self.panic(\"Unrecognized adverb :\" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');\n\t"
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: babble
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        ($start,$stop) = $.peek_delimiters();\n        $lang = $start ne $stop ?? $lang.balanced($start,$stop)\n                                !! $lang.unbalanced($stop);\n        $<B> = [$lang,$start,$stop];\n    "
block: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: block
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: block
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_meta 
        a: 0
        dba: block
        extra: "local $::GOAL = '}' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: block
        i: 0
        min: 12345
        name: statementlist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: block
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: block
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: ('}' , 'block')
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &114 !!perl/hash:RE_any 
          a: 0
          altname: block_01
          dba: block
          i: 0
          min: 0
          name: block_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: block_01 0
              dba: block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: block
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 0
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: block
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: block
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \h
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: block
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: $$
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @+MEMOS[$.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'block_endstmt_simple_'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: block_01 1
              dba: block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: block
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: block
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: block
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_cclass 
                        a: 0
                        dba: block
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[,:]"
                    s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'block_normal_'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: block_01 2
              dba: block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: block
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $$
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @+MEMOS[$.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'block_endstmt_complex'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: block_01 3
              dba: block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: block
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @+MEMOS[$.pos]<endargs> = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'block_endargs'
                  max: 0
                  min: 0
                  name: _REDUCE
block_01: *114
capterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: capterm
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: capterm
        i: 0
        min: 1
        r: 1
        s: 0
        text: \
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &122 !!perl/hash:RE_any 
          a: 0
          altname: capterm_01
          dba: capterm
          i: 0
          min: 2
          name: capterm_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: capterm_01 0
              dba: capterm
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: capterm
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: capterm
                    i: 0
                    min: 12345
                    name: capture
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: capterm
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: )
            - !!perl/hash:RE_sequence 
              a: 0
              alt: capterm_01 1
              dba: capterm
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: capterm
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: capterm
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \S
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: capterm
                  i: 0
                  min: 12345
                  name: termish
                  r: 1
                  rest: ''
                  s: 0
capterm_01: *122
capture: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: capture
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: capture
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
category__S_000category: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_000category
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: category
category__S_001sigil: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_001sigil
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: sigil
category__S_002twigil: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_002twigil
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: twigil
category__S_003special_variable: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_003special_variable
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: special_variable
category__S_004version: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_004version
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: version
category__S_005module_name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_005module_name
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: module_name
category__S_006term: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_006term
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: term
category__S_007quote: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_007quote
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quote
category__S_008prefix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_008prefix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: prefix
category__S_009infix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_009infix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix
category__S_010postfix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_010postfix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: postfix
category__S_011dotty: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_011dotty
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: dotty
category__S_012circumfix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_012circumfix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: circumfix
category__S_013postcircumfix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_013postcircumfix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: postcircumfix
category__S_014quote_mod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_014quote_mod
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: quote_mod
category__S_015trait_verb: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_015trait_verb
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: trait_verb
category__S_016trait_auxiliary: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_016trait_auxiliary
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: trait_auxiliary
category__S_017type_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_017type_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: type_declarator
category__S_018scope_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_018scope_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: scope_declarator
category__S_019package_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_019package_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: package_declarator
category__S_020multi_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_020multi_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: multi_declarator
category__S_021routine_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_021routine_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: routine_declarator
category__S_022regex_declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_022regex_declarator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: regex_declarator
category__S_023statement_prefix: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_023statement_prefix
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_prefix
category__S_024statement_control: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_024statement_control
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_control
category__S_025statement_mod_cond: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_025statement_mod_cond
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_mod_cond
category__S_026statement_mod_loop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_026statement_mod_loop
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: statement_mod_loop
category__S_027infix_prefix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_027infix_prefix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix_prefix_meta_operator
category__S_028infix_postfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_028infix_postfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix_postfix_meta_operator
category__S_029infix_circumfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_029infix_circumfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: infix_circumfix_meta_operator
category__S_030postfix_prefix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_030postfix_prefix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: postfix_prefix_meta_operator
category__S_031prefix_postfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_031prefix_postfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: prefix_postfix_meta_operator
category__S_032prefix_circumfix_meta_operator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_032prefix_circumfix_meta_operator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: prefix_circumfix_meta_operator
category__S_033terminator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: category__S_033terminator
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: terminator
circumfix__S_094Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: circumfix__S_094Cur_Ly
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: circumfix__S_094Cur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &41 !!perl/hash:RE_any 
              a: 0
              altname: circumfix__S_094Cur_Ly_01
              dba: circumfix__S_094Cur_Ly
              i: 0
              min: 1
              name: circumfix__S_094Cur_Ly_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  alt: circumfix__S_094Cur_Ly_01 0
                  dba: circumfix__S_094Cur_Ly
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "{"
                - !!perl/hash:RE_method 
                  a: 0
                  alt: circumfix__S_094Cur_Ly_01 1
                  dba: circumfix__S_094Cur_Ly
                  i: 0
                  min: 12345
                  name: lambda
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: circumfix__S_094Cur_Ly
        i: 0
        min: 12345
        name: pblock
        r: 1
        rest: ''
        s: 0
circumfix__S_094Cur_Ly_01: *41
circumfix__S_273sigil: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24692
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: contextualizer
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: contextualizer
        i: 0
        min: 12345
        name: sigil
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: contextualizer
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: contextualizer
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: contextualizer
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: contextualizer
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: contextualizer
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'contextualizer')
circumfix__S_274Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: parenthesized expression
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: parenthesized expression
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: parenthesized expression
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: parenthesized expression
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: parenthesized expression
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: parenthesized expression
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'parenthesized expression')
circumfix__S_275Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: array composer
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: array composer
        i: 0
        min: 1
        r: 1
        s: 0
        text: "["
      - !!perl/hash:RE_meta 
        a: 0
        dba: array composer
        extra: "local $::GOAL = ']' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: array composer
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: array composer
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: array composer
              i: 0
              min: 1
              r: 1
              s: 0
              text: "]"
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (']' , 'array composer')
codepoint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: codepoint
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: codepoint
        i: 0
        min: 1
        r: 1
        s: 0
        text: "["
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: codepoint
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 0
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_sequence 
                a: 0
                dba: codepoint
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_assertion 
                    assert: "!"
                    min: 0
                    re: !!perl/hash:RE_method_re 
                      a: 0
                      dba: codepoint
                      i: 0
                      min: 0
                      name: before
                      nobind: 1
                      r: 1
                      re: !!perl/hash:RE 
                        decl: []

                        min: 1
                        re: !!perl/hash:RE_string 
                          a: 0
                          dba: codepoint
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "]"
                      s: 0
                  - !!perl/hash:RE_meta 
                    a: 0
                    dba: codepoint
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .
            min: 0
            quant: 
              - "*"
              - "?"
              - ''
              - 0
        min: 0
        var: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: codepoint
        i: 0
        min: 1
        r: 1
        s: 0
        text: "]"
colonpair: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: colonpair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $key
    - !!perl/hash:RE_decl 
      a: 0
      dba: colonpair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $value
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: colon pair
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: colonpair
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &32 !!perl/hash:RE_any 
          a: 0
          altname: colonpair_01
          dba: signature
          i: 0
          min: 12345
          name: colonpair_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 0
              dba: colon pair
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.text; $value = 0; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair_false'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 1
              dba: colon pair
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: colon pair
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  dba: colon pair
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: num
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 2
              dba: colon pair
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.text; "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: colon pair
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: colon pair
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: colon pair
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_string 
                              a: 0
                              dba: colon pair
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: .
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: colon pair
                            i: 0
                            min: 12345
                            name: postcircumfix
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: colon pair
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $value = $<postcircumfix>; "
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: colon pair
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $value = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair_value'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 3
              dba: signature
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: signature
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: signature
                  extra: "local $::GOAL = ')' "
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: signature
                  i: 0
                  min: 12345
                  name: signature
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: signature
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: signature
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')' , 'signature')
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 4
              dba: signature
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: signature
                  i: 0
                  min: 12345
                  name: postcircumfix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: signature
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = \"\"; $value = $<postcircumfix>; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair_structural'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: colonpair_01 5
              dba: signature
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 24690
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: signature
                      i: 0
                      min: 24690
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: signature
                          i: 0
                          min: 12345
                          name: sigil
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: signature
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: signature
                            i: 0
                            min: 12345
                            name: twigil
                            r: 1
                            rest: ''
                            s: 0
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: signature
                          i: 0
                          min: 12345
                          name: desigilname
                          r: 1
                          rest: ''
                          s: 0
                  dba: signature
                  i: 0
                  min: 24690
                  r: 1
                  s: 0
                  var: var
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: signature
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<var><desigilname>.text; $value = $<var>; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'colonpair_varname'
                  max: 0
                  min: 0
                  name: _REDUCE
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: colon pair
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<k> = $key; $<v> = $value; "
colonpair_01: *32
comp_unit: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $begin_compunit is context = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $endargs        is context<rw> = -1
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $LANG is context
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $PKGDECL is context = ""
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $PKG is context = ""
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $GOAL is context = "(eof)"
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $PARSER is context<rw>
    - !!perl/hash:RE_decl 
      a: 0
      dba: comp_unit
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw>
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: comp_unit
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: comp_unit
        i: 0
        min: 0
        r: 1
        s: 1
        text: " init_pads(); "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: comp_unit
        i: 0
        min: 12345
        name: statementlist
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: comp_unit
          i: 0
          min: 0
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: comp_unit
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method 
                    a: 0
                    dba: comp_unit
                    i: 0
                    min: 12345
                    name: unitstopper
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              dba: comp_unit
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Can't understand next input--giving up")
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: comp_unit
        i: 0
        min: 0
        r: 1
        s: 1
        text: "\n        if @COMPILING::WORRIES {\n            warn \"Potential difficulties:\\n  \" ~ join( \"\\n  \", @COMPILING::WORRIES) ~ \"\\n\";\n        }\n\n        my %UNKNOWN;\n        for keys(%ROUTINES) {\n            next if $.is_routine($_);\n            %UNKNOWN{$_} = %ROUTINES{$_};\n        }\n        if %UNKNOWN {\n            warn \"Unknown routines:\\n\";\n            for sort keys(%UNKNOWN) {\n                warn \"\\t$_ called at \", %UNKNOWN{$_}, \"\\n\";\n            }\n        }\n    "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
dec_number: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 2
    re: &111 !!perl/hash:RE_any 
      a: 0
      altname: dec_number_01
      dba: decimal number
      i: 0
      min: 2
      name: dec_number_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: dec_number_01 0
          dba: decimal number
          i: 0
          min: 2
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_bindnamed 
              a: 0
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 2
                nobind: 1
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: decimal number
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: decimal number
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: .
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: decimal number
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_bracket 
                        decl: []

                        min: 2
                        re: !!perl/hash:RE_sequence 
                          a: 0
                          dba: decimal number
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: _
                            - !!perl/hash:RE_quantified_atom 
                              atom: !!perl/hash:RE_meta 
                                a: 0
                                dba: decimal number
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \d
                              min: 1
                              quant: 
                                - +
                                - ":"
                                - ''
                                - 1
                      min: 0
                      quant: 
                        - "*"
                        - ":"
                        - ''
                        - 0
              dba: decimal number
              i: 0
              min: 2
              r: 1
              s: 0
              var: coeff
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: decimal number
                i: 0
                min: 12345
                name: escale
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: dec_number_01 1
          dba: decimal number
          i: 0
          min: 3
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_bindnamed 
              a: 0
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 3
                nobind: 1
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: decimal number
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: decimal number
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_bracket 
                        decl: []

                        min: 2
                        re: !!perl/hash:RE_sequence 
                          a: 0
                          dba: decimal number
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: _
                            - !!perl/hash:RE_quantified_atom 
                              atom: !!perl/hash:RE_meta 
                                a: 0
                                dba: decimal number
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \d
                              min: 1
                              quant: 
                                - +
                                - ":"
                                - ''
                                - 1
                      min: 0
                      quant: 
                        - "*"
                        - ":"
                        - ''
                        - 0
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: decimal number
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: .
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: decimal number
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_bracket 
                        decl: []

                        min: 2
                        re: !!perl/hash:RE_sequence 
                          a: 0
                          dba: decimal number
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: _
                            - !!perl/hash:RE_quantified_atom 
                              atom: !!perl/hash:RE_meta 
                                a: 0
                                dba: decimal number
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \d
                              min: 1
                              quant: 
                                - +
                                - ":"
                                - ''
                                - 1
                      min: 0
                      quant: 
                        - "*"
                        - ":"
                        - ''
                        - 0
              dba: decimal number
              i: 0
              min: 3
              r: 1
              s: 0
              var: coeff
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: decimal number
                i: 0
                min: 12345
                name: escale
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: dec_number_01 2
          dba: decimal number
          i: 0
          min: 12346
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_bindnamed 
              a: 0
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 1
                nobind: 1
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: decimal number
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: decimal number
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_bracket 
                        decl: []

                        min: 2
                        re: !!perl/hash:RE_sequence 
                          a: 0
                          dba: decimal number
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: decimal number
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: _
                            - !!perl/hash:RE_quantified_atom 
                              atom: !!perl/hash:RE_meta 
                                a: 0
                                dba: decimal number
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \d
                              min: 1
                              quant: 
                                - +
                                - ":"
                                - ''
                                - 1
                      min: 0
                      quant: 
                        - "*"
                        - ":"
                        - ''
                        - 0
              dba: decimal number
              i: 0
              min: 1
              r: 1
              s: 0
              var: coeff
            - !!perl/hash:RE_method 
              a: 0
              dba: decimal number
              i: 0
              min: 12345
              name: escale
              r: 1
              rest: ''
              s: 0
dec_number_01: *111
declarator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &13 !!perl/hash:RE_any 
      a: 0
      altname: declarator_01
      dba: declarator
      i: 0
      min: 12345
      name: declarator_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: declarator_01 0
          dba: declarator
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: declarator
              i: 0
              min: 12345
              name: variable_declarator
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: declarator
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $<SIGIL> = $<variable_declarator><SIGIL> "
        - !!perl/hash:RE_sequence 
          a: 0
          alt: declarator_01 1
          dba: declarator
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: declarator
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
            - !!perl/hash:RE_meta 
              a: 0
              dba: declarator
              extra: "local $::GOAL = ')' "
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_method 
              a: 0
              dba: declarator
              i: 0
              min: 12345
              name: signature
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_first 
                a: 0
                dba: declarator
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: declarator
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                  - !!perl/hash:RE_method 
                    min: 0
                    name: FAILGOAL
                    nobind: 1
                    rest: (')' , 'declarator')
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: declarator
                i: 0
                min: 12345
                name: trait
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 2
          dba: declarator
          i: 0
          min: 12345
          name: routine_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 3
          dba: declarator
          i: 0
          min: 12345
          name: regex_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: declarator_01 4
          dba: declarator
          i: 0
          min: 12345
          name: type_declarator
          r: 1
          rest: ''
          s: 0
declarator_01: *13
default_value: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: default_value
    i: 0
    min: 1
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_string 
        a: 0
        dba: default_value
        i: 0
        min: 1
        r: 1
        s: 1
        text: =
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: EXPR
        rest: (item %item_assignment)
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
deflongname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: name to be defined
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: name to be defined
        i: 0
        min: 12345
        name: name
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: name to be defined
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: name to be defined
                  i: 0
                  min: 12345
                  name: colonpair
                  r: 1
                  rest: ''
                  s: 0
                min: 12345
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: name to be defined
                i: 0
                min: 0
                r: 1
                s: 0
                text: " $.add_macro($<name>) if $+IN_DECL; "
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: name to be defined
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $.add_routine($<name>.text) if $+IN_DECL; "
desigilname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &95 !!perl/hash:RE_any 
      a: 0
      altname: desigilname_01
      dba: desigilname
      i: 0
      min: 12345
      name: desigilname_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: desigilname_01 0
          dba: desigilname
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: desigilname
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: desigilname
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: $
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: desigilname
              i: 0
              min: 12345
              name: variable
              r: 1
              rest: ''
              s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: desigilname_01 1
          dba: desigilname
          i: 0
          min: 12345
          name: longname
          r: 1
          rest: ''
          s: 0
desigilname_01: *95
dotty__S_079DotStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24692
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: dotty__S_079DotStar
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: dotty__S_079DotStar
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: dotty__S_079DotStar
                i: 0
                min: 1
                r: 1
                s: 0
                text: .
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: &106 !!perl/hash:RE_any 
                  a: 0
                  altname: dotty__S_079DotStar_02
                  dba: dotty__S_079DotStar
                  i: 0
                  min: 1
                  name: dotty__S_079DotStar_02
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_cclass 
                      a: 0
                      alt: dotty__S_079DotStar_02 0
                      dba: dotty__S_079DotStar
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "[+*?=:]"
                    - !!perl/hash:RE_sequence 
                      a: 0
                      alt: dotty__S_079DotStar_02 1
                      dba: dotty__S_079DotStar
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: dotty__S_079DotStar
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "^"
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: dotty__S_079DotStar
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "!"
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
        min: 2
        var: 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: dotty__S_079DotStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_079DotStar
        i: 0
        min: 12345
        name: unspacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_079DotStar
        i: 0
        min: 12345
        name: dottyop
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: dotty__S_079DotStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<sym> = $0.item; "
dotty__S_079DotStar_02: *106
dotty__S_080Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: dotty__S_080Dot
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_080Dot
        endsym: unspacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: .
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_080Dot
        i: 0
        min: 12345
        name: unspacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: dotty__S_080Dot
        i: 0
        min: 12345
        name: dottyop
        r: 1
        rest: ''
        s: 0
dottyop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &99 !!perl/hash:RE_any 
      a: 0
      altname: dottyop_01
      dba: dotty method or postfix
      i: 0
      min: 12345
      name: dottyop_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: dottyop_01 0
          dba: dotty method or postfix
          i: 0
          min: 12345
          name: methodop
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: dottyop_01 1
          dba: dotty method or postfix
          i: 0
          min: 12345
          name: postop
          r: 1
          rest: ''
          s: 0
dottyop_01: *99
eat_terminator: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: !!perl/hash:RE_first 
      a: 0
      dba: eat_terminator
      i: 0
      min: 0
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_string 
          a: 0
          dba: eat_terminator
          i: 0
          min: 1
          r: 1
          s: 0
          text: ;
        - !!perl/hash:RE_sequence 
          a: 0
          dba: eat_terminator
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: eat_terminator
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: " @+MEMOS[$.pos]<endstmt> "
            - !!perl/hash:RE_method 
              a: 0
              dba: eat_terminator
              i: 0
              min: 12345
              name: ws
              nobind: 1
              r: 1
              rest: ''
              s: 0
        - !!perl/hash:RE_assertion 
          assert: "?"
          min: 0
          re: !!perl/hash:RE_method 
            a: 0
            dba: eat_terminator
            i: 0
            min: 12345
            name: terminator
            nobind: 1
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_meta 
          a: 0
          dba: eat_terminator
          i: 0
          min: 0
          r: 1
          s: 0
          text: $
        - !!perl/hash:RE_sequence 
          a: 0
          dba: eat_terminator
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: eat_terminator
              i: 0
              min: 0
              r: 1
              s: 0
              text: " if @+MEMOS[$.pos]<ws> { $.pos = @+MEMOS[$.pos]<ws>; } "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Syntax error")
escale: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: escale
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_cclass 
        a: 0
        dba: escale
        i: 0
        min: 1
        r: 1
        s: 0
        text: "[Ee]"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: escale
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[+\\-]"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: escale
          i: 0
          min: 1
          r: 1
          s: 0
          text: \d
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: escale
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: escale
                i: 0
                min: 1
                r: 1
                s: 0
                text: _
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_meta 
                  a: 0
                  dba: escale
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \d
                min: 1
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
escape__S_177none: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: escape__S_177none
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
extrapost: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: extrapost
      i: 0
      max: 0
      min: 0
      r: 0
      s: 0
      text: my $inquote is context = 1
  kind: regex
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: extrapost
    i: 0
    min: 0
    r: 0
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: extrapost
          i: 0
          min: 12345
          name: POST
          r: 0
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - "!"
          - ''
          - 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: extrapost
          i: 0
          min: 0
          name: after
          nobind: 1
          r: 0
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: extrapost
              i: 0
              min: 1
              r: 0
              s: 0
              text: "[ \\] } > ) ]"
          s: 0
fatarrow: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24692
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: fatarrow
    i: 0
    min: 24692
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          a: 0
          dba: fatarrow
          i: 0
          min: 12345
          name: identifier
          nobind: 1
          r: 1
          rest: ''
          s: 0
        dba: fatarrow
        i: 0
        min: 12345
        r: 1
        s: 0
        var: key
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: fatarrow
          i: 0
          min: 1
          r: 1
          s: 0
          text: \h
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_string 
        a: 0
        dba: fatarrow
        i: 0
        min: 2
        r: 1
        s: 0
        text: =>
      - !!perl/hash:RE_method 
        a: 0
        dba: fatarrow
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: EXPR
          nobind: 1
          rest: (item %item_assignment)
        dba: fatarrow
        i: 0
        min: 0
        r: 1
        s: 0
        var: val
foo: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24699
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: foo
    i: 0
    min: 24699
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: foo
        i: 0
        min: 3
        r: 1
        s: 0
        text: foo
      - !!perl/hash:RE_method 
        a: 0
        dba: foo
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: foo
        i: 0
        min: 3
        r: 1
        s: 0
        text: bar
      - !!perl/hash:RE_method 
        a: 0
        dba: foo
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: foo
        i: 0
        min: 3
        r: 1
        s: 0
        text: baz
fulltypename: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: fulltypename
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: fulltypename
        i: 0
        min: 12345
        name: typename
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12346
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: fulltypename
            i: 0
            min: 12346
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: fulltypename
                i: 0
                min: 1
                r: 1
                s: 1
                text: "|"
              - !!perl/hash:RE_method 
                a: 0
                dba: fulltypename
                i: 0
                min: 12345
                name: typename
                r: 1
                rest: ''
                s: 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12347
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: fulltypename
            i: 0
            min: 12347
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_string 
                a: 0
                dba: fulltypename
                i: 0
                min: 2
                r: 1
                s: 1
                text: of
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                a: 0
                dba: fulltypename
                i: 0
                min: 12345
                name: fulltypename
                r: 1
                rest: ''
                s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
hexint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: hexint
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: hexint
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[ 0..9 a..f A..F ]"
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: hexint
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: hexint
                i: 0
                min: 1
                r: 1
                s: 0
                text: _
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_cclass 
                  a: 0
                  dba: hexint
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "[ 0..9 a..f A..F ]"
                min: 1
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
ident: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: ident
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: ident
        i: 0
        min: 12345
        name: alpha
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: ident
          i: 0
          min: 1
          r: 1
          s: 0
          text: \w
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
identifier: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: identifier
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: identifier
        i: 0
        min: 12345
        name: ident
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: identifier
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: identifier
                i: 0
                min: 12345
                name: apostrophe
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: identifier
                i: 0
                min: 12345
                name: ident
                nobind: 1
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
infix__S_276Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_276Dot
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: infix__S_276Dot
        i: 0
        min: 1
        r: 1
        s: 0
        text: .
      - !!perl/hash:RE_cclass 
        a: 0
        dba: infix__S_276Dot
        i: 0
        min: 1
        r: 1
        s: 0
        text: "[\\]\\)\\},:\\s\\$\"']"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('. to concatenate strings', '~')
infix__S_283StarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Exponentiation
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_283StarStar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "**"
infix__S_295Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_295Star
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "*"
infix__S_296Slash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_296Slash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: /
infix__S_297Percent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_297Percent
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "%"
infix__S_298PlusAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_298PlusAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +&
infix__S_299PlusLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_299PlusLt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +<
infix__S_300LtLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_300LtLt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_300LtLt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: <<
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('<< to do left shift', '+< or ~<')
infix__S_301GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_301GtGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_301GtGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ">>"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('>> to do right shift', '+> or ~>')
infix__S_302PlusGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_302PlusGt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +>
infix__S_303TildeAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_303TildeAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~&
infix__S_304QuestionAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_304QuestionAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?&
infix__S_305TildeLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_305TildeLt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~<
infix__S_306TildeGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Multiplicative
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_306TildeGt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~>
infix__S_307Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_307Plus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +
infix__S_308Minus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_308Minus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "-"
infix__S_309PlusVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_309PlusVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +|
infix__S_310PlusCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_310PlusCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +^
infix__S_311TildeVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_311TildeVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~|
infix__S_312TildeCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_312TildeCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~^
infix__S_313QuestionVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_313QuestionVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?|
infix__S_314QuestionCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Additive
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_314QuestionCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?^
infix__S_315x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Replication
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_315x
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: x
infix__S_316xx: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Replication
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_316xx
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: xx
infix__S_317Tilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Concatenation
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_317Tilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '~'
infix__S_318Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_318Amp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&"
infix__S_319also: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_319also
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: also
infix__S_320Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_320Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
infix__S_321Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Junctive_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_321Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
infix__S_327LtEqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_327LtEqualGt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <=>
infix__S_328cmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_328cmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: cmp
infix__S_329leg: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_329leg
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: leg
infix__S_330but: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_330but
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: but
infix__S_331does: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_331does
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: does
infix__S_332DotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_332DotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ..
infix__S_333CaretDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_333CaretDotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^.."
infix__S_334DotDotCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_334DotDotCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ..^
infix__S_335CaretDotDotCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_335CaretDotDotCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^..^"
infix__S_336ff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_336ff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ff
infix__S_337Caretff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_337Caretff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^ff"
infix__S_338ffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_338ffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ff^
infix__S_339CaretffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_339CaretffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^ff^"
infix__S_340fff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_340fff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: fff
infix__S_341Caretfff: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_341Caretfff
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^fff"
infix__S_342fffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_342fffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: fff^
infix__S_343CaretfffCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Nonchaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_343CaretfffCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^fff^"
infix__S_344EqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_344EqualEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ==
infix__S_345BangEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_345BangEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "!="
infix__S_346Lt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_346Lt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <
infix__S_347LtEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_347LtEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <=
infix__S_348Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_348Gt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ">"
infix__S_349GtEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_349GtEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ">="
infix__S_350TildeTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_350TildeTilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~~
infix__S_351BangTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_351BangTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_351BangTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!~"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('!~ to do negated pattern matching', '!~~')
infix__S_352EqualTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_352EqualTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_352EqualTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: =~
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('=~ to do pattern matching', '~~')
infix__S_353eq: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_353eq
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: eq
infix__S_354ne: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_354ne
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ne
infix__S_355lt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_355lt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: lt
infix__S_356le: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_356le
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: le
infix__S_357gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_357gt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: gt
infix__S_358ge: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_358ge
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ge
infix__S_359EqualColonEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_359EqualColonEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: =:=
infix__S_360EqualEqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_360EqualEqualEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ===
infix__S_361eqv: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Chaining
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_361eqv
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: eqv
infix__S_362AmpAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_362AmpAmp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&&"
infix__S_363VertVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_363VertVert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "||"
infix__S_364CaretCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_364CaretCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_364CaretCaret
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "^^"
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_364CaretCaret
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<O><assoc> := 'list' "
infix__S_365SlashSlash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_365SlashSlash
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: //
infix__S_366min: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_366min
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: min
infix__S_367max: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Tight_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_367max
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: max
infix__S_368QuestionQuestion_BangBang: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: infix__S_368QuestionQuestion_BangBang
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '!!'
  kind: token
  min: 12347
  pkg: STD::Conditional
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_368QuestionQuestion_BangBang
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: infix__S_368QuestionQuestion_BangBang
        i: 0
        min: 2
        r: 1
        s: 0
        text: ??
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_368QuestionQuestion_BangBang
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: EXPR
        rest: (item %item_assignment)
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix__S_368QuestionQuestion_BangBang
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: infix__S_368QuestionQuestion_BangBang
              i: 0
              min: 2
              r: 1
              s: 0
              text: "!!"
            - !!perl/hash:RE_bracket 
              decl: []

              min: 0
              re: !!perl/hash:RE_first 
                a: 0
                dba: infix__S_368QuestionQuestion_BangBang
                i: 0
                min: 0
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_sequence 
                    a: 0
                    dba: infix__S_368QuestionQuestion_BangBang
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: infix__S_368QuestionQuestion_BangBang
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 1
                            re: !!perl/hash:RE_string 
                              a: 0
                              dba: infix__S_368QuestionQuestion_BangBang
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: =
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Assignment not allowed within ??!!")
                  - !!perl/hash:RE_sequence 
                    a: 0
                    dba: infix__S_368QuestionQuestion_BangBang
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: infix__S_368QuestionQuestion_BangBang
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_string 
                              a: 0
                              dba: infix__S_368QuestionQuestion_BangBang
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              text: "::"
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Please use !! rather than ::")
                  - !!perl/hash:RE_sequence 
                    a: 0
                    dba: infix__S_368QuestionQuestion_BangBang
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: infix__S_368QuestionQuestion_BangBang
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 12345
                            re: !!perl/hash:RE_method 
                              a: 0
                              dba: infix__S_368QuestionQuestion_BangBang
                              i: 0
                              min: 12345
                              name: infix
                              r: 1
                              rest: ''
                              s: 0
                          s: 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Precedence too loose within ??!!; use ??()!! instead ")
                  - !!perl/hash:RE_method 
                    min: 0
                    name: panic
                    nobind: 1
                    rest: ("Found ?? but no !!; possible precedence problem")
infix__S_369Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Conditional
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_369Question
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_369Question
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "?"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: "('?: for the conditional operator', '??!!')"
infix__S_370Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_370Equal
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_370Equal
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: =
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_370Equal
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $ = (self.<SIGIL> // self.<sigil> // '') eq '$' \n        ?? STD::Item_assignment.coerce($)\n        !! STD::List_assignment.coerce($);\n    "
infix__S_371ColonEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_371ColonEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: :=
infix__S_372ColonColonEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_372ColonColonEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ::=
infix__S_373DotEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_373DotEqual
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_373DotEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: .=
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_373DotEqual
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix__S_373DotEqual
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: infix__S_373DotEqual
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 2
                  re: &51 !!perl/hash:RE_any 
                    a: 0
                    altname: infix__S_373DotEqual_02
                    dba: infix__S_373DotEqual
                    i: 0
                    min: 2
                    name: infix__S_373DotEqual_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: infix__S_373DotEqual_02 0
                        dba: infix__S_373DotEqual
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: infix__S_373DotEqual
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \w
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: infix__S_373DotEqual
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: ;
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_373DotEqual_02 1
                        dba: infix__S_373DotEqual
                        i: 0
                        min: 3
                        r: 1
                        s: 0
                        text: new
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_373DotEqual_02 2
                        dba: infix__S_373DotEqual
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: sort
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_373DotEqual_02 3
                        dba: infix__S_373DotEqual
                        i: 0
                        min: 5
                        r: 1
                        s: 0
                        text: subst
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_373DotEqual_02 4
                        dba: infix__S_373DotEqual
                        i: 0
                        min: 5
                        r: 1
                        s: 0
                        text: trans
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_373DotEqual_02 5
                        dba: infix__S_373DotEqual
                        i: 0
                        min: 7
                        r: 1
                        s: 0
                        text: reverse
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_373DotEqual_02 6
                        dba: infix__S_373DotEqual
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: uniq
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_373DotEqual_02 7
                        dba: infix__S_373DotEqual
                        i: 0
                        min: 3
                        r: 1
                        s: 0
                        text: map
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_373DotEqual_02 8
                        dba: infix__S_373DotEqual
                        i: 0
                        min: 8
                        r: 1
                        s: 0
                        text: samecase
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix__S_373DotEqual_02 9
                        dba: infix__S_373DotEqual
                        i: 0
                        min: 6
                        r: 1
                        s: 0
                        text: substr
                s: 0
            - !!perl/hash:RE_method 
              min: 0
              name: worryobs
              rest: ('.= as append operator', '~=')
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix__S_373DotEqual
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<O><nextterm> = 'dottyop' "
infix__S_373DotEqual_02: *51
infix__S_374EqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_374EqualGt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: =>
infix__S_377Comma: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Comma
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_377Comma
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ","
infix__S_378Colon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Comma
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_378Colon
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ":"
infix__S_379p5EqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Comma
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_379p5EqualGt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: p5=>
infix__S_380X: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_380X
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: X
infix__S_381Z: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_381Z
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: Z
infix__S_382minmax: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_382minmax
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: minmax
infix__S_383DotDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_infix
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_383DotDotDot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ...
infix__S_391and: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_391and
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: and
infix__S_392andthen: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_392andthen
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: andthen
infix__S_393andthen: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_and
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_393andthen
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: andthen
infix__S_394or: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_394or
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: or
infix__S_395orelse: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_395orelse
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: orelse
infix__S_396xor: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_396xor
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: xor
infix__S_397orelse: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_or
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_397orelse
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: orelse
infix__S_398Semi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_398Semi
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ;
infix__S_399LtEqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_399LtEqualEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <==
infix__S_400EqualEqualGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_400EqualEqualGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_400EqualEqualGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ==>
      - !!perl/hash:RE_method_internal 
        args: $S, 'infix__S_400EqualEqualGt'
        max: 0
        min: 0
        name: _REDUCE
infix__S_401LtLtEqualEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_method 
    a: 0
    dba: infix__S_401LtLtEqualEqual
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: <<==
infix__S_402EqualEqualGtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Sequencer
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix__S_402EqualEqualGtGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix__S_402EqualEqualGtGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ==>>
      - !!perl/hash:RE_method_internal 
        args: $S, 'infix__S_402EqualEqualGtGt'
        max: 0
        min: 0
        name: _REDUCE
infix_circumfix_meta_operator__S_085X_X: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::List_infix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_circumfix_meta_operator__S_085X_X
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: infix_circumfix_meta_operator__S_085X_X
        i: 0
        min: 1
        r: 1
        s: 0
        text: X
      - !!perl/hash:RE_method 
        a: 0
        dba: infix_circumfix_meta_operator__S_085X_X
        i: 0
        min: 12345
        name: infix
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: infix_circumfix_meta_operator__S_085X_X
        i: 0
        min: 1
        r: 1
        s: 0
        text: X
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_block 
            a: 0
            context: bool
            dba: infix_circumfix_meta_operator__S_085X_X
            i: 0
            min: 0
            nobind: 1
            r: 1
            s: 0
            text: " $<O> = $<infix><O>; "
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_method 
            min: 0
            name: lex1
            nobind: 1
            rest: ('cross')
infix_circumfix_meta_operator__S_086Fre_Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Hyper
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_circumfix_meta_operator__S_086Fre_Nch
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12347
        re: &42 !!perl/hash:RE_any 
          a: 0
          altname: infix_circumfix_meta_operator__S_086Fre_Nch_01
          dba: infix_circumfix_meta_operator__S_086Fre_Nch
          i: 0
          min: 12347
          name: infix_circumfix_meta_operator__S_086Fre_Nch_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infix_circumfix_meta_operator__S_086Fre_Nch_01 0
              dba: infix_circumfix_meta_operator__S_086Fre_Nch
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: infix_circumfix_meta_operator__S_086Fre_Nch
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix_circumfix_meta_operator__S_086Fre_Nch
                  i: 0
                  min: 12345
                  name: infix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: &48 !!perl/hash:RE_any 
                    a: 0
                    altname: infix_circumfix_meta_operator__S_086Fre_Nch_02
                    dba: infix_circumfix_meta_operator__S_086Fre_Nch
                    i: 0
                    min: 1
                    name: infix_circumfix_meta_operator__S_086Fre_Nch_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix_circumfix_meta_operator__S_086Fre_Nch_02 0
                        dba: infix_circumfix_meta_operator__S_086Fre_Nch
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: 
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix_circumfix_meta_operator__S_086Fre_Nch_02 1
                        dba: infix_circumfix_meta_operator__S_086Fre_Nch
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infix_circumfix_meta_operator__S_086Fre_Nch_01 1
              dba: infix_circumfix_meta_operator__S_086Fre_Nch
              i: 0
              min: 12347
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: infix_circumfix_meta_operator__S_086Fre_Nch
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix_circumfix_meta_operator__S_086Fre_Nch
                  i: 0
                  min: 12345
                  name: infix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: &16 !!perl/hash:RE_any 
                    a: 0
                    altname: infix_circumfix_meta_operator__S_086Fre_Nch_03
                    dba: infix_circumfix_meta_operator__S_086Fre_Nch
                    i: 0
                    min: 1
                    name: infix_circumfix_meta_operator__S_086Fre_Nch_03
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix_circumfix_meta_operator__S_086Fre_Nch_03 0
                        dba: infix_circumfix_meta_operator__S_086Fre_Nch
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: 
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix_circumfix_meta_operator__S_086Fre_Nch_03 1
                        dba: infix_circumfix_meta_operator__S_086Fre_Nch
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infix_circumfix_meta_operator__S_086Fre_Nch_01 2
              dba: infix_circumfix_meta_operator__S_086Fre_Nch
              i: 0
              min: 12349
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: infix_circumfix_meta_operator__S_086Fre_Nch
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: <<
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix_circumfix_meta_operator__S_086Fre_Nch
                  i: 0
                  min: 12345
                  name: infix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 2
                  re: &55 !!perl/hash:RE_any 
                    a: 0
                    altname: infix_circumfix_meta_operator__S_086Fre_Nch_04
                    dba: infix_circumfix_meta_operator__S_086Fre_Nch
                    i: 0
                    min: 2
                    name: infix_circumfix_meta_operator__S_086Fre_Nch_04
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix_circumfix_meta_operator__S_086Fre_Nch_04 0
                        dba: infix_circumfix_meta_operator__S_086Fre_Nch
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        text: <<
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix_circumfix_meta_operator__S_086Fre_Nch_04 1
                        dba: infix_circumfix_meta_operator__S_086Fre_Nch
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        text: ">>"
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infix_circumfix_meta_operator__S_086Fre_Nch_01 3
              dba: infix_circumfix_meta_operator__S_086Fre_Nch
              i: 0
              min: 12349
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: infix_circumfix_meta_operator__S_086Fre_Nch
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: ">>"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix_circumfix_meta_operator__S_086Fre_Nch
                  i: 0
                  min: 12345
                  name: infix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 2
                  re: &5 !!perl/hash:RE_any 
                    a: 0
                    altname: infix_circumfix_meta_operator__S_086Fre_Nch_05
                    dba: infix_circumfix_meta_operator__S_086Fre_Nch
                    i: 0
                    min: 2
                    name: infix_circumfix_meta_operator__S_086Fre_Nch_05
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix_circumfix_meta_operator__S_086Fre_Nch_05 0
                        dba: infix_circumfix_meta_operator__S_086Fre_Nch
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        text: <<
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infix_circumfix_meta_operator__S_086Fre_Nch_05 1
                        dba: infix_circumfix_meta_operator__S_086Fre_Nch
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        text: ">>"
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_block 
            a: 0
            context: bool
            dba: infix_circumfix_meta_operator__S_086Fre_Nch
            i: 0
            min: 0
            nobind: 1
            r: 1
            s: 0
            text: " $<O> := $<infix><O>; "
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_method 
            min: 0
            name: lex1
            nobind: 1
            rest: ('hyper')
infix_circumfix_meta_operator__S_086Fre_Nch_01: *42
infix_circumfix_meta_operator__S_086Fre_Nch_02: *48
infix_circumfix_meta_operator__S_086Fre_Nch_03: *16
infix_circumfix_meta_operator__S_086Fre_Nch_04: *55
infix_circumfix_meta_operator__S_086Fre_Nch_05: *5
infix_postfix_meta_operator__S_087Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Item_assignment
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_postfix_meta_operator__S_087Equal
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: infix_postfix_meta_operator__S_087Equal
        i: 0
        min: 1
        r: 1
        s: 0
        text: =
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: infix_postfix_meta_operator__S_087Equal
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<O> = $op<O>; "
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method 
          min: 0
          name: lex1
          nobind: 1
          rest: ('assignment')
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: infix_postfix_meta_operator__S_087Equal
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: infix_postfix_meta_operator__S_087Equal
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " ($<O><assoc> // '') eq 'chain' "
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("Can't make assignment op of boolean operator")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: infix_postfix_meta_operator__S_087Equal
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: infix_postfix_meta_operator__S_087Equal
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " ($<O><assoc> // '') eq 'non'   "
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("Can't make assignment op of non-associative operator")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
infix_prefix_meta_operator__S_084Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::Chaining
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix_prefix_meta_operator__S_084Bang
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: infix_prefix_meta_operator__S_084Bang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!"
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: infix_prefix_meta_operator__S_084Bang
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: infix_prefix_meta_operator__S_084Bang
              i: 0
              min: 1
              r: 1
              s: 0
              text: "!"
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: infix_prefix_meta_operator__S_084Bang
        i: 0
        min: 12345
        name: infix
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_block 
            a: 0
            context: bool
            dba: infix_prefix_meta_operator__S_084Bang
            i: 0
            min: 0
            nobind: 1
            r: 1
            s: 0
            text: " $<O> = $<infix><O>; "
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_method 
            min: 0
            name: lex1
            nobind: 1
            rest: ('negation')
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: infix_prefix_meta_operator__S_084Bang
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                nobind: 1
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: infix_prefix_meta_operator__S_084Bang
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " $<O><assoc> eq 'chain'"
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                nobind: 1
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: infix_prefix_meta_operator__S_084Bang
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " $<O><assoc> and $<O><bool> "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Only boolean infix operators may be negated")
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: infix_prefix_meta_operator__S_084Bang
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $<O><hyper> and $.panic(\"Negation of hyper operator not allowed\") "
infixish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: infix or meta-infix
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: stdstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: infixish
          i: 0
          min: 12345
          name: infixstopper
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &119 !!perl/hash:RE_any 
          a: 0
          altname: infixish_01
          dba: infix or meta-infix
          i: 0
          min: 12345
          name: infixish_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 0
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: colonpair
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "\n            $<fake> = 1;\n            $<sym> = ':';\n            %<O><prec> = %loose_unary<prec>;\n            %<O><assoc> = 'left';\n        "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 1
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: infix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix>.<O>; $<sym> = $<infix>.<sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 2
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: infix_prefix_meta_operator
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix_prefix_meta_operator><O>;\n          $<sym> = $<infix_prefix_meta_operator><sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 3
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: infix_circumfix_meta_operator
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix_circumfix_meta_operator><O>;\n          $<sym> = $<infix_circumfix_meta_operator><sym>; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: infixish_01 4
              dba: infix or meta-infix
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: infix or meta-infix
                  i: 0
                  min: 12345
                  name: infix
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: infix or meta-infix
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: infix or meta-infix
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: =
                    s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: infix_postfix_meta_operator
                  rest: ($<infix>)
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: infix or meta-infix
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<O> = $<infix_postfix_meta_operator>.<O>; $<sym> = $<infix_postfix_meta_operator>.<sym>; "
infixish_01: *119
infixstopper: !!perl/hash:RE 
  decl: []

  kind: regex
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: &60 !!perl/hash:RE_any 
      a: 0
      altname: infixstopper_01
      dba: infix stopper
      i: 0
      min: 0
      name: infixstopper_01
      r: 0
      s: 0
      zyg: 
        - !!perl/hash:RE_assertion 
          alt: infixstopper_01 0
          assert: "?"
          min: 0
          re: !!perl/hash:RE_method_re 
            a: 0
            dba: infix stopper
            i: 0
            min: 0
            name: before
            nobind: 1
            r: 0
            re: !!perl/hash:RE 
              decl: []

              min: 12345
              re: !!perl/hash:RE_method 
                a: 0
                dba: infix stopper
                i: 0
                min: 12345
                name: stopper
                r: 0
                rest: ''
                s: 0
            s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: infixstopper_01 1
          dba: infix stopper
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: infix stopper
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 0
                re: !!perl/hash:RE 
                  decl: []

                  min: 2
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: infix stopper
                    i: 0
                    min: 2
                    r: 0
                    s: 0
                    text: "!!"
                s: 0
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: infix stopper
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " $+GOAL eq '!!' "
        - !!perl/hash:RE_sequence 
          a: 0
          alt: infixstopper_01 2
          dba: infix stopper
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: infix stopper
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 0
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: &82 !!perl/hash:RE_any 
                    a: 0
                    altname: infixstopper_04
                    dba: infix stopper
                    i: 0
                    min: 1
                    name: infixstopper_04
                    r: 0
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: infixstopper_04 0
                        dba: infix stopper
                        i: 0
                        min: 1
                        r: 0
                        s: 0
                        text: "{"
                      - !!perl/hash:RE_method 
                        a: 0
                        alt: infixstopper_04 1
                        dba: infix stopper
                        i: 0
                        min: 12345
                        name: lambda
                        r: 0
                        rest: ''
                        s: 0
                s: 0
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: infix stopper
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " ($+GOAL eq '{' or $+GOAL eq 'endargs') and @+MEMOS[$.pos]<ws> "
        - !!perl/hash:RE_assertion 
          alt: infixstopper_01 3
          assert: "?"
          min: 0
          re: !!perl/hash:RE_block 
            a: 0
            context: bool
            dba: infix stopper
            i: 0
            min: 0
            nobind: 1
            r: 0
            s: 0
            text: " $+GOAL eq 'endargs' and @+MEMOS[$.pos]<endargs> "
infixstopper_01: *60
infixstopper_04: *82
integer: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 1
    re: &116 !!perl/hash:RE_any 
      a: 0
      altname: integer_01
      dba: integer
      i: 0
      min: 1
      name: integer_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: integer_01 0
          dba: integer
          i: 0
          min: 2
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: integer
              i: 0
              min: 1
              r: 1
              s: 0
              text: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: &43 !!perl/hash:RE_any 
                a: 0
                altname: integer_02
                dba: integer
                i: 0
                min: 1
                name: integer_02
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: integer_02 0
                    dba: integer
                    i: 0
                    min: 2
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: integer
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: b
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_cclass 
                          a: 0
                          dba: integer
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "[01]"
                        min: 1
                        quant: 
                          - +
                          - ":"
                          - ''
                          - 1
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_bracket 
                          decl: []

                          min: 2
                          re: !!perl/hash:RE_sequence 
                            a: 0
                            dba: integer
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                dba: integer
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: _
                              - !!perl/hash:RE_quantified_atom 
                                atom: !!perl/hash:RE_cclass 
                                  a: 0
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: "[01]"
                                min: 1
                                quant: 
                                  - +
                                  - ":"
                                  - ''
                                  - 1
                        min: 0
                        quant: 
                          - "*"
                          - ":"
                          - ''
                          - 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: integer_02 1
                    dba: integer
                    i: 0
                    min: 2
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: integer
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: o
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_cclass 
                          a: 0
                          dba: integer
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "[0..7]"
                        min: 1
                        quant: 
                          - +
                          - ":"
                          - ''
                          - 1
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_bracket 
                          decl: []

                          min: 2
                          re: !!perl/hash:RE_sequence 
                            a: 0
                            dba: integer
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                dba: integer
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: _
                              - !!perl/hash:RE_quantified_atom 
                                atom: !!perl/hash:RE_cclass 
                                  a: 0
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: "[0..7]"
                                min: 1
                                quant: 
                                  - +
                                  - ":"
                                  - ''
                                  - 1
                        min: 0
                        quant: 
                          - "*"
                          - ":"
                          - ''
                          - 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: integer_02 2
                    dba: integer
                    i: 0
                    min: 2
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: integer
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: x
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_cclass 
                          a: 0
                          dba: integer
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "[0..9a..fA..F]"
                        min: 1
                        quant: 
                          - +
                          - ":"
                          - ''
                          - 1
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_bracket 
                          decl: []

                          min: 2
                          re: !!perl/hash:RE_sequence 
                            a: 0
                            dba: integer
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                dba: integer
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: _
                              - !!perl/hash:RE_quantified_atom 
                                atom: !!perl/hash:RE_cclass 
                                  a: 0
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: "[0..9a..fA..F]"
                                min: 1
                                quant: 
                                  - +
                                  - ":"
                                  - ''
                                  - 1
                        min: 0
                        quant: 
                          - "*"
                          - ":"
                          - ''
                          - 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: integer_02 3
                    dba: integer
                    i: 0
                    min: 2
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: integer
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: d
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_meta 
                          a: 0
                          dba: integer
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \d
                        min: 1
                        quant: 
                          - +
                          - ":"
                          - ''
                          - 1
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_bracket 
                          decl: []

                          min: 2
                          re: !!perl/hash:RE_sequence 
                            a: 0
                            dba: integer
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                dba: integer
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: _
                              - !!perl/hash:RE_quantified_atom 
                                atom: !!perl/hash:RE_meta 
                                  a: 0
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: \d
                                min: 1
                                quant: 
                                  - +
                                  - ":"
                                  - ''
                                  - 1
                        min: 0
                        quant: 
                          - "*"
                          - ":"
                          - ''
                          - 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: integer_02 4
                    dba: integer
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_meta 
                          a: 0
                          dba: integer
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \d
                        min: 1
                        quant: 
                          - +
                          - ":"
                          - ''
                          - 1
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_bracket 
                          decl: []

                          min: 2
                          re: !!perl/hash:RE_sequence 
                            a: 0
                            dba: integer
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                dba: integer
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: _
                              - !!perl/hash:RE_quantified_atom 
                                atom: !!perl/hash:RE_meta 
                                  a: 0
                                  dba: integer
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: \d
                                min: 1
                                quant: 
                                  - +
                                  - ":"
                                  - ''
                                  - 1
                        min: 0
                        quant: 
                          - "*"
                          - ":"
                          - ''
                          - 0
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: integer
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $.worry(\"Leading 0 does not indicate octal in Perl 6\") "
        - !!perl/hash:RE_sequence 
          a: 0
          alt: integer_01 1
          dba: integer
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: integer
                i: 0
                min: 1
                r: 1
                s: 0
                text: \d
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 2
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: integer
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: integer
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: _
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: integer
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
integer_01: *116
integer_02: *43
label: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24691
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: label
    i: 0
    min: 24691
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: label
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: label
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: label
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: label
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: label
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: label
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: label
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " $.is_type($<identifier>.text) "
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("You tried to use an existing typename as a label")
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: label
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $.add_type($<identifier>.text); "
lambda: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: &100 !!perl/hash:RE_any 
    a: 0
    altname: lambda_00
    dba: lambda
    i: 0
    min: 2
    name: lambda_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        alt: lambda_00 0
        dba: lambda
        i: 0
        min: 2
        r: 1
        s: 0
        text: ->
      - !!perl/hash:RE_string 
        a: 0
        alt: lambda_00 1
        dba: lambda
        i: 0
        min: 3
        r: 1
        s: 0
        text: <->
lambda_00: *100
longname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: longname
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: longname
        i: 0
        min: 12345
        name: name
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: longname
          i: 0
          min: 12345
          name: colonpair
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
macro_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: macro_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 1
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: macro_def
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: &78 !!perl/hash:RE_any 
            a: 0
            altname: macro_def_01
            dba: macro_def
            i: 0
            min: 1
            name: macro_def_01
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: macro_def_01 0
                dba: macro_def
                i: 0
                min: 1
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: macro_def
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: "&"
                  - !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: macro_def
                      i: 0
                      min: 12345
                      name: deflongname
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
              - !!perl/hash:RE_sequence 
                a: 0
                alt: macro_def_01 1
                dba: macro_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: macro_def
                    i: 0
                    min: 12345
                    name: deflongname
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: &105 !!perl/hash:RE_any 
            a: 0
            altname: macro_def_02
            dba: macro_def
            i: 0
            min: 12345
            name: macro_def_02
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: macro_def_02 0
                dba: macro_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: macro_def
                    i: 0
                    min: 12345
                    name: multisig
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
              - !!perl/hash:RE_sequence 
                a: 0
                alt: macro_def_02 1
                dba: macro_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: macro_def
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: macro_def
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 1
          text: "\n        $ = $+PARSER.bless($);\n        $IN_DECL = 0;\n    "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: macro_def
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
macro_def_01: *78
macro_def_02: *105
method_def: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: method_def
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &93 !!perl/hash:RE_any 
          a: 0
          altname: method_def_01
          dba: subscript signature
          i: 0
          min: 0
          name: method_def_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: method_def_01 0
              dba: method_def
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_string 
                    a: 0
                    dba: method_def
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: "!"
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: method_def
                  i: 0
                  min: 12345
                  name: longname
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: &65 !!perl/hash:RE_any 
                      a: 0
                      altname: method_def_02
                      dba: method_def
                      i: 0
                      min: 12345
                      name: method_def_02
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: method_def_02 0
                          dba: method_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: method_def
                              i: 0
                              min: 12345
                              name: multisig
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: method_def_02 1
                          dba: method_def
                          i: 0
                          min: 12345
                          r: 1
                          s: 1
                          zyg: 
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: method_def
                              i: 0
                              min: 12345
                              name: trait
                              r: 1
                              rest: ''
                              s: 1
                            - !!perl/hash:RE_method 
                              min: 0
                              name: ws
                              nobind: 1
                              noquant: 1
                              rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: method_def_01 1
              dba: subscript signature
              i: 0
              min: 24691
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: method_def
                  i: 0
                  min: 12345
                  name: sigil
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: method_def
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: .
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: &1 !!perl/hash:RE_any 
                    a: 0
                    altname: method_def_03
                    dba: subscript signature
                    i: 0
                    min: 12345
                    name: method_def_03
                    r: 1
                    s: 1
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_03 0
                        dba: subscript signature
                        i: 0
                        min: 12347
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: subscript signature
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: (
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: subscript signature
                            extra: local $::GOAL = ')'
                            i: 0
                            min: 0
                            r: 1
                            s: 1
                            text: "::"
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: subscript signature
                            i: 0
                            min: 12345
                            name: signature
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 1
                            re: !!perl/hash:RE_first 
                              a: 0
                              dba: subscript signature
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: subscript signature
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: )
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: FAILGOAL
                                  nobind: 1
                                  rest: (')', 'subscript signature')
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_03 1
                        dba: subscript signature
                        i: 0
                        min: 12347
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: subscript signature
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: "["
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: subscript signature
                            extra: local $::GOAL = ']'
                            i: 0
                            min: 0
                            r: 1
                            s: 1
                            text: "::"
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: subscript signature
                            i: 0
                            min: 12345
                            name: signature
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 1
                            re: !!perl/hash:RE_first 
                              a: 0
                              dba: subscript signature
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: subscript signature
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: "]"
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: FAILGOAL
                                  nobind: 1
                                  rest: (']', 'subscript signature')
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_03 2
                        dba: subscript signature
                        i: 0
                        min: 12347
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: subscript signature
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: "{"
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: subscript signature
                            extra: local $::GOAL = '}'
                            i: 0
                            min: 0
                            r: 1
                            s: 1
                            text: "::"
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: subscript signature
                            i: 0
                            min: 12345
                            name: signature
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_bracket 
                            decl: []

                            min: 1
                            re: !!perl/hash:RE_first 
                              a: 0
                              dba: subscript signature
                              i: 0
                              min: 1
                              r: 1
                              s: 1
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: subscript signature
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: "}"
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: FAILGOAL
                                  nobind: 1
                                  rest: ('}', 'subscript signature')
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: method_def_03 3
                        dba: subscript signature
                        i: 0
                        min: 12345
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_method_re 
                              a: 0
                              dba: subscript signature
                              i: 0
                              min: 0
                              name: before
                              nobind: 1
                              r: 1
                              re: !!perl/hash:RE 
                                decl: []

                                min: 1
                                re: !!perl/hash:RE_string 
                                  a: 0
                                  dba: subscript signature
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: <
                              s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: subscript signature
                            i: 0
                            min: 12345
                            name: postcircumfix
                            r: 1
                            rest: ''
                            s: 1
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: subscript signature
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: method_def_01 2
              dba: subscript signature
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_noop 
                    a: 0
                    dba: subscript signature
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: method_def
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
method_def_01: *93
method_def_02: *65
method_def_03: *1
methodop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: method arguments
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &72 !!perl/hash:RE_any 
          a: 0
          altname: methodop_01
          dba: methodop
          i: 0
          min: 12345
          name: methodop_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              alt: methodop_01 0
              dba: methodop
              i: 0
              min: 12345
              name: longname
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: methodop_01 1
              dba: methodop
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: methodop
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: &109 !!perl/hash:RE_any 
                        a: 0
                        altname: methodop_02
                        dba: methodop
                        i: 0
                        min: 1
                        name: methodop_02
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            alt: methodop_02 0
                            dba: methodop
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: $
                          - !!perl/hash:RE_string 
                            a: 0
                            alt: methodop_02 1
                            dba: methodop
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "@"
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: methodop
                  i: 0
                  min: 12345
                  name: variable
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: methodop_01 2
              dba: methodop
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: methodop
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_cclass 
                        a: 0
                        dba: methodop
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[ ' \" ]"
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: methodop
                  i: 0
                  min: 12345
                  name: quote
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: methodop
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<quote> ~~ /\\W/ or $.panic(\"Useless use of quotes\") "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: methodop
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12346
          re: &63 !!perl/hash:RE_any 
            a: 0
            altname: methodop_04
            dba: method arguments
            i: 0
            min: 12346
            name: methodop_04
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: methodop_04 0
                dba: method arguments
                i: 0
                min: 12347
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_string 
                      a: 0
                      dba: method arguments
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: .
                    min: 0
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  - !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: method arguments
                      i: 0
                      min: 12345
                      name: unsp
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 0
                    min: 0
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: method arguments
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: (
                  - !!perl/hash:RE_meta 
                    a: 0
                    dba: method arguments
                    extra: "local $::GOAL = ')' "
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    text: "::"
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: method arguments
                    i: 0
                    min: 12345
                    name: semilist
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_first 
                      a: 0
                      dba: method arguments
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: method arguments
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_method 
                          min: 0
                          name: FAILGOAL
                          nobind: 1
                          rest: (')' , 'method arguments')
              - !!perl/hash:RE_sequence 
                a: 0
                alt: methodop_04 1
                dba: method arguments
                i: 0
                min: 12346
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: method arguments
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ":"
                  - !!perl/hash:RE_assertion 
                    assert: "?"
                    min: 0
                    re: !!perl/hash:RE_method_re 
                      a: 0
                      dba: method arguments
                      i: 0
                      min: 0
                      name: before
                      nobind: 1
                      r: 1
                      re: !!perl/hash:RE 
                        decl: []

                        min: 1
                        re: !!perl/hash:RE_meta 
                          a: 0
                          dba: method arguments
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \s
                      s: 0
                  - !!perl/hash:RE_assertion 
                    assert: "!"
                    min: 0
                    re: !!perl/hash:RE_block 
                      a: 0
                      context: bool
                      dba: method arguments
                      i: 0
                      min: 0
                      nobind: 1
                      r: 1
                      s: 0
                      text: " $+inquote "
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: method arguments
                    i: 0
                    min: 12345
                    name: arglist
                    r: 1
                    rest: ''
                    s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
methodop_01: *72
methodop_02: *109
methodop_04: *63
modifier_expr: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: modifier_expr
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: modifier_expr
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
module_name__S_076normal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: module_name__S_076normal
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: module_name__S_076normal
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: module_name__S_076normal
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_block 
                  a: 0
                  context: bool
                  dba: module_name__S_076normal
                  i: 0
                  min: 0
                  nobind: 1
                  r: 1
                  s: 0
                  text: " ($+PKGDECL//'') eq 'role' "
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: module_name__S_076normal
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: module_name__S_076normal
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "["
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: module_name__S_076normal
                i: 0
                min: 12345
                name: postcircumfix
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
module_name__S_077deprecated: !!perl/hash:RE 
  decl: []

  kind: token
  min: 8
  pkg: ~
  re: !!perl/hash:RE_string 
    a: 0
    dba: module_name__S_077deprecated
    i: 0
    min: 8
    r: 1
    s: 0
    text: v6-alpha
morename: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: morename
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: morename
        i: 0
        min: 2
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: morename
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: morename
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &120 !!perl/hash:RE_any 
                      a: 0
                      altname: morename_02
                      dba: morename
                      i: 0
                      min: 1
                      name: morename_02
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: morename_02 0
                          dba: morename
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: (
                        - !!perl/hash:RE_method 
                          a: 0
                          alt: morename_02 1
                          dba: morename
                          i: 0
                          min: 12345
                          name: alpha
                          r: 1
                          rest: ''
                          s: 0
                  s: 0
              - !!perl/hash:RE_bracket 
                decl: []

                min: 12345
                re: &121 !!perl/hash:RE_any 
                  a: 0
                  altname: morename_03
                  dba: indirect name
                  i: 0
                  min: 12345
                  name: morename_03
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_method 
                      a: 0
                      alt: morename_03 0
                      dba: morename
                      i: 0
                      min: 12345
                      name: identifier
                      r: 1
                      rest: ''
                      s: 0
                    - !!perl/hash:RE_sequence 
                      a: 0
                      alt: morename_03 1
                      dba: indirect name
                      i: 0
                      min: 12347
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: indirect name
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: (
                        - !!perl/hash:RE_meta 
                          a: 0
                          dba: indirect name
                          extra: "local $::GOAL = ')' "
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "::"
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: indirect name
                          i: 0
                          min: 12345
                          name: EXPR
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          re: !!perl/hash:RE_first 
                            a: 0
                            dba: indirect name
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                dba: indirect name
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: )
                              - !!perl/hash:RE_method 
                                min: 0
                                name: FAILGOAL
                                nobind: 1
                                rest: (')' , 'indirect name')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
morename_02: *120
morename_03: *121
multi_declarator__S_109multi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multi_declarator__S_109multi
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_109multi
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: multi
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_109multi
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_first 
          a: 0
          dba: multi_declarator__S_109multi
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: multi_declarator__S_109multi
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: multi_declarator__S_109multi
                  i: 0
                  min: 12345
                  name: declarator
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: multi_declarator__S_109multi
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<SIGIL> = $<declarator><SIGIL> "
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_109multi
              i: 0
              min: 12345
              name: routine_def
              r: 1
              rest: ''
              s: 0
multi_declarator__S_110proto: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multi_declarator__S_110proto
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_110proto
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: proto
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_110proto
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_first 
          a: 0
          dba: multi_declarator__S_110proto
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: multi_declarator__S_110proto
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: multi_declarator__S_110proto
                  i: 0
                  min: 12345
                  name: declarator
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: multi_declarator__S_110proto
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<SIGIL> = $<declarator><SIGIL> "
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_110proto
              i: 0
              min: 12345
              name: routine_def
              r: 1
              rest: ''
              s: 0
multi_declarator__S_111only: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multi_declarator__S_111only
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_111only
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: only
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_111only
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_first 
          a: 0
          dba: multi_declarator__S_111only
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: multi_declarator__S_111only
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: multi_declarator__S_111only
                  i: 0
                  min: 12345
                  name: declarator
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: multi_declarator__S_111only
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $<SIGIL> = $<declarator><SIGIL> "
            - !!perl/hash:RE_method 
              a: 0
              dba: multi_declarator__S_111only
              i: 0
              min: 12345
              name: routine_def
              r: 1
              rest: ''
              s: 0
multi_declarator__S_112null: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multi_declarator__S_112null
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: multi_declarator__S_112null
        i: 0
        min: 12345
        name: declarator
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: multi_declarator__S_112null
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<SIGIL> = $<declarator><SIGIL> "
multisig: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: multisig
    i: 0
    min: 12347
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12347
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: multisig
            i: 0
            min: 12347
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_string 
                  a: 0
                  dba: multisig
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: ":"
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_string 
                a: 0
                dba: multisig
                i: 0
                min: 1
                r: 1
                s: 1
                text: (
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_meta 
                a: 0
                dba: multisig
                extra: local $::GOAL = ')'
                i: 0
                min: 0
                r: 1
                s: 1
                text: "::"
              - !!perl/hash:RE_method 
                a: 0
                dba: multisig
                i: 0
                min: 12345
                name: signature
                r: 1
                rest: ''
                s: 1
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: multisig
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  zyg: 
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: multisig
                      i: 0
                      min: 1
                      r: 1
                      s: 1
                      text: )
                    - !!perl/hash:RE_method 
                      min: 0
                      name: FAILGOAL
                      nobind: 1
                      rest: (')', 'multisig')
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 12347
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_string 
            a: 0
            dba: multisig
            i: 0
            min: 1
            r: 1
            s: 1
            text: "|"
          - 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &75 !!perl/hash:RE_any 
      a: 0
      altname: name_01
      dba: name
      i: 0
      min: 12345
      name: name_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: name_01 0
          dba: name
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: name
              i: 0
              min: 12345
              name: identifier
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: name
                i: 0
                min: 12345
                name: morename
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_quantified_atom 
          alt: name_01 1
          atom: !!perl/hash:RE_method 
            a: 0
            dba: name
            i: 0
            min: 12345
            name: morename
            r: 1
            rest: ''
            s: 0
          min: 12345
          quant: 
            - +
            - ":"
            - ''
            - 1
name_01: *75
named_param: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: named_param
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = ')'
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: named_param
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: named_param
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &26 !!perl/hash:RE_any 
          a: 0
          altname: named_param_01
          dba: named_param
          i: 0
          min: 12345
          name: named_param_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: named_param_01 0
              dba: named_param
              i: 0
              min: 37036
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: named_param
                    i: 0
                    min: 12345
                    name: identifier
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  dba: named_param
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  var: name
                - !!perl/hash:RE_string 
                  a: 0
                  dba: named_param
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: (
                - !!perl/hash:RE_method 
                  a: 0
                  dba: named_param
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: &94 !!perl/hash:RE_any 
                    a: 0
                    altname: named_param_02
                    dba: named_param
                    i: 0
                    min: 12345
                    name: named_param_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        alt: named_param_02 0
                        dba: named_param
                        i: 0
                        min: 12345
                        name: named_param
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: named_param_02 1
                        dba: named_param
                        i: 0
                        min: 24690
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: named_param
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: named_param
                            i: 0
                            min: 12345
                            name: ws
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: named_param
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: named_param
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Unable to parse named parameter; couldn't find right parenthesis")
            - !!perl/hash:RE_method 
              a: 0
              alt: named_param_01 1
              dba: named_param
              i: 0
              min: 12345
              name: param_var
              r: 1
              rest: ''
              s: 0
named_param_01: *26
named_param_02: *94
nibbler: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $text = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my @nibbles = ()
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $multiline = 0
    - !!perl/hash:RE_decl 
      a: 0
      dba: nibbler
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $nibble
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: nibbler
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: nibbler
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<firstpos> = self.pos; "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: nibbler
            i: 0
            min: 1
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_method 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 12345
                      name: stopper
                      r: 1
                      rest: ''
                      s: 0
                  s: 0
              - !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: nibbler
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 37035
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: starter
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: nibbler
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: stopper
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: nibbler
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "\n                            my $n = $<nibbler>[*-1]<nibbles>;\n                            my @n = @$n;\n                            $text ~= $<starter>[*-1].text ~ shift(@n);\n                            $text = (@n ?? pop(@n) !! '') ~ $<stopper>[*-1].text;\n                            push @nibbles, @n;\n                        "
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 12345
                          name: escape
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: nibbler
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "\n                            push @nibbles, $text, $<escape>[*-1];\n                            $text = '';\n                        "
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: nibbler
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_meta 
                          a: 0
                          dba: nibbler
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: .
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: nibbler
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: "\n                            my $ch = substr($ORIG, $.pos-1, 1);\n                            $text ~= $ch;\n                            if $ch ~~ \"\\n\" {\n                                $multiline++;\n                            }\n                        "
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: nibbler
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        push @nibbles, $text; $<nibbles> = [@nibbles];\n        $<lastpos> = $.pos;\n        $<nibbler> :delete;\n        $<escape> :delete;\n        $COMPILING::LAST_NIBBLE = $;\n        $COMPILING::LAST_NIBBLE_MULTILINE = $ if $multiline;\n    "
nofun: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_method_re 
      a: 0
      dba: nofun
      i: 0
      min: 0
      name: before
      nobind: 1
      r: 1
      re: !!perl/hash:RE 
        decl: []

        min: 1
        re: &50 !!perl/hash:RE_any 
          a: 0
          altname: nofun_01
          dba: nofun
          i: 0
          min: 1
          name: nofun_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: nofun_01 0
              dba: nofun
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
            - !!perl/hash:RE_string 
              a: 0
              alt: nofun_01 1
              dba: nofun
              i: 0
              min: 2
              r: 1
              s: 0
              text: .(
            - !!perl/hash:RE_string 
              a: 0
              alt: nofun_01 2
              dba: nofun
              i: 0
              min: 1
              r: 1
              s: 0
              text: \
      s: 0
nofun_01: *50
noun: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &71 !!perl/hash:RE_any 
      a: 0
      altname: noun_01
      dba: noun
      i: 0
      min: 12345
      name: noun_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 0
          dba: noun
          i: 0
          min: 12345
          name: fatarrow
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: noun_01 1
          dba: noun
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: noun
              i: 0
              min: 12345
              name: variable
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: noun
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $<SIGIL> = $<variable><sigil> "
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 2
          dba: noun
          i: 0
          min: 12345
          name: package_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 3
          dba: noun
          i: 0
          min: 12345
          name: scope_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: noun_01 4
          dba: noun
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: noun
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 4
                  re: &39 !!perl/hash:RE_any 
                    a: 0
                    altname: noun_02
                    dba: noun
                    i: 0
                    min: 4
                    name: noun_02
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: noun_02 0
                        dba: noun
                        i: 0
                        min: 5
                        r: 1
                        s: 0
                        text: multi
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: noun_02 1
                        dba: noun
                        i: 0
                        min: 5
                        r: 1
                        s: 0
                        text: proto
                      - !!perl/hash:RE_string 
                        a: 0
                        alt: noun_02 2
                        dba: noun
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: only
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: noun
              i: 0
              min: 12345
              name: multi_declarator
              r: 1
              rest: ''
              s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 5
          dba: noun
          i: 0
          min: 12345
          name: routine_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 6
          dba: noun
          i: 0
          min: 12345
          name: regex_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 7
          dba: noun
          i: 0
          min: 12345
          name: type_declarator
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 8
          dba: noun
          i: 0
          min: 12345
          name: circumfix
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 9
          dba: noun
          i: 0
          min: 12345
          name: dotty
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 10
          dba: noun
          i: 0
          min: 12345
          name: value
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 11
          dba: noun
          i: 0
          min: 12345
          name: capterm
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 12
          dba: noun
          i: 0
          min: 12345
          name: sigterm
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 13
          dba: noun
          i: 0
          min: 12345
          name: term
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: noun_01 14
          dba: noun
          i: 0
          min: 12345
          name: statement_prefix
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_quantified_atom 
          alt: noun_01 15
          atom: !!perl/hash:RE_bracket 
            decl: []

            min: 24690
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: noun
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: noun
                  i: 0
                  min: 12345
                  name: colonpair
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: noun
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
          min: 24690
          quant: 
            - +
            - ":"
            - ''
            - 1
noun_01: *71
noun_02: *39
nullterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "?"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: nullterm
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
nulltermish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 0
    re: &84 !!perl/hash:RE_any 
      a: 0
      altname: nulltermish_01
      dba: null term
      i: 0
      min: 0
      name: nulltermish_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_assertion 
          alt: nulltermish_01 0
          assert: "?"
          min: 0
          re: !!perl/hash:RE_method 
            a: 0
            dba: null term
            i: 0
            min: 12345
            name: stdstopper
            nobind: 1
            r: 1
            rest: ''
            s: 0
        - !!perl/hash:RE_quantified_atom 
          alt: nulltermish_01 1
          atom: !!perl/hash:RE_method 
            a: 0
            dba: null term
            i: 0
            min: 12345
            name: termish
            r: 1
            rest: ''
            s: 0
          min: 0
          quant: 
            - "?"
            - ":"
            - ''
            - 0
nulltermish_01: *84
number: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &6 !!perl/hash:RE_any 
      a: 0
      altname: number_01
      dba: number
      i: 0
      min: 12345
      name: number_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: number_01 0
          dba: number
          i: 0
          min: 12345
          name: dec_number
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: number_01 1
          dba: number
          i: 0
          min: 12345
          name: integer
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: number_01 2
          dba: number
          i: 0
          min: 12345
          name: rad_number
          r: 1
          rest: ''
          s: 0
number_01: *6
octint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: octint
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_cclass 
          a: 0
          dba: octint
          i: 0
          min: 1
          r: 1
          s: 0
          text: "[ 0..7 ]"
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 2
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: octint
            i: 0
            min: 2
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: octint
                i: 0
                min: 1
                r: 1
                s: 0
                text: _
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_cclass 
                  a: 0
                  dba: octint
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "[ 0..7 ]"
                min: 1
                quant: 
                  - +
                  - ":"
                  - ''
                  - 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
old_rx_mods: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: old_rx_mods
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_qw 
              a: 0
              dba: old_rx_mods
              i: 0
              min: 1
              r: 1
              s: 0
              text: < i g s m x c e ] >
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: old_rx_mods
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        given $0.text {\n            $_ ~~ /i/ and $.worryobs('/i',':i');\n            $_ ~~ /g/ and $.worryobs('/g',':g');\n            $_ ~~ /s/ and $.worryobs('/s','^^ and $$ anchors');\n            $_ ~~ /m/ and $.worryobs('/m','. or \\N');\n            $_ ~~ /x/ and $.worryobs('/x','normal default whitespace');\n            $_ ~~ /c/ and $.worryobs('/c',':c or :p');\n            $_ ~~ /e/ and $.worryobs('/e','interpolated {...} or s{} = ... form');\n            $.obs('suffix regex modifiers','prefix adverbs');\n        }\n    "
old_tr_mods: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: old_tr_mods
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_qw 
              a: 0
              dba: old_tr_mods
              i: 0
              min: 1
              r: 1
              s: 0
              text: < c d s ] >
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        min: 1
        var: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: old_tr_mods
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        given $0.text {\n            $_ ~~ /c/ and $.worryobs('/c',':c');\n            $_ ~~ /d/ and $.worryobs('/g',':d');\n            $_ ~~ /s/ and $.worryobs('/s',':s');\n            $.obs('suffix transliteration modifiers','prefix adverbs');\n        }\n    "
opener: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_cclass 
    a: 0
    dba: opener
    i: 0
    min: 1
    r: 1
    s: 0
    text: "[\\x{0028} \\x{003C} \\x{005B}\n    \\x{007B} \\x{00AB} \\x{0F3A}\n    \\x{0F3C} \\x{169B} \\x{2039}\n    \\x{2045} \\x{207D} \\x{208D}\n    \\x{2208} \\x{2209} \\x{220A}\n    \\x{2215} \\x{223C} \\x{2243}\n    \\x{2252} \\x{2254} \\x{2264}\n    \\x{2266} \\x{2268} \\x{226A}\n    \\x{226E} \\x{2270} \\x{2272}\n    \\x{2274} \\x{2276} \\x{2278}\n    \\x{227A} \\x{227C} \\x{227E}\n    \\x{2280} \\x{2282} \\x{2284}\n    \\x{2286} \\x{2288} \\x{228A}\n    \\x{228F} \\x{2291} \\x{2298}\n    \\x{22A2} \\x{22A6} \\x{22A8}\n    \\x{22A9} \\x{22AB} \\x{22B0}\n    \\x{22B2} \\x{22B4} \\x{22B6}\n    \\x{22C9} \\x{22CB} \\x{22D0}\n    \\x{22D6} \\x{22D8} \\x{22DA}\n    \\x{22DC} \\x{22DE} \\x{22E0}\n    \\x{22E2} \\x{22E4} \\x{22E6}\n    \\x{22E8} \\x{22EA} \\x{22EC}\n    \\x{22F0} \\x{22F2} \\x{22F3}\n    \\x{22F4} \\x{22F6} \\x{22F7}\n    \\x{2308} \\x{230A} \\x{2329}\n    \\x{23B4} \\x{2768} \\x{276A}\n    \\x{276C} \\x{276E} \\x{2770}\n    \\x{2772} \\x{2774} \\x{27C3}\n    \\x{27C5} \\x{27D5} \\x{27DD}\n    \\x{27E2} \\x{27E4} \\x{27E6}\n    \\x{27E8} \\x{27EA} \\x{2983}\n    \\x{2985} \\x{2987} \\x{2989}\n    \\x{298B} \\x{298D} \\x{298F}\n    \\x{2991} \\x{2993} \\x{2995}\n    \\x{2997} \\x{29C0} \\x{29C4}\n    \\x{29CF} \\x{29D1} \\x{29D4}\n    \\x{29D8} \\x{29DA} \\x{29F8}\n    \\x{29FC} \\x{2A2B} \\x{2A2D}\n    \\x{2A34} \\x{2A3C} \\x{2A64}\n    \\x{2A79} \\x{2A7D} \\x{2A7F}\n    \\x{2A81} \\x{2A83} \\x{2A8B}\n    \\x{2A91} \\x{2A93} \\x{2A95}\n    \\x{2A97} \\x{2A99} \\x{2A9B}\n    \\x{2AA1} \\x{2AA6} \\x{2AA8}\n    \\x{2AAA} \\x{2AAC} \\x{2AAF}\n    \\x{2AB3} \\x{2ABB} \\x{2ABD}\n    \\x{2ABF} \\x{2AC1} \\x{2AC3}\n    \\x{2AC5} \\x{2ACD} \\x{2ACF}\n    \\x{2AD1} \\x{2AD3} \\x{2AD5}\n    \\x{2AEC} \\x{2AF7} \\x{2AF9}\n    \\x{2E02} \\x{2E04} \\x{2E09}\n    \\x{2E0C} \\x{2E1C} \\x{3008}\n    \\x{300A} \\x{300C} \\x{300E}\n    \\x{3010} \\x{3014} \\x{3016}\n    \\x{3018} \\x{301A} \\x{301D}\n    \\x{FD3E} \\x{FE17} \\x{FE35}\n    \\x{FE37} \\x{FE39} \\x{FE3B}\n    \\x{FE3D} \\x{FE3F} \\x{FE41}\n    \\x{FE43} \\x{FE47} \\x{FE59}\n    \\x{FE5B} \\x{FE5D} \\x{FF08}\n    \\x{FF1C} \\x{FF3B} \\x{FF5B}\n    \\x{FF5F} \\x{FF62}]"
package_declarator__S_100class: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_100class
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'class'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_100class
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_100class
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: class
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_100class
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_101grammar: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_101grammar
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'grammar'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_101grammar
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_101grammar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: grammar
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_101grammar
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_102module: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_102module
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'module'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_102module
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_102module
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: module
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_102module
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_103package: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_103package
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'package'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_103package
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_103package
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: package
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_103package
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_104role: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_104role
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'role'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_104role
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_104role
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: role
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_104role
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_105knowhow: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_declarator__S_105knowhow
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'knowhow'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_105knowhow
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_105knowhow
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: knowhow
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_105knowhow
        i: 0
        min: 12345
        name: package_def
        r: 1
        rest: ''
        s: 0
package_declarator__S_106require: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_106require
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_106require
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: require
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_106require
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_first 
          a: 0
          dba: package_declarator__S_106require
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: package_declarator__S_106require
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: package_declarator__S_106require
                  i: 0
                  min: 12345
                  name: module_name
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: package_declarator__S_106require
                    i: 0
                    min: 12345
                    name: EXPR
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_method 
              a: 0
              dba: package_declarator__S_106require
              i: 0
              min: 12345
              name: EXPR
              r: 1
              rest: ''
              s: 0
package_declarator__S_107trusts: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_107trusts
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_107trusts
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: trusts
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_107trusts
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_107trusts
        i: 0
        min: 12345
        name: module_name
        r: 1
        rest: ''
        s: 0
package_declarator__S_108does: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_declarator__S_108does
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_108does
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: does
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_108does
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: package_declarator__S_108does
        i: 0
        min: 12345
        name: typename
        r: 1
        rest: ''
        s: 0
package_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: package_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $longname
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: package_def
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: package_def
            i: 0
            min: 12345
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                a: 0
                dba: package_def
                i: 0
                min: 12345
                name: module_name
                r: 1
                rest: ''
                s: 1
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: package_def
                i: 0
                min: 0
                r: 1
                s: 1
                text: "\n            $longname = $<module_name>[0]<longname>;\n            $.add_type($longname.text);\n        "
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: package_def
          i: 0
          min: 12345
          name: trait
          r: 1
          rest: ''
          s: 1
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: package_def
          i: 0
          min: 0
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: package_def
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: package_def
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: package_def
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: "{"
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: package_def
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "\n\t   # figure out the actual full package name (nested in outer package)\n            my $pkg = $+PKG // \"GLOBAL\";\n\t    push @PKGS, $pkg;\n\t    if $longname {\n\t\tmy $shortname = $longname.<name>.text;\n\t\t$+PKG = $pkg ~ '::' ~ $shortname;\n\t    }\n\t    else {\n\t\t$+PKG = $pkg ~ '::_anon_';\n\t    }\n\t"
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: package_def
                  i: 0
                  min: 12345
                  name: block
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: package_def
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "\n\t    $+PKG = pop(@PKGS);\n\t"
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'package_def_block'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              dba: package_def
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: package_def
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 1
                    text: " $+begin_compunit "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: package_def
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: package_def
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: package_def
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: ;
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: package_def
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "\n            $longname orelse $.panic(\"Compilation unit cannot be anonymous\");\n\t    my $shortname = $longname.<name>.text;\n\t    $+PKG = $shortname;\n            $+begin_compunit = 0;\n        "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'package_def_semi'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              dba: package_def
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("Unable to parse " ~ $+PKGDECL ~ " definition")
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
param_sep: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: param_sep
    i: 0
    min: 1
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: &54 !!perl/hash:RE_any 
          a: 0
          altname: param_sep_01
          dba: param_sep
          i: 0
          min: 1
          name: param_sep_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 0
              dba: param_sep
              i: 0
              min: 1
              r: 1
              s: 1
              text: ","
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 1
              dba: param_sep
              i: 0
              min: 1
              r: 1
              s: 1
              text: ":"
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 2
              dba: param_sep
              i: 0
              min: 1
              r: 1
              s: 1
              text: ;
            - !!perl/hash:RE_string 
              a: 0
              alt: param_sep_01 3
              dba: param_sep
              i: 0
              min: 2
              r: 1
              s: 1
              text: ;;
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
param_sep_01: *54
param_var: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &108 !!perl/hash:RE_any 
      a: 0
      altname: param_var_01
      dba: param_var
      i: 0
      min: 12345
      name: param_var_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: param_var_01 0
          dba: param_var
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: param_var
              i: 0
              min: 1
              r: 1
              s: 0
              text: "["
            - !!perl/hash:RE_meta 
              a: 0
              dba: param_var
              extra: "local $::GOAL = ']' "
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_method 
              a: 0
              dba: param_var
              i: 0
              min: 12345
              name: signature
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_first 
                a: 0
                dba: param_var
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: param_var
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "]"
                  - !!perl/hash:RE_method 
                    min: 0
                    name: FAILGOAL
                    nobind: 1
                    rest: (']' , 'param_var')
        - !!perl/hash:RE_sequence 
          a: 0
          alt: param_var_01 1
          dba: param_var
          i: 0
          min: 12347
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: param_var
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
            - !!perl/hash:RE_meta 
              a: 0
              dba: param_var
              extra: "local $::GOAL = ')' "
              i: 0
              min: 0
              r: 1
              s: 0
              text: "::"
            - !!perl/hash:RE_method 
              a: 0
              dba: param_var
              i: 0
              min: 12345
              name: signature
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: !!perl/hash:RE_first 
                a: 0
                dba: param_var
                i: 0
                min: 1
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: param_var
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: )
                  - !!perl/hash:RE_method 
                    min: 0
                    name: FAILGOAL
                    nobind: 1
                    rest: (')' , 'param_var')
        - !!perl/hash:RE_sequence 
          a: 0
          alt: param_var_01 2
          dba: param_var
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: param_var
              i: 0
              min: 12345
              name: sigil
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: param_var
                i: 0
                min: 12345
                name: twigil
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 12345
                re: !!perl/hash:RE_first 
                  a: 0
                  dba: param_var
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: param_var
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_block 
                            a: 0
                            context: bool
                            dba: param_var
                            i: 0
                            min: 0
                            nobind: 1
                            r: 1
                            s: 0
                            text: " $<sigil>.text eq '&' "
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method 
                            a: 0
                            dba: param_var
                            i: 0
                            min: 12345
                            name: ident
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                        - !!perl/hash:RE_block 
                          a: 0
                          context: void
                          dba: param_var
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          text: ''
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: param_var
                            i: 0
                            min: 12345
                            name: sublongname
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          dba: param_var
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          var: identifier
                    - !!perl/hash:RE_sequence 
                      a: 0
                      dba: param_var
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_block 
                            a: 0
                            context: bool
                            dba: param_var
                            i: 0
                            min: 0
                            nobind: 1
                            r: 1
                            s: 0
                            text: " $<sigil>.text eq '@' || $<sigil>.text eq '%' "
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: param_var
                            i: 0
                            min: 12345
                            name: identifier
                            r: 1
                            rest: ''
                            s: 0
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: param_var
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_cclass 
                                a: 0
                                dba: param_var
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: "[ \\< \\( \\[ \\{ ]"
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: param_var
                          i: 0
                          min: 12345
                          name: postcircumfix
                          r: 1
                          rest: ''
                          s: 0
                    - !!perl/hash:RE_method 
                      a: 0
                      dba: param_var
                      i: 0
                      min: 12345
                      name: identifier
                      r: 1
                      rest: ''
                      s: 0
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
param_var_01: *108
parameter: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: parameter
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $kind
    - !!perl/hash:RE_decl 
      a: 0
      dba: parameter
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $quant = ''
    - !!perl/hash:RE_decl 
      a: 0
      dba: parameter
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $q
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: parameter
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: parameter
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_bracket 
              decl: []

              min: 12345
              re: &59 !!perl/hash:RE_any 
                a: 0
                altname: parameter_02
                dba: parameter
                i: 0
                min: 12345
                name: parameter_02
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: parameter_02 0
                    dba: parameter
                    i: 0
                    min: 12345
                    name: type_constraint
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: parameter_02 1
                    dba: parameter
                    i: 0
                    min: 12345
                    name: param_var
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: parameter_02 2
                    dba: parameter
                    i: 0
                    min: 12346
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "*"
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: parameter
                        i: 0
                        min: 12345
                        name: param_var
                        r: 1
                        rest: ''
                        s: 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: parameter_02 3
                    dba: parameter
                    i: 0
                    min: 12346
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "|"
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: parameter
                        i: 0
                        min: 12345
                        name: param_var
                        r: 1
                        rest: ''
                        s: 0
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: parameter_02 4
                    dba: parameter
                    i: 0
                    min: 12345
                    name: named_param
                    r: 1
                    rest: ''
                    s: 0
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: parameter
          i: 0
          min: 12345
          name: type_constraint
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &91 !!perl/hash:RE_any 
          a: 0
          altname: parameter_03
          dba: parameter
          i: 0
          min: 0
          name: parameter_03
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_03 0
              dba: parameter
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "*"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $quant = '*'; $kind = '*'; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_03 1
              dba: parameter
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "|"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: parameter
                  i: 0
                  min: 12345
                  name: param_var
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $quant = '|'; $kind = '*'; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_03 2
              dba: parameter
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: &104 !!perl/hash:RE_any 
                    a: 0
                    altname: parameter_04
                    dba: parameter
                    i: 0
                    min: 12345
                    name: parameter_04
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_04 0
                        dba: parameter
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: param_var
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = ''; $kind = '!'; "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_04 1
                        dba: parameter
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 12345
                            name: named_param
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = ''; $kind = '*'; "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: &9 !!perl/hash:RE_any 
                    a: 0
                    altname: parameter_05
                    dba: parameter
                    i: 0
                    min: 0
                    name: parameter_05
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_05 0
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "?"
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '?'; $kind = '?' "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        alt: parameter_05 1
                        dba: parameter
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: parameter
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "!"
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: parameter
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $quant = '!'; $kind = '!' "
                      - !!perl/hash:RE_assertion 
                        alt: parameter_05 2
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_noop 
                          a: 0
                          dba: parameter
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: parameter_03 3
              dba: parameter
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_noop 
                    a: 0
                    dba: parameter
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: parameter
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $quant = ''; $kind = '!'; "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: parameter
          i: 0
          min: 12345
          name: trait
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: parameter
          i: 0
          min: 12345
          name: post_constraint
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: parameter
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: parameter
                i: 0
                min: 12345
                name: default_value
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: parameter
                i: 0
                min: 0
                r: 1
                s: 0
                text: "\n            given $quant {\n              when '!' { $.panic(\"Can't put a default on a required parameter\") }\n              when '*' { $.panic(\"Can't put a default on a slurpy parameter\") }\n              when '|' { $.panic(\"Can't put a default on a capture parameter\") }\n            }\n            $kind = '?';\n        "
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: parameter
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        $<quant> = $quant;\n        $<kind> = $kind;\n    "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: parameter
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        given $kind {\n            when '!' {\n                given $+zone {\n                    when 'posopt' {\n$.panic(\"Can't put required parameter after optional parameters\");\n                    }\n                    when 'var' {\n$.panic(\"Can't put required parameter after variadic parameters\");\n                    }\n                }\n            }\n            when '?' {\n                given $+zone {\n                    when 'posreq' { $+zone = 'posopt' }\n                    when 'var' {\n$.panic(\"Can't put optional positional parameter after variadic parameters\");\n                    }\n                }\n            }\n            when '*' {\n                $+zone = 'var';\n            }\n        }\n    "
parameter_02: *59
parameter_03: *91
parameter_04: *104
parameter_05: *9
pblock: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: parameterized block
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: parameterized block
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: parameterized block
                i: 0
                min: 12345
                name: lambda
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: parameterized block
                i: 0
                min: 12345
                name: signature
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: parameterized block
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 0
pod_comment: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: pod_comment
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_meta 
        a: 0
        dba: pod_comment
        i: 0
        min: 0
        r: 1
        s: 0
        text: "^^"
      - !!perl/hash:RE_string 
        a: 0
        dba: pod_comment
        i: 0
        min: 1
        r: 1
        s: 0
        text: =
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: pod_comment
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &24 !!perl/hash:RE_any 
          a: 0
          altname: pod_comment_01
          dba: pod_comment
          i: 0
          min: 0
          name: pod_comment_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pod_comment_01 0
              dba: pod_comment
              i: 0
              min: 12352
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: begin
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_method 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 7
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .*?
                          - !!perl/hash:RE_double 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            text: \n=
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 3
                            r: 1
                            s: 0
                            text: end
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \h
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_var 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            var: $<identifier>
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \N
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_method_internal 
                            args: $S, 'pod_comment_tagged'
                            max: 0
                            min: 0
                            name: _REDUCE
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .*?
                          - !!perl/hash:RE_method_internal 
                            args: $S, 'pod_comment_end'
                            max: 0
                            min: 0
                            name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pod_comment_01 1
              dba: pod_comment
              i: 0
              min: 5
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 5
                  r: 1
                  s: 0
                  text: begin
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_meta 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: $$
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "#"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Unrecognized token after =begin")
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: pod_comment
                        i: 0
                        min: 6
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .*?
                          - !!perl/hash:RE_double 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 2
                            r: 1
                            s: 0
                            text: \n=
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 3
                            r: 1
                            s: 0
                            text: end
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: pod_comment
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \N
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("=begin without =end")
                - !!perl/hash:RE_method_internal 
                  args: $S, 'pod_comment_anon'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: pod_comment_01 2
              dba: pod_comment
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: pod_comment
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: "::"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 0
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: pod_comment
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: pod_comment
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 5
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: pod_comment
                                i: 0
                                min: 5
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_meta 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: .*?
                                  - !!perl/hash:RE_meta 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 0
                                    r: 1
                                    s: 0
                                    text: "^^"
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 4
                                    r: 1
                                    s: 0
                                    text: =cut
                                  - !!perl/hash:RE_meta 
                                    a: 0
                                    dba: pod_comment
                                    i: 0
                                    min: 0
                                    r: 1
                                    s: 0
                                    text: 
                            s: 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: panic
                          nobind: 1
                          rest: ("Obsolete pod format, please use =begin/=end instead")
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: pod_comment
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \N
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'pod_comment_misc'
                  max: 0
                  min: 0
                  name: _REDUCE
pod_comment_01: *24
post_constraint: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: post_constraint
    i: 0
    min: 5
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 5
        re: &79 !!perl/hash:RE_any 
          a: 0
          altname: post_constraint_01
          dba: post_constraint
          i: 0
          min: 5
          name: post_constraint_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: post_constraint_01 0
              dba: post_constraint
              i: 0
              min: 12347
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: "["
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: post_constraint
                  extra: local $::GOAL = ']'
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 12345
                  name: signature
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: post_constraint
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: post_constraint
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: "]"
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (']', 'post_constraint')
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: post_constraint_01 1
              dba: post_constraint
              i: 0
              min: 12347
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: (
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: post_constraint
                  extra: local $::GOAL = ')'
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "::"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 12345
                  name: signature
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: post_constraint
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: post_constraint
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        text: )
                      - !!perl/hash:RE_method 
                        min: 0
                        name: FAILGOAL
                        nobind: 1
                        rest: (')', 'post_constraint')
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: post_constraint_01 2
              dba: post_constraint
              i: 0
              min: 5
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: post_constraint
                  i: 0
                  min: 5
                  r: 1
                  s: 1
                  text: where
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %chaining)
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
post_constraint_01: *79
postcircumfix__S_088Paren_Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: argument list
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: argument list
        i: 0
        min: 1
        r: 1
        s: 0
        text: (
      - !!perl/hash:RE_meta 
        a: 0
        dba: argument list
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: argument list
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: argument list
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: argument list
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'argument list')
postcircumfix__S_089Bra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: subscript
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: subscript
        i: 0
        min: 1
        r: 1
        s: 0
        text: "["
      - !!perl/hash:RE_meta 
        a: 0
        dba: subscript
        extra: "local $::GOAL = ']' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: subscript
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: subscript
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: subscript
              i: 0
              min: 1
              r: 1
              s: 0
              text: "]"
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (']' , 'subscript')
postcircumfix__S_090Cur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12347
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: subscript
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: subscript
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_meta 
        a: 0
        dba: subscript
        extra: "local $::GOAL = '}' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: subscript
        i: 0
        min: 12345
        name: semilist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: subscript
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: subscript
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: ('}' , 'subscript')
postcircumfix__S_091Lt_Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postcircumfix__S_091Lt_Gt
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postcircumfix__S_091Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: <
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:q).tweak(:w).balanced('<','>'))
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postcircumfix__S_091Lt_Gt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: postcircumfix__S_091Lt_Gt
              i: 0
              min: 1
              r: 1
              s: 0
              text: ">"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse quote-words subscript; couldn't find right angle quote")
postcircumfix__S_092LtLt_GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postcircumfix__S_092LtLt_GtGt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postcircumfix__S_092LtLt_GtGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: <<
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('<<','>>'))
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postcircumfix__S_092LtLt_GtGt
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: postcircumfix__S_092LtLt_GtGt
              i: 0
              min: 2
              r: 1
              s: 0
              text: ">>"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse quote-words subscript; couldn't find right double-angle quote")
postcircumfix__S_093Fre_Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postcircumfix__S_093Fre_Nch
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postcircumfix__S_093Fre_Nch
        i: 0
        min: 1
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('',''))
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postcircumfix__S_093Fre_Nch
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: postcircumfix__S_093Fre_Nch
              i: 0
              min: 1
              r: 1
              s: 0
              text: 
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse quote-words subscript; couldn't find right double-angle quote")
postfix__S_277MinusGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix__S_277MinusGt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: postfix__S_277MinusGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: ->
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('-> to call a method', '.')
postfix__S_278PlusPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: postfix__S_278PlusPlus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ++
postfix__S_279MinusMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: postfix__S_279MinusMinus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: --
postfix__S_282i: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix__S_282i
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: postfix__S_282i
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: i
      - !!perl/hash:RE_meta 
        a: 0
        dba: postfix__S_282i
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
postfix_prefix_meta_operator__S_083Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: &17 !!perl/hash:RE_any 
    a: 0
    altname: postfix_prefix_meta_operator__S_083Nch_00
    dba: postfix_prefix_meta_operator__S_083Nch
    i: 0
    min: 2
    name: postfix_prefix_meta_operator__S_083Nch_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        alt: postfix_prefix_meta_operator__S_083Nch_00 0
        dba: postfix_prefix_meta_operator__S_083Nch
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: 
      - !!perl/hash:RE_string 
        a: 0
        alt: postfix_prefix_meta_operator__S_083Nch_00 1
        dba: postfix_prefix_meta_operator__S_083Nch
        i: 0
        min: 2
        r: 1
        s: 0
        text: ">>"
postfix_prefix_meta_operator__S_083Nch_00: *17
postop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: &11 !!perl/hash:RE_any 
    a: 0
    altname: postop_00
    dba: postop
    i: 0
    min: 12345
    name: postop_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_sequence 
        a: 0
        alt: postop_00 0
        dba: postop
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: postop
            i: 0
            min: 12345
            name: postfix
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block 
            a: 0
            context: void
            dba: postop
            i: 0
            min: 0
            r: 1
            s: 0
            text: " $<O> := $<postfix><O> "
      - !!perl/hash:RE_sequence 
        a: 0
        alt: postop_00 1
        dba: postop
        i: 0
        min: 12345
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_method 
            a: 0
            dba: postop
            i: 0
            min: 12345
            name: postcircumfix
            r: 1
            rest: ''
            s: 0
          - !!perl/hash:RE_block 
            a: 0
            context: void
            dba: postop
            i: 0
            min: 0
            r: 1
            s: 0
            text: " $<O> := $<postcircumfix><O> "
postop_00: *11
prefix__S_280PlusPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_280PlusPlus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ++
prefix__S_281MinusMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Autoincrement
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_281MinusMinus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: --
prefix__S_284Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_284Bang
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "!"
prefix__S_285Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_285Plus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +
prefix__S_286Minus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_286Minus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "-"
prefix__S_287Tilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_287Tilde
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: '~'
prefix__S_288Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_288Question
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "?"
prefix__S_289Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_289Equal
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: =
prefix__S_290TildeCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_290TildeCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ~^
prefix__S_291PlusCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_291PlusCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +^
prefix__S_292QuestionCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_292QuestionCaret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ?^
prefix__S_293Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_293Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
prefix__S_294Vert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Symbolic_unary
  re: !!perl/hash:RE_method 
    a: 0
    dba: prefix__S_294Vert
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "|"
prefix__S_322sleep: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_322sleep
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_322sleep
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: sleep
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_322sleep
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_322sleep
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_322sleep
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_323abs: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_323abs
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_323abs
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: abs
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_323abs
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_323abs
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_323abs
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_324int: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_324int
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_324int
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: int
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_324int
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_324int
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_324int
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_325let: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_325let
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_325let
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: let
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_325let
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_325let
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_325let
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_326temp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Named_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_326temp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_326temp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: temp
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_326temp
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix__S_326temp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: prefix__S_326temp
                i: 0
                min: 1
                r: 1
                s: 0
                text: \s
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
          s: 0
prefix__S_375true: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_375true
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_375true
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: 'true'
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_375true
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
prefix__S_376not: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Loose_unary
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix__S_376not
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: prefix__S_376not
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: not
      - !!perl/hash:RE_meta 
        a: 0
        dba: prefix__S_376not
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
prefix_circumfix_meta_operator__S_081reduce: !!perl/hash:RE 
  decl: []

  kind: regex
  min: 12347
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: prefix_circumfix_meta_operator__S_081reduce
    i: 0
    min: 12347
    r: 0
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 12347
          nobind: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: prefix_circumfix_meta_operator__S_081reduce
            i: 0
            min: 12347
            r: 0
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: prefix_circumfix_meta_operator__S_081reduce
                i: 0
                min: 1
                r: 0
                s: 0
                text: "["
              - !!perl/hash:RE_bracket 
                decl: []

                min: 12346
                re: &92 !!perl/hash:RE_any 
                  a: 0
                  altname: prefix_circumfix_meta_operator__S_081reduce_02
                  dba: prefix_circumfix_meta_operator__S_081reduce
                  i: 0
                  min: 12346
                  name: prefix_circumfix_meta_operator__S_081reduce_02
                  r: 0
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_sequence 
                      a: 0
                      alt: prefix_circumfix_meta_operator__S_081reduce_02 0
                      dba: prefix_circumfix_meta_operator__S_081reduce
                      i: 0
                      min: 12346
                      r: 0
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: prefix_circumfix_meta_operator__S_081reduce
                            i: 0
                            min: 12345
                            name: infix
                            nobind: 1
                            r: 0
                            rest: ''
                            s: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 12345
                          r: 0
                          s: 0
                          var: op
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 0
                          re: &117 !!perl/hash:RE_any 
                            a: 0
                            altname: prefix_circumfix_meta_operator__S_081reduce_03
                            dba: prefix_circumfix_meta_operator__S_081reduce
                            i: 0
                            min: 0
                            name: prefix_circumfix_meta_operator__S_081reduce_03
                            r: 0
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: prefix_circumfix_meta_operator__S_081reduce_03 0
                                dba: prefix_circumfix_meta_operator__S_081reduce
                                i: 0
                                min: 1
                                r: 0
                                s: 0
                                text: 
                              - !!perl/hash:RE_assertion 
                                alt: prefix_circumfix_meta_operator__S_081reduce_03 1
                                assert: "?"
                                min: 0
                                re: !!perl/hash:RE_noop 
                                  a: 0
                                  dba: prefix_circumfix_meta_operator__S_081reduce
                                  i: 0
                                  min: 0
                                  nobind: 1
                                  r: 0
                                  s: 0
                    - !!perl/hash:RE_sequence 
                      a: 0
                      alt: prefix_circumfix_meta_operator__S_081reduce_02 1
                      dba: prefix_circumfix_meta_operator__S_081reduce
                      i: 0
                      min: 12346
                      r: 0
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: prefix_circumfix_meta_operator__S_081reduce
                            i: 0
                            min: 12345
                            name: infix_prefix_meta_operator
                            nobind: 1
                            r: 0
                            rest: ''
                            s: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 12345
                          r: 0
                          s: 0
                          var: op
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 0
                          re: &85 !!perl/hash:RE_any 
                            a: 0
                            altname: prefix_circumfix_meta_operator__S_081reduce_04
                            dba: prefix_circumfix_meta_operator__S_081reduce
                            i: 0
                            min: 0
                            name: prefix_circumfix_meta_operator__S_081reduce_04
                            r: 0
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: prefix_circumfix_meta_operator__S_081reduce_04 0
                                dba: prefix_circumfix_meta_operator__S_081reduce
                                i: 0
                                min: 1
                                r: 0
                                s: 0
                                text: 
                              - !!perl/hash:RE_assertion 
                                alt: prefix_circumfix_meta_operator__S_081reduce_04 1
                                assert: "?"
                                min: 0
                                re: !!perl/hash:RE_noop 
                                  a: 0
                                  dba: prefix_circumfix_meta_operator__S_081reduce
                                  i: 0
                                  min: 0
                                  nobind: 1
                                  r: 0
                                  s: 0
                    - !!perl/hash:RE_sequence 
                      a: 0
                      alt: prefix_circumfix_meta_operator__S_081reduce_02 2
                      dba: prefix_circumfix_meta_operator__S_081reduce
                      i: 0
                      min: 12346
                      r: 0
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: prefix_circumfix_meta_operator__S_081reduce
                            i: 0
                            min: 12345
                            name: infix_circumfix_meta_operator
                            nobind: 1
                            r: 0
                            rest: ''
                            s: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 12345
                          r: 0
                          s: 0
                          var: op
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 0
                          re: &86 !!perl/hash:RE_any 
                            a: 0
                            altname: prefix_circumfix_meta_operator__S_081reduce_05
                            dba: prefix_circumfix_meta_operator__S_081reduce
                            i: 0
                            min: 0
                            name: prefix_circumfix_meta_operator__S_081reduce_05
                            r: 0
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: prefix_circumfix_meta_operator__S_081reduce_05 0
                                dba: prefix_circumfix_meta_operator__S_081reduce
                                i: 0
                                min: 1
                                r: 0
                                s: 0
                                text: 
                              - !!perl/hash:RE_assertion 
                                alt: prefix_circumfix_meta_operator__S_081reduce_05 1
                                assert: "?"
                                min: 0
                                re: !!perl/hash:RE_noop 
                                  a: 0
                                  dba: prefix_circumfix_meta_operator__S_081reduce
                                  i: 0
                                  min: 0
                                  nobind: 1
                                  r: 0
                                  s: 0
                    - !!perl/hash:RE_sequence 
                      a: 0
                      alt: prefix_circumfix_meta_operator__S_081reduce_02 3
                      dba: prefix_circumfix_meta_operator__S_081reduce
                      i: 0
                      min: 12347
                      r: 0
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: \
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: prefix_circumfix_meta_operator__S_081reduce
                            i: 0
                            min: 12345
                            name: infix
                            nobind: 1
                            r: 0
                            rest: ''
                            s: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 12345
                          r: 0
                          s: 0
                          var: op
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 0
                          re: &87 !!perl/hash:RE_any 
                            a: 0
                            altname: prefix_circumfix_meta_operator__S_081reduce_06
                            dba: prefix_circumfix_meta_operator__S_081reduce
                            i: 0
                            min: 0
                            name: prefix_circumfix_meta_operator__S_081reduce_06
                            r: 0
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: prefix_circumfix_meta_operator__S_081reduce_06 0
                                dba: prefix_circumfix_meta_operator__S_081reduce
                                i: 0
                                min: 1
                                r: 0
                                s: 0
                                text: 
                              - !!perl/hash:RE_assertion 
                                alt: prefix_circumfix_meta_operator__S_081reduce_06 1
                                assert: "?"
                                min: 0
                                re: !!perl/hash:RE_noop 
                                  a: 0
                                  dba: prefix_circumfix_meta_operator__S_081reduce
                                  i: 0
                                  min: 0
                                  nobind: 1
                                  r: 0
                                  s: 0
                    - !!perl/hash:RE_sequence 
                      a: 0
                      alt: prefix_circumfix_meta_operator__S_081reduce_02 4
                      dba: prefix_circumfix_meta_operator__S_081reduce
                      i: 0
                      min: 12347
                      r: 0
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: \
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: prefix_circumfix_meta_operator__S_081reduce
                            i: 0
                            min: 12345
                            name: infix_prefix_meta_operator
                            nobind: 1
                            r: 0
                            rest: ''
                            s: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 12345
                          r: 0
                          s: 0
                          var: op
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 0
                          re: &88 !!perl/hash:RE_any 
                            a: 0
                            altname: prefix_circumfix_meta_operator__S_081reduce_07
                            dba: prefix_circumfix_meta_operator__S_081reduce
                            i: 0
                            min: 0
                            name: prefix_circumfix_meta_operator__S_081reduce_07
                            r: 0
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: prefix_circumfix_meta_operator__S_081reduce_07 0
                                dba: prefix_circumfix_meta_operator__S_081reduce
                                i: 0
                                min: 1
                                r: 0
                                s: 0
                                text: 
                              - !!perl/hash:RE_assertion 
                                alt: prefix_circumfix_meta_operator__S_081reduce_07 1
                                assert: "?"
                                min: 0
                                re: !!perl/hash:RE_noop 
                                  a: 0
                                  dba: prefix_circumfix_meta_operator__S_081reduce
                                  i: 0
                                  min: 0
                                  nobind: 1
                                  r: 0
                                  s: 0
                    - !!perl/hash:RE_sequence 
                      a: 0
                      alt: prefix_circumfix_meta_operator__S_081reduce_02 5
                      dba: prefix_circumfix_meta_operator__S_081reduce
                      i: 0
                      min: 12347
                      r: 0
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: \
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: prefix_circumfix_meta_operator__S_081reduce
                            i: 0
                            min: 12345
                            name: infix_circumfix_meta_operator
                            nobind: 1
                            r: 0
                            rest: ''
                            s: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 12345
                          r: 0
                          s: 0
                          var: op
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: prefix_circumfix_meta_operator__S_081reduce
                          i: 0
                          min: 1
                          r: 0
                          s: 0
                          text: "]"
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 0
                          re: &123 !!perl/hash:RE_any 
                            a: 0
                            altname: prefix_circumfix_meta_operator__S_081reduce_08
                            dba: prefix_circumfix_meta_operator__S_081reduce
                            i: 0
                            min: 0
                            name: prefix_circumfix_meta_operator__S_081reduce_08
                            r: 0
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: prefix_circumfix_meta_operator__S_081reduce_08 0
                                dba: prefix_circumfix_meta_operator__S_081reduce
                                i: 0
                                min: 1
                                r: 0
                                s: 0
                                text: 
                              - !!perl/hash:RE_assertion 
                                alt: prefix_circumfix_meta_operator__S_081reduce_08 1
                                assert: "?"
                                min: 0
                                re: !!perl/hash:RE_noop 
                                  a: 0
                                  dba: prefix_circumfix_meta_operator__S_081reduce
                                  i: 0
                                  min: 0
                                  nobind: 1
                                  r: 0
                                  s: 0
        dba: prefix_circumfix_meta_operator__S_081reduce
        i: 0
        min: 12347
        r: 0
        s: 0
        var: s
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: prefix_circumfix_meta_operator__S_081reduce
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 0
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &89 !!perl/hash:RE_any 
              a: 0
              altname: prefix_circumfix_meta_operator__S_081reduce_09
              dba: prefix_circumfix_meta_operator__S_081reduce
              i: 0
              min: 1
              name: prefix_circumfix_meta_operator__S_081reduce_09
              r: 0
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: prefix_circumfix_meta_operator__S_081reduce_09 0
                  dba: prefix_circumfix_meta_operator__S_081reduce
                  i: 0
                  min: 1
                  r: 0
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: prefix_circumfix_meta_operator__S_081reduce_09 1
                  dba: prefix_circumfix_meta_operator__S_081reduce
                  i: 0
                  min: 1
                  r: 0
                  s: 0
                  text: (
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: prefix_circumfix_meta_operator__S_081reduce
        i: 0
        min: 0
        r: 0
        s: 0
        text: " $<O> = $<s><op><O>; $<sym> = $<s>.text; "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: prefix_circumfix_meta_operator__S_081reduce
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: prefix_circumfix_meta_operator__S_081reduce
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " $<O><assoc> eq 'non' "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Can't reduce a non-associative operator")
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: prefix_circumfix_meta_operator__S_081reduce
          i: 0
          min: 0
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "!"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: prefix_circumfix_meta_operator__S_081reduce
                i: 0
                min: 0
                nobind: 1
                r: 0
                s: 0
                text: " $<O><prec> eq %conditional<prec> "
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Can't reduce a conditional operator")
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: prefix_circumfix_meta_operator__S_081reduce
        i: 0
        min: 0
        r: 0
        s: 0
        text: " $<O><assoc> = 'unary'; "
prefix_circumfix_meta_operator__S_081reduce_02: *92
prefix_circumfix_meta_operator__S_081reduce_03: *117
prefix_circumfix_meta_operator__S_081reduce_04: *85
prefix_circumfix_meta_operator__S_081reduce_05: *86
prefix_circumfix_meta_operator__S_081reduce_06: *87
prefix_circumfix_meta_operator__S_081reduce_07: *88
prefix_circumfix_meta_operator__S_081reduce_08: *123
prefix_circumfix_meta_operator__S_081reduce_09: *89
prefix_postfix_meta_operator__S_082Fre: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: &90 !!perl/hash:RE_any 
    a: 0
    altname: prefix_postfix_meta_operator__S_082Fre_00
    dba: prefix_postfix_meta_operator__S_082Fre
    i: 0
    min: 2
    name: prefix_postfix_meta_operator__S_082Fre_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        alt: prefix_postfix_meta_operator__S_082Fre_00 0
        dba: prefix_postfix_meta_operator__S_082Fre
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: 
      - !!perl/hash:RE_string 
        a: 0
        alt: prefix_postfix_meta_operator__S_082Fre_00 1
        dba: prefix_postfix_meta_operator__S_082Fre
        i: 0
        min: 2
        r: 1
        s: 0
        text: <<
prefix_postfix_meta_operator__S_082Fre_00: *90
privop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: STD::Methodcall
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: privop
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: privop
        i: 0
        min: 1
        r: 1
        s: 0
        text: "!"
      - !!perl/hash:RE_method 
        a: 0
        dba: privop
        i: 0
        min: 12345
        name: methodop
        r: 1
        rest: ''
        s: 0
quasiquibble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quasiquibble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quasiquibble
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: quasiquibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: !!perl/hash:RE_first 
          a: 0
          dba: quasiquibble
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: quasiquibble
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: quasiquibble
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $start eq '{' "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: quasiquibble
                    i: 0
                    lang: ($lang)
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_decl 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        max: 0
                        min: 0
                        noquant: 1
                        r: 1
                        s: 0
                        text: "my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); "
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        min: 12345
                        name: block
                        r: 1
                        rest: ''
                        s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: quasiquibble
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_var 
                  a: 0
                  dba: quasiquibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $start
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 12345
                  re: !!perl/hash:RE_sequence 
                    a: 0
                    dba: quasiquibble
                    i: 0
                    lang: ($lang)
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_decl 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        max: 0
                        min: 0
                        noquant: 1
                        r: 1
                        s: 0
                        text: "my $newlang = ($lang);  $C = $C->cursor_fresh($newlang); "
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: quasiquibble
                        i: 0
                        lang: ($lang)
                        min: 12345
                        name: statementlist
                        r: 1
                        rest: ''
                        s: 0
                - !!perl/hash:RE_var 
                  a: 0
                  dba: quasiquibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $stop
quibble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quibble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quibble
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_var 
        a: 0
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $start
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($lang)
      - !!perl/hash:RE_var 
        a: 0
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $stop
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: quibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        if $lang<_herelang> {\n            push @herestub_queue,\n                STD::Herestub.new(\n                    delim => $<nibble><nibbles>[0],\n                    orignode => $,\n                    lang => $lang<_herelang>,\n                );\n        }\n    "
quote__S_178Single_Single: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_178Single_Single
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_double 
        a: 0
        dba: quote__S_178Single_Single
        i: 0
        min: 1
        r: 1
        s: 0
        text: "'"
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:q).unbalanced("'"))
      - !!perl/hash:RE_double 
        a: 0
        dba: quote__S_178Single_Single
        i: 0
        min: 1
        r: 1
        s: 0
        text: "'"
quote__S_179Double_Double: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_179Double_Double
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_179Double_Double
        i: 0
        min: 1
        r: 1
        s: 0
        text: "\""
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq).unbalanced('"'))
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_179Double_Double
        i: 0
        min: 1
        r: 1
        s: 0
        text: "\""
quote__S_180Fre_Nch: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_180Fre_Nch
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_180Fre_Nch
        i: 0
        min: 1
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('',''))
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_180Fre_Nch
        i: 0
        min: 1
        r: 1
        s: 0
        text: 
quote__S_181LtLt_GtGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 4
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_181LtLt_GtGt
    i: 0
    min: 4
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_181LtLt_GtGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: <<
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak(:ww).balanced('<<','>>'))
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_181LtLt_GtGt
        i: 0
        min: 2
        r: 1
        s: 0
        text: ">>"
quote__S_182Lt_Gt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_182Lt_Gt
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_182Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: <
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ($.cursor_fresh( ::STD::Q ).tweak(:q).tweak(:w).balanced('<','>'))
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_182Lt_Gt
        i: 0
        min: 1
        r: 1
        s: 0
        text: ">"
quote__S_183Slash_Slash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_183Slash_Slash
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_183Slash_Slash
        i: 0
        min: 1
        r: 1
        s: 0
        text: /
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ( $.cursor_fresh( ::Regex ).unbalanced("/") )
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: quote__S_183Slash_Slash
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: quote__S_183Slash_Slash
              i: 0
              min: 1
              r: 1
              s: 0
              text: /
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find final '/'")
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_183Slash_Slash
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
quote__S_184qq: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quote__S_184qq
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $qm
  kind: token
  min: 12347
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_184qq
    i: 0
    min: 12347
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_184qq
        i: 0
        min: 2
        r: 1
        s: 0
        text: qq
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &21 !!perl/hash:RE_any 
          a: 0
          altname: quote__S_184qq_01
          dba: quote__S_184qq
          i: 0
          min: 12345
          name: quote__S_184qq_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_184qq_01 0
              dba: quote__S_184qq
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_184qq
                  i: 0
                  min: 12345
                  name: quote_mod
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_184qq
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_184qq
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_184qq
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: quote__S_184qq
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $qm = $<quote_mod>.text "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_184qq
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq).tweak($qm => 1))
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_184qq_01 1
              dba: quote__S_184qq
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_184qq
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_184qq
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_184qq
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_184qq
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ).tweak(:qq))
quote__S_184qq_01: *21
quote__S_185q: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quote__S_185q
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $qm
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_185q
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_185q
        i: 0
        min: 1
        r: 1
        s: 0
        text: q
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &49 !!perl/hash:RE_any 
          a: 0
          altname: quote__S_185q_01
          dba: quote__S_185q
          i: 0
          min: 12345
          name: quote__S_185q_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_185q_01 0
              dba: quote__S_185q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_185q
                  i: 0
                  min: 12345
                  name: quote_mod
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_185q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_185q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_185q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: quote__S_185q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $qm = $<quote_mod>.text "
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ).tweak(:q).tweak($qm => 1))
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_185q_01 1
              dba: quote__S_185q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_185q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_185q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_185q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_185q
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ).tweak(:q))
quote__S_185q_01: *49
quote__S_186Q: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quote__S_186Q
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $qm
  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_186Q
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quote__S_186Q
        i: 0
        min: 1
        r: 1
        s: 0
        text: Q
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &126 !!perl/hash:RE_any 
          a: 0
          altname: quote__S_186Q_01
          dba: quote__S_186Q
          i: 0
          min: 12345
          name: quote__S_186Q_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_186Q_01 0
              dba: quote__S_186Q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_186Q
                  i: 0
                  min: 12345
                  name: quote_mod
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_186Q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_186Q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_186Q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: quote__S_186Q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $qm = $<quote_mod>.text "
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ).tweak($qm => 1))
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quote__S_186Q_01 1
              dba: quote__S_186Q
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: quote__S_186Q
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: quote__S_186Q
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: quote__S_186Q
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: quote__S_186Q
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($.cursor_fresh( ::STD::Q ))
quote__S_186Q_01: *126
quote__S_197rx: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_197rx
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_197rx
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: rx
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_197rx
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_197rx
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_197rx
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ( $.cursor_fresh( ::Regex ) )
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_197rx
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_198m: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_198m
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_198m
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: m
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_198m
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_198m
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_198m
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ( $.cursor_fresh( ::Regex ) )
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_198m
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_199mm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_199mm
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_199mm
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: mm
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_199mm
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_199mm
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_199mm
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quibble
        rest: ( $.cursor_fresh( ::Regex ).tweak(:s))
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_199mm
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_200s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_200s
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_200s
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: s
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_200s
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_200s
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_200s
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: sibble
          nobind: 1
          rest: ( $.cursor_fresh( ::Regex ), $.cursor_fresh( ::STD::Q ).tweak(:qq))
        dba: quote__S_200s
        i: 0
        min: 0
        r: 1
        s: 0
        var: pat
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_200s
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_201ss: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_201ss
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_201ss
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ss
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_201ss
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_201ss
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_201ss
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: sibble
          nobind: 1
          rest: ( $.cursor_fresh( ::Regex ).tweak(:s), $.cursor_fresh( ::STD::Q ).tweak(:qq))
        dba: quote__S_201ss
        i: 0
        min: 0
        r: 1
        s: 0
        var: pat
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_201ss
          i: 0
          min: 12345
          name: old_rx_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_202tr: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_202tr
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_202tr
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: tr
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_202tr
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_202tr
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_202tr
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: tribble
          nobind: 1
          rest: ( $.cursor_fresh( ::STD::Q ).tweak(:q))
        dba: quote__S_202tr
        i: 0
        min: 0
        r: 1
        s: 0
        var: pat
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: quote__S_202tr
          i: 0
          min: 12345
          name: old_tr_mods
          nobind: 1
          r: 1
          rest: ''
          s: 0
quote__S_203quasi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: quote__S_203quasi
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: quote__S_203quasi
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: quasi
      - !!perl/hash:RE_meta 
        a: 0
        dba: quote__S_203quasi
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: quote__S_203quasi
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: quote__S_203quasi
              i: 0
              min: 1
              r: 1
              s: 0
              text: (
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: quasiquibble
        rest: ($.cursor_fresh( ::STD::Quasi ))
quote_mod__S_187w: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_187w
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: w
quote_mod__S_188ww: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_188ww
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: ww
quote_mod__S_189x: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_189x
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: x
quote_mod__S_190to: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_190to
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: to
quote_mod__S_191s: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_191s
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: s
quote_mod__S_192a: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_192a
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: a
quote_mod__S_193h: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_193h
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: h
quote_mod__S_194f: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_194f
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: f
quote_mod__S_195c: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_195c
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: c
quote_mod__S_196b: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: quote_mod__S_196b
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: b
quotepair: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: quotepair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $key
    - !!perl/hash:RE_decl 
      a: 0
      dba: quotepair
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $value
  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: colon pair (restricted)
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: quotepair
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 2
        re: &35 !!perl/hash:RE_any 
          a: 0
          altname: quotepair_01
          dba: colon pair (restricted)
          i: 0
          min: 2
          name: quotepair_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quotepair_01 0
              dba: colon pair (restricted)
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "!"
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair (restricted)
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.text; $value = 0; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'quotepair_false'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quotepair_01 1
              dba: colon pair (restricted)
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: colon pair (restricted)
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair (restricted)
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<identifier>.text; "
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: colon pair (restricted)
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: colon pair (restricted)
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_method 
                              a: 0
                              dba: colon pair (restricted)
                              i: 0
                              min: 12345
                              name: unsp
                              nobind: 1
                              r: 1
                              rest: ''
                              s: 0
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_string 
                              a: 0
                              dba: colon pair (restricted)
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: .
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_assertion 
                            assert: "?"
                            min: 0
                            re: !!perl/hash:RE_method_re 
                              a: 0
                              dba: colon pair (restricted)
                              i: 0
                              min: 0
                              name: before
                              nobind: 1
                              r: 1
                              re: !!perl/hash:RE 
                                decl: []

                                min: 1
                                re: !!perl/hash:RE_string 
                                  a: 0
                                  dba: colon pair (restricted)
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: (
                              s: 0
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: colon pair (restricted)
                            i: 0
                            min: 12345
                            name: postcircumfix
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_block 
                            a: 0
                            context: void
                            dba: colon pair (restricted)
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: " $value = $<postcircumfix>; "
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: colon pair (restricted)
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $value = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'quotepair_value'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: quotepair_01 2
              dba: colon pair (restricted)
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: colon pair (restricted)
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \d
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: 'n'
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_cclass 
                        a: 0
                        dba: colon pair (restricted)
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[a..z]"
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  dba: colon pair (restricted)
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: id
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: colon pair (restricted)
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $key = $<id>.text; $value = $<n>.text; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'quotepair_nth'
                  max: 0
                  min: 0
                  name: _REDUCE
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: colon pair (restricted)
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<k> = $key; $<v> = $value; "
quotepair_01: *35
rad_number: !!perl/hash:RE 
  decl: []

  kind: token
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: number in radix notation
    i: 0
    min: 5
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: rad_number
        i: 0
        min: 1
        r: 1
        s: 0
        text: ":"
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_meta 
              a: 0
              dba: rad_number
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
            min: 1
            quant: 
              - +
              - ":"
              - ''
              - 1
        dba: rad_number
        i: 0
        min: 1
        r: 1
        s: 0
        var: radix
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: rad_number
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: rad_number
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 3
        re: !!perl/hash:RE_first 
          a: 0
          dba: number in radix notation
          i: 0
          min: 3
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: number in radix notation
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: <
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 1
                    nobind: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: number in radix notation
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_cclass 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: "[ 0..9 a..z A..Z ]"
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 2
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: number in radix notation
                              i: 0
                              min: 2
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: number in radix notation
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: _
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_cclass 
                                    a: 0
                                    dba: number in radix notation
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: "[ 0..9 a..z A..Z ]"
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                  dba: number in radix notation
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  var: intpart
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_bracket 
                      decl: []

                      min: 2
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: number in radix notation
                        i: 0
                        min: 2
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_string 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: .
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_cclass 
                              a: 0
                              dba: number in radix notation
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "[ 0..9 a..z A..Z ]"
                            min: 1
                            quant: 
                              - +
                              - ":"
                              - ''
                              - 1
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 2
                              re: !!perl/hash:RE_sequence 
                                a: 0
                                dba: number in radix notation
                                i: 0
                                min: 2
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: number in radix notation
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: _
                                  - !!perl/hash:RE_quantified_atom 
                                    atom: !!perl/hash:RE_cclass 
                                      a: 0
                                      dba: number in radix notation
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "[ 0..9 a..z A..Z ]"
                                    min: 1
                                    quant: 
                                      - +
                                      - ":"
                                      - ''
                                      - 1
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: number in radix notation
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: fracpart
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24693
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: number in radix notation
                      i: 0
                      min: 24693
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: number in radix notation
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "*"
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 12345
                            name: radint
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          dba: number in radix notation
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          var: base
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: number in radix notation
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: "**"
                        - !!perl/hash:RE_bindnamed 
                          a: 0
                          atom: !!perl/hash:RE_method 
                            a: 0
                            dba: number in radix notation
                            i: 0
                            min: 12345
                            name: radint
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          dba: number in radix notation
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          var: exp
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ">"
            - !!perl/hash:RE_sequence 
              a: 0
              dba: number in radix notation
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: number in radix notation
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: number in radix notation
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "["
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 12345
                  name: postcircumfix
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: number in radix notation
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: number in radix notation
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: number in radix notation
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: (
                    s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: number in radix notation
                  i: 0
                  min: 12345
                  name: postcircumfix
                  r: 1
                  rest: ''
                  s: 0
radint: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &96 !!perl/hash:RE_any 
      a: 0
      altname: radint_01
      dba: radint
      i: 0
      min: 12345
      name: radint_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: radint_01 0
          dba: radint
          i: 0
          min: 12345
          name: integer
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: radint_01 1
          dba: radint
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: radint
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: radint
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: ":"
                s: 0
            - !!perl/hash:RE_method 
              a: 0
              dba: radint
              i: 0
              min: 12345
              name: rad_number
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_block 
                a: 0
                context: bool
                dba: radint
                i: 0
                min: 0
                nobind: 1
                r: 1
                s: 0
                text: "\n                        defined $<rad_number><intpart>\n                        and\n                        not defined $<rad_number><fracpart>\n                    "
radint_01: *96
regex_block: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: regex_block
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $lang = ::Regex
    - !!perl/hash:RE_decl 
      a: 0
      dba: regex_block
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '}'
  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_block
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: regex_block
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: regex_block
                i: 0
                min: 12345
                name: quotepair
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: regex_block
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: regex_block
                i: 0
                min: 0
                r: 1
                s: 0
                text: "\n\t    my $kv = $<quotepair>[*-1];\n\t    $lang = $lang.tweak($kv.<k>, $kv.<v>)\n                or self.panic(\"Unrecognized adverb :\" ~ $kv.<k> ~ '(' ~ $kv.<v> ~ ')');\n\t"
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_string 
        a: 0
        dba: regex_block
        i: 0
        min: 1
        r: 1
        s: 0
        text: "{"
      - !!perl/hash:RE_method 
        min: 0
        name: nibble
        rest: ( $.cursor_fresh($lang).unbalanced('}') )
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: regex_block
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: regex_block
              i: 0
              min: 1
              r: 1
              s: 0
              text: "}"
            - !!perl/hash:RE_method 
              min: 0
              name: panic
              nobind: 1
              rest: ("Unable to parse regex; couldn't find right brace")
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &23 !!perl/hash:RE_any 
          a: 0
          altname: regex_block_04
          dba: regex_block
          i: 0
          min: 0
          name: regex_block_04
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 0
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 0
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: regex_block
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_meta 
                              a: 0
                              dba: regex_block
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: \h
                            min: 0
                            quant: 
                              - "*"
                              - ":"
                              - ''
                              - 0
                          - !!perl/hash:RE_meta 
                            a: 0
                            dba: regex_block
                            i: 0
                            min: 0
                            r: 1
                            s: 0
                            text: $$
                    s: 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @+MEMOS[$.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block_endstmt_simple_'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 1
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_cclass 
                        a: 0
                        dba: regex_block
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: "[,:]"
                    s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block_normal_'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 2
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: $$
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @+MEMOS[$.pos]<endstmt> = 2; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block_endstmt_complex'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: regex_block_04 3
              dba: regex_block
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: regex_block
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: regex_block
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @+MEMOS[$.pos]<endargs> = 1; "
                - !!perl/hash:RE_method_internal 
                  args: $S, 'regex_block_endargs'
                  max: 0
                  min: 0
                  name: _REDUCE
regex_block_04: *23
regex_declarator__S_117regex: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_declarator__S_117regex
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_117regex
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: regex
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_117regex
        i: 0
        min: 12345
        name: regex_def
        r: 1
        rest: ''
        s: 0
regex_declarator__S_118token: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_declarator__S_118token
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_118token
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: token
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_118token
        i: 0
        min: 12345
        name: regex_def
        r: 1
        rest: ''
        s: 0
regex_declarator__S_119rule: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_declarator__S_119rule
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_119rule
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: rule
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_declarator__S_119rule
        i: 0
        min: 12345
        name: regex_def
        r: 1
        rest: ''
        s: 0
regex_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: regex_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 1
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: regex_def
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: &25 !!perl/hash:RE_any 
            a: 0
            altname: regex_def_01
            dba: regex_def
            i: 0
            min: 1
            name: regex_def_01
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: regex_def_01 0
                dba: regex_def
                i: 0
                min: 1
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: regex_def
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: "&"
                  - !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: regex_def
                      i: 0
                      min: 12345
                      name: deflongname
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
              - !!perl/hash:RE_sequence 
                a: 0
                alt: regex_def_01 1
                dba: regex_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: regex_def
                    i: 0
                    min: 12345
                    name: deflongname
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: &80 !!perl/hash:RE_any 
            a: 0
            altname: regex_def_02
            dba: regex_def
            i: 0
            min: 12345
            name: regex_def_02
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: regex_def_02 0
                dba: regex_def
                i: 0
                min: 12347
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_bracket 
                    decl: []

                    min: 12347
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: regex_def
                      i: 0
                      min: 12347
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: regex_def
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: ":"
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: regex_def
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: (
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: regex_def
                          i: 0
                          min: 12345
                          name: signature
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: regex_def
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: )
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
              - !!perl/hash:RE_sequence 
                a: 0
                alt: regex_def_02 1
                dba: regex_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: regex_def
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: regex_def
        i: 0
        min: 0
        r: 1
        s: 1
        text: " $IN_DECL = 0; "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: regex_def
        i: 0
        min: 12345
        name: regex_block
        r: 1
        rest: ''
        s: 1
regex_def_01: *25
regex_def_02: *80
routine_declarator__S_113sub: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_113sub
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_113sub
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: sub
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_113sub
        i: 0
        min: 12345
        name: routine_def
        r: 1
        rest: ''
        s: 0
routine_declarator__S_114method: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_114method
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_114method
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: method
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_114method
        i: 0
        min: 12345
        name: method_def
        r: 1
        rest: ''
        s: 0
routine_declarator__S_115submethod: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_115submethod
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_115submethod
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: submethod
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_115submethod
        i: 0
        min: 12345
        name: method_def
        r: 1
        rest: ''
        s: 0
routine_declarator__S_116macro: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_declarator__S_116macro
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_116macro
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: macro
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_declarator__S_116macro
        i: 0
        min: 12345
        name: macro_def
        r: 1
        rest: ''
        s: 0
routine_def: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: routine_def
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $IN_DECL is context<rw> = 1
  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: routine_def
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          re: &83 !!perl/hash:RE_any 
            a: 0
            altname: routine_def_01
            dba: routine_def
            i: 0
            min: 1
            name: routine_def_01
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: routine_def_01 0
                dba: routine_def
                i: 0
                min: 1
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: routine_def
                    i: 0
                    min: 1
                    r: 1
                    s: 1
                    text: "&"
                  - !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: routine_def
                      i: 0
                      min: 12345
                      name: deflongname
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
              - !!perl/hash:RE_sequence 
                a: 0
                alt: routine_def_01 1
                dba: routine_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: routine_def
                    i: 0
                    min: 12345
                    name: deflongname
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: &107 !!perl/hash:RE_any 
            a: 0
            altname: routine_def_02
            dba: routine_def
            i: 0
            min: 12345
            name: routine_def_02
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: routine_def_02 0
                dba: routine_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: routine_def
                    i: 0
                    min: 12345
                    name: multisig
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
              - !!perl/hash:RE_sequence 
                a: 0
                alt: routine_def_02 1
                dba: routine_def
                i: 0
                min: 12345
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: routine_def
                    i: 0
                    min: 12345
                    name: trait
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: routine_def
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 1
          text: "\n        $ = $+PARSER.bless($);\n        $IN_DECL = 0;\n    "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: routine_def
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
routine_def_01: *83
routine_def_02: *107
scope_declarator__S_095my: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_095my
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_095my
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: my
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_095my
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_095my
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_095my
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<SIGIL> = $<scoped><SIGIL> "
scope_declarator__S_096our: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_096our
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_096our
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: our
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_096our
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_096our
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_096our
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<SIGIL> = $<scoped><SIGIL> "
scope_declarator__S_097state: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_097state
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_097state
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: state
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_097state
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_097state
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_097state
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<SIGIL> = $<scoped><SIGIL> "
scope_declarator__S_098constant: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_098constant
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_098constant
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: constant
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_098constant
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_098constant
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_098constant
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<SIGIL> = $<scoped><SIGIL> "
scope_declarator__S_099has: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scope_declarator__S_099has
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_099has
        endsym: nofun
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: has
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_099has
        i: 0
        min: 12345
        name: nofun
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: scope_declarator__S_099has
        i: 0
        min: 12345
        name: scoped
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: scope_declarator__S_099has
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<SIGIL> = $<scoped><SIGIL> "
scoped: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: scoped declarator
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &56 !!perl/hash:RE_any 
          a: 0
          altname: scoped_01
          dba: scoped declarator
          i: 0
          min: 12345
          name: scoped_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: scoped_01 0
              dba: scoped declarator
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  name: declarator
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: scoped declarator
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: " $<SIGIL> = $<declarator><SIGIL> "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: scoped_01 1
              dba: scoped declarator
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  name: regex_declarator
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: scoped_01 2
              dba: scoped declarator
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  name: package_declarator
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: scoped_01 3
              dba: scoped declarator
              i: 0
              min: 24690
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: scoped declarator
                    i: 0
                    min: 12345
                    name: fulltypename
                    r: 1
                    rest: ''
                    s: 1
                  min: 12345
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  name: multi_declarator
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: scoped_01 4
              dba: scoped declarator
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: scoped declarator
                  i: 0
                  min: 12345
                  name: multi_declarator
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: scoped declarator
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: " $<SIGIL> = $<multi_declarator><SIGIL> "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
scoped_01: *56
semilist: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: semicolon list
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &45 !!perl/hash:RE_any 
          a: 0
          altname: semilist_01
          dba: semicolon list
          i: 0
          min: 0
          name: semilist_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: semilist_01 0
              dba: semicolon list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: semicolon list
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: semicolon list
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_cclass 
                            a: 0
                            dba: semicolon list
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: "[\\)\\]\\}]"
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: semilist_01 1
              dba: semicolon list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24690
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: semicolon list
                      i: 0
                      min: 24690
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: semicolon list
                          i: 0
                          min: 12345
                          name: statement
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: semicolon list
                          i: 0
                          min: 12345
                          name: eat_terminator
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
semilist_01: *45
sibble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: sibble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: sibble
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_var 
        a: 0
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $start
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: nibble
          nobind: 1
          rest: ($lang)
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: left
      - !!perl/hash:RE_var 
        a: 0
        dba: sibble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $stop
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: sibble
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: sibble
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: sibble
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $start ne $stop "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: sibble
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: sibble
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_string 
                        a: 0
                        dba: sibble
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: =
                      - !!perl/hash:RE_method 
                        min: 0
                        name: panic
                        nobind: 1
                        rest: ("Missing '='")
                - !!perl/hash:RE_method 
                  a: 0
                  dba: sibble
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    min: 0
                    name: EXPR
                    nobind: 1
                    rest: (item %item_assignment)
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: right
            - !!perl/hash:RE_sequence 
              a: 0
              dba: sibble
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $lang = $lang2.unbalanced($stop); "
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    min: 0
                    name: nibble
                    nobind: 1
                    rest: ($lang)
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: right
                - !!perl/hash:RE_var 
                  a: 0
                  dba: sibble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $stop
sigil__S_164Dollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_164Dollar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: $
sigil__S_165AtAt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_165AtAt
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "@@"
sigil__S_166At: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_166At
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "@"
sigil__S_167Percent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_167Percent
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "%"
sigil__S_168Amp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: sigil__S_168Amp
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "&"
signature: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: signature
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_DECL is context<rw> = 1
    - !!perl/hash:RE_decl 
      a: 0
      dba: signature
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $zone is context<rw> = 'posreq'
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: signature
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: signature
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: &66 !!perl/hash:RE_any 
            a: 0
            altname: signature_01
            dba: signature
            i: 0
            min: 0
            name: signature_01
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                alt: signature_01 0
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: signature
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: &8 !!perl/hash:RE_any 
                      a: 0
                      altname: signature_02
                      dba: signature
                      i: 0
                      min: 1
                      name: signature_02
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 0
                          dba: signature
                          i: 0
                          min: 3
                          r: 1
                          s: 0
                          text: -->
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 1
                          dba: signature
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: )
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: signature_02 2
                          dba: signature
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: "{"
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                alt: signature_01 1
                dba: signature
                i: 0
                min: 12345
                name: parameter
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_method 
            a: 0
            dba: signature
            i: 0
            min: 12345
            name: param_sep
            r: 1
            rest: ''
            s: 0
          - 1
      - !!perl/hash:RE_method 
        a: 0
        dba: signature
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24693
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: signature
            i: 0
            min: 24693
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: signature
                i: 0
                min: 3
                r: 1
                s: 0
                text: -->
              - !!perl/hash:RE_method 
                a: 0
                dba: signature
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: signature
                i: 0
                min: 12345
                name: fulltypename
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: signature
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $IN_DECL = 0; "
signature_01: *66
signature_02: *8
sigterm: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: sigterm
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: sigterm
        i: 0
        min: 2
        r: 1
        s: 0
        text: :(
      - !!perl/hash:RE_meta 
        a: 0
        dba: sigterm
        extra: "local $::GOAL = ')' "
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        a: 0
        dba: sigterm
        i: 0
        min: 12345
        name: signature
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: sigterm
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_string 
              a: 0
              dba: sigterm
              i: 0
              min: 1
              r: 1
              s: 0
              text: )
            - !!perl/hash:RE_method 
              min: 0
              name: FAILGOAL
              nobind: 1
              rest: (')' , 'sigterm')
spacey: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "?"
    min: 0
    re: !!perl/hash:RE_method_re 
      a: 0
      dba: spacey
      i: 0
      min: 0
      name: before
      nobind: 1
      r: 1
      re: !!perl/hash:RE 
        decl: []

        min: 1
        re: &70 !!perl/hash:RE_any 
          a: 0
          altname: spacey_01
          dba: spacey
          i: 0
          min: 1
          name: spacey_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_meta 
              a: 0
              alt: spacey_01 0
              dba: spacey
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
            - !!perl/hash:RE_string 
              a: 0
              alt: spacey_01 1
              dba: spacey
              i: 0
              min: 1
              r: 1
              s: 0
              text: "#"
      s: 0
spacey_01: *70
special_variable__S_120Dollar_a2_: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: special_variable__S_120Dollar_a2_
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: $
special_variable__S_121DollarBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_121DollarBang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_121DollarBang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $!
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_121DollarBang
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: special_variable__S_121DollarBang
              i: 0
              min: 1
              r: 1
              s: 0
              text: \w
          s: 0
special_variable__S_122DollarBangCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_122DollarBangCur_Ly
    i: 0
    min: 5
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 5
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: special_variable__S_122DollarBangCur_Ly
            i: 0
            min: 5
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_122DollarBangCur_Ly
                i: 0
                min: 3
                r: 1
                s: 0
                text: $!{
              - !!perl/hash:RE_meta 
                a: 0
                dba: special_variable__S_122DollarBangCur_Ly
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_bindpos 
                atom: !!perl/hash:RE_paren 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_122DollarBangCur_Ly
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .*?
                min: 1
                var: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_122DollarBangCur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "}"
        min: 5
        var: 1
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ($0.text ~ " variable", 'smart match against $!')
special_variable__S_123DollarSlash: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_123DollarSlash
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_123DollarSlash
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $/
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: special_variable__S_123DollarSlash
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: special_variable__S_123DollarSlash
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: special_variable__S_123DollarSlash
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: special_variable__S_123DollarSlash
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: special_variable__S_123DollarSlash
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: =
                        - !!perl/hash:RE_assertion 
                          assert: "!"
                          min: 0
                          re: !!perl/hash:RE_cclass 
                            a: 0
                            dba: special_variable__S_123DollarSlash
                            i: 0
                            min: 1
                            nobind: 1
                            r: 1
                            s: 0
                            text: "[=]"
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                rest: "('$/ variable as input record separator',\n             \"filehandle's :irs attribute\")"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
special_variable__S_124DollarTilde: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_124DollarTilde
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_124DollarTilde
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $~
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_124DollarTilde
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_124DollarTilde
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &113 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_124DollarTilde_01
              dba: special_variable__S_124DollarTilde
              i: 0
              min: 1
              name: special_variable__S_124DollarTilde_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_124DollarTilde_01 0
                  dba: special_variable__S_124DollarTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_124DollarTilde_01 1
                  dba: special_variable__S_124DollarTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_124DollarTilde_01 2
                  dba: special_variable__S_124DollarTilde
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_124DollarTilde_01 3
                  dba: special_variable__S_124DollarTilde
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$~ variable', 'Form module')
special_variable__S_124DollarTilde_01: *113
special_variable__S_125DollarGrave: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_125DollarGrave
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_125DollarGrave
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $`
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_125DollarGrave
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_125DollarGrave
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &2 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_125DollarGrave_01
              dba: special_variable__S_125DollarGrave
              i: 0
              min: 1
              name: special_variable__S_125DollarGrave_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_125DollarGrave_01 0
                  dba: special_variable__S_125DollarGrave
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_125DollarGrave_01 1
                  dba: special_variable__S_125DollarGrave
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_125DollarGrave_01 2
                  dba: special_variable__S_125DollarGrave
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$` variable', 'explicit pattern before <(')
special_variable__S_125DollarGrave_01: *2
special_variable__S_126DollarAt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_126DollarAt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_126DollarAt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $@
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_126DollarAt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$@ variable as eval error', '$!')
special_variable__S_127DollarSharp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_127DollarSharp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_127DollarSharp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $#
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_127DollarSharp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: special_variable__S_127DollarSharp
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: special_variable__S_127DollarSharp
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_meta 
                        a: 0
                        dba: special_variable__S_127DollarSharp
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \w
                      min: 1
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                  min: 1
                  var: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: obs
                  rest: ("\$#" ~ $0.text ~ " variable", "\@{" ~ $0.text ~ "}.end")
            - !!perl/hash:RE_method 
              min: 0
              name: obs
              rest: ('$# variable', '.fmt')
special_variable__S_128DollarDollar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_128DollarDollar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_128DollarDollar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $$
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method 
          a: 0
          dba: special_variable__S_128DollarDollar
          i: 0
          min: 12345
          name: alpha
          nobind: 1
          r: 1
          rest: ''
          s: 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_128DollarDollar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_128DollarDollar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &34 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_128DollarDollar_01
              dba: special_variable__S_128DollarDollar
              i: 0
              min: 1
              name: special_variable__S_128DollarDollar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_128DollarDollar_01 0
                  dba: special_variable__S_128DollarDollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_128DollarDollar_01 1
                  dba: special_variable__S_128DollarDollar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_128DollarDollar_01 2
                  dba: special_variable__S_128DollarDollar
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$$ variable', '$*PID')
special_variable__S_128DollarDollar_01: *34
special_variable__S_129DollarPercent: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_129DollarPercent
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_129DollarPercent
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $%
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_129DollarPercent
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$% variable', 'Form module')
special_variable__S_130DollarCaretX: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_130DollarCaretX
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_130DollarCaretX
        i: 0
        min: 12345
        name: sigil
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_130DollarCaretX
        i: 0
        min: 1
        r: 1
        s: 0
        text: "^"
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 1
          nobind: 1
          re: !!perl/hash:RE_cclass 
            a: 0
            dba: special_variable__S_130DollarCaretX
            i: 0
            min: 1
            r: 1
            s: 0
            text: "[A..Z]"
        dba: special_variable__S_130DollarCaretX
        i: 0
        min: 1
        r: 1
        s: 0
        var: letter
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_130DollarCaretX
        i: 0
        min: 1
        r: 1
        s: 0
        text: \W
      - !!perl/hash:RE_method 
        min: 0
        name: obscaret
        rest: ($<sigil>.text ~ '^' ~ $<letter>.text, $<sigil>, $<letter>.text)
special_variable__S_131DollarCaret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_131DollarCaret
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_131DollarCaret
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $^
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_131DollarCaret
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_131DollarCaret
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &4 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_131DollarCaret_01
              dba: special_variable__S_131DollarCaret
              i: 0
              min: 1
              name: special_variable__S_131DollarCaret_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_131DollarCaret_01 0
                  dba: special_variable__S_131DollarCaret
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_131DollarCaret_01 1
                  dba: special_variable__S_131DollarCaret
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_131DollarCaret_01 2
                  dba: special_variable__S_131DollarCaret
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_131DollarCaret_01 3
                  dba: special_variable__S_131DollarCaret
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$^ variable', 'Form module')
special_variable__S_131DollarCaret_01: *4
special_variable__S_132DollarAmp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_132DollarAmp
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_132DollarAmp
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $&
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_132DollarAmp
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_132DollarAmp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &40 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_132DollarAmp_01
              dba: special_variable__S_132DollarAmp
              i: 0
              min: 1
              name: special_variable__S_132DollarAmp_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_132DollarAmp_01 0
                  dba: special_variable__S_132DollarAmp
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_132DollarAmp_01 1
                  dba: special_variable__S_132DollarAmp
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_132DollarAmp_01 2
                  dba: special_variable__S_132DollarAmp
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$& variable', '$/ or $()')
special_variable__S_132DollarAmp_01: *40
special_variable__S_133DollarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_133DollarStar
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_133DollarStar
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $*
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_133DollarStar
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_133DollarStar
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &74 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_133DollarStar_01
              dba: special_variable__S_133DollarStar
              i: 0
              min: 1
              name: special_variable__S_133DollarStar_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_133DollarStar_01 0
                  dba: special_variable__S_133DollarStar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_133DollarStar_01 1
                  dba: special_variable__S_133DollarStar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_133DollarStar_01 2
                  dba: special_variable__S_133DollarStar
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_133DollarStar_01 3
                  dba: special_variable__S_133DollarStar
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$* variable', '^^ and $$')
special_variable__S_133DollarStar_01: *74
special_variable__S_134DollarThesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_134DollarThesis
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_134DollarThesis
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $)
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_134DollarThesis
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_134DollarThesis
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &127 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_134DollarThesis_01
              dba: special_variable__S_134DollarThesis
              i: 0
              min: 1
              name: special_variable__S_134DollarThesis_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_134DollarThesis_01 0
                  dba: special_variable__S_134DollarThesis
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_134DollarThesis_01 1
                  dba: special_variable__S_134DollarThesis
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_134DollarThesis_01 2
                  dba: special_variable__S_134DollarThesis
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$) variable', '$*EGID')
special_variable__S_134DollarThesis_01: *127
special_variable__S_135DollarMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_135DollarMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_135DollarMinus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $-
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_135DollarMinus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_135DollarMinus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &115 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_135DollarMinus_01
              dba: special_variable__S_135DollarMinus
              i: 0
              min: 1
              name: special_variable__S_135DollarMinus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_135DollarMinus_01 0
                  dba: special_variable__S_135DollarMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_135DollarMinus_01 1
                  dba: special_variable__S_135DollarMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_135DollarMinus_01 2
                  dba: special_variable__S_135DollarMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_135DollarMinus_01 3
                  dba: special_variable__S_135DollarMinus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$- variable', 'Form module')
special_variable__S_135DollarMinus_01: *115
special_variable__S_136DollarEqual: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_136DollarEqual
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_136DollarEqual
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $=
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_136DollarEqual
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_136DollarEqual
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &77 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_136DollarEqual_01
              dba: special_variable__S_136DollarEqual
              i: 0
              min: 1
              name: special_variable__S_136DollarEqual_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_136DollarEqual_01 0
                  dba: special_variable__S_136DollarEqual
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_136DollarEqual_01 1
                  dba: special_variable__S_136DollarEqual
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_136DollarEqual_01 2
                  dba: special_variable__S_136DollarEqual
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_136DollarEqual_01 3
                  dba: special_variable__S_136DollarEqual
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$= variable', 'Form module')
special_variable__S_136DollarEqual_01: *77
special_variable__S_137AtPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_137AtPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_137AtPlus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "@+"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_137AtPlus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_137AtPlus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &27 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_137AtPlus_01
              dba: special_variable__S_137AtPlus
              i: 0
              min: 1
              name: special_variable__S_137AtPlus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_137AtPlus_01 0
                  dba: special_variable__S_137AtPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_137AtPlus_01 1
                  dba: special_variable__S_137AtPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_137AtPlus_01 2
                  dba: special_variable__S_137AtPlus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('@+ variable', '.to method')
special_variable__S_137AtPlus_01: *27
special_variable__S_138PercentPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_138PercentPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_138PercentPlus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "%+"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_138PercentPlus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_138PercentPlus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &47 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_138PercentPlus_01
              dba: special_variable__S_138PercentPlus
              i: 0
              min: 1
              name: special_variable__S_138PercentPlus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_138PercentPlus_01 0
                  dba: special_variable__S_138PercentPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_138PercentPlus_01 1
                  dba: special_variable__S_138PercentPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_138PercentPlus_01 2
                  dba: special_variable__S_138PercentPlus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('%+ variable', '.to method')
special_variable__S_138PercentPlus_01: *47
special_variable__S_139DollarPlusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_139DollarPlusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_139DollarPlusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: $+[
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('@+ variable', '.to method')
special_variable__S_140AtPlusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_140AtPlusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_140AtPlusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@+["
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('@+ variable', '.to method')
special_variable__S_141AtPlusCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_141AtPlusCur_Ly
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_141AtPlusCur_Ly
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@+{"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('%+ variable', '.to method')
special_variable__S_142AtMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_142AtMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_142AtMinus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "@-"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_142AtMinus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_142AtMinus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &61 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_142AtMinus_01
              dba: special_variable__S_142AtMinus
              i: 0
              min: 1
              name: special_variable__S_142AtMinus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_142AtMinus_01 0
                  dba: special_variable__S_142AtMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_142AtMinus_01 1
                  dba: special_variable__S_142AtMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_142AtMinus_01 2
                  dba: special_variable__S_142AtMinus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('@- variable', '.from method')
special_variable__S_142AtMinus_01: *61
special_variable__S_143PercentMinus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_143PercentMinus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_143PercentMinus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "%-"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_143PercentMinus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_143PercentMinus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &81 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_143PercentMinus_01
              dba: special_variable__S_143PercentMinus
              i: 0
              min: 1
              name: special_variable__S_143PercentMinus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_143PercentMinus_01 0
                  dba: special_variable__S_143PercentMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_143PercentMinus_01 1
                  dba: special_variable__S_143PercentMinus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_143PercentMinus_01 2
                  dba: special_variable__S_143PercentMinus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('%- variable', '.from method')
special_variable__S_143PercentMinus_01: *81
special_variable__S_144DollarMinusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_144DollarMinusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_144DollarMinusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: $-[
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('@- variable', '.from method')
special_variable__S_145AtMinusBra_Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_145AtMinusBra_Ket
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_145AtMinusBra_Ket
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@-["
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('@- variable', '.from method')
special_variable__S_146PercentMinusCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_146PercentMinusCur_Ly
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_146PercentMinusCur_Ly
        i: 0
        min: 3
        r: 1
        s: 0
        text: "@-{"
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('%- variable', '.from method')
special_variable__S_147DollarPlus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_147DollarPlus
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_147DollarPlus
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $+
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_147DollarPlus
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_147DollarPlus
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &76 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_147DollarPlus_01
              dba: special_variable__S_147DollarPlus
              i: 0
              min: 1
              name: special_variable__S_147DollarPlus_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_147DollarPlus_01 0
                  dba: special_variable__S_147DollarPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_147DollarPlus_01 1
                  dba: special_variable__S_147DollarPlus
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_147DollarPlus_01 2
                  dba: special_variable__S_147DollarPlus
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$+ variable', 'Form module')
special_variable__S_147DollarPlus_01: *76
special_variable__S_148DollarCurCaret_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12349
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_148DollarCurCaret_Ly
    i: 0
    min: 12349
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 12349
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: special_variable__S_148DollarCurCaret_Ly
            i: 0
            min: 12349
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_method 
                a: 0
                dba: special_variable__S_148DollarCurCaret_Ly
                i: 0
                min: 12345
                name: sigil
                r: 1
                rest: ''
                s: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_148DollarCurCaret_Ly
                i: 0
                min: 2
                r: 1
                s: 0
                text: "{^"
              - !!perl/hash:RE_meta 
                a: 0
                dba: special_variable__S_148DollarCurCaret_Ly
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_bindpos 
                atom: !!perl/hash:RE_paren 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_148DollarCurCaret_Ly
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .*?
                min: 1
                var: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_148DollarCurCaret_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "}"
        min: 12349
        var: 1
      - !!perl/hash:RE_method 
        min: 0
        name: obscaret
        rest: ($0.text, $<sigil>, $0.{0}.text)
special_variable__S_149ColonColonCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_149ColonColonCur_Ly
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: special_variable__S_149ColonColonCur_Ly
        i: 0
        min: 2
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_149ColonColonCur_Ly
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: special_variable__S_149ColonColonCur_Ly
              i: 0
              min: 1
              r: 1
              s: 0
              text: "{"
          s: 0
special_variable__S_150DollarCur_Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 4
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_150DollarCur_Ly
    i: 0
    min: 4
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindpos 
        atom: !!perl/hash:RE_paren 
          decl: []

          min: 4
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: special_variable__S_150DollarCur_Ly
            i: 0
            min: 4
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_cclass 
                a: 0
                dba: special_variable__S_150DollarCur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "[$@%]"
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_150DollarCur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "{"
              - !!perl/hash:RE_meta 
                a: 0
                dba: special_variable__S_150DollarCur_Ly
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_bindpos 
                atom: !!perl/hash:RE_paren 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_150DollarCur_Ly
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: .*?
                min: 1
                var: 0
              - !!perl/hash:RE_string 
                a: 0
                dba: special_variable__S_150DollarCur_Ly
                i: 0
                min: 1
                r: 1
                s: 0
                text: "}"
        min: 4
        var: 1
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ("" ~ $0.text ~ " variable", "{" ~ $<sigil>.text ~ "}(" ~ $0.{0}.text ~ ")")
special_variable__S_151DollarBra: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_151DollarBra
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_151DollarBra
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $[
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_151DollarBra
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_151DollarBra
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &69 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_151DollarBra_01
              dba: special_variable__S_151DollarBra
              i: 0
              min: 1
              name: special_variable__S_151DollarBra_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_151DollarBra_01 0
                  dba: special_variable__S_151DollarBra
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_151DollarBra_01 1
                  dba: special_variable__S_151DollarBra
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_151DollarBra_01 2
                  dba: special_variable__S_151DollarBra
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_151DollarBra_01 3
                  dba: special_variable__S_151DollarBra
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$[ variable', 'user-defined array indices')
special_variable__S_151DollarBra_01: *69
special_variable__S_152DollarKet: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_152DollarKet
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_152DollarKet
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $]
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_152DollarKet
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_152DollarKet
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &118 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_152DollarKet_01
              dba: special_variable__S_152DollarKet
              i: 0
              min: 1
              name: special_variable__S_152DollarKet_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_152DollarKet_01 0
                  dba: special_variable__S_152DollarKet
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_152DollarKet_01 1
                  dba: special_variable__S_152DollarKet
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_152DollarKet_01 2
                  dba: special_variable__S_152DollarKet
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$] variable', '$*PERL_VERSION')
special_variable__S_152DollarKet_01: *118
special_variable__S_153DollarBack: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_153DollarBack
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_153DollarBack
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $\
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_153DollarBack
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_153DollarBack
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &98 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_153DollarBack_01
              dba: special_variable__S_153DollarBack
              i: 0
              min: 1
              name: special_variable__S_153DollarBack_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_153DollarBack_01 0
                  dba: special_variable__S_153DollarBack
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_153DollarBack_01 1
                  dba: special_variable__S_153DollarBack
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_153DollarBack_01 2
                  dba: special_variable__S_153DollarBack
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_153DollarBack_01 3
                  dba: special_variable__S_153DollarBack
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$\\ variable', "the filehandle's :ors attribute")
special_variable__S_153DollarBack_01: *98
special_variable__S_154DollarVert: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_154DollarVert
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_154DollarVert
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $|
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_154DollarVert
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_154DollarVert
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &7 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_154DollarVert_01
              dba: special_variable__S_154DollarVert
              i: 0
              min: 1
              name: special_variable__S_154DollarVert_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_154DollarVert_01 0
                  dba: special_variable__S_154DollarVert
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_154DollarVert_01 1
                  dba: special_variable__S_154DollarVert
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_154DollarVert_01 2
                  dba: special_variable__S_154DollarVert
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_154DollarVert_01 3
                  dba: special_variable__S_154DollarVert
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$| variable', 'Form module')
special_variable__S_154DollarVert_01: *7
special_variable__S_155DollarColon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_155DollarColon
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_155DollarColon
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "$:"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_155DollarColon
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: special_variable__S_155DollarColon
              i: 0
              min: 1
              r: 1
              s: 0
              text: "[\\x20\\t\\n\\],=)}]"
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: "('$: variable', 'Form module')"
special_variable__S_156DollarSemi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_156DollarSemi
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_156DollarSemi
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $;
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_156DollarSemi
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_156DollarSemi
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &97 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_156DollarSemi_01
              dba: special_variable__S_156DollarSemi
              i: 0
              min: 1
              name: special_variable__S_156DollarSemi_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_156DollarSemi_01 0
                  dba: special_variable__S_156DollarSemi
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_156DollarSemi_01 1
                  dba: special_variable__S_156DollarSemi
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_156DollarSemi_01 2
                  dba: special_variable__S_156DollarSemi
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_156DollarSemi_01 3
                  dba: special_variable__S_156DollarSemi
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$; variable', 'real multidimensional hashes')
special_variable__S_156DollarSemi_01: *97
special_variable__S_157DollarSingle: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_157DollarSingle
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_157DollarSingle
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $'
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_157DollarSingle
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_157DollarSingle
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &10 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_157DollarSingle_01
              dba: special_variable__S_157DollarSingle
              i: 0
              min: 1
              name: special_variable__S_157DollarSingle_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_157DollarSingle_01 0
                  dba: special_variable__S_157DollarSingle
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_157DollarSingle_01 1
                  dba: special_variable__S_157DollarSingle
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_157DollarSingle_01 2
                  dba: special_variable__S_157DollarSingle
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$' ~ "'" ~ 'variable', "explicit pattern after )\x3E")
special_variable__S_157DollarSingle_01: *10
special_variable__S_158DollarDouble: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_158DollarDouble
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_158DollarDouble
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_158DollarDouble
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_158DollarDouble
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &129 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_158DollarDouble_01
              dba: special_variable__S_158DollarDouble
              i: 0
              min: 1
              name: special_variable__S_158DollarDouble_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_158DollarDouble_01 0
                  dba: special_variable__S_158DollarDouble
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_158DollarDouble_01 1
                  dba: special_variable__S_158DollarDouble
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_158DollarDouble_01 2
                  dba: special_variable__S_158DollarDouble
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: =
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_158DollarDouble_01 3
                  dba: special_variable__S_158DollarDouble
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$" variable', '.join() method')
special_variable__S_158DollarDouble_01: *129
special_variable__S_159DollarComma: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_159DollarComma
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_159DollarComma
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $,
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_159DollarComma
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_159DollarComma
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &58 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_159DollarComma_01
              dba: special_variable__S_159DollarComma
              i: 0
              min: 1
              name: special_variable__S_159DollarComma_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_159DollarComma_01 0
                  dba: special_variable__S_159DollarComma
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_159DollarComma_01 1
                  dba: special_variable__S_159DollarComma
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_159DollarComma_01 2
                  dba: special_variable__S_159DollarComma
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$, variable', ".join() method")
special_variable__S_159DollarComma_01: *58
special_variable__S_160DollarLt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_160DollarLt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_160DollarLt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "['$<']"
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_160DollarLt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_160DollarLt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 2
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: special_variable__S_160DollarLt
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_160DollarLt
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \s
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_160DollarLt
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \w
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: special_variable__S_160DollarLt
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \s
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: special_variable__S_160DollarLt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ">"
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$< variable', '$*UID')
special_variable__S_161DollarGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_161DollarGt
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_161DollarGt
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $>
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_161DollarGt
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_161DollarGt
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &44 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_161DollarGt_01
              dba: special_variable__S_161DollarGt
              i: 0
              min: 1
              name: special_variable__S_161DollarGt_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_161DollarGt_01 0
                  dba: special_variable__S_161DollarGt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_161DollarGt_01 1
                  dba: special_variable__S_161DollarGt
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_161DollarGt_01 2
                  dba: special_variable__S_161DollarGt
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ("$() variable", '$*EUID')
special_variable__S_161DollarGt_01: *44
special_variable__S_162DollarDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_162DollarDot
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_162DollarDot
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $.
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_162DollarDot
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_162DollarDot
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &73 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_162DollarDot_01
              dba: special_variable__S_162DollarDot
              i: 0
              min: 1
              name: special_variable__S_162DollarDot_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_162DollarDot_01 0
                  dba: special_variable__S_162DollarDot
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_162DollarDot_01 1
                  dba: special_variable__S_162DollarDot
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_162DollarDot_01 2
                  dba: special_variable__S_162DollarDot
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$. variable', "filehandle's .line method")
special_variable__S_162DollarDot_01: *73
special_variable__S_163DollarQuestion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: special_variable__S_163DollarQuestion
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: special_variable__S_163DollarQuestion
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: $?
      - !!perl/hash:RE_meta 
        a: 0
        dba: special_variable__S_163DollarQuestion
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: special_variable__S_163DollarQuestion
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: &29 !!perl/hash:RE_any 
              a: 0
              altname: special_variable__S_163DollarQuestion_01
              dba: special_variable__S_163DollarQuestion
              i: 0
              min: 1
              name: special_variable__S_163DollarQuestion_01
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  alt: special_variable__S_163DollarQuestion_01 0
                  dba: special_variable__S_163DollarQuestion
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: \s
                - !!perl/hash:RE_string 
                  a: 0
                  alt: special_variable__S_163DollarQuestion_01 1
                  dba: special_variable__S_163DollarQuestion
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: ","
                - !!perl/hash:RE_method 
                  a: 0
                  alt: special_variable__S_163DollarQuestion_01 2
                  dba: special_variable__S_163DollarQuestion
                  i: 0
                  min: 12345
                  name: terminator
                  r: 1
                  rest: ''
                  s: 0
          s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: obs
        rest: ('$? variable as child error', '$!')
special_variable__S_163DollarQuestion_01: *29
starter: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: starter
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
statement: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: statement
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $endargs is context = -1
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_cclass 
              a: 0
              dba: statement
              i: 0
              min: 1
              r: 1
              s: 0
              text: "[\\)\\]\\}]"
          s: 0
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_assertion 
          assert: "!"
          min: 0
          nobind: 1
          re: !!perl/hash:RE_block 
            a: 0
            context: bool
            dba: statement
            i: 0
            min: 0
            nobind: 1
            r: 1
            s: 0
            text: " $ = $+PARSER.bless($); "
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &38 !!perl/hash:RE_any 
          a: 0
          altname: statement_02
          dba: statement end
          i: 0
          min: 0
          name: statement_02
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 0
              dba: statement
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: label
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: statement
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_label'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 1
              dba: statement
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: statement_control
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 2
              dba: statement end
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement
                  i: 0
                  min: 12345
                  name: EXPR
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_expr'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_bracket 
                  decl: []

                  min: 0
                  re: !!perl/hash:RE_first 
                    a: 0
                    dba: statement modifier
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_block 
                          a: 0
                          context: bool
                          dba: statement end
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
                          text: " (@+MEMOS[$.pos]<endstmt> // 0) == 2 "
                      - !!perl/hash:RE_sequence 
                        a: 0
                        dba: statement modifier
                        i: 0
                        min: 12345
                        r: 1
                        s: 0
                        zyg: 
                          - !!perl/hash:RE_method 
                            a: 0
                            dba: statement modifier
                            i: 0
                            min: 12345
                            name: ws
                            nobind: 1
                            r: 1
                            rest: ''
                            s: 0
                          - !!perl/hash:RE_quantified_atom 
                            atom: !!perl/hash:RE_bracket 
                              decl: []

                              min: 12345
                              re: &125 !!perl/hash:RE_any 
                                a: 0
                                altname: statement_05
                                dba: statement modifier loop
                                i: 0
                                min: 12345
                                name: statement_05
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_sequence 
                                    a: 0
                                    alt: statement_05 0
                                    dba: statement modifier
                                    i: 0
                                    min: 12345
                                    r: 1
                                    s: 0
                                    zyg: 
                                      - !!perl/hash:RE_method 
                                        a: 0
                                        dba: statement modifier
                                        i: 0
                                        min: 12345
                                        name: statement_mod_loop
                                        r: 1
                                        rest: ''
                                        s: 0
                                      - !!perl/hash:RE_method_internal 
                                        args: $S, 'statement_mod_loop'
                                        max: 0
                                        min: 0
                                        name: _REDUCE
                                  - !!perl/hash:RE_sequence 
                                    a: 0
                                    alt: statement_05 1
                                    dba: statement modifier loop
                                    i: 0
                                    min: 12345
                                    r: 1
                                    s: 0
                                    zyg: 
                                      - !!perl/hash:RE_method 
                                        a: 0
                                        dba: statement modifier
                                        i: 0
                                        min: 12345
                                        name: statement_mod_cond
                                        r: 1
                                        rest: ''
                                        s: 0
                                      - !!perl/hash:RE_method_internal 
                                        args: $S, 'statement_mod_cond'
                                        max: 0
                                        min: 0
                                        name: _REDUCE
                                      - !!perl/hash:RE_bracket 
                                        decl: []

                                        min: 0
                                        re: !!perl/hash:RE_first 
                                          a: 0
                                          dba: statement modifier loop
                                          i: 0
                                          min: 0
                                          r: 1
                                          s: 0
                                          zyg: 
                                            - !!perl/hash:RE_assertion 
                                              assert: "?"
                                              min: 0
                                              re: !!perl/hash:RE_block 
                                                a: 0
                                                context: bool
                                                dba: statement modifier loop
                                                i: 0
                                                min: 0
                                                nobind: 1
                                                r: 1
                                                s: 0
                                                text: " (@+MEMOS[$.pos]<endstmt> // 0) == 2 "
                                            - !!perl/hash:RE_sequence 
                                              a: 0
                                              dba: statement modifier loop
                                              i: 0
                                              min: 12345
                                              r: 1
                                              s: 0
                                              zyg: 
                                                - !!perl/hash:RE_method 
                                                  a: 0
                                                  dba: statement modifier loop
                                                  i: 0
                                                  min: 12345
                                                  name: ws
                                                  nobind: 1
                                                  r: 1
                                                  rest: ''
                                                  s: 0
                                                - !!perl/hash:RE_quantified_atom 
                                                  atom: !!perl/hash:RE_method 
                                                    a: 0
                                                    dba: statement modifier loop
                                                    i: 0
                                                    min: 12345
                                                    name: statement_mod_loop
                                                    r: 1
                                                    rest: ''
                                                    s: 0
                                                  min: 0
                                                  quant: 
                                                    - "?"
                                                    - ":"
                                                    - ''
                                                    - 0
                                                - !!perl/hash:RE_method_internal 
                                                  args: $S, 'statement_mod_condloop'
                                                  max: 0
                                                  min: 0
                                                  name: _REDUCE
                            min: 0
                            quant: 
                              - "?"
                              - ":"
                              - ''
                              - 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_modexpr'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_02 3
              dba: statement end
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: statement end
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: statement end
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: ;
                    s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_null'
                  max: 0
                  min: 0
                  name: _REDUCE
statement_02: *38
statement_05: *125
statement_control__S_034use: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_034use
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_034use
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: use
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_034use
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &30 !!perl/hash:RE_any 
          a: 0
          altname: statement_control__S_034use_01
          dba: statement_control__S_034use
          i: 0
          min: 12345
          name: statement_control__S_034use_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_control__S_034use_01 0
              dba: statement_control__S_034use
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_034use
                  i: 0
                  min: 12345
                  name: version
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_control__S_034use_01 1
              dba: statement_control__S_034use
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_034use
                  i: 0
                  min: 12345
                  name: module_name
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: statement_control__S_034use
                    i: 0
                    min: 12345
                    name: arglist
                    r: 1
                    rest: ''
                    s: 1
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: statement_control__S_034use
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: "\n            my $longname = $<module_name><longname>;\n            $.add_type($longname.text);\n        "
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_034use_01: *30
statement_control__S_035no: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_035no
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_035no
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: 'no'
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_035no
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_035no
        i: 0
        min: 12345
        name: module_name
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: statement_control__S_035no
          i: 0
          min: 12345
          name: arglist
          r: 1
          rest: ''
          s: 1
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_036if: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_036if
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_036if
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: if
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_036if
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_036if
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12350
          re: !!perl/hash:RE_bindnamed 
            a: 0
            atom: !!perl/hash:RE_paren 
              decl: []

              min: 12350
              nobind: 1
              re: !!perl/hash:RE_sequence 
                a: 0
                dba: statement_control__S_036if
                i: 0
                min: 12350
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: statement_control__S_036if
                    i: 0
                    min: 5
                    r: 1
                    s: 1
                    text: elsif
                  - !!perl/hash:RE_assertion 
                    assert: "?"
                    min: 0
                    re: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_036if
                      i: 0
                      min: 12345
                      name: spacey
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: statement_control__S_036if
                    i: 0
                    min: 12345
                    name: xblock
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method_internal 
                    args: $S, 'statement_control__S_036if_elsif'
                    max: 0
                    min: 0
                    name: _REDUCE
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
            dba: statement_control__S_036if
            i: 0
            min: 12350
            r: 1
            s: 1
            var: elsif
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12349
          re: !!perl/hash:RE_bindnamed 
            a: 0
            atom: !!perl/hash:RE_paren 
              decl: []

              min: 12349
              nobind: 1
              re: !!perl/hash:RE_sequence 
                a: 0
                dba: statement_control__S_036if
                i: 0
                min: 12349
                r: 1
                s: 1
                zyg: 
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_string 
                    a: 0
                    dba: statement_control__S_036if
                    i: 0
                    min: 4
                    r: 1
                    s: 1
                    text: else
                  - !!perl/hash:RE_assertion 
                    assert: "?"
                    min: 0
                    re: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_036if
                      i: 0
                      min: 12345
                      name: spacey
                      nobind: 1
                      r: 1
                      rest: ''
                      s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: statement_control__S_036if
                    i: 0
                    min: 12345
                    name: pblock
                    r: 1
                    rest: ''
                    s: 1
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
                  - !!perl/hash:RE_method_internal 
                    args: $S, 'statement_control__S_036if_else'
                    max: 0
                    min: 0
                    name: _REDUCE
                  - !!perl/hash:RE_method 
                    min: 0
                    name: ws
                    nobind: 1
                    noquant: 1
                    rest: ''
            dba: statement_control__S_036if
            i: 0
            min: 12349
            r: 1
            s: 1
            var: else
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_037unless: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_037unless
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_037unless
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: unless
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_037unless
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_037unless
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: statement_control__S_037unless
          i: 0
          min: 0
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: statement_control__S_037unless
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: statement_control__S_037unless
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 4
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: statement_control__S_037unless
                        i: 0
                        min: 4
                        r: 1
                        s: 1
                        text: else
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              dba: statement_control__S_037unless
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: panic
                  nobind: 1
                  rest: ("unless does not take \"else\" in Perl 6; please rewrite using \"if\"")
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_038while: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_038while
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038while
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: while
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038while
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_038while
            i: 0
            min: 0
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: statement_control__S_038while
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 5
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement_control__S_038while
                      i: 0
                      min: 5
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_038while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: (
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_bracket 
                            decl: []

                            min: 3
                            re: !!perl/hash:RE_sequence 
                              a: 0
                              dba: statement_control__S_038while
                              i: 0
                              min: 3
                              r: 1
                              s: 1
                              zyg: 
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_string 
                                    a: 0
                                    dba: statement_control__S_038while
                                    i: 0
                                    min: 2
                                    r: 1
                                    s: 1
                                    text: my
                                  min: 0
                                  quant: 
                                    - "?"
                                    - ":"
                                    - ''
                                    - 0
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: ws
                                  nobind: 1
                                  noquant: 1
                                  rest: ''
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: statement_control__S_038while
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: $
                                - !!perl/hash:RE_quantified_atom 
                                  atom: !!perl/hash:RE_meta 
                                    a: 0
                                    dba: statement_control__S_038while
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 1
                                    text: \w
                                  min: 1
                                  quant: 
                                    - +
                                    - ":"
                                    - ''
                                    - 1
                                - !!perl/hash:RE_method 
                                  min: 0
                                  name: ws
                                  nobind: 1
                                  noquant: 1
                                  rest: ''
                                - !!perl/hash:RE_string 
                                  a: 0
                                  dba: statement_control__S_038while
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 1
                                  text: =
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_038while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: <
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: statement_control__S_038while
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: $
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: statement_control__S_038while
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: \w
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_038while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: ">"
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_038while
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: )
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("This appears to be Perl 5 code")
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_038while
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_039until: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_039until
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_039until
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: until
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_039until
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_039until
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_040repeat: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37040
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_040repeat
    i: 0
    min: 37040
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_040repeat
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: repeat
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_040repeat
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12350
        re: &128 !!perl/hash:RE_any 
          a: 0
          altname: statement_control__S_040repeat_01
          dba: statement_control__S_040repeat
          i: 0
          min: 12350
          name: statement_control__S_040repeat_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_control__S_040repeat_01 0
              dba: statement_control__S_040repeat
              i: 0
              min: 12350
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 5
                    re: &14 !!perl/hash:RE_any 
                      a: 0
                      altname: statement_control__S_040repeat_02
                      dba: statement_control__S_040repeat
                      i: 0
                      min: 5
                      name: statement_control__S_040repeat_02
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_040repeat_02 0
                          dba: statement_control__S_040repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: while
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_040repeat_02 1
                          dba: statement_control__S_040repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: until
                  min: 5
                  var: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_040repeat
                  i: 0
                  min: 12345
                  name: xblock
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statement_control__S_040repeat_01 1
              dba: statement_control__S_040repeat
              i: 0
              min: 24695
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_040repeat
                  i: 0
                  min: 12345
                  name: block
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_040repeat_block_wu'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindpos 
                  atom: !!perl/hash:RE_paren 
                    decl: []

                    min: 5
                    re: &15 !!perl/hash:RE_any 
                      a: 0
                      altname: statement_control__S_040repeat_03
                      dba: statement_control__S_040repeat
                      i: 0
                      min: 5
                      name: statement_control__S_040repeat_03
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_040repeat_03 0
                          dba: statement_control__S_040repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: while
                        - !!perl/hash:RE_string 
                          a: 0
                          alt: statement_control__S_040repeat_03 1
                          dba: statement_control__S_040repeat
                          i: 0
                          min: 5
                          r: 1
                          s: 1
                          text: until
                  min: 5
                  var: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  a: 0
                  dba: statement_control__S_040repeat
                  i: 0
                  min: 12345
                  name: EXPR
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_040repeat_expr_wu'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_040repeat_01: *128
statement_control__S_040repeat_02: *14
statement_control__S_040repeat_03: *15
statement_control__S_041loop: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_041loop
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_041loop
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: loop
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_041loop
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_quantified_atom 
          atom: !!perl/hash:RE_paren 
            decl: []

            min: 4
            re: !!perl/hash:RE_sequence 
              a: 0
              dba: statement_control__S_041loop
              i: 0
              min: 4
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_041loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: (
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_041loop
                      i: 0
                      min: 12345
                      name: EXPR
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: statement_control__S_041loop
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  var: e1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_041loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: ;
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_041loop_e1'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_041loop
                      i: 0
                      min: 12345
                      name: EXPR
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: statement_control__S_041loop
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  var: e2
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_041loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: ;
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_041loop_e2'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_quantified_atom 
                    atom: !!perl/hash:RE_method 
                      a: 0
                      dba: statement_control__S_041loop
                      i: 0
                      min: 12345
                      name: EXPR
                      r: 1
                      rest: ''
                      s: 1
                    min: 0
                    nobind: 1
                    quant: 
                      - "?"
                      - ":"
                      - ''
                      - 0
                  dba: statement_control__S_041loop
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  var: e3
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_041loop_e3'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_string 
                  a: 0
                  dba: statement_control__S_041loop
                  i: 0
                  min: 1
                  r: 1
                  s: 1
                  text: )
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method_internal 
                  args: $S, 'statement_control__S_041loop_eee'
                  max: 0
                  min: 0
                  name: _REDUCE
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
          min: 0
          nobind: 1
          quant: 
            - "?"
            - ":"
            - ''
            - 0
        dba: statement_control__S_041loop
        i: 0
        min: 0
        r: 1
        s: 1
        var: eee
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_041loop
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_control__S_041loop_block'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_042for: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_042for
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_042for
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: for
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_042for
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: statement_control__S_042for
            i: 0
            min: 0
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: statement_control__S_042for
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 3
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement_control__S_042for
                      i: 0
                      min: 3
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_string 
                            a: 0
                            dba: statement_control__S_042for
                            i: 0
                            min: 2
                            r: 1
                            s: 1
                            text: my
                          min: 0
                          quant: 
                            - "?"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_042for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: $
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: statement_control__S_042for
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: \w
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: statement_control__S_042for
                          i: 0
                          min: 1
                          r: 1
                          s: 1
                          text: (
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                min: 0
                name: panic
                nobind: 1
                rest: ("This appears to be Perl 5 code")
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_042for
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_043given: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_043given
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_043given
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: given
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_043given
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_043given
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_044when: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_044when
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_044when
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: when
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_044when
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_044when
        i: 0
        min: 12345
        name: xblock
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_045default: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_045default
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_045default
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: default
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_045default
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_045default
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_046BEGIN: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_046BEGIN
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_046BEGIN
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: BEGIN
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_046BEGIN
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_046BEGIN
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_047CHECK: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_047CHECK
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_047CHECK
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: CHECK
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_047CHECK
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_047CHECK
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_048INIT: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_048INIT
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_048INIT
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: INIT
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_048INIT
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_048INIT
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_049END: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_049END
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_049END
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: END
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_049END
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_049END
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_050START: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_050START
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_050START
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: START
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_050START
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_050START
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_051ENTER: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_051ENTER
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_051ENTER
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: ENTER
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_051ENTER
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_051ENTER
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_052LEAVE: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_052LEAVE
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_052LEAVE
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: LEAVE
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_052LEAVE
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_052LEAVE
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_053KEEP: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_053KEEP
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_053KEEP
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: KEEP
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_053KEEP
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_053KEEP
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_054UNDO: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_054UNDO
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_054UNDO
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: UNDO
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_054UNDO
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_054UNDO
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_055FIRST: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_055FIRST
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_055FIRST
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: FIRST
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_055FIRST
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_055FIRST
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_056NEXT: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_056NEXT
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_056NEXT
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: NEXT
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_056NEXT
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_056NEXT
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_057LAST: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_057LAST
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_057LAST
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: LAST
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_057LAST
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_057LAST
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_058PRE: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_058PRE
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_058PRE
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: PRE
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_058PRE
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_058PRE
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_059POST: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_059POST
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_059POST
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: POST
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_059POST
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_059POST
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_060CATCH: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_060CATCH
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_060CATCH
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: CATCH
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_060CATCH
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_060CATCH
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_061CONTROL: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_061CONTROL
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_061CONTROL
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: CONTROL
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_061CONTROL
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_061CONTROL
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_control__S_062TEMP: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_control__S_062TEMP
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_062TEMP
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: TEMP
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_062TEMP
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_control__S_062TEMP
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_cond__S_069if: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_cond__S_069if
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_069if
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: if
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_069if
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_cond__S_069if_if'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_cond__S_070unless: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_cond__S_070unless
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_070unless
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: unless
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_070unless
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_cond__S_070unless_unless'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_cond__S_071when: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_cond__S_071when
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_071when
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: when
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_cond__S_071when
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_cond__S_071when_when'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_072while: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_072while
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_072while
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: while
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_072while
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_loop__S_072while_while'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_073until: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_073until
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_073until
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: until
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_073until
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_loop__S_073until_until'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_074for: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_074for
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_074for
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: for
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_074for
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_loop__S_074for_for'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_mod_loop__S_075given: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_mod_loop__S_075given
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_075given
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: given
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_mod_loop__S_075given
        i: 0
        min: 12345
        name: modifier_expr
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method_internal 
        args: $S, 'statement_mod_loop__S_075given_given'
        max: 0
        min: 0
        name: _REDUCE
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statement_prefix__S_248do: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_248do
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_248do
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: do
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_248do
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_248do
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_248do
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_248do
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statement_prefix__S_249try: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_249try
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_249try
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: try
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_249try
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_249try
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_249try
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_249try
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statement_prefix__S_250gather: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_250gather
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_250gather
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: gather
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_250gather
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_250gather
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_250gather
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_250gather
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statement_prefix__S_251contend: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_251contend
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_251contend
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: contend
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_251contend
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_251contend
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_251contend
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_251contend
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statement_prefix__S_252async: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_252async
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_252async
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: async
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_252async
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_252async
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_252async
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_252async
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statement_prefix__S_253maybe: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_253maybe
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_253maybe
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: maybe
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_253maybe
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_253maybe
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_253maybe
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_253maybe
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statement_prefix__S_254lazy: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement_prefix__S_254lazy
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_254lazy
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: lazy
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: statement_prefix__S_254lazy
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: statement_prefix__S_254lazy
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_254lazy
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: statement_prefix__S_254lazy
        i: 0
        min: 12345
        name: statement
        r: 1
        rest: ''
        s: 0
statementlist: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: statementlist
      i: 0
      max: 0
      min: 0
      r: 1
      s: 1
      text: my $PARSER is context<rw> = self
  kind: rule
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: statement list
    i: 0
    min: 0
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &36 !!perl/hash:RE_any 
          a: 0
          altname: statementlist_01
          dba: statement list
          i: 0
          min: 0
          name: statementlist_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statementlist_01 0
              dba: statement list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: statement list
                  i: 0
                  min: 0
                  r: 1
                  s: 1
                  text: $
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statementlist_01 1
              dba: statement list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: statement list
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_sequence 
                        a: 0
                        dba: statement list
                        i: 0
                        min: 1
                        r: 1
                        s: 1
                        zyg: 
                          - !!perl/hash:RE_cclass 
                            a: 0
                            dba: statement list
                            i: 0
                            min: 1
                            r: 1
                            s: 1
                            text: "[\\)\\]\\}]"
                          - !!perl/hash:RE_method 
                            min: 0
                            name: ws
                            nobind: 1
                            noquant: 1
                            rest: ''
                    s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: statementlist_01 2
              dba: statement list
              i: 0
              min: 0
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 24690
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: statement list
                      i: 0
                      min: 24690
                      r: 1
                      s: 1
                      zyg: 
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: statement list
                          i: 0
                          min: 12345
                          name: statement
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: statement list
                          i: 0
                          min: 12345
                          name: eat_terminator
                          r: 1
                          rest: ''
                          s: 1
                        - !!perl/hash:RE_method 
                          min: 0
                          name: ws
                          nobind: 1
                          noquant: 1
                          rest: ''
                  min: 0
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
statementlist_01: *36
stdstopper: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: stdstopper
      i: 0
      max: 0
      min: 0
      r: 0
      s: 0
      text: my @stub = return self if @+MEMOS[self.pos]<endstmt> :exists
  kind: regex
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: standard stopper
    i: 0
    min: 0
    r: 0
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &52 !!perl/hash:RE_any 
          a: 0
          altname: stdstopper_01
          dba: standard stopper
          i: 0
          min: 0
          name: stdstopper_01
          r: 0
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              alt: stdstopper_01 0
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: standard stopper
                i: 0
                min: 12345
                name: terminator
                nobind: 1
                r: 0
                rest: ''
                s: 0
            - !!perl/hash:RE_assertion 
              alt: stdstopper_01 1
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: standard stopper
                i: 0
                min: 12345
                name: unitstopper
                nobind: 1
                r: 0
                rest: ''
                s: 0
            - !!perl/hash:RE_meta 
              a: 0
              alt: stdstopper_01 2
              dba: standard stopper
              i: 0
              min: 0
              r: 0
              s: 0
              text: $
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: standard stopper
        i: 0
        min: 0
        r: 0
        s: 0
        text: " @+MEMOS[$.pos]<endstmt> ||= 1; "
stdstopper_01: *52
stopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_assertion 
    assert: "!"
    min: 0
    re: !!perl/hash:RE_noop 
      a: 0
      dba: stopper
      i: 0
      min: 0
      nobind: 1
      r: 1
      s: 0
sublongname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: sublongname
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: sublongname
        i: 0
        min: 12345
        name: subshortname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: sublongname
          i: 0
          min: 12345
          name: sigterm
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
subshortname: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &31 !!perl/hash:RE_any 
      a: 0
      altname: subshortname_01
      dba: subshortname
      i: 0
      min: 12345
      name: subshortname_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: subshortname_01 0
          dba: subshortname
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: subshortname
              i: 0
              min: 12345
              name: category
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 12345
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: subshortname
                  i: 0
                  min: 12345
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_method 
                        a: 0
                        dba: subshortname
                        i: 0
                        min: 12345
                        name: colonpair
                        r: 1
                        rest: ''
                        s: 0
                      min: 12345
                      quant: 
                        - +
                        - ":"
                        - ''
                        - 1
                    - !!perl/hash:RE_block 
                      a: 0
                      context: void
                      dba: subshortname
                      i: 0
                      min: 0
                      r: 1
                      s: 0
                      text: " $.add_macro($<category>) if $+IN_DECL; "
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
        - !!perl/hash:RE_sequence 
          a: 0
          alt: subshortname_01 1
          dba: subshortname
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_method 
              a: 0
              dba: subshortname
              i: 0
              min: 12345
              name: desigilname
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_block 
              a: 0
              context: void
              dba: subshortname
              i: 0
              min: 0
              r: 1
              s: 0
              text: " $.add_routine($<desigilname>.text) if $+IN_DECL; "
subshortname_01: *31
term__S_063BEGIN: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_063BEGIN
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_063BEGIN
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: BEGIN
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_063BEGIN
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_064CHECK: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_064CHECK
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_064CHECK
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: CHECK
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_064CHECK
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_065INIT: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_065INIT
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_065INIT
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: INIT
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_065INIT
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_066START: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_066START
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_066START
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: START
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_066START
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_067ENTER: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_067ENTER
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_067ENTER
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: ENTER
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_067ENTER
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_068FIRST: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_068FIRST
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_068FIRST
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: FIRST
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_068FIRST
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
term__S_255ColonColonQuestionIDENT: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12348
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_255ColonColonQuestionIDENT
    i: 0
    min: 12348
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12348
          nobind: 1
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_255ColonColonQuestionIDENT
            i: 0
            min: 12348
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: term__S_255ColonColonQuestionIDENT
                i: 0
                min: 3
                r: 1
                s: 0
                text: ::?
              - !!perl/hash:RE_method 
                a: 0
                dba: term__S_255ColonColonQuestionIDENT
                i: 0
                min: 12345
                name: identifier
                r: 1
                rest: ''
                s: 0
        dba: term__S_255ColonColonQuestionIDENT
        i: 0
        min: 12348
        r: 1
        s: 0
        var: sym
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_255ColonColonQuestionIDENT
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_256undef: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_256undef
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_256undef
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: undef
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_256undef
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_256undef
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: term__S_256undef
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 2
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_256undef
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: term__S_256undef
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: term__S_256undef
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: $/
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                rest: "('$/ variable as input record separator',\n             \"the filehandle's .slurp method\")"
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_256undef
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: term__S_256undef
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_256undef
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: term__S_256undef
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 0
                          quant: 
                            - "*"
                            - ":"
                            - ''
                            - 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: term__S_256undef
                          i: 0
                          min: 12345
                          name: variable
                          r: 1
                          rest: ''
                          s: 0
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                rest: ('undef as a verb', 'undefine function')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_257next: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_257next
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_257next
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: next
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_257next
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_257next
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_257next
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_method 
                  a: 0
                  dba: term__S_257next
                  i: 0
                  min: 12345
                  name: stdstopper
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: term__S_257next
                i: 0
                min: 12345
                name: termish
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_258last: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_258last
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_258last
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: last
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_258last
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_258last
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_258last
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_method 
                  a: 0
                  dba: term__S_258last
                  i: 0
                  min: 12345
                  name: stdstopper
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: term__S_258last
                i: 0
                min: 12345
                name: termish
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_259redo: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_259redo
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_259redo
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: redo
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_259redo
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_259redo
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_259redo
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_method 
                  a: 0
                  dba: term__S_259redo
                  i: 0
                  min: 12345
                  name: stdstopper
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: term__S_259redo
                i: 0
                min: 12345
                name: termish
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_260break: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_260break
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_260break
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: break
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_260break
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_260break
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_260break
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "!"
                min: 0
                re: !!perl/hash:RE_method 
                  a: 0
                  dba: term__S_260break
                  i: 0
                  min: 12345
                  name: stdstopper
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: term__S_260break
                i: 0
                min: 12345
                name: termish
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_261continue: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_261continue
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_261continue
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: continue
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_261continue
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_262goto: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_262goto
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_262goto
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: goto
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_262goto
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_262goto
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_262goto
        i: 0
        min: 12345
        name: termish
        r: 1
        rest: ''
        s: 0
term__S_263self: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_263self
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_263self
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: self
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_263self
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_264defer: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_264defer
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_264defer
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: defer
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_264defer
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_265rand: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_265rand
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_265rand
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: rand
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_265rand
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: term__S_265rand
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: term__S_265rand
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 2
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_265rand
                      i: 0
                      min: 2
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_quantified_atom 
                          atom: !!perl/hash:RE_meta 
                            a: 0
                            dba: term__S_265rand
                            i: 0
                            min: 1
                            r: 1
                            s: 0
                            text: \h
                          min: 1
                          quant: 
                            - +
                            - ":"
                            - ''
                            - 1
                        - !!perl/hash:RE_bracket 
                          decl: []

                          min: 1
                          re: &62 !!perl/hash:RE_any 
                            a: 0
                            altname: term__S_265rand_03
                            dba: term__S_265rand
                            i: 0
                            min: 1
                            name: term__S_265rand_03
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_meta 
                                a: 0
                                alt: term__S_265rand_03 0
                                dba: term__S_265rand
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: \d
                              - !!perl/hash:RE_string 
                                a: 0
                                alt: term__S_265rand_03 1
                                dba: term__S_265rand
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: $
                  s: 0
              - !!perl/hash:RE_method 
                min: 0
                name: obs
                nobind: 1
                rest: ('rand(N)', 'N.rand or (1..N).pick')
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_265rand_03: *62
term__S_266e: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_266e
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_266e
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: e
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_266e
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_267i: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_267i
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_267i
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: i
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_267i
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_268pi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_268pi
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_268pi
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: pi
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_268pi
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_269Inf: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_269Inf
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_269Inf
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: Inf
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_269Inf
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_270NaN: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_270NaN
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_270NaN
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: NaN
      - !!perl/hash:RE_meta 
        a: 0
        dba: term__S_270NaN
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
term__S_271Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_method 
    a: 0
    dba: term__S_271Star
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "*"
term__S_272StarStar: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_method 
    a: 0
    dba: term__S_272StarStar
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "**"
term__S_384DotDotDot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_384DotDotDot
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_384DotDotDot
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ...
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_384DotDotDot
          i: 0
          min: 12345
          name: args
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_385QuestionQuestionQuestion: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_385QuestionQuestionQuestion
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_385QuestionQuestionQuestion
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ???
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_385QuestionQuestionQuestion
          i: 0
          min: 12345
          name: args
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_386BangBangBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_386BangBangBang
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_386BangBangBang
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: "!!!"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_386BangBangBang
          i: 0
          min: 12345
          name: args
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
term__S_387sigil: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: STD::List_prefix
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_387sigil
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_387sigil
        i: 0
        min: 12345
        name: sigil
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: term__S_387sigil
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: term__S_387sigil
              i: 0
              min: 1
              r: 1
              s: 0
              text: \s
          s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_387sigil
        i: 0
        min: 12345
        name: arglist
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_387sigil
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<sym> = $<sigil>.item; "
term__S_388identifier: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: term__S_388identifier
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $t
  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_388identifier
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_388identifier
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: term__S_388identifier
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 0
            re: !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_bracket 
                decl: []

                min: 1
                re: !!perl/hash:RE_sequence 
                  a: 0
                  dba: term__S_388identifier
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  zyg: 
                    - !!perl/hash:RE_quantified_atom 
                      atom: !!perl/hash:RE_string 
                        a: 0
                        dba: term__S_388identifier
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: .
                      min: 0
                      quant: 
                        - "?"
                        - ":"
                        - ''
                        - 0
                    - !!perl/hash:RE_string 
                      a: 0
                      dba: term__S_388identifier
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: (
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_388identifier
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $t = $<identifier>.text; "
      - !!perl/hash:RE_method 
        min: 0
        name: args
        rest: ( $.is_type($t) )
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: term__S_388identifier
        i: 0
        min: 0
        r: 1
        s: 0
        text: "\n        %ROUTINES{$t} ~= $.lineof($.pos) ~ ' ' unless $.is_routine($t);\n    "
term__S_389opfunc: !!perl/hash:RE 
  decl: []

  kind: token
  min: 37035
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_389opfunc
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_389opfunc
        i: 0
        min: 12345
        name: category
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: term__S_389opfunc
          i: 0
          min: 12345
          name: colonpair
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_389opfunc
        i: 0
        min: 12345
        name: args
        r: 1
        rest: ''
        s: 0
term__S_390name: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Term
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: term__S_390name
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: term__S_390name
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: type parameter
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: type parameter
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: term__S_390name
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: "\n            $.is_type($<longname>.text) or substr($<longname>.text,0,2) eq '::'\n        "
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: term__S_390name
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: term__S_390name
                      i: 0
                      min: 12345
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: term__S_390name
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_string 
                                a: 0
                                dba: term__S_390name
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                text: "["
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: term__S_390name
                          i: 0
                          min: 12345
                          name: postcircumfix
                          r: 1
                          rest: ''
                          s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12347
                    re: !!perl/hash:RE_sequence 
                      a: 0
                      dba: type parameter
                      i: 0
                      min: 12347
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_string 
                          a: 0
                          dba: type parameter
                          i: 0
                          min: 2
                          r: 1
                          s: 0
                          text: "::"
                        - !!perl/hash:RE_assertion 
                          assert: "?"
                          min: 0
                          re: !!perl/hash:RE_method_re 
                            a: 0
                            dba: type parameter
                            i: 0
                            min: 0
                            name: before
                            nobind: 1
                            r: 1
                            re: !!perl/hash:RE 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_bracket 
                                decl: []

                                min: 1
                                re: &57 !!perl/hash:RE_any 
                                  a: 0
                                  altname: term__S_390name_06
                                  dba: type parameter
                                  i: 0
                                  min: 1
                                  name: term__S_390name_06
                                  r: 1
                                  s: 0
                                  zyg: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_390name_06 0
                                      dba: type parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: 
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_390name_06 1
                                      dba: type parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: <
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_390name_06 2
                                      dba: type parameter
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: "{"
                                    - !!perl/hash:RE_string 
                                      a: 0
                                      alt: term__S_390name_06 3
                                      dba: type parameter
                                      i: 0
                                      min: 2
                                      r: 1
                                      s: 0
                                      text: <<
                            s: 0
                        - !!perl/hash:RE_method 
                          a: 0
                          dba: type parameter
                          i: 0
                          min: 12345
                          name: postcircumfix
                          r: 1
                          rest: ''
                          s: 0
                        - !!perl/hash:RE_method_internal 
                          args: $S, 'term__S_390name_packagevar_'
                          max: 0
                          min: 0
                          name: _REDUCE
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'term__S_390name_typename'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: type parameter
                i: 0
                min: 12345
                name: args
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "?"
                - ":"
                - ''
                - 0
term__S_390name_06: *57
terminator__S_403Semi: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Terminator
  re: !!perl/hash:RE_string 
    a: 0
    dba: terminator__S_403Semi
    i: 0
    min: 1
    r: 1
    s: 0
    text: ;
terminator__S_404if: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_404if
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_404if
        i: 0
        min: 2
        r: 1
        s: 0
        text: if
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_404if
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
terminator__S_405unless: !!perl/hash:RE 
  decl: []

  kind: token
  min: 6
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_405unless
    i: 0
    min: 6
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_405unless
        i: 0
        min: 6
        r: 1
        s: 0
        text: unless
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_405unless
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
terminator__S_406while: !!perl/hash:RE 
  decl: []

  kind: token
  min: 5
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_406while
    i: 0
    min: 5
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_406while
        i: 0
        min: 5
        r: 1
        s: 0
        text: while
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_406while
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
terminator__S_407until: !!perl/hash:RE 
  decl: []

  kind: token
  min: 5
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_407until
    i: 0
    min: 5
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_407until
        i: 0
        min: 5
        r: 1
        s: 0
        text: until
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_407until
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
terminator__S_408for: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_408for
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_408for
        i: 0
        min: 3
        r: 1
        s: 0
        text: for
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_408for
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
terminator__S_409given: !!perl/hash:RE 
  decl: []

  kind: token
  min: 5
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_409given
    i: 0
    min: 5
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_409given
        i: 0
        min: 5
        r: 1
        s: 0
        text: given
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_409given
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
terminator__S_410when: !!perl/hash:RE 
  decl: []

  kind: token
  min: 4
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_410when
    i: 0
    min: 4
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_410when
        i: 0
        min: 4
        r: 1
        s: 0
        text: when
      - !!perl/hash:RE_meta 
        a: 0
        dba: terminator__S_410when
        i: 0
        min: 0
        r: 1
        s: 0
        text: 
terminator__S_411MinusMinusGt: !!perl/hash:RE 
  decl: []

  kind: token
  min: 3
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_411MinusMinusGt
    i: 0
    min: 3
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_411MinusMinusGt
        i: 0
        min: 3
        r: 1
        s: 0
        text: -->
      - !!perl/hash:RE_method_internal 
        args: $S, 'terminator__S_411MinusMinusGt'
        max: 0
        min: 0
        name: _REDUCE
terminator__S_412Thesis: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: STD::Terminator
  re: !!perl/hash:RE_method 
    a: 0
    dba: terminator__S_412Thesis
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: )
terminator__S_413Ket: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Terminator
  re: !!perl/hash:RE_string 
    a: 0
    dba: terminator__S_413Ket
    i: 0
    min: 1
    r: 1
    s: 0
    text: "]"
terminator__S_414Ly: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: STD::Terminator
  re: !!perl/hash:RE_string 
    a: 0
    dba: terminator__S_414Ly
    i: 0
    min: 1
    r: 1
    s: 0
    text: "}"
terminator__S_415BangBang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 2
  pkg: STD::Terminator
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: terminator__S_415BangBang
    i: 0
    min: 2
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: terminator__S_415BangBang
        i: 0
        min: 2
        r: 1
        s: 0
        text: "!!"
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_block 
          a: 0
          context: bool
          dba: terminator__S_415BangBang
          i: 0
          min: 0
          nobind: 1
          r: 1
          s: 0
          text: " $+GOAL eq '!!' "
termish: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: postfix
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &46 !!perl/hash:RE_any 
          a: 0
          altname: termish_01
          dba: prefix or noun
          i: 0
          min: 12345
          name: termish_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: termish_01 0
              dba: prefix or noun
              i: 0
              min: 24690
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: prefix or noun
                    i: 0
                    min: 12345
                    name: PRE
                    r: 1
                    rest: ''
                    s: 0
                  min: 12345
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_method 
                  a: 0
                  dba: prefix or noun
                  i: 0
                  min: 12345
                  name: noun
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_method 
              a: 0
              alt: termish_01 1
              dba: prefix or noun
              i: 0
              min: 12345
              name: noun
              r: 1
              rest: ''
              s: 0
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: postfix
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method 
                a: 0
                dba: postfix
                i: 0
                min: 12345
                name: stdstopper
                nobind: 1
                r: 1
                rest: ''
                s: 0
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_method 
                a: 0
                dba: postfix
                i: 0
                min: 12345
                name: POST
                r: 1
                rest: ''
                s: 0
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
termish_01: *46
trait: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait
    i: 0
    min: 12345
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &68 !!perl/hash:RE_any 
          a: 0
          altname: trait_01
          dba: trait
          i: 0
          min: 12345
          name: trait_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: trait_01 0
              dba: trait
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: trait
                  i: 0
                  min: 12345
                  name: trait_verb
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: trait_01 1
              dba: trait
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: trait
                  i: 0
                  min: 12345
                  name: trait_auxiliary
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: trait_01 2
              dba: trait
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: trait
                  i: 0
                  min: 12345
                  name: colonpair
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_01: *68
trait_auxiliary__S_239is: !!perl/hash:RE 
  decl: []

  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_auxiliary__S_239is
    i: 0
    min: 49380
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_239is
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: is
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_239is
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_239is
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_239is
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: trait_auxiliary__S_239is
          i: 0
          min: 12345
          name: postcircumfix
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
trait_auxiliary__S_240does: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: trait_auxiliary__S_240does
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $PKGDECL is context = 'role'
  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_auxiliary__S_240does
    i: 0
    min: 49380
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_240does
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: does
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_240does
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_240does
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_240does
        i: 0
        min: 12345
        name: module_name
        r: 1
        rest: ''
        s: 0
trait_auxiliary__S_241will: !!perl/hash:RE 
  decl: []

  kind: token
  min: 74070
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_auxiliary__S_241will
    i: 0
    min: 74070
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_241will
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: will
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_241will
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_241will
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_241will
        i: 0
        min: 12345
        name: identifier
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_241will
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_auxiliary__S_241will
        i: 0
        min: 12345
        name: block
        r: 1
        rest: ''
        s: 0
trait_verb__S_242of: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_verb__S_242of
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_242of
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: of
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_242of
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_242of
        i: 0
        min: 12345
        name: fulltypename
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_verb__S_243as: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_verb__S_243as
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_243as
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: as
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_243as
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_243as
        i: 0
        min: 12345
        name: fulltypename
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_verb__S_244returns: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_verb__S_244returns
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_244returns
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: returns
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_244returns
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_244returns
        i: 0
        min: 12345
        name: fulltypename
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
trait_verb__S_245handles: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: trait_verb__S_245handles
    i: 0
    min: 37035
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_245handles
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 1
        sym: handles
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_245handles
        i: 0
        min: 12345
        name: spacey
        nobind: 1
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: trait_verb__S_245handles
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
tribble: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: tribble
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my ($lang, $start, $stop)
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: tribble
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: babble
        rest: ($l)
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        text: " my $B = $<babble><B>; ($lang,$start,$stop) = @$B; "
      - !!perl/hash:RE_var 
        a: 0
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $start
      - !!perl/hash:RE_bindnamed 
        a: 0
        atom: !!perl/hash:RE_method 
          min: 0
          name: nibble
          nobind: 1
          rest: ($lang)
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        var: left
      - !!perl/hash:RE_var 
        a: 0
        dba: tribble
        i: 0
        min: 0
        r: 1
        s: 0
        var: $stop
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: !!perl/hash:RE_first 
          a: 0
          dba: tribble
          i: 0
          min: 0
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: tribble
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: tribble
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: " $start ne $stop "
                - !!perl/hash:RE_method 
                  a: 0
                  dba: tribble
                  i: 0
                  min: 12345
                  name: ws
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method 
                  min: 0
                  name: quibble
                  rest: ($lang2)
            - !!perl/hash:RE_sequence 
              a: 0
              dba: tribble
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: tribble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " $lang = $lang2.unbalanced($stop); "
                - !!perl/hash:RE_bindnamed 
                  a: 0
                  atom: !!perl/hash:RE_method 
                    min: 0
                    name: nibble
                    nobind: 1
                    rest: ($lang)
                  dba: tribble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: right
                - !!perl/hash:RE_var 
                  a: 0
                  dba: tribble
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  var: $stop
twigil__S_169Dot: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_169Dot
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: .
twigil__S_170Bang: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_170Bang
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "!"
twigil__S_171Caret: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_171Caret
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "^"
twigil__S_172Colon: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: twigil__S_172Colon
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: twigil__S_172Colon
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: ":"
      - !!perl/hash:RE_assertion 
        assert: "!"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: twigil__S_172Colon
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_string 
              a: 0
              dba: twigil__S_172Colon
              i: 0
              min: 1
              r: 1
              s: 0
              text: ":"
          s: 0
twigil__S_173Star: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_173Star
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "*"
twigil__S_174Plus: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_174Plus
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: +
twigil__S_175Question: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_175Question
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: "?"
twigil__S_176Equal: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_method 
    a: 0
    dba: twigil__S_176Equal
    i: 0
    min: 12345
    name: sym
    r: 1
    rest: ''
    s: 0
    sym: =
type_constraint: !!perl/hash:RE 
  decl: []

  kind: rule
  min: 5
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: type_constraint
    i: 0
    min: 5
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 5
        re: &12 !!perl/hash:RE_any 
          a: 0
          altname: type_constraint_01
          dba: type_constraint
          i: 0
          min: 5
          name: type_constraint_01
          r: 1
          s: 1
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: type_constraint_01 0
              dba: type_constraint
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: type_constraint
                  i: 0
                  min: 12345
                  name: value
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: type_constraint_01 1
              dba: type_constraint
              i: 0
              min: 12345
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: type_constraint
                  i: 0
                  min: 12345
                  name: fulltypename
                  r: 1
                  rest: ''
                  s: 1
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
            - !!perl/hash:RE_sequence 
              a: 0
              alt: type_constraint_01 2
              dba: type_constraint
              i: 0
              min: 5
              r: 1
              s: 1
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: type_constraint
                  i: 0
                  min: 5
                  r: 1
                  s: 1
                  text: where
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
                - !!perl/hash:RE_method 
                  min: 0
                  name: EXPR
                  rest: (item %chaining)
                - !!perl/hash:RE_method 
                  min: 0
                  name: ws
                  nobind: 1
                  noquant: 1
                  rest: ''
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
type_constraint_01: *12
type_declarator__S_246subset: !!perl/hash:RE 
  decl: []

  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: type_declarator__S_246subset
    i: 0
    min: 24690
    r: 1
    s: 1
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_246subset
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: subset
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_246subset
        i: 0
        min: 12345
        name: longname
        r: 1
        rest: ''
        s: 1
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: type_declarator__S_246subset
        i: 0
        min: 0
        r: 1
        s: 1
        text: " $.add_type($<longname>.text); "
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12347
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: type_declarator__S_246subset
            i: 0
            min: 12347
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_string 
                a: 0
                dba: type_declarator__S_246subset
                i: 0
                min: 2
                r: 1
                s: 1
                text: of
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                a: 0
                dba: type_declarator__S_246subset
                i: 0
                min: 12345
                name: fulltypename
                r: 1
                rest: ''
                s: 1
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 5
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: type_declarator__S_246subset
            i: 0
            min: 5
            r: 1
            s: 1
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: type_declarator__S_246subset
                i: 0
                min: 5
                r: 1
                s: 1
                text: where
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
              - !!perl/hash:RE_method 
                min: 0
                name: EXPR
                rest: (item %chaining)
              - !!perl/hash:RE_method 
                min: 0
                name: ws
                nobind: 1
                noquant: 1
                rest: ''
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        min: 0
        name: ws
        nobind: 1
        noquant: 1
        rest: ''
type_declarator__S_247enum: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: type_declarator__S_247enum
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $l
  kind: token
  min: 49380
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: type_declarator__S_247enum
    i: 0
    min: 49380
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_247enum
        i: 0
        min: 12345
        name: sym
        r: 1
        rest: ''
        s: 0
        sym: enum
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_247enum
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 24690
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: type_declarator__S_247enum
            i: 0
            min: 24690
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_bindvar 
                a: 0
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: type_declarator__S_247enum
                  i: 0
                  min: 12345
                  name: longname
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                dba: type_declarator__S_247enum
                i: 0
                min: 12345
                r: 1
                s: 0
                var: $l
              - !!perl/hash:RE_meta 
                a: 0
                dba: type_declarator__S_247enum
                i: 0
                min: 0
                r: 1
                s: 0
                text: "::"
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: type_declarator__S_247enum
                i: 0
                min: 0
                r: 1
                s: 0
                text: " $.add_type($l.text); "
              - !!perl/hash:RE_method 
                a: 0
                dba: type_declarator__S_247enum
                i: 0
                min: 12345
                name: ws
                nobind: 1
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_247enum
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: type_declarator__S_247enum
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
typename: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: typename
    i: 0
    min: 12345
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 12345
        re: &112 !!perl/hash:RE_any 
          a: 0
          altname: typename_01
          dba: typename
          i: 0
          min: 12345
          name: typename_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: typename_01 0
              dba: typename
              i: 0
              min: 12348
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: typename
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  text: ::?
                - !!perl/hash:RE_method 
                  a: 0
                  dba: typename
                  i: 0
                  min: 12345
                  name: identifier
                  r: 1
                  rest: ''
                  s: 0
            - !!perl/hash:RE_sequence 
              a: 0
              alt: typename_01 1
              dba: typename
              i: 0
              min: 12345
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_method 
                  a: 0
                  dba: typename
                  i: 0
                  min: 12345
                  name: longname
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_block 
                    a: 0
                    context: bool
                    dba: typename
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
                    text: "\n        my $longname = $<longname>.text;\n        if substr($longname, 0, 2) eq '::' {\n            $.add_type(substr($longname, 2));\n        }\n        else {\n            $.is_type($longname)\n        }\n      "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: typename
          i: 0
          min: 12345
          name: unsp
          nobind: 1
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 12345
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: typename
            i: 0
            min: 12345
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_assertion 
                assert: "?"
                min: 0
                re: !!perl/hash:RE_method_re 
                  a: 0
                  dba: typename
                  i: 0
                  min: 0
                  name: before
                  nobind: 1
                  r: 1
                  re: !!perl/hash:RE 
                    decl: []

                    min: 1
                    re: !!perl/hash:RE_string 
                      a: 0
                      dba: typename
                      i: 0
                      min: 1
                      r: 1
                      s: 0
                      text: "["
                  s: 0
              - !!perl/hash:RE_method 
                a: 0
                dba: typename
                i: 0
                min: 12345
                name: postcircumfix
                r: 1
                rest: ''
                s: 0
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
typename_01: *112
unitstopper: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_meta 
    a: 0
    dba: unitstopper
    i: 0
    min: 0
    r: 1
    s: 0
    text: $
unsp: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: unspace
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: unsp
        i: 0
        min: 1
        r: 1
        s: 0
        text: \
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: unsp
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_bracket 
              decl: []

              min: 1
              re: &37 !!perl/hash:RE_any 
                a: 0
                altname: unsp_02
                dba: unsp
                i: 0
                min: 1
                name: unsp_02
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_meta 
                    a: 0
                    alt: unsp_02 0
                    dba: unsp
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \s
                  - !!perl/hash:RE_string 
                    a: 0
                    alt: unsp_02 1
                    dba: unsp
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: "#"
          s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: &20 !!perl/hash:RE_any 
            a: 0
            altname: unsp_03
            dba: unspace
            i: 0
            min: 0
            name: unsp_03
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_sequence 
                a: 0
                alt: unsp_03 0
                dba: unspace
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: unspace
                    i: 0
                    min: 12345
                    name: vws
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method_internal 
                    args: $S, 'unsp_vwhite'
                    max: 0
                    min: 0
                    name: _REDUCE
              - !!perl/hash:RE_sequence 
                a: 0
                alt: unsp_03 1
                dba: unspace
                i: 0
                min: 12345
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    dba: unspace
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_method_internal 
                    args: $S, 'unsp_unv'
                    max: 0
                    min: 0
                    name: _REDUCE
              - !!perl/hash:RE_sequence 
                a: 0
                alt: unsp_03 2
                dba: unspace
                i: 0
                min: 0
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_meta 
                    a: 0
                    dba: unspace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    text: $
                  - !!perl/hash:RE_block 
                    a: 0
                    context: void
                    dba: unspace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    text: " $.moreinput "
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
unsp_02: *37
unsp_03: *20
unspacey: !!perl/hash:RE 
  decl: []

  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_quantified_atom 
    atom: !!perl/hash:RE_method 
      a: 0
      dba: unspacey
      i: 0
      min: 12345
      name: unsp
      nobind: 1
      r: 1
      rest: ''
      s: 0
    min: 0
    quant: 
      - "?"
      - ":"
      - ''
      - 0
unv: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 1
    re: &3 !!perl/hash:RE_any 
      a: 0
      altname: unv_01
      dba: horizontal whitespace
      i: 0
      min: 1
      name: unv_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_sequence 
          a: 0
          alt: unv_01 0
          dba: horizontal whitespace
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: horizontal whitespace
                i: 0
                min: 1
                r: 1
                s: 0
                text: \h
              min: 1
              quant: 
                - +
                - ":"
                - ''
                - 1
            - !!perl/hash:RE_method_internal 
              args: $S, 'unv_hwhite'
              max: 0
              min: 0
              name: _REDUCE
        - !!perl/hash:RE_sequence 
          a: 0
          alt: unv_01 1
          dba: horizontal whitespace
          i: 0
          min: 12345
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_assertion 
              assert: "?"
              min: 0
              re: !!perl/hash:RE_method_re 
                a: 0
                dba: horizontal whitespace
                i: 0
                min: 0
                name: before
                nobind: 1
                r: 1
                re: !!perl/hash:RE 
                  decl: []

                  min: 1
                  re: !!perl/hash:RE_string 
                    a: 0
                    dba: horizontal whitespace
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: =
                s: 0
            - !!perl/hash:RE_meta 
              a: 0
              dba: horizontal whitespace
              i: 0
              min: 0
              r: 1
              s: 0
              text: "^^"
            - !!perl/hash:RE_method 
              a: 0
              dba: horizontal whitespace
              i: 0
              min: 12345
              name: pod_comment
              nobind: 1
              r: 1
              rest: ''
              s: 0
            - !!perl/hash:RE_method_internal 
              args: $S, 'unv_pod'
              max: 0
              min: 0
              name: _REDUCE
        - !!perl/hash:RE_sequence 
          a: 0
          alt: unv_01 2
          dba: horizontal whitespace
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_quantified_atom 
              atom: !!perl/hash:RE_meta 
                a: 0
                dba: horizontal whitespace
                i: 0
                min: 1
                r: 1
                s: 0
                text: \h
              min: 0
              quant: 
                - "*"
                - ":"
                - ''
                - 0
            - !!perl/hash:RE_string 
              a: 0
              dba: horizontal whitespace
              i: 0
              min: 1
              r: 1
              s: 0
              text: "#"
            - !!perl/hash:RE_bracket 
              decl: []

              min: 0
              re: &53 !!perl/hash:RE_any 
                a: 0
                altname: unv_03
                dba: horizontal whitespace
                i: 0
                min: 0
                name: unv_03
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: unv_03 0
                    dba: horizontal whitespace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method 
                          a: 0
                          dba: horizontal whitespace
                          i: 0
                          min: 12345
                          name: opener
                          nobind: 1
                          r: 1
                          rest: ''
                          s: 0
                      - !!perl/hash:RE_bracket 
                        decl: []

                        min: 0
                        re: !!perl/hash:RE_first 
                          a: 0
                          dba: horizontal whitespace
                          i: 0
                          min: 0
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_assertion 
                              assert: "!"
                              min: 0
                              re: !!perl/hash:RE_method_re 
                                a: 0
                                dba: horizontal whitespace
                                i: 0
                                min: 0
                                name: after
                                nobind: 1
                                r: 1
                                re: !!perl/hash:RE 
                                  decl: []

                                  min: 1
                                  re: !!perl/hash:RE_sequence 
                                    a: 0
                                    dba: horizontal whitespace
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    zyg: 
                                      - !!perl/hash:RE_meta 
                                        a: 0
                                        dba: horizontal whitespace
                                        i: 0
                                        min: 0
                                        r: 1
                                        s: 0
                                        text: "^^"
                                      - !!perl/hash:RE_meta 
                                        a: 0
                                        dba: horizontal whitespace
                                        i: 0
                                        min: 1
                                        r: 1
                                        s: 0
                                        text: .
                                s: 0
                            - !!perl/hash:RE_method 
                              min: 0
                              name: panic
                              nobind: 1
                              rest: ("Can't use embedded comments in column 1")
                      - !!perl/hash:RE_method 
                        min: 0
                        name: quibble
                        nobind: 1
                        rest: ($.cursor_fresh( ::STD::Q ))
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'unv_embedded'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: unv_03 1
                    dba: horizontal whitespace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: horizontal whitespace
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: ''
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_meta 
                          a: 0
                          dba: horizontal whitespace
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \N
                        min: 0
                        quant: 
                          - "*"
                          - ":"
                          - ''
                          - 0
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'unv_end'
                        max: 0
                        min: 0
                        name: _REDUCE
unv_01: *3
unv_03: *53
value: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12345
  pkg: ~
  re: !!perl/hash:RE_bracket 
    decl: []

    min: 12345
    re: &22 !!perl/hash:RE_any 
      a: 0
      altname: value_01
      dba: value
      i: 0
      min: 12345
      name: value_01
      r: 1
      s: 0
      zyg: 
        - !!perl/hash:RE_method 
          a: 0
          alt: value_01 0
          dba: value
          i: 0
          min: 12345
          name: quote
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: value_01 1
          dba: value
          i: 0
          min: 12345
          name: number
          r: 1
          rest: ''
          s: 0
        - !!perl/hash:RE_method 
          a: 0
          alt: value_01 2
          dba: value
          i: 0
          min: 12345
          name: version
          r: 1
          rest: ''
          s: 0
value_01: *22
variable: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: variable
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: variable
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 12345
            re: !!perl/hash:RE_method 
              a: 0
              dba: variable
              i: 0
              min: 12345
              name: sigil
              r: 1
              rest: ''
              s: 0
          s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: variable
        i: 0
        min: 0
        r: 1
        s: 0
        text: ''
      - !!perl/hash:RE_bracket 
        decl: []

        min: 1
        re: !!perl/hash:RE_first 
          a: 0
          dba: variable
          i: 0
          min: 1
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 12346
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: variable
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: "&"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: variable
                    i: 0
                    min: 12345
                    name: twigil
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
                - !!perl/hash:RE_method 
                  a: 0
                  dba: variable
                  i: 0
                  min: 12345
                  name: sublongname
                  r: 1
                  rest: ''
                  s: 0
                - !!perl/hash:RE_method_internal 
                  args: $S, 'variable_subnoun'
                  max: 0
                  min: 0
                  name: _REDUCE
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: variable
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 4
                      re: !!perl/hash:RE_string 
                        a: 0
                        dba: variable
                        i: 0
                        min: 4
                        r: 1
                        s: 0
                        text: $::(
                    s: 0
                - !!perl/hash:RE_string 
                  a: 0
                  dba: variable
                  i: 0
                  min: 1
                  r: 1
                  s: 0
                  text: $
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: variable
                    i: 0
                    min: 12345
                    name: name
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 3
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: variable
                  i: 0
                  min: 3
                  r: 1
                  s: 0
                  text: "$::"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: variable
                    i: 0
                    min: 12345
                    name: name
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_sequence 
              a: 0
              dba: variable
              i: 0
              min: 2
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_string 
                  a: 0
                  dba: variable
                  i: 0
                  min: 2
                  r: 1
                  s: 0
                  text: "$:"
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_method 
                    a: 0
                    dba: variable
                    i: 0
                    min: 12345
                    name: name
                    r: 1
                    rest: ''
                    s: 0
                  min: 0
                  quant: 
                    - "?"
                    - ":"
                    - ''
                    - 0
            - !!perl/hash:RE_bracket 
              decl: []

              min: 12345
              re: &110 !!perl/hash:RE_any 
                a: 0
                altname: variable_08
                dba: variable
                i: 0
                min: 12345
                name: variable_08
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_08 0
                    dba: variable
                    i: 0
                    min: 24690
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_method 
                          a: 0
                          dba: variable
                          i: 0
                          min: 12345
                          name: twigil
                          r: 1
                          rest: ''
                          s: 0
                        min: 0
                        quant: 
                          - "?"
                          - ":"
                          - ''
                          - 0
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: desigilname
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable_desigilname'
                        max: 0
                        min: 0
                        name: _REDUCE
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_bracket 
                          decl: []

                          min: 12345
                          re: !!perl/hash:RE_sequence 
                            a: 0
                            dba: variable
                            i: 0
                            min: 12345
                            r: 1
                            s: 0
                            zyg: 
                              - !!perl/hash:RE_assertion 
                                assert: "?"
                                min: 0
                                re: !!perl/hash:RE_block 
                                  a: 0
                                  context: bool
                                  dba: variable
                                  i: 0
                                  min: 0
                                  nobind: 1
                                  r: 1
                                  s: 0
                                  text: " my $t = $<twigil>; @$t and $t.[0].text eq '.' "
                              - !!perl/hash:RE_quantified_atom 
                                atom: !!perl/hash:RE_method 
                                  a: 0
                                  dba: variable
                                  i: 0
                                  min: 12345
                                  name: unsp
                                  nobind: 1
                                  r: 1
                                  rest: ''
                                  s: 0
                                min: 0
                                quant: 
                                  - "?"
                                  - ":"
                                  - ''
                                  - 0
                              - !!perl/hash:RE_assertion 
                                assert: "?"
                                min: 0
                                re: !!perl/hash:RE_method_re 
                                  a: 0
                                  dba: variable
                                  i: 0
                                  min: 0
                                  name: before
                                  nobind: 1
                                  r: 1
                                  re: !!perl/hash:RE 
                                    decl: []

                                    min: 1
                                    re: !!perl/hash:RE_string 
                                      a: 0
                                      dba: variable
                                      i: 0
                                      min: 1
                                      r: 1
                                      s: 0
                                      text: (
                                  s: 0
                              - !!perl/hash:RE_method 
                                a: 0
                                dba: variable
                                i: 0
                                min: 12345
                                name: postcircumfix
                                r: 1
                                rest: ''
                                s: 0
                              - !!perl/hash:RE_method_internal 
                                args: $S, 'variable_methcall'
                                max: 0
                                min: 0
                                name: _REDUCE
                        min: 0
                        quant: 
                          - "?"
                          - ":"
                          - ''
                          - 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_08 1
                    dba: variable
                    i: 0
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: special_variable
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable_special'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_08 2
                    dba: variable
                    i: 0
                    min: 12346
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_quantified_atom 
                        atom: !!perl/hash:RE_meta 
                          a: 0
                          dba: variable
                          i: 0
                          min: 1
                          r: 1
                          s: 0
                          text: \d
                        min: 1
                        quant: 
                          - +
                          - ":"
                          - ''
                          - 1
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable_$0'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_08 3
                    dba: variable
                    i: 0
                    min: 24690
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_method_re 
                          a: 0
                          dba: variable
                          i: 0
                          min: 0
                          name: before
                          nobind: 1
                          r: 1
                          re: !!perl/hash:RE 
                            decl: []

                            min: 1
                            re: &102 !!perl/hash:RE_any 
                              a: 0
                              altname: variable_11
                              dba: variable
                              i: 0
                              min: 1
                              name: variable_11
                              r: 1
                              s: 0
                              zyg: 
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: variable_11 0
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: <
                                - !!perl/hash:RE_string 
                                  a: 0
                                  alt: variable_11 1
                                  dba: variable
                                  i: 0
                                  min: 1
                                  r: 1
                                  s: 0
                                  text: (
                          s: 0
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: postcircumfix
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable_$()'
                        max: 0
                        min: 0
                        name: _REDUCE
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: variable_08 4
                    dba: variable
                    i: 0
                    min: 12345
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: variable
                        i: 0
                        min: 12345
                        name: sigil
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_assertion 
                        assert: "?"
                        min: 0
                        re: !!perl/hash:RE_block 
                          a: 0
                          context: bool
                          dba: variable
                          i: 0
                          min: 0
                          nobind: 1
                          r: 1
                          s: 0
                          text: " $+IN_DECL "
                      - !!perl/hash:RE_method_internal 
                        args: $S, 'variable_anondecl'
                        max: 0
                        min: 0
                        name: _REDUCE
variable_08: *110
variable_11: *102
variable_declarator: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: variable_declarator
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $IN_DECL is context<rw> = 1
  kind: token
  min: 24690
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: variable_declarator
    i: 0
    min: 24690
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: variable_declarator
        i: 0
        min: 12345
        name: variable
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: variable_declarator
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $<SIGIL> = $<variable><sigil> "
      - !!perl/hash:RE_block 
        a: 0
        context: void
        dba: variable_declarator
        i: 0
        min: 0
        r: 1
        s: 0
        text: " $IN_DECL = 0; "
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 0
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: variable_declarator
            i: 0
            min: 0
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_quantified_atom 
                atom: !!perl/hash:RE_method 
                  a: 0
                  dba: variable_declarator
                  i: 0
                  min: 12345
                  name: unsp
                  nobind: 1
                  r: 1
                  rest: ''
                  s: 0
                min: 0
                quant: 
                  - "?"
                  - ":"
                  - ''
                  - 0
              - !!perl/hash:RE_bindnamed 
                a: 0
                atom: !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_bracket 
                    decl: []

                    min: 12345
                    re: &64 !!perl/hash:RE_any 
                      a: 0
                      altname: variable_declarator_02
                      dba: shape definition
                      i: 0
                      min: 12345
                      name: variable_declarator_02
                      r: 1
                      s: 0
                      zyg: 
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 0
                          dba: variable_declarator
                          i: 0
                          min: 12347
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: variable_declarator
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: (
                            - !!perl/hash:RE_meta 
                              a: 0
                              dba: variable_declarator
                              extra: "local $::GOAL = ')' "
                              i: 0
                              min: 0
                              r: 1
                              s: 0
                              text: "::"
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: variable_declarator
                              i: 0
                              min: 12345
                              name: signature
                              r: 1
                              rest: ''
                              s: 0
                            - !!perl/hash:RE_bracket 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_first 
                                a: 0
                                dba: variable_declarator
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: variable_declarator
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: )
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: FAILGOAL
                                    nobind: 1
                                    rest: (')' , 'variable_declarator')
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 1
                          dba: shape definition
                          i: 0
                          min: 12347
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "["
                            - !!perl/hash:RE_meta 
                              a: 0
                              dba: shape definition
                              extra: "local $::GOAL = ']' "
                              i: 0
                              min: 0
                              r: 1
                              s: 0
                              text: "::"
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 12345
                              name: semilist
                              r: 1
                              rest: ''
                              s: 0
                            - !!perl/hash:RE_bracket 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_first 
                                a: 0
                                dba: shape definition
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: shape definition
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: "]"
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: FAILGOAL
                                    nobind: 1
                                    rest: (']' , 'shape definition')
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 2
                          dba: shape definition
                          i: 0
                          min: 12347
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_string 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 1
                              r: 1
                              s: 0
                              text: "{"
                            - !!perl/hash:RE_meta 
                              a: 0
                              dba: shape definition
                              extra: "local $::GOAL = '}' "
                              i: 0
                              min: 0
                              r: 1
                              s: 0
                              text: "::"
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 12345
                              name: semilist
                              r: 1
                              rest: ''
                              s: 0
                            - !!perl/hash:RE_bracket 
                              decl: []

                              min: 1
                              re: !!perl/hash:RE_first 
                                a: 0
                                dba: shape definition
                                i: 0
                                min: 1
                                r: 1
                                s: 0
                                zyg: 
                                  - !!perl/hash:RE_string 
                                    a: 0
                                    dba: shape definition
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: "}"
                                  - !!perl/hash:RE_method 
                                    min: 0
                                    name: FAILGOAL
                                    nobind: 1
                                    rest: ('}' , 'shape definition')
                        - !!perl/hash:RE_sequence 
                          a: 0
                          alt: variable_declarator_02 3
                          dba: shape definition
                          i: 0
                          min: 12345
                          r: 1
                          s: 0
                          zyg: 
                            - !!perl/hash:RE_assertion 
                              assert: "?"
                              min: 0
                              re: !!perl/hash:RE_method_re 
                                a: 0
                                dba: shape definition
                                i: 0
                                min: 0
                                name: before
                                nobind: 1
                                r: 1
                                re: !!perl/hash:RE 
                                  decl: []

                                  min: 1
                                  re: !!perl/hash:RE_string 
                                    a: 0
                                    dba: shape definition
                                    i: 0
                                    min: 1
                                    r: 1
                                    s: 0
                                    text: <
                                s: 0
                            - !!perl/hash:RE_method 
                              a: 0
                              dba: shape definition
                              i: 0
                              min: 12345
                              name: postcircumfix
                              r: 1
                              rest: ''
                              s: 0
                  min: 0
                  nobind: 1
                  quant: 
                    - "*"
                    - ":"
                    - ''
                    - 0
                dba: variable_declarator
                i: 0
                min: 0
                r: 1
                s: 0
                var: shape
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_method 
        a: 0
        dba: variable_declarator
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: variable_declarator
          i: 0
          min: 12345
          name: trait
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: variable_declarator
          i: 0
          min: 12345
          name: post_constraint
          r: 1
          rest: ''
          s: 0
        min: 0
        quant: 
          - "*"
          - ":"
          - ''
          - 0
variable_declarator_02: *64
version__S_078v: !!perl/hash:RE 
  decl: []

  kind: token
  min: 12346
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: version__S_078v
    i: 0
    min: 12346
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_string 
        a: 0
        dba: version__S_078v
        i: 0
        min: 1
        r: 1
        s: 0
        text: v
      - !!perl/hash:RE_assertion 
        assert: "?"
        min: 0
        re: !!perl/hash:RE_method_re 
          a: 0
          dba: version__S_078v
          i: 0
          min: 0
          name: before
          nobind: 1
          r: 1
          re: !!perl/hash:RE 
            decl: []

            min: 1
            re: !!perl/hash:RE_meta 
              a: 0
              dba: version__S_078v
              i: 0
              min: 1
              r: 1
              s: 0
              text: \d
          s: 0
      - !!perl/hash:RE_meta 
        a: 0
        dba: version__S_078v
        i: 0
        min: 0
        r: 1
        s: 0
        text: "::"
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_method 
          a: 0
          dba: version__S_078v
          i: 0
          min: 12345
          name: vnum
          r: 1
          rest: ''
          s: 0
        min: 12345
        quant: 
          - "**"
          - ":"
          - !!perl/hash:RE_string 
            a: 0
            dba: version__S_078v
            i: 0
            min: 1
            r: 1
            s: 0
            text: .
          - 1
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_string 
          a: 0
          dba: version__S_078v
          i: 0
          min: 1
          r: 1
          s: 0
          text: +
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
vnum: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: &101 !!perl/hash:RE_any 
    a: 0
    altname: vnum_00
    dba: vnum
    i: 0
    min: 1
    name: vnum_00
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_quantified_atom 
        alt: vnum_00 0
        atom: !!perl/hash:RE_meta 
          a: 0
          dba: vnum
          i: 0
          min: 1
          r: 1
          s: 0
          text: \d
        min: 1
        quant: 
          - +
          - ":"
          - ''
          - 1
      - !!perl/hash:RE_string 
        a: 0
        alt: vnum_00 1
        dba: vnum
        i: 0
        min: 1
        r: 1
        s: 0
        text: "*"
vnum_00: *101
vws: !!perl/hash:RE 
  decl: []

  kind: token
  min: 1
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: vertical whitespace
    i: 0
    min: 1
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_meta 
        a: 0
        dba: vertical whitespace
        i: 0
        min: 1
        r: 1
        s: 0
        text: \v
      - !!perl/hash:RE_quantified_atom 
        atom: !!perl/hash:RE_bracket 
          decl: []

          min: 9
          re: !!perl/hash:RE_sequence 
            a: 0
            dba: vertical whitespace
            i: 0
            min: 9
            r: 1
            s: 0
            zyg: 
              - !!perl/hash:RE_string 
                a: 0
                dba: vertical whitespace
                i: 0
                min: 9
                r: 1
                s: 0
                text: "#DEBUG -1"
              - !!perl/hash:RE_block 
                a: 0
                context: void
                dba: vertical whitespace
                i: 0
                min: 0
                r: 1
                s: 0
                text: " say \"DEBUG\"; $STD::DEBUG = $*DEBUG = -1; "
        min: 0
        quant: 
          - "?"
          - ":"
          - ''
          - 0
ws: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: ws
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my @stub = return self if @+MEMOS[self.pos]<ws> :exists
    - !!perl/hash:RE_decl 
      a: 0
      dba: ws
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $startpos = self.pos
  kind: token
  min: 0
  pkg: ~
  re: !!perl/hash:RE_first 
    a: 0
    dba: whitespace
    i: 0
    min: 0
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_bracket 
        decl: []

        min: 0
        re: &33 !!perl/hash:RE_any 
          a: 0
          altname: ws_01
          dba: whitespace
          i: 0
          min: 0
          name: ws_01
          r: 1
          s: 0
          zyg: 
            - !!perl/hash:RE_sequence 
              a: 0
              alt: ws_01 0
              dba: whitespace
              i: 0
              min: 1
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_quantified_atom 
                  atom: !!perl/hash:RE_meta 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 1
                    r: 1
                    s: 0
                    text: \h
                  min: 1
                  quant: 
                    - +
                    - ":"
                    - ''
                    - 1
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_cclass 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 1
                    nobind: 1
                    r: 1
                    s: 0
                    text: "[#\\s\\\\]"
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: whitespace
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @+MEMOS[$.pos]<ws> = $startpos; "
            - !!perl/hash:RE_sequence 
              a: 0
              alt: ws_01 1
              dba: whitespace
              i: 0
              min: 0
              r: 1
              s: 0
              zyg: 
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 0
                    name: before
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \w
                    s: 0
                - !!perl/hash:RE_assertion 
                  assert: "?"
                  min: 0
                  re: !!perl/hash:RE_method_re 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 0
                    name: after
                    nobind: 1
                    r: 1
                    re: !!perl/hash:RE 
                      decl: []

                      min: 1
                      re: !!perl/hash:RE_meta 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 1
                        r: 1
                        s: 0
                        text: \w
                    s: 0
                - !!perl/hash:RE_meta 
                  a: 0
                  dba: whitespace
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: ":::"
                - !!perl/hash:RE_block 
                  a: 0
                  context: void
                  dba: whitespace
                  i: 0
                  min: 0
                  r: 1
                  s: 0
                  text: " @+MEMOS[$startpos]<ws> = undef; "
                - !!perl/hash:RE_assertion 
                  assert: "!"
                  min: 0
                  re: !!perl/hash:RE_noop 
                    a: 0
                    dba: whitespace
                    i: 0
                    min: 0
                    nobind: 1
                    r: 1
                    s: 0
      - !!perl/hash:RE_sequence 
        a: 0
        dba: whitespace
        i: 0
        min: 0
        r: 1
        s: 0
        zyg: 
          - !!perl/hash:RE_quantified_atom 
            atom: !!perl/hash:RE_bracket 
              decl: []

              min: 0
              re: &124 !!perl/hash:RE_any 
                a: 0
                altname: ws_05
                dba: whitespace
                i: 0
                min: 0
                name: ws_05
                r: 1
                s: 0
                zyg: 
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: ws_05 0
                    dba: whitespace
                    i: 0
                    min: 12345
                    name: unsp
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: ws_05 1
                    dba: whitespace
                    i: 0
                    min: 24690
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 12345
                        name: vws
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                      - !!perl/hash:RE_method 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 12345
                        name: heredoc
                        nobind: 1
                        r: 1
                        rest: ''
                        s: 0
                  - !!perl/hash:RE_method 
                    a: 0
                    alt: ws_05 2
                    dba: whitespace
                    i: 0
                    min: 12345
                    name: unv
                    nobind: 1
                    r: 1
                    rest: ''
                    s: 0
                  - !!perl/hash:RE_sequence 
                    a: 0
                    alt: ws_05 3
                    dba: whitespace
                    i: 0
                    min: 0
                    r: 1
                    s: 0
                    zyg: 
                      - !!perl/hash:RE_meta 
                        a: 0
                        dba: whitespace
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: $
                      - !!perl/hash:RE_block 
                        a: 0
                        context: void
                        dba: whitespace
                        i: 0
                        min: 0
                        r: 1
                        s: 0
                        text: " $.moreinput "
            min: 0
            quant: 
              - "*"
              - ":"
              - ''
              - 0
          - !!perl/hash:RE_block 
            a: 0
            context: void
            dba: whitespace
            i: 0
            min: 0
            r: 1
            s: 0
            text: "\n        if ($.pos == $startpos) {\n            @+MEMOS[$.pos]<ws> = undef;\n        }\n        else {\n            @+MEMOS[$.pos]<ws> = $startpos;\n            @+MEMOS[$.pos]<endstmt> = @+MEMOS[$startpos]<endstmt>\n                if @+MEMOS[$startpos]<endstmt> :exists;\n        }\n    "
ws_01: *33
ws_05: *124
xblock: !!perl/hash:RE 
  decl: 
    - !!perl/hash:RE_decl 
      a: 0
      dba: xblock
      i: 0
      max: 0
      min: 0
      r: 1
      s: 0
      text: my $GOAL is context = '{'
  kind: token
  min: 37035
  pkg: ~
  re: !!perl/hash:RE_sequence 
    a: 0
    dba: xblock
    i: 0
    min: 37035
    r: 1
    s: 0
    zyg: 
      - !!perl/hash:RE_method 
        a: 0
        dba: xblock
        i: 0
        min: 12345
        name: EXPR
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: xblock
        i: 0
        min: 12345
        name: ws
        nobind: 1
        r: 1
        rest: ''
        s: 0
      - !!perl/hash:RE_method 
        a: 0
        dba: xblock
        i: 0
        min: 12345
        name: pblock
        r: 1
        rest: ''
        s: 0
RETREE_END
}

1;
# vim: sw=4 ft=perl
