use 5.010;
use utf8;
{ package STD;
use Moose ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc
moose_extends('Cursor');

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
alnumint: !!perl/hash:RE_ast
  dba: alnumint
  min: 1
  re: !!perl/hash:RE_bracket
    min: 1
    re: !!perl/hash:RE_sequence
      min: 1
      zyg:
      - !!perl/hash:RE_quantified_atom
        atom: !!perl/hash:RE_cclass
          i: 0
          min: 1
          text: '[ 0..9 a..z A..Z ]'
        min: 1
        quant:
        - +
      - !!perl/hash:RE_quantified_atom
        atom: !!perl/hash:RE_bracket
          min: 2
          re: !!perl/hash:RE_sequence
            min: 2
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: _
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_cclass
                i: 0
                min: 1
                text: '[ 0..9 a..z A..Z ]'
              min: 1
              quant:
              - +
        min: 0
        quant:
        - '*'
apostrophe: !!perl/hash:RE_ast
  dba: apostrophe
  min: 1
  re: !!perl/hash:RE_cclass
    i: 0
    min: 1
    text: '[ '' \- ]'
babble: !!perl/hash:RE_ast
  dba: babble
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 24690
        re: !!perl/hash:RE_sequence
          min: 24690
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: quotepair
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_block
            min: 0
      min: 0
      quant:
      - '*'
    - !!perl/hash:RE_block
      min: 0
begid: !!perl/hash:RE_ast
  dba: begid
  min: 0
  re: !!perl/hash:RE_assertion
    assert: '?'
    min: 0
    re: !!perl/hash:RE_method_re
      min: 12345
      name: before
      nobind: 1
      re: !!perl/hash:RE_meta
        min: 1
        text: \w
binint: !!perl/hash:RE_ast
  dba: binint
  min: 1
  re: !!perl/hash:RE_sequence
    min: 1
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        i: 0
        min: 1
        text: '[ 0..1 ]'
      min: 1
      quant:
      - +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 2
        re: !!perl/hash:RE_sequence
          min: 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: _
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              i: 0
              min: 1
              text: '[ 0..1 ]'
            min: 1
            quant:
            - +
      min: 0
      quant:
      - '*'
binints: !!perl/hash:RE_ast
  dba: binints
  min: 37035
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      min: 37035
      re: !!perl/hash:RE_sequence
        min: 37035
        zyg:
        - !!perl/hash:RE_method
          min: 12345
          name: ws
          rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: binint
          rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: ws
          rest: ''
    min: 37035
    quant:
    - '**'
    - ':'
    - !!perl/hash:RE_string
      a: 0
      dba: binints
      i: 0
      i_needed: 1
      min: 1
      r: 1
      s: 0
      text: ','
category__S_000category: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: category
category__S_001sigil: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: sigil
category__S_002twigil: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: twigil
category__S_003special_variable: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: special_variable
category__S_004comment: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: comment
category__S_005version: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: version
category__S_006module_name: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: module_name
category__S_007value: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: value
category__S_008term: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: term
category__S_009strtonum: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: strtonum
category__S_010quote: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: quote
category__S_011prefix: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: prefix
category__S_012infix: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: infix
category__S_013postfix: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: postfix
category__S_014dotty: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: dotty
category__S_015circumfix: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: circumfix
category__S_016postcircumfix: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: postcircumfix
category__S_017quote_mod: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: quote_mod
category__S_018trait_mod: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: trait_mod
category__S_019type_declarator: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: type_declarator
category__S_020scope_declarator: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: scope_declarator
category__S_021package_declarator: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: package_declarator
category__S_022multi_declarator: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: multi_declarator
category__S_023routine_declarator: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: routine_declarator
category__S_024regex_declarator: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: regex_declarator
category__S_025statement_prefix: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: statement_prefix
category__S_026statement_control: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: statement_control
category__S_027statement_mod_cond: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: statement_mod_cond
category__S_028statement_mod_loop: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: statement_mod_loop
category__S_029infix_prefix_meta_operator: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: infix_prefix_meta_operator
category__S_030infix_postfix_meta_operator: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: infix_postfix_meta_operator
category__S_031infix_circumfix_meta_operator: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: infix_circumfix_meta_operator
category__S_032postfix_prefix_meta_operator: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: postfix_prefix_meta_operator
category__S_033prefix_postfix_meta_operator: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: prefix_postfix_meta_operator
category__S_034prefix_circumfix_meta_operator: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: prefix_circumfix_meta_operator
category__S_035terminator: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: terminator
charname: !!perl/hash:RE_ast
  dba: charname
  min: 2
  re: !!perl/hash:RE_first
    min: 2
    zyg:
    - !!perl/hash:RE_bracket
      min: 2
      re: &1 !!perl/hash:RE_any
        altname: charname_0
        dba: charname
        min: 2
        zyg:
        - !!perl/hash:RE_method
          alt: charname_0 0
          min: 12345
          name: radint
          rest: ''
        - !!perl/hash:RE_sequence
          alt: charname_0 1
          min: 2
          zyg:
          - !!perl/hash:RE_cclass
            i: 0
            min: 1
            text: '[a..z A..Z]'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              i: 0
              min: 1
              text: -[ \] , \# ]
            min: 0
            quant:
            - '*'
          - !!perl/hash:RE_cclass
            i: 0
            min: 1
            text: '[a..z A..Z ) ]'
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                min: 1
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \s
                  min: 0
                  quant:
                  - '*'
                - !!perl/hash:RE_cclass
                  i: 0
                  min: 1
                  text: '[ \] , \# ]'
    - !!perl/hash:RE_sequence
      min: 12345
      zyg:
      - !!perl/hash:RE_method
        min: 12345
        name: sorry
        rest: 1
      - !!perl/hash:RE_meta
        min: 0
        text: .*?
      - !!perl/hash:RE_assertion
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method
          min: 12345
          name: terminator
          rest: ''
charname_0: *1
charnames: !!perl/hash:RE_ast
  dba: charnames
  min: 37035
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      min: 37035
      re: !!perl/hash:RE_sequence
        min: 37035
        zyg:
        - !!perl/hash:RE_method
          min: 12345
          name: ws
          rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: charname
          rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: ws
          rest: ''
    min: 37035
    quant:
    - '**'
    - ':'
    - !!perl/hash:RE_string
      a: 0
      dba: charnames
      i: 0
      i_needed: 1
      min: 1
      r: 1
      s: 0
      text: ','
charspec: !!perl/hash:RE_ast
  dba: charspec
  min: 1
  re: !!perl/hash:RE_bracket
    min: 1
    re: &2 !!perl/hash:RE_any
      altname: charspec_0
      dba: character name
      min: 1
      zyg:
      - !!perl/hash:RE_bracket
        alt: charspec_0 0
        min: 12347
        re: !!perl/hash:RE_sequence
          min: 12347
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: '['
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: charnames
            rest: ''
          - !!perl/hash:RE_bracket
            min: 1
            re: !!perl/hash:RE_first
              min: 1
              zyg:
              - !!perl/hash:RE_string
                i: 0
                min: 1
                text: ']'
              - !!perl/hash:RE_method
                min: 12345
                name: FAILGOAL
                rest: 1
      - !!perl/hash:RE_quantified_atom
        alt: charspec_0 1
        atom: !!perl/hash:RE_meta
          min: 1
          text: \d
        min: 1
        quant:
        - +
      - !!perl/hash:RE_cclass
        alt: charspec_0 2
        i: 0
        min: 1
        text: '[ ?..Z \\.._ ]'
      - !!perl/hash:RE_sequence
        alt: charspec_0 3
        min: 12346
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_noop
            min: 0
            nobind: 1
        - !!perl/hash:RE_method
          min: 12345
          name: sorry
          rest: 1
        - !!perl/hash:RE_meta
          min: 1
          text: .
charspec_0: *2
circumfix__S_051Fre_Nch: !!perl/hash:RE_ast
  dba: shell-quote words
  min: 12347
  re: !!perl/hash:RE_bracket
    min: 12347
    re: !!perl/hash:RE_sequence
      min: 12347
      zyg:
      - !!perl/hash:RE_string
        i: 0
        min: 1
        text: «
      - !!perl/hash:RE_block
        min: 0
      - !!perl/hash:RE_method
        min: 12345
        name: nibble
        rest: 1
      - !!perl/hash:RE_bracket
        min: 1
        re: !!perl/hash:RE_first
          min: 1
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: »
          - !!perl/hash:RE_method
            min: 12345
            name: FAILGOAL
            rest: 1
circumfix__S_052LtLt_GtGt: !!perl/hash:RE_ast
  dba: shell-quote words
  min: 12349
  re: !!perl/hash:RE_bracket
    min: 12349
    re: !!perl/hash:RE_sequence
      min: 12349
      zyg:
      - !!perl/hash:RE_string
        i: 0
        min: 2
        text: <<
      - !!perl/hash:RE_block
        min: 0
      - !!perl/hash:RE_method
        min: 12345
        name: nibble
        rest: 1
      - !!perl/hash:RE_bracket
        min: 2
        re: !!perl/hash:RE_first
          min: 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 2
            text: '>>'
          - !!perl/hash:RE_method
            min: 12345
            name: FAILGOAL
            rest: 1
circumfix__S_053Lt_Gt: !!perl/hash:RE_ast
  dba: quote words
  min: 12347
  re: !!perl/hash:RE_bracket
    min: 12347
    re: !!perl/hash:RE_sequence
      min: 12347
      zyg:
      - !!perl/hash:RE_string
        i: 0
        min: 1
        text: <
      - !!perl/hash:RE_block
        min: 0
      - !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 12345
              re: !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      min: 6
                      text: STDIN>
                - !!perl/hash:RE_method
                  min: 12345
                  name: obs
                  rest: 1
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 12345
              re: !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      min: 1
                      text: '>'
                - !!perl/hash:RE_method
                  min: 12345
                  name: obs
                  rest: 1
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_method
            min: 12345
            name: nibble
            rest: 1
      - !!perl/hash:RE_bracket
        min: 1
        re: !!perl/hash:RE_first
          min: 1
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: '>'
          - !!perl/hash:RE_method
            min: 12345
            name: FAILGOAL
            rest: 1
comment__S_054SharpGraveParenDotDotDotThesis: !!perl/hash:RE_ast
  dba: comment
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: '#`'
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method
            min: 12345
            name: opener
            rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: quibble
      rest: 1
comment__S_055SharpParenDotDotDotThesis: !!perl/hash:RE_ast
  dba: comment
  min: 24691
  re: !!perl/hash:RE_sequence
    min: 24691
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: '#'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method
        min: 12345
        name: opener
        rest: ''
    - !!perl/hash:RE_method_re
      min: 12345
      name: suppose
      nobind: 1
      re: !!perl/hash:RE_sequence
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          min: 12345
          name: quibble
          rest: 1
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              min: 0
              zyg:
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_cclass
                  i: 0
                  min: 1
                  text: '[,;:]'
                min: 0
                quant:
                - '*'
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \h
                min: 0
                quant:
                - '*'
              - !!perl/hash:RE_bracket
                min: 0
                re: &3 !!perl/hash:RE_any
                  altname: comment__S_055SharpParenDotDotDotThesis_0
                  dba: comment
                  min: 0
                  zyg:
                  - !!perl/hash:RE_string
                    alt: comment__S_055SharpParenDotDotDotThesis_0 0
                    i: 0
                    min: 1
                    text: '#'
                  - !!perl/hash:RE_meta
                    alt: comment__S_055SharpParenDotDotDotThesis_0 1
                    min: 0
                    text: $$
    - !!perl/hash:RE_method
      min: 12345
      name: worry
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_noop
        min: 0
        nobind: 1
comment__S_055SharpParenDotDotDotThesis_0: *3
comment__S_056SharpEqualParenDotDotDotThesis: !!perl/hash:RE_ast
  dba: comment
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: '#='
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method
        min: 12345
        name: opener
        rest: ''
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_method
      min: 12345
      name: quibble
      rest: 1
comment__S_057SharpEqual: !!perl/hash:RE_ast
  dba: comment
  min: 2
  re: !!perl/hash:RE_sequence
    min: 2
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: '#='
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        min: 0
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \N
          min: 0
          quant:
          - '*'
      min: 0
comment__S_058Sharp: !!perl/hash:RE_ast
  dba: comment
  min: 1
  re: !!perl/hash:RE_sequence
    min: 1
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: '#'
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \N
      min: 0
      quant:
      - '*'
dec_number: !!perl/hash:RE_ast
  dba: decimal number
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_bracket
      min: 12346
      re: &4 !!perl/hash:RE_any
        altname: dec_number_0
        dba: decimal number
        min: 12346
        zyg:
        - !!perl/hash:RE_sequence
          alt: dec_number_0 0
          min: 12346
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              min: 12346
              re: !!perl/hash:RE_sequence
                min: 12346
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: .
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: decint
                    rest: ''
                  min: 12345
            min: 12346
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              min: 12345
              name: escale
              rest: ''
            min: 0
            quant:
            - '?'
        - !!perl/hash:RE_sequence
          alt: dec_number_0 1
          min: 24691
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              min: 24691
              re: !!perl/hash:RE_sequence
                min: 24691
                zyg:
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: decint
                    rest: ''
                  min: 12345
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: .
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: decint
                    rest: ''
                  min: 12345
            min: 24691
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              min: 12345
              name: escale
              rest: ''
            min: 0
            quant:
            - '?'
        - !!perl/hash:RE_sequence
          alt: dec_number_0 2
          min: 24690
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              min: 12345
              re: !!perl/hash:RE_bindnamed
                atom: !!perl/hash:RE_method
                  min: 12345
                  name: decint
                  rest: ''
                min: 12345
            min: 12345
          - !!perl/hash:RE_method
            min: 12345
            name: escale
            rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12347
        re: !!perl/hash:RE_sequence
          min: 12347
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                min: 2
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: .
                - !!perl/hash:RE_meta
                  min: 1
                  text: \d
          - !!perl/hash:RE_method
            min: 12345
            name: sorry
            rest: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 2
              re: !!perl/hash:RE_sequence
                min: 2
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: .
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \d
                  min: 1
                  quant:
                  - +
            min: 2
            quant:
            - +
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                min: 3
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: _
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: _
                  min: 1
                  quant:
                  - +
                - !!perl/hash:RE_meta
                  min: 1
                  text: \d
          - !!perl/hash:RE_method
            min: 12345
            name: sorry
            rest: 1
      min: 0
      quant:
      - '?'
dec_number_0: *4
decint: !!perl/hash:RE_ast
  dba: decint
  min: 1
  re: !!perl/hash:RE_sequence
    min: 1
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \d
      min: 1
      quant:
      - +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 2
        re: !!perl/hash:RE_sequence
          min: 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: _
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \d
            min: 1
            quant:
            - +
      min: 0
      quant:
      - '*'
decints: !!perl/hash:RE_ast
  dba: decints
  min: 37035
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      min: 37035
      re: !!perl/hash:RE_sequence
        min: 37035
        zyg:
        - !!perl/hash:RE_method
          min: 12345
          name: ws
          rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: decint
          rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: ws
          rest: ''
    min: 37035
    quant:
    - '**'
    - ':'
    - !!perl/hash:RE_string
      a: 0
      dba: decints
      i: 0
      i_needed: 1
      min: 1
      r: 1
      s: 0
      text: ','
embeddedblock: !!perl/hash:RE_ast
  dba: embedded block
  min: 37037
  re: !!perl/hash:RE_sequence
    min: 37037
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: newpad
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: finishpad
      rest: ''
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: '{'
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_sequence
        min: 12345
        zyg:
        - !!perl/hash:RE_decl
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: statementlist
          rest: ''
    - !!perl/hash:RE_bracket
      min: 1
      re: !!perl/hash:RE_first
        min: 1
        zyg:
        - !!perl/hash:RE_string
          i: 0
          min: 1
          text: '}'
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
endid: !!perl/hash:RE_ast
  dba: endid
  min: 0
  re: !!perl/hash:RE_assertion
    assert: '?'
    min: 0
    re: !!perl/hash:RE_method_re
      min: 12345
      name: before
      nobind: 1
      re: !!perl/hash:RE_cclass
        i: 0
        min: 1
        text: -[ \- \' \w ]
escale: !!perl/hash:RE_ast
  dba: escale
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_cclass
      i: 0
      min: 1
      text: '[Ee]'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        i: 0
        min: 1
        text: '[+\-]'
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: decint
      rest: ''
escape__S_048none: !!perl/hash:RE_ast
  dba: escape
  min: 0
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      min: 0
      nobind: 1
hexint: !!perl/hash:RE_ast
  dba: hexint
  min: 1
  re: !!perl/hash:RE_sequence
    min: 1
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        i: 0
        min: 1
        text: '[ 0..9 a..f A..F ]'
      min: 1
      quant:
      - +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 2
        re: !!perl/hash:RE_sequence
          min: 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: _
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              i: 0
              min: 1
              text: '[ 0..9 a..f A..F ]'
            min: 1
            quant:
            - +
      min: 0
      quant:
      - '*'
hexints: !!perl/hash:RE_ast
  dba: hexints
  min: 37035
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      min: 37035
      re: !!perl/hash:RE_sequence
        min: 37035
        zyg:
        - !!perl/hash:RE_method
          min: 12345
          name: ws
          rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: hexint
          rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: ws
          rest: ''
    min: 37035
    quant:
    - '**'
    - ':'
    - !!perl/hash:RE_string
      a: 0
      dba: hexints
      i: 0
      i_needed: 1
      min: 1
      r: 1
      s: 0
      text: ','
ident: !!perl/hash:RE_ast
  dba: ident
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: alpha
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \w
      min: 0
      quant:
      - '*'
identifier: !!perl/hash:RE_ast
  dba: identifier
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: ident
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 24690
        re: !!perl/hash:RE_sequence
          min: 24690
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: apostrophe
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: ident
            rest: ''
      min: 0
      quant:
      - '*'
integer: !!perl/hash:RE_ast
  dba: integer
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_bracket
      min: 12345
      re: &5 !!perl/hash:RE_any
        altname: integer_0
        dba: integer
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          alt: integer_0 0
          min: 12346
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: '0'
          - !!perl/hash:RE_bracket
            min: 12345
            re: &6 !!perl/hash:RE_any
              altname: integer_1
              dba: integer
              min: 12345
              zyg:
              - !!perl/hash:RE_sequence
                alt: integer_1 0
                min: 12346
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: b
                - !!perl/hash:RE_method
                  min: 12345
                  name: binint
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: integer_1 1
                min: 12346
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: o
                - !!perl/hash:RE_method
                  min: 12345
                  name: octint
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: integer_1 2
                min: 12346
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: x
                - !!perl/hash:RE_method
                  min: 12345
                  name: hexint
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: integer_1 3
                min: 12346
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: d
                - !!perl/hash:RE_method
                  min: 12345
                  name: decint
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: integer_1 4
                min: 12345
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: decint
                  rest: ''
                - !!perl/hash:RE_assertion
                  assert: '!'
                  min: 0
                  re: !!perl/hash:RE_assertion
                    assert: '!'
                    min: 0
                    nobind: 1
                    re: !!perl/hash:RE_block
                      min: 0
                      nobind: 1
        - !!perl/hash:RE_method
          alt: integer_0 1
          min: 12345
          name: decint
          rest: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_assertion
        assert: '!'
        min: 0
        nobind: 1
        re: !!perl/hash:RE_method_re
          min: 12345
          name: before
          nobind: 1
          re: !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 12346
              re: !!perl/hash:RE_sequence
                min: 12346
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: .
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: &7 !!perl/hash:RE_any
                      altname: integer_2
                      dba: integer
                      min: 1
                      zyg:
                      - !!perl/hash:RE_meta
                        alt: integer_2 0
                        min: 1
                        text: \s
                      - !!perl/hash:RE_string
                        alt: integer_2 1
                        i: 0
                        min: 1
                        text: ','
                      - !!perl/hash:RE_string
                        alt: integer_2 2
                        i: 0
                        min: 1
                        text: =
                      - !!perl/hash:RE_method
                        alt: integer_2 3
                        min: 12345
                        name: terminator
                        rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: sorry
                  rest: 1
            min: 0
            quant:
            - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                min: 3
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: _
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: _
                  min: 1
                  quant:
                  - +
                - !!perl/hash:RE_meta
                  min: 1
                  text: \d
          - !!perl/hash:RE_method
            min: 12345
            name: sorry
            rest: 1
      min: 0
      quant:
      - '?'
integer_0: *5
integer_1: *6
integer_2: *7
longname: !!perl/hash:RE_ast
  dba: longname
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: name
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                min: 2
                text: :{
          - !!perl/hash:RE_method
            min: 12345
            name: colonpair
            rest: ''
      min: 0
      quant:
      - '*'
morename: !!perl/hash:RE_ast
  dba: morename
  min: 2
  re: !!perl/hash:RE_sequence
    min: 2
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: '::'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_first
          min: 12345
          zyg:
          - !!perl/hash:RE_sequence
            min: 12345
            zyg:
            - !!perl/hash:RE_assertion
              assert: '?'
              min: 0
              re: !!perl/hash:RE_method_re
                min: 12345
                name: before
                nobind: 1
                re: &8 !!perl/hash:RE_any
                  altname: morename_0
                  dba: morename
                  min: 1
                  zyg:
                  - !!perl/hash:RE_string
                    alt: morename_0 0
                    i: 0
                    min: 1
                    text: (
                  - !!perl/hash:RE_method
                    alt: morename_0 1
                    min: 12345
                    name: alpha
                    rest: ''
            - !!perl/hash:RE_bracket
              min: 12345
              re: &9 !!perl/hash:RE_any
                altname: morename_1
                dba: indirect name
                min: 12345
                zyg:
                - !!perl/hash:RE_method
                  alt: morename_1 0
                  min: 12345
                  name: identifier
                  rest: ''
                - !!perl/hash:RE_bracket
                  alt: morename_1 1
                  min: 12347
                  re: !!perl/hash:RE_sequence
                    min: 12347
                    zyg:
                    - !!perl/hash:RE_string
                      i: 0
                      min: 1
                      text: (
                    - !!perl/hash:RE_block
                      min: 0
                    - !!perl/hash:RE_method
                      min: 12345
                      name: EXPR
                      rest: ''
                    - !!perl/hash:RE_bracket
                      min: 1
                      re: !!perl/hash:RE_first
                        min: 1
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          min: 1
                          text: )
                        - !!perl/hash:RE_method
                          min: 12345
                          name: FAILGOAL
                          rest: 1
          - !!perl/hash:RE_sequence
            min: 12345
            zyg:
            - !!perl/hash:RE_assertion
              assert: '?'
              min: 0
              re: !!perl/hash:RE_method_re
                min: 12345
                name: before
                nobind: 1
                re: !!perl/hash:RE_string
                  i: 0
                  min: 2
                  text: '::'
            - !!perl/hash:RE_method
              min: 12345
              name: panic
              rest: 1
      min: 0
      quant:
      - '?'
morename_0: *8
morename_1: *9
name: !!perl/hash:RE_ast
  dba: name
  min: 12345
  re: !!perl/hash:RE_bracket
    min: 12345
    re: &10 !!perl/hash:RE_any
      altname: name_0
      dba: name
      min: 12345
      zyg:
      - !!perl/hash:RE_sequence
        alt: name_0 0
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          min: 12345
          name: identifier
          rest: ''
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            min: 12345
            name: morename
            rest: ''
          min: 0
          quant:
          - '*'
      - !!perl/hash:RE_quantified_atom
        alt: name_0 1
        atom: !!perl/hash:RE_method
          min: 12345
          name: morename
          rest: ''
        min: 12345
        quant:
        - +
name_0: *10
nibbler: !!perl/hash:RE_ast
  dba: nibbler
  min: 0
  re: !!perl/hash:RE_sequence
    min: 0
    zyg:
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 1
        re: !!perl/hash:RE_sequence
          min: 1
          zyg:
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_method
                min: 12345
                name: stopper
                rest: ''
          - !!perl/hash:RE_bracket
            min: 1
            re: !!perl/hash:RE_first
              min: 1
              zyg:
              - !!perl/hash:RE_sequence
                min: 37035
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: starter
                  rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: nibbler
                  rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: stopper
                  rest: ''
                - !!perl/hash:RE_block
                  min: 0
              - !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: escape
                  rest: ''
                - !!perl/hash:RE_block
                  min: 0
              - !!perl/hash:RE_sequence
                min: 1
                zyg:
                - !!perl/hash:RE_meta
                  min: 1
                  text: .
                - !!perl/hash:RE_block
                  min: 0
      min: 0
      quant:
      - '*'
    - !!perl/hash:RE_block
      min: 0
nofun: !!perl/hash:RE_ast
  dba: nofun
  min: 0
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_method_re
      min: 12345
      name: before
      nobind: 1
      re: &11 !!perl/hash:RE_any
        altname: nofun_0
        dba: nofun
        min: 1
        zyg:
        - !!perl/hash:RE_string
          alt: nofun_0 0
          i: 0
          min: 1
          text: (
        - !!perl/hash:RE_string
          alt: nofun_0 1
          i: 0
          min: 2
          text: .(
        - !!perl/hash:RE_string
          alt: nofun_0 2
          i: 0
          min: 1
          text: \
        - !!perl/hash:RE_string
          alt: nofun_0 3
          i: 0
          min: 1
          text: ''''
        - !!perl/hash:RE_string
          alt: nofun_0 4
          i: 0
          min: 1
          text: '-'
        - !!perl/hash:RE_double
          alt: nofun_0 5
          i: 0
          min: 1
          text: ''''
        - !!perl/hash:RE_meta
          alt: nofun_0 6
          min: 1
          text: \w
nofun_0: *11
octint: !!perl/hash:RE_ast
  dba: octint
  min: 1
  re: !!perl/hash:RE_sequence
    min: 1
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        i: 0
        min: 1
        text: '[ 0..7 ]'
      min: 1
      quant:
      - +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 2
        re: !!perl/hash:RE_sequence
          min: 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: _
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              i: 0
              min: 1
              text: '[ 0..7 ]'
            min: 1
            quant:
            - +
      min: 0
      quant:
      - '*'
octints: !!perl/hash:RE_ast
  dba: octints
  min: 37035
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      min: 37035
      re: !!perl/hash:RE_sequence
        min: 37035
        zyg:
        - !!perl/hash:RE_method
          min: 12345
          name: ws
          rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: octint
          rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: ws
          rest: ''
    min: 37035
    quant:
    - '**'
    - ':'
    - !!perl/hash:RE_string
      a: 0
      dba: octints
      i: 0
      i_needed: 1
      min: 1
      r: 1
      s: 0
      text: ','
opener: !!perl/hash:RE_ast
  dba: opener
  min: 1
  re: !!perl/hash:RE_cclass
    i: 0
    min: 1
    text: "[\n\\x{0028}\n\\x{003C}\n\\x{005B}\n\\x{007B}\n\\x{00AB}\n\\x{0F3A}\n\\x{0F3C}\n\\x{169B}\n\\x{2018}\n\\x{201A}\n\\x{201B}\n\\x{201C}\n\\x{201E}\n\\x{201F}\n\\x{2039}\n\\x{2045}\n\\x{207D}\n\\x{208D}\n\\x{2208}\n\\x{2209}\n\\x{220A}\n\\x{2215}\n\\x{223C}\n\\x{2243}\n\\x{2252}\n\\x{2254}\n\\x{2264}\n\\x{2266}\n\\x{2268}\n\\x{226A}\n\\x{226E}\n\\x{2270}\n\\x{2272}\n\\x{2274}\n\\x{2276}\n\\x{2278}\n\\x{227A}\n\\x{227C}\n\\x{227E}\n\\x{2280}\n\\x{2282}\n\\x{2284}\n\\x{2286}\n\\x{2288}\n\\x{228A}\n\\x{228F}\n\\x{2291}\n\\x{2298}\n\\x{22A2}\n\\x{22A6}\n\\x{22A8}\n\\x{22A9}\n\\x{22AB}\n\\x{22B0}\n\\x{22B2}\n\\x{22B4}\n\\x{22B6}\n\\x{22C9}\n\\x{22CB}\n\\x{22D0}\n\\x{22D6}\n\\x{22D8}\n\\x{22DA}\n\\x{22DC}\n\\x{22DE}\n\\x{22E0}\n\\x{22E2}\n\\x{22E4}\n\\x{22E6}\n\\x{22E8}\n\\x{22EA}\n\\x{22EC}\n\\x{22F0}\n\\x{22F2}\n\\x{22F3}\n\\x{22F4}\n\\x{22F6}\n\\x{22F7}\n\\x{2308}\n\\x{230A}\n\\x{2329}\n\\x{23B4}\n\\x{2768}\n\\x{276A}\n\\x{276C}\n\\x{276E}\n\\x{2770}\n\\x{2772}\n\\x{2774}\n\\x{27C3}\n\\x{27C5}\n\\x{27D5}\n\\x{27DD}\n\\x{27E2}\n\\x{27E4}\n\\x{27E6}\n\\x{27E8}\n\\x{27EA}\n\\x{2983}\n\\x{2985}\n\\x{2987}\n\\x{2989}\n\\x{298B}\n\\x{298D}\n\\x{298F}\n\\x{2991}\n\\x{2993}\n\\x{2995}\n\\x{2997}\n\\x{29C0}\n\\x{29C4}\n\\x{29CF}\n\\x{29D1}\n\\x{29D4}\n\\x{29D8}\n\\x{29DA}\n\\x{29F8}\n\\x{29FC}\n\\x{2A2B}\n\\x{2A2D}\n\\x{2A34}\n\\x{2A3C}\n\\x{2A64}\n\\x{2A79}\n\\x{2A7D}\n\\x{2A7F}\n\\x{2A81}\n\\x{2A83}\n\\x{2A8B}\n\\x{2A91}\n\\x{2A93}\n\\x{2A95}\n\\x{2A97}\n\\x{2A99}\n\\x{2A9B}\n\\x{2AA1}\n\\x{2AA6}\n\\x{2AA8}\n\\x{2AAA}\n\\x{2AAC}\n\\x{2AAF}\n\\x{2AB3}\n\\x{2ABB}\n\\x{2ABD}\n\\x{2ABF}\n\\x{2AC1}\n\\x{2AC3}\n\\x{2AC5}\n\\x{2ACD}\n\\x{2ACF}\n\\x{2AD1}\n\\x{2AD3}\n\\x{2AD5}\n\\x{2AEC}\n\\x{2AF7}\n\\x{2AF9}\n\\x{2E02}\n\\x{2E04}\n\\x{2E09}\n\\x{2E0C}\n\\x{2E1C}\n\\x{2E20}\n\\x{3008}\n\\x{300A}\n\\x{300C}\n\\x{300E}\n\\x{3010}\n\\x{3014}\n\\x{3016}\n\\x{3018}\n\\x{301A}\n\\x{301D}\n\\x{FD3E}\n\\x{FE17}\n\\x{FE35}\n\\x{FE37}\n\\x{FE39}\n\\x{FE3B}\n\\x{FE3D}\n\\x{FE3F}\n\\x{FE41}\n\\x{FE43}\n\\x{FE47}\n\\x{FE59}\n\\x{FE5B}\n\\x{FE5D}\n\\x{FF08}\n\\x{FF1C}\n\\x{FF3B}\n\\x{FF5B}\n\\x{FF5F}\n\\x{FF62}\n
      \ ]"
pod_comment: !!perl/hash:RE_ast
  dba: pod_comment
  min: 2
  re: !!perl/hash:RE_sequence
    min: 2
    zyg:
    - !!perl/hash:RE_meta
      min: 0
      text: ^^
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      min: 0
      quant:
      - '*'
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: =
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: unsp
        rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_bracket
      min: 1
      re: &12 !!perl/hash:RE_any
        altname: pod_comment_0
        dba: pod_comment
        min: 1
        zyg:
        - !!perl/hash:RE_sequence
          alt: pod_comment_0 0
          min: 12351
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 5
            text: begin
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            min: 1
            quant:
            - +
          - !!perl/hash:RE_method
            min: 12345
            name: identifier
            rest: ''
          - !!perl/hash:RE_meta
            min: 0
            text: '::'
          - !!perl/hash:RE_bracket
            min: 0
            re: !!perl/hash:RE_first
              min: 0
              zyg:
              - !!perl/hash:RE_sequence
                min: 6
                zyg:
                - !!perl/hash:RE_meta
                  min: 0
                  text: .*?
                - !!perl/hash:RE_double
                  i: 0
                  min: 1
                  text: '

'
                - !!perl/hash:RE_bracket
                  min: 5
                  re: !!perl/hash:RE_sequence
                    min: 5
                    zyg:
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_meta
                        min: 1
                        text: \h
                      min: 0
                      quant:
                      - '*'
                    - !!perl/hash:RE_string
                      i: 0
                      min: 1
                      text: =
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_method
                        min: 12345
                        name: unsp
                        rest: ''
                      min: 0
                      quant:
                      - '?'
                    - !!perl/hash:RE_string
                      i: 0
                      min: 3
                      text: end
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_meta
                        min: 1
                        text: \h
                      min: 1
                      quant:
                      - +
                    - !!perl/hash:RE_var
                      min: 0
                      var: $M->{'identifier'}
                    - !!perl/hash:RE_meta
                      min: 0
                      text: »
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_meta
                        min: 1
                        text: \N
                      min: 0
                      quant:
                      - '*'
              - !!perl/hash:RE_sequence
                min: 0
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_block
                    min: 0
                    nobind: 1
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: .
                  min: 0
                  quant:
                  - '*'
              - !!perl/hash:RE_block
                min: 0
        - !!perl/hash:RE_sequence
          alt: pod_comment_0 1
          min: 5
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 5
            text: begin
          - !!perl/hash:RE_meta
            min: 0
            text: »
          - !!perl/hash:RE_meta
            min: 0
            text: '::'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            min: 0
            quant:
            - '*'
          - !!perl/hash:RE_bracket
            min: 0
            re: !!perl/hash:RE_first
              min: 0
              zyg:
              - !!perl/hash:RE_meta
                min: 0
                text: $$
              - !!perl/hash:RE_string
                i: 0
                min: 1
                text: '#'
              - !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: sorry
                  rest: 1
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \N
                  min: 0
                  quant:
                  - '*'
          - !!perl/hash:RE_bracket
            min: 0
            re: !!perl/hash:RE_first
              min: 0
              zyg:
              - !!perl/hash:RE_sequence
                min: 5
                zyg:
                - !!perl/hash:RE_meta
                  min: 0
                  text: .*?
                - !!perl/hash:RE_double
                  i: 0
                  min: 1
                  text: '

'
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  min: 0
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: =
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: unsp
                    rest: ''
                  min: 0
                  quant:
                  - '?'
                - !!perl/hash:RE_string
                  i: 0
                  min: 3
                  text: end
                - !!perl/hash:RE_meta
                  min: 0
                  text: »
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \N
                  min: 0
                  quant:
                  - '*'
              - !!perl/hash:RE_block
                min: 0
        - !!perl/hash:RE_sequence
          alt: pod_comment_0 2
          min: 3
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 3
            text: for
          - !!perl/hash:RE_meta
            min: 0
            text: »
          - !!perl/hash:RE_meta
            min: 0
            text: '::'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            min: 0
            quant:
            - '*'
          - !!perl/hash:RE_bracket
            min: 0
            re: !!perl/hash:RE_first
              min: 0
              zyg:
              - !!perl/hash:RE_method
                min: 12345
                name: identifier
                rest: ''
              - !!perl/hash:RE_meta
                min: 0
                text: $$
              - !!perl/hash:RE_string
                i: 0
                min: 1
                text: '#'
              - !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: sorry
                  rest: 1
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \N
                  min: 0
                  quant:
                  - '*'
          - !!perl/hash:RE_bracket
            min: 0
            re: !!perl/hash:RE_first
              min: 0
              zyg:
              - !!perl/hash:RE_sequence
                min: 0
                zyg:
                - !!perl/hash:RE_meta
                  min: 0
                  text: .*?
                - !!perl/hash:RE_meta
                  min: 0
                  text: ^^
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  min: 0
                  quant:
                  - '*'
                - !!perl/hash:RE_meta
                  min: 0
                  text: $$
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: .
                min: 0
                quant:
                - '*'
        - !!perl/hash:RE_sequence
          alt: pod_comment_0 3
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            min: 0
            text: '::'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 12345
              re: !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_sequence
                      min: 4
                      zyg:
                      - !!perl/hash:RE_meta
                        min: 0
                        text: .*?
                      - !!perl/hash:RE_meta
                        min: 0
                        text: ^^
                      - !!perl/hash:RE_string
                        i: 0
                        min: 4
                        text: =cut
                      - !!perl/hash:RE_meta
                        min: 0
                        text: »
                - !!perl/hash:RE_method
                  min: 12345
                  name: panic
                  rest: 1
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_bracket
            min: 1
            re: !!perl/hash:RE_first
              min: 1
              zyg:
              - !!perl/hash:RE_method
                min: 12345
                name: alpha
                rest: ''
              - !!perl/hash:RE_meta
                min: 1
                text: \s
              - !!perl/hash:RE_method
                min: 12345
                name: sorry
                rest: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \N
            min: 0
            quant:
            - '*'
pod_comment_0: *12
quibble: !!perl/hash:RE_ast
  dba: quibble
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: babble
      rest: 1
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_var
      min: 0
      var: $start
    - !!perl/hash:RE_method
      min: 12345
      name: nibble
      rest: 1
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_var
          min: 0
          var: $stop
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
    - !!perl/hash:RE_block
      min: 0
quote__S_049Single_Single: !!perl/hash:RE_ast
  dba: single quotes
  min: 12347
  re: !!perl/hash:RE_bracket
    min: 12347
    re: !!perl/hash:RE_sequence
      min: 12347
      zyg:
      - !!perl/hash:RE_double
        i: 0
        min: 1
        text: ''''
      - !!perl/hash:RE_block
        min: 0
      - !!perl/hash:RE_method
        min: 12345
        name: nibble
        rest: 1
      - !!perl/hash:RE_bracket
        min: 1
        re: !!perl/hash:RE_first
          min: 1
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: ''''
          - !!perl/hash:RE_method
            min: 12345
            name: FAILGOAL
            rest: 1
quote__S_050Double_Double: !!perl/hash:RE_ast
  dba: double quotes
  min: 12347
  re: !!perl/hash:RE_bracket
    min: 12347
    re: !!perl/hash:RE_sequence
      min: 12347
      zyg:
      - !!perl/hash:RE_string
        i: 0
        min: 1
        text: '"'
      - !!perl/hash:RE_block
        min: 0
      - !!perl/hash:RE_method
        min: 12345
        name: nibble
        rest: 1
      - !!perl/hash:RE_bracket
        min: 1
        re: !!perl/hash:RE_first
          min: 1
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: '"'
          - !!perl/hash:RE_method
            min: 12345
            name: FAILGOAL
            rest: 1
quotepair: !!perl/hash:RE_ast
  dba: colon pair (restricted)
  min: 3
  re: !!perl/hash:RE_sequence
    min: 3
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: ':'
    - !!perl/hash:RE_bracket
      min: 2
      re: &13 !!perl/hash:RE_any
        altname: quotepair_0
        dba: colon pair (restricted)
        min: 2
        zyg:
        - !!perl/hash:RE_sequence
          alt: quotepair_0 0
          min: 12346
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: '!'
          - !!perl/hash:RE_method
            min: 12345
            name: identifier
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 24690
              re: !!perl/hash:RE_sequence
                min: 24690
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      min: 1
                      text: (
                - !!perl/hash:RE_method
                  min: 12345
                  name: sorry
                  rest: 1
                - !!perl/hash:RE_method
                  min: 12345
                  name: circumfix
                  rest: ''
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          alt: quotepair_0 1
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: identifier
            rest: ''
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_bracket
            min: 0
            re: !!perl/hash:RE_first
              min: 0
              zyg:
              - !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: unsp
                    rest: ''
                  min: 0
                  quant:
                  - '?'
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      min: 1
                      text: (
                - !!perl/hash:RE_method
                  min: 12345
                  name: circumfix
                  rest: ''
                - !!perl/hash:RE_block
                  min: 0
              - !!perl/hash:RE_block
                min: 0
        - !!perl/hash:RE_sequence
          alt: quotepair_0 2
          min: 2
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_paren
              min: 1
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \d
                min: 1
                quant:
                - +
            min: 1
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_paren
              min: 1
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_cclass
                  i: 0
                  min: 1
                  text: '[a..z]'
                min: 1
                quant:
                - +
            min: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 24690
              re: !!perl/hash:RE_sequence
                min: 24690
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      min: 1
                      text: (
                - !!perl/hash:RE_method
                  min: 12345
                  name: sorry
                  rest: 1
                - !!perl/hash:RE_method
                  min: 12345
                  name: circumfix
                  rest: ''
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_block
            min: 0
    - !!perl/hash:RE_block
      min: 0
quotepair_0: *13
rad_number: !!perl/hash:RE_ast
  dba: number in radix notation
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: ':'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        min: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          min: 1
          quant:
          - +
      min: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: unsp
        rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_first
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          min: 12347
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: <
          - !!perl/hash:RE_bracket
            min: 12345
            re: &14 !!perl/hash:RE_any
              altname: rad_number_0
              dba: number in radix notation
              min: 12345
              zyg:
              - !!perl/hash:RE_bindnamed
                alt: rad_number_0 0
                atom: !!perl/hash:RE_bracket
                  min: 12346
                  re: !!perl/hash:RE_sequence
                    min: 12346
                    zyg:
                    - !!perl/hash:RE_string
                      i: 0
                      min: 1
                      text: .
                    - !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        min: 12345
                        name: alnumint
                        rest: ''
                      min: 12345
                min: 12346
              - !!perl/hash:RE_bindnamed
                alt: rad_number_0 1
                atom: !!perl/hash:RE_bracket
                  min: 24691
                  re: !!perl/hash:RE_sequence
                    min: 24691
                    zyg:
                    - !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        min: 12345
                        name: alnumint
                        rest: ''
                      min: 12345
                    - !!perl/hash:RE_string
                      i: 0
                      min: 1
                      text: .
                    - !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        min: 12345
                        name: alnumint
                        rest: ''
                      min: 12345
                min: 24691
              - !!perl/hash:RE_bindnamed
                alt: rad_number_0 2
                atom: !!perl/hash:RE_bracket
                  min: 12345
                  re: !!perl/hash:RE_bindnamed
                    atom: !!perl/hash:RE_method
                      min: 12345
                      name: alnumint
                      rest: ''
                    min: 12345
                min: 12345
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 24691
              re: !!perl/hash:RE_sequence
                min: 24691
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: '*'
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: radint
                    rest: ''
                  min: 12345
                - !!perl/hash:RE_bracket
                  min: 12345
                  re: !!perl/hash:RE_first
                    min: 12345
                    zyg:
                    - !!perl/hash:RE_sequence
                      min: 12347
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        min: 2
                        text: '**'
                      - !!perl/hash:RE_bindnamed
                        atom: !!perl/hash:RE_method
                          min: 12345
                          name: radint
                          rest: ''
                        min: 12345
                    - !!perl/hash:RE_method
                      min: 12345
                      name: sorry
                      rest: 1
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: '>'
        - !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                min: 1
                text: '['
          - !!perl/hash:RE_method
            min: 12345
            name: circumfix
            rest: ''
        - !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                min: 1
                text: (
          - !!perl/hash:RE_method
            min: 12345
            name: circumfix
            rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
rad_number_0: *14
radint: !!perl/hash:RE_ast
  dba: radint
  min: 12345
  re: !!perl/hash:RE_bracket
    min: 12345
    re: &15 !!perl/hash:RE_any
      altname: radint_0
      dba: radint
      min: 12345
      zyg:
      - !!perl/hash:RE_method
        alt: radint_0 0
        min: 12345
        name: integer
        rest: ''
      - !!perl/hash:RE_sequence
        alt: radint_0 1
        min: 12345
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              min: 2
              zyg:
              - !!perl/hash:RE_string
                i: 0
                min: 1
                text: ':'
              - !!perl/hash:RE_meta
                min: 1
                text: \d
        - !!perl/hash:RE_method
          min: 12345
          name: rad_number
          rest: ''
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_block
            min: 0
            nobind: 1
radint_0: *15
sigil__S_036Dollar: !!perl/hash:RE_ast
  dba: sigil
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: $
sigil__S_037At: !!perl/hash:RE_ast
  dba: sigil
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: '@'
sigil__S_038Percent: !!perl/hash:RE_ast
  dba: sigil
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: '%'
sigil__S_039Amp: !!perl/hash:RE_ast
  dba: sigil
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: '&'
spacey: !!perl/hash:RE_ast
  dba: spacey
  min: 0
  re: !!perl/hash:RE_assertion
    assert: '?'
    min: 0
    re: !!perl/hash:RE_method_re
      min: 12345
      name: before
      nobind: 1
      re: !!perl/hash:RE_cclass
        i: 0
        min: 1
        text: '[ \s \# ]'
starter: !!perl/hash:RE_ast
  dba: starter
  min: 0
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      min: 0
      nobind: 1
stdstopper: !!perl/hash:RE_ast
  dba: standard stopper
  min: 0
  re: !!perl/hash:RE_sequence
    min: 0
    zyg:
    - !!perl/hash:RE_bracket
      min: 0
      re: &16 !!perl/hash:RE_any
        altname: stdstopper_0
        dba: standard stopper
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          alt: stdstopper_0 0
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method
            min: 12345
            name: terminator
            rest: ''
        - !!perl/hash:RE_assertion
          alt: stdstopper_0 1
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method
            min: 12345
            name: unitstopper
            rest: ''
        - !!perl/hash:RE_assertion
          alt: stdstopper_0 2
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_method
              min: 12345
              name: stopper
              rest: ''
        - !!perl/hash:RE_meta
          alt: stdstopper_0 3
          min: 0
          text: $
    - !!perl/hash:RE_block
      min: 0
stdstopper_0: *16
stopper: !!perl/hash:RE_ast
  dba: stopper
  min: 0
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      min: 0
      nobind: 1
term__S_062miscbad: !!perl/hash:RE_ast
  dba: term
  min: 0
  re: !!perl/hash:RE_sequence
    min: 0
    zyg:
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_block
        min: 0
        nobind: 1
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_noop
        min: 0
        nobind: 1
terminator__S_059Thesis: !!perl/hash:RE_ast
  dba: terminator
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: )
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
terminator__S_060Ket: !!perl/hash:RE_ast
  dba: terminator
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: ']'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
terminator__S_061Ly: !!perl/hash:RE_ast
  dba: terminator
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: '}'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
twigil__S_040Dot: !!perl/hash:RE_ast
  dba: twigil
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: .
    - !!perl/hash:RE_method
      min: 12345
      name: begid
      rest: ''
twigil__S_041Bang: !!perl/hash:RE_ast
  dba: twigil
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '!'
    - !!perl/hash:RE_method
      min: 12345
      name: begid
      rest: ''
twigil__S_042Caret: !!perl/hash:RE_ast
  dba: twigil
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ^
    - !!perl/hash:RE_method
      min: 12345
      name: begid
      rest: ''
twigil__S_043Colon: !!perl/hash:RE_ast
  dba: twigil
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ':'
    - !!perl/hash:RE_method
      min: 12345
      name: begid
      rest: ''
twigil__S_044Star: !!perl/hash:RE_ast
  dba: twigil
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '*'
    - !!perl/hash:RE_method
      min: 12345
      name: begid
      rest: ''
twigil__S_045Question: !!perl/hash:RE_ast
  dba: twigil
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '?'
    - !!perl/hash:RE_method
      min: 12345
      name: begid
      rest: ''
twigil__S_046Equal: !!perl/hash:RE_ast
  dba: twigil
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: =
    - !!perl/hash:RE_method
      min: 12345
      name: begid
      rest: ''
twigil__S_047Tilde: !!perl/hash:RE_ast
  dba: twigil
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      endsym: begid
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '~'
    - !!perl/hash:RE_method
      min: 12345
      name: begid
      rest: ''
unitstopper: !!perl/hash:RE_ast
  dba: unitstopper
  min: 0
  re: !!perl/hash:RE_meta
    min: 0
    text: $
unsp: !!perl/hash:RE_ast
  dba: unspace
  min: 1
  re: !!perl/hash:RE_sequence
    min: 1
    zyg:
    - !!perl/hash:RE_meta
      min: 1
      text: \\
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_bracket
          min: 1
          re: &17 !!perl/hash:RE_any
            altname: unsp_0
            dba: unsp
            min: 1
            zyg:
            - !!perl/hash:RE_meta
              alt: unsp_0 0
              min: 1
              text: \s
            - !!perl/hash:RE_string
              alt: unsp_0 1
              i: 0
              min: 1
              text: '#'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 0
        re: &18 !!perl/hash:RE_any
          altname: unsp_1
          dba: unspace
          min: 0
          zyg:
          - !!perl/hash:RE_method
            alt: unsp_1 0
            min: 12345
            name: vws
            rest: ''
          - !!perl/hash:RE_method
            alt: unsp_1 1
            min: 12345
            name: unv
            rest: ''
          - !!perl/hash:RE_sequence
            alt: unsp_1 2
            min: 0
            zyg:
            - !!perl/hash:RE_meta
              min: 0
              text: $
            - !!perl/hash:RE_block
              min: 0
      min: 0
      quant:
      - '*'
unsp_0: *17
unsp_1: *18
unspacey: !!perl/hash:RE_ast
  dba: unspacey
  min: 0
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_method
      min: 12345
      name: unsp
      rest: ''
    min: 0
    quant:
    - '?'
unv: !!perl/hash:RE_ast
  dba: horizontal whitespace
  min: 1
  re: !!perl/hash:RE_bracket
    min: 1
    re: &19 !!perl/hash:RE_any
      altname: unv_0
      dba: horizontal whitespace
      min: 1
      zyg:
      - !!perl/hash:RE_quantified_atom
        alt: unv_0 0
        atom: !!perl/hash:RE_meta
          min: 1
          text: \h
        min: 1
        quant:
        - +
      - !!perl/hash:RE_sequence
        alt: unv_0 1
        min: 12345
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              min: 2
              zyg:
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \h
                min: 0
                quant:
                - '*'
              - !!perl/hash:RE_string
                i: 0
                min: 1
                text: =
              - !!perl/hash:RE_bracket
                min: 1
                re: &20 !!perl/hash:RE_any
                  altname: unv_1
                  dba: horizontal whitespace
                  min: 1
                  zyg:
                  - !!perl/hash:RE_meta
                    alt: unv_1 0
                    min: 1
                    text: \w
                  - !!perl/hash:RE_string
                    alt: unv_1 1
                    i: 0
                    min: 1
                    text: \
        - !!perl/hash:RE_meta
          min: 0
          text: ^^
        - !!perl/hash:RE_method
          min: 12345
          name: pod_comment
          rest: ''
      - !!perl/hash:RE_sequence
        alt: unv_0 2
        min: 12345
        zyg:
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \h
          min: 0
          quant:
          - '*'
        - !!perl/hash:RE_method
          min: 12345
          name: comment
          rest: ''
unv_0: *19
unv_1: *20
vws: !!perl/hash:RE_ast
  dba: vertical whitespace
  min: 1
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      min: 1
      re: !!perl/hash:RE_bracket
        min: 1
        re: &21 !!perl/hash:RE_any
          altname: vws_0
          dba: vertical whitespace
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: vws_0 0
            min: 1
            text: \v
          - !!perl/hash:RE_sequence
            alt: vws_0 1
            min: 10
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 9
              text: '#DEBUG -1'
            - !!perl/hash:RE_block
              min: 0
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                min: 1
                text: \V
              min: 0
              quant:
              - '*'
            - !!perl/hash:RE_meta
              min: 1
              text: \v
          - !!perl/hash:RE_sequence
            alt: vws_0 2
            min: 12353
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 7
              text: <<<<<<<
            - !!perl/hash:RE_meta
              min: 0
              text: '::'
            - !!perl/hash:RE_assertion
              assert: '?'
              min: 0
              re: !!perl/hash:RE_method_re
                min: 12345
                name: before
                nobind: 1
                re: !!perl/hash:RE_sequence
                  min: 16
                  zyg:
                  - !!perl/hash:RE_bracket
                    min: 8
                    re: !!perl/hash:RE_sequence
                      min: 8
                      zyg:
                      - !!perl/hash:RE_meta
                        min: 0
                        text: .*?
                      - !!perl/hash:RE_meta
                        min: 1
                        text: \v
                      - !!perl/hash:RE_string
                        i: 0
                        min: 7
                        text: =======
                  - !!perl/hash:RE_meta
                    min: 0
                    text: .*?
                  - !!perl/hash:RE_meta
                    min: 1
                    text: \v
                  - !!perl/hash:RE_string
                    i: 0
                    min: 7
                    text: '>>>>>>>'
            - !!perl/hash:RE_method
              min: 12345
              name: sorry
              rest: 1
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                min: 1
                text: \V
              min: 0
              quant:
              - '*'
            - !!perl/hash:RE_meta
              min: 1
              text: \v
          - !!perl/hash:RE_sequence
            alt: vws_0 3
            min: 16
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 7
              text: =======
            - !!perl/hash:RE_meta
              min: 0
              text: '::'
            - !!perl/hash:RE_meta
              min: 0
              text: .*?
            - !!perl/hash:RE_meta
              min: 1
              text: \v
            - !!perl/hash:RE_string
              i: 0
              min: 7
              text: '>>>>>>>'
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                min: 1
                text: \V
              min: 0
              quant:
              - '*'
            - !!perl/hash:RE_meta
              min: 1
              text: \v
    min: 1
    quant:
    - +
vws_0: *21
ws: !!perl/hash:RE_ast
  dba: whitespace
  min: 0
  re: !!perl/hash:RE_first
    min: 0
    zyg:
    - !!perl/hash:RE_bracket
      min: 1
      re: &22 !!perl/hash:RE_any
        altname: ws_0
        dba: whitespace
        min: 1
        zyg:
        - !!perl/hash:RE_sequence
          alt: ws_0 0
          min: 1
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            min: 1
            quant:
            - +
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_cclass
              i: 0
              min: 1
              nobind: 1
              text: '[\#\s\\]'
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          alt: ws_0 1
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: \w
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: after
              nobind: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: \w
          - !!perl/hash:RE_meta
            min: 0
            text: ':::'
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: sorry
            rest: 1
    - !!perl/hash:RE_sequence
      min: 0
      zyg:
      - !!perl/hash:RE_quantified_atom
        atom: !!perl/hash:RE_bracket
          min: 0
          re: &23 !!perl/hash:RE_any
            altname: ws_1
            dba: whitespace
            min: 0
            zyg:
            - !!perl/hash:RE_method
              alt: ws_1 0
              min: 12345
              name: unsp
              rest: ''
            - !!perl/hash:RE_sequence
              alt: ws_1 1
              min: 24690
              zyg:
              - !!perl/hash:RE_method
                min: 12345
                name: vws
                rest: ''
              - !!perl/hash:RE_method
                min: 12345
                name: heredoc
                rest: ''
            - !!perl/hash:RE_method
              alt: ws_1 2
              min: 12345
              name: unv
              rest: ''
            - !!perl/hash:RE_sequence
              alt: ws_1 3
              min: 0
              zyg:
              - !!perl/hash:RE_meta
                min: 0
                text: $
              - !!perl/hash:RE_block
                min: 0
        min: 0
        quant:
        - '*'
      - !!perl/hash:RE_block
        min: 0
ws_0: *22
ws_1: *23
RETREE_END
;
use DEBUG;
use NAME;
use Stash;
use Cursor;
our $ALL;
## method TOP ($STOP = '')
sub TOP {
no warnings 'recursion';
my $self = shift;
my $STOP = @_ ? shift() : '';
my $lang = $self->cursor_fresh( 'STD::P6' );
if ($STOP) {
local $::GOAL = $STOP;
$lang->unitstop($STOP)->comp_unit;
}
else {
$lang->comp_unit};
};
our %term            = ('dba' => ('term')            , 'prec' => 'z=');
our %methodcall      = ('dba' => ('methodcall')      , 'prec' => 'y=', 'assoc' => 'unary', 'uassoc' => 'left', 'fiddly' => 1, 'pure' => 0);
our %autoincrement   = ('dba' => ('autoincrement')   , 'prec' => 'x=', 'assoc' => 'unary', 'uassoc' => 'non', 'pure' => 0);
our %exponentiation  = ('dba' => ('exponentiation')  , 'prec' => 'w=', 'assoc' => 'right', 'pure' => 1);
our %symbolic_unary  = ('dba' => ('symbolic unary')  , 'prec' => 'v=', 'assoc' => 'unary', 'uassoc' => 'left', 'pure' => 1);
our %multiplicative  = ('dba' => ('multiplicative')  , 'prec' => 'u=', 'assoc' => 'left', 'pure' => 1);
our %additive        = ('dba' => ('additive')        , 'prec' => 't=', 'assoc' => 'left', 'pure' => 1);
our %replication     = ('dba' => ('replication')     , 'prec' => 's=', 'assoc' => 'left', 'pure' => 1);
our %concatenation   = ('dba' => ('concatenation')   , 'prec' => 'r=', 'assoc' => 'list', 'pure' => 1);
our %junctive_and    = ('dba' => ('junctive and')    , 'prec' => 'q=', 'assoc' => 'list', 'pure' => 1);
our %junctive_or     = ('dba' => ('junctive or')     , 'prec' => 'p=', 'assoc' => 'list', 'pure' => 1);
our %named_unary     = ('dba' => ('named unary')     , 'prec' => 'o=', 'assoc' => 'unary', 'uassoc' => 'left', 'pure' => 1);
our %structural      = ('dba' => ('structural infix'), 'prec' => 'n=', 'assoc' => 'non', 'diffy' => 1);
our %chaining        = ('dba' => ('chaining')        , 'prec' => 'm=', 'assoc' => 'chain', 'diffy' => 1, 'iffy' => 1, 'pure' => 1);
our %tight_and       = ('dba' => ('tight and')       , 'prec' => 'l=', 'assoc' => 'list');
our %tight_or        = ('dba' => ('tight or')        , 'prec' => 'k=', 'assoc' => 'list');
our %conditional     = ('dba' => ('conditional')     , 'prec' => 'j=', 'assoc' => 'right', 'fiddly' => 1);
our %item_assignment = ('dba' => ('item assignment') , 'prec' => 'i=', 'assoc' => 'right', 'pure' => 0);
our %list_assignment = ('dba' => ('list assignment') , 'prec' => 'i=', 'assoc' => 'right', 'sub' => 'e=', 'fiddly' => 1, 'pure' => 0);
our %loose_unary     = ('dba' => ('loose unary')     , 'prec' => 'h=', 'assoc' => 'unary', 'uassoc' => 'left', 'pure' => 1);
our %comma           = ('dba' => ('comma')           , 'prec' => 'g=', 'assoc' => 'list', 'nextterm' => 'nulltermish', 'fiddly' => 1, 'pure' => 1);
our %list_infix      = ('dba' => ('list infix')      , 'prec' => 'f=', 'assoc' => 'list', 'pure' => 1);
our %list_prefix     = ('dba' => ('list prefix')     , 'prec' => 'e=', 'assoc' => 'unary', 'uassoc' => 'left');
our %loose_and       = ('dba' => ('loose and')       , 'prec' => 'd=', 'assoc' => 'list');
our %loose_or        = ('dba' => ('loose or')        , 'prec' => 'c=', 'assoc' => 'list');
our %sequencer       = ('dba' => ('sequencer')       , 'prec' => 'b=', 'assoc' => 'list', 'nextterm' => 'statement', 'fiddly' => 1);
our %LOOSEST         = ('dba' => ('LOOSEST')         , 'prec' => 'a=!');
our %terminator      = ('dba' => ('terminator')      , 'prec' => 'a=', 'assoc' => 'list');
our $LOOSEST = "a=!";
our $item_assignment_prec = 'i=';
our $methodcall_prec = 'y=';
local $::endsym = "null";
local $::endargs = -1;
## token category { <...> }
sub category__PEEK { $_[0]->_AUTOLEXpeek('category:*',$retree); }
sub category {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE category');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'category') {
                $C->deb("Fate passed to category: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT category';
            }
            else {
                $x = 'ALTLTM category';
            }
        }
        else {
            $x = 'ALTLTM category';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'category:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("category trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "category", @gather);
    };
    @result;
}
;
## token category:category { <sym> }
sub category__S_000category__PEEK { $_[0]->_AUTOLEXpeek('category__S_000category', $retree) }
sub category__S_000category {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_000category");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "category";
$self->_MATCHIFYr($S, "category__S_000category", $C->_EXACT("category"));
}
;
## token category:sigil { <sym> }
sub category__S_001sigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_001sigil', $retree) }
sub category__S_001sigil {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_001sigil");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sigil";
$self->_MATCHIFYr($S, "category__S_001sigil", $C->_EXACT("sigil"));
}
;
## token sigil { <...> }
sub sigil__PEEK { $_[0]->_AUTOLEXpeek('sigil:*',$retree); }
sub sigil {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE sigil');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'sigil') {
                $C->deb("Fate passed to sigil: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT sigil';
            }
            else {
                $x = 'ALTLTM sigil';
            }
        }
        else {
            $x = 'ALTLTM sigil';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'sigil:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("sigil trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "sigil", @gather);
    };
    @result;
}
;
## token category:twigil { <sym> }
sub category__S_002twigil__PEEK { $_[0]->_AUTOLEXpeek('category__S_002twigil', $retree) }
sub category__S_002twigil {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_002twigil");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "twigil";
$self->_MATCHIFYr($S, "category__S_002twigil", $C->_EXACT("twigil"));
}
;
## token twigil (:$*endsym = 'begid') { <...> }
sub twigil__PEEK { $_[0]->_AUTOLEXpeek('twigil:*',$retree); }
sub twigil {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE twigil');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'twigil') {
                $C->deb("Fate passed to twigil: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT twigil';
            }
            else {
                $x = 'ALTLTM twigil';
            }
        }
        else {
            $x = 'ALTLTM twigil';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'twigil:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("twigil trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "twigil", @gather);
    };
    @result;
}
;
## token category:special_variable { <sym> }
sub category__S_003special_variable__PEEK { $_[0]->_AUTOLEXpeek('category__S_003special_variable', $retree) }
sub category__S_003special_variable {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_003special_variable");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "special_variable";
$self->_MATCHIFYr($S, "category__S_003special_variable", $C->_EXACT("special_variable"));
}
;
## token special_variable { <...> }
sub special_variable__PEEK { $_[0]->_AUTOLEXpeek('special_variable:*',$retree); }
sub special_variable {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE special_variable');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'special_variable') {
                $C->deb("Fate passed to special_variable: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT special_variable';
            }
            else {
                $x = 'ALTLTM special_variable';
            }
        }
        else {
            $x = 'ALTLTM special_variable';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'special_variable:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("special_variable trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "special_variable", @gather);
    };
    @result;
}
;
## token category:comment { <sym> }
sub category__S_004comment__PEEK { $_[0]->_AUTOLEXpeek('category__S_004comment', $retree) }
sub category__S_004comment {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_004comment");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "comment";
$self->_MATCHIFYr($S, "category__S_004comment", $C->_EXACT("comment"));
}
;
## token comment { <...> }
sub comment__PEEK { $_[0]->_AUTOLEXpeek('comment:*',$retree); }
sub comment {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE comment');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'comment') {
                $C->deb("Fate passed to comment: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT comment';
            }
            else {
                $x = 'ALTLTM comment';
            }
        }
        else {
            $x = 'ALTLTM comment';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'comment:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("comment trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "comment", @gather);
    };
    @result;
}
;
## token category:version { <sym> }
sub category__S_005version__PEEK { $_[0]->_AUTOLEXpeek('category__S_005version', $retree) }
sub category__S_005version {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_005version");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "version";
$self->_MATCHIFYr($S, "category__S_005version", $C->_EXACT("version"));
}
;
## token version { <...> }
sub version__PEEK { $_[0]->_AUTOLEXpeek('version:*',$retree); }
sub version {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE version');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'version') {
                $C->deb("Fate passed to version: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT version';
            }
            else {
                $x = 'ALTLTM version';
            }
        }
        else {
            $x = 'ALTLTM version';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'version:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("version trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "version", @gather);
    };
    @result;
}
;
## token category:module_name { <sym> }
sub category__S_006module_name__PEEK { $_[0]->_AUTOLEXpeek('category__S_006module_name', $retree) }
sub category__S_006module_name {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_006module_name");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "module_name";
$self->_MATCHIFYr($S, "category__S_006module_name", $C->_EXACT("module_name"));
}
;
## token module_name { <...> }
sub module_name__PEEK { $_[0]->_AUTOLEXpeek('module_name:*',$retree); }
sub module_name {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE module_name');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'module_name') {
                $C->deb("Fate passed to module_name: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT module_name';
            }
            else {
                $x = 'ALTLTM module_name';
            }
        }
        else {
            $x = 'ALTLTM module_name';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'module_name:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("module_name trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "module_name", @gather);
    };
    @result;
}
;
## token category:value { <sym> }
sub category__S_007value__PEEK { $_[0]->_AUTOLEXpeek('category__S_007value', $retree) }
sub category__S_007value {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_007value");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "value";
$self->_MATCHIFYr($S, "category__S_007value", $C->_EXACT("value"));
}
;
## token value { <...> }
sub value__PEEK { $_[0]->_AUTOLEXpeek('value:*',$retree); }
sub value {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE value');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'value') {
                $C->deb("Fate passed to value: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT value';
            }
            else {
                $x = 'ALTLTM value';
            }
        }
        else {
            $x = 'ALTLTM value';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'value:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("value trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "value", @gather);
    };
    @result;
}
;
## token category:term { <sym> }
sub category__S_008term__PEEK { $_[0]->_AUTOLEXpeek('category__S_008term', $retree) }
sub category__S_008term {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_008term");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "term";
$self->_MATCHIFYr($S, "category__S_008term", $C->_EXACT("term"));
}
;
## token term { <...> }
sub term__PEEK { $_[0]->_AUTOLEXpeek('term:*',$retree); }
sub term {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE term');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'term') {
                $C->deb("Fate passed to term: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT term';
            }
            else {
                $x = 'ALTLTM term';
            }
        }
        else {
            $x = 'ALTLTM term';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'term:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("term trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "term", @gather);
    };
    @result;
}
;
## token category:strtonum { <sym> }
sub category__S_009strtonum__PEEK { $_[0]->_AUTOLEXpeek('category__S_009strtonum', $retree) }
sub category__S_009strtonum {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_009strtonum");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "strtonum";
$self->_MATCHIFYr($S, "category__S_009strtonum", $C->_EXACT("strtonum"));
}
;
## token strtonum { <...> }
sub strtonum__PEEK { $_[0]->_AUTOLEXpeek('strtonum:*',$retree); }
sub strtonum {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE strtonum');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'strtonum') {
                $C->deb("Fate passed to strtonum: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT strtonum';
            }
            else {
                $x = 'ALTLTM strtonum';
            }
        }
        else {
            $x = 'ALTLTM strtonum';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'strtonum:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("strtonum trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "strtonum", @gather);
    };
    @result;
}
;
## token category:quote { <sym> }
sub category__S_010quote__PEEK { $_[0]->_AUTOLEXpeek('category__S_010quote', $retree) }
sub category__S_010quote {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_010quote");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quote";
$self->_MATCHIFYr($S, "category__S_010quote", $C->_EXACT("quote"));
}
;
## token quote () { <...> }
sub quote__PEEK { $_[0]->_AUTOLEXpeek('quote:*',$retree); }
sub quote {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE quote');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'quote') {
                $C->deb("Fate passed to quote: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT quote';
            }
            else {
                $x = 'ALTLTM quote';
            }
        }
        else {
            $x = 'ALTLTM quote';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'quote:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("quote trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "quote", @gather);
    };
    @result;
}
;
## token category:prefix { <sym> }
sub category__S_011prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_011prefix', $retree) }
sub category__S_011prefix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_011prefix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "prefix";
$self->_MATCHIFYr($S, "category__S_011prefix", $C->_EXACT("prefix"));
}
;
## token prefix is unary is defequiv(%symbolic_unary) { <...> }
sub prefix__PEEK { $_[0]->_AUTOLEXpeek('prefix:*',$retree); }
sub prefix {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE prefix');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'prefix') {
                $C->deb("Fate passed to prefix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT prefix';
            }
            else {
                $x = 'ALTLTM prefix';
            }
        }
        else {
            $x = 'ALTLTM prefix';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'prefix:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("prefix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "prefix", @gather);
    };
    @result;
}
;
## token category:infix { <sym> }
sub category__S_012infix__PEEK { $_[0]->_AUTOLEXpeek('category__S_012infix', $retree) }
sub category__S_012infix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_012infix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "infix";
$self->_MATCHIFYr($S, "category__S_012infix", $C->_EXACT("infix"));
}
;
## token infix is binary is defequiv(%additive) { <...> }
sub infix__PEEK { $_[0]->_AUTOLEXpeek('infix:*',$retree); }
sub infix {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE infix');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'infix') {
                $C->deb("Fate passed to infix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT infix';
            }
            else {
                $x = 'ALTLTM infix';
            }
        }
        else {
            $x = 'ALTLTM infix';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'infix:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("infix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "infix", @gather);
    };
    @result;
}
;
## token category:postfix { <sym> }
sub category__S_013postfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_013postfix', $retree) }
sub category__S_013postfix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_013postfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "postfix";
$self->_MATCHIFYr($S, "category__S_013postfix", $C->_EXACT("postfix"));
}
;
## token postfix is unary is defequiv(%autoincrement) { <...> }
sub postfix__PEEK { $_[0]->_AUTOLEXpeek('postfix:*',$retree); }
sub postfix {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE postfix');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'postfix') {
                $C->deb("Fate passed to postfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT postfix';
            }
            else {
                $x = 'ALTLTM postfix';
            }
        }
        else {
            $x = 'ALTLTM postfix';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'postfix:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("postfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "postfix", @gather);
    };
    @result;
}
;
## token category:dotty { <sym> }
sub category__S_014dotty__PEEK { $_[0]->_AUTOLEXpeek('category__S_014dotty', $retree) }
sub category__S_014dotty {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_014dotty");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "dotty";
$self->_MATCHIFYr($S, "category__S_014dotty", $C->_EXACT("dotty"));
}
;
## token dotty (:$*endsym = 'unspacey') { <...> }
sub dotty__PEEK { $_[0]->_AUTOLEXpeek('dotty:*',$retree); }
sub dotty {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE dotty');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'dotty') {
                $C->deb("Fate passed to dotty: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT dotty';
            }
            else {
                $x = 'ALTLTM dotty';
            }
        }
        else {
            $x = 'ALTLTM dotty';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'dotty:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("dotty trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "dotty", @gather);
    };
    @result;
}
;
## token category:circumfix { <sym> }
sub category__S_015circumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_015circumfix', $retree) }
sub category__S_015circumfix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_015circumfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "circumfix";
$self->_MATCHIFYr($S, "category__S_015circumfix", $C->_EXACT("circumfix"));
}
;
## token circumfix { <...> }
sub circumfix__PEEK { $_[0]->_AUTOLEXpeek('circumfix:*',$retree); }
sub circumfix {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE circumfix');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'circumfix') {
                $C->deb("Fate passed to circumfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT circumfix';
            }
            else {
                $x = 'ALTLTM circumfix';
            }
        }
        else {
            $x = 'ALTLTM circumfix';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'circumfix:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("circumfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "circumfix", @gather);
    };
    @result;
}
;
## token category:postcircumfix { <sym> }
sub category__S_016postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('category__S_016postcircumfix', $retree) }
sub category__S_016postcircumfix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_016postcircumfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "postcircumfix";
$self->_MATCHIFYr($S, "category__S_016postcircumfix", $C->_EXACT("postcircumfix"));
}
;
## token postcircumfix is unary { <...> }  # unary as far as EXPR knows...
sub postcircumfix__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix:*',$retree); }
sub postcircumfix {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE postcircumfix');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'postcircumfix') {
                $C->deb("Fate passed to postcircumfix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT postcircumfix';
            }
            else {
                $x = 'ALTLTM postcircumfix';
            }
        }
        else {
            $x = 'ALTLTM postcircumfix';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'postcircumfix:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("postcircumfix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "postcircumfix", @gather);
    };
    @result;
}
;
## token category:quote_mod { <sym> }
sub category__S_017quote_mod__PEEK { $_[0]->_AUTOLEXpeek('category__S_017quote_mod', $retree) }
sub category__S_017quote_mod {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_017quote_mod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quote_mod";
$self->_MATCHIFYr($S, "category__S_017quote_mod", $C->_EXACT("quote_mod"));
}
;
## token quote_mod { <...> }
sub quote_mod__PEEK { $_[0]->_AUTOLEXpeek('quote_mod:*',$retree); }
sub quote_mod {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE quote_mod');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'quote_mod') {
                $C->deb("Fate passed to quote_mod: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT quote_mod';
            }
            else {
                $x = 'ALTLTM quote_mod';
            }
        }
        else {
            $x = 'ALTLTM quote_mod';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'quote_mod:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("quote_mod trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "quote_mod", @gather);
    };
    @result;
}
;
## token category:trait_mod { <sym> }
sub category__S_018trait_mod__PEEK { $_[0]->_AUTOLEXpeek('category__S_018trait_mod', $retree) }
sub category__S_018trait_mod {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_018trait_mod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "trait_mod";
$self->_MATCHIFYr($S, "category__S_018trait_mod", $C->_EXACT("trait_mod"));
}
;
## token trait_mod (:$*endsym = 'spacey') { <...> }
sub trait_mod__PEEK { $_[0]->_AUTOLEXpeek('trait_mod:*',$retree); }
sub trait_mod {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE trait_mod');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'trait_mod') {
                $C->deb("Fate passed to trait_mod: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT trait_mod';
            }
            else {
                $x = 'ALTLTM trait_mod';
            }
        }
        else {
            $x = 'ALTLTM trait_mod';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'trait_mod:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("trait_mod trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "trait_mod", @gather);
    };
    @result;
}
;
## token category:type_declarator { <sym> }
sub category__S_019type_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_019type_declarator', $retree) }
sub category__S_019type_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_019type_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "type_declarator";
$self->_MATCHIFYr($S, "category__S_019type_declarator", $C->_EXACT("type_declarator"));
}
;
## token type_declarator (:$*endsym = 'spacey') { <...> }
sub type_declarator__PEEK { $_[0]->_AUTOLEXpeek('type_declarator:*',$retree); }
sub type_declarator {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE type_declarator');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'type_declarator') {
                $C->deb("Fate passed to type_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT type_declarator';
            }
            else {
                $x = 'ALTLTM type_declarator';
            }
        }
        else {
            $x = 'ALTLTM type_declarator';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'type_declarator:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("type_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "type_declarator", @gather);
    };
    @result;
}
;
## token category:scope_declarator { <sym> }
sub category__S_020scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_020scope_declarator', $retree) }
sub category__S_020scope_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_020scope_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "scope_declarator";
$self->_MATCHIFYr($S, "category__S_020scope_declarator", $C->_EXACT("scope_declarator"));
}
;
## token scope_declarator (:$*endsym = 'nofun') { <...> }
sub scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator:*',$retree); }
sub scope_declarator {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE scope_declarator');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'scope_declarator') {
                $C->deb("Fate passed to scope_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT scope_declarator';
            }
            else {
                $x = 'ALTLTM scope_declarator';
            }
        }
        else {
            $x = 'ALTLTM scope_declarator';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'scope_declarator:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("scope_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "scope_declarator", @gather);
    };
    @result;
}
;
## token category:package_declarator { <sym> }
sub category__S_021package_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_021package_declarator', $retree) }
sub category__S_021package_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_021package_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "package_declarator";
$self->_MATCHIFYr($S, "category__S_021package_declarator", $C->_EXACT("package_declarator"));
}
;
## token package_declarator (:$*endsym = 'spacey') { <...> }
sub package_declarator__PEEK { $_[0]->_AUTOLEXpeek('package_declarator:*',$retree); }
sub package_declarator {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE package_declarator');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'package_declarator') {
                $C->deb("Fate passed to package_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT package_declarator';
            }
            else {
                $x = 'ALTLTM package_declarator';
            }
        }
        else {
            $x = 'ALTLTM package_declarator';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'package_declarator:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("package_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "package_declarator", @gather);
    };
    @result;
}
;
## token category:multi_declarator { <sym> }
sub category__S_022multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_022multi_declarator', $retree) }
sub category__S_022multi_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_022multi_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "multi_declarator";
$self->_MATCHIFYr($S, "category__S_022multi_declarator", $C->_EXACT("multi_declarator"));
}
;
## token multi_declarator (:$*endsym = 'spacey') { <...> }
sub multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator:*',$retree); }
sub multi_declarator {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE multi_declarator');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'multi_declarator') {
                $C->deb("Fate passed to multi_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT multi_declarator';
            }
            else {
                $x = 'ALTLTM multi_declarator';
            }
        }
        else {
            $x = 'ALTLTM multi_declarator';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'multi_declarator:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("multi_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "multi_declarator", @gather);
    };
    @result;
}
;
## token category:routine_declarator { <sym> }
sub category__S_023routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_023routine_declarator', $retree) }
sub category__S_023routine_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_023routine_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "routine_declarator";
$self->_MATCHIFYr($S, "category__S_023routine_declarator", $C->_EXACT("routine_declarator"));
}
;
## token routine_declarator (:$*endsym = 'nofun') { <...> }
sub routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator:*',$retree); }
sub routine_declarator {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE routine_declarator');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'routine_declarator') {
                $C->deb("Fate passed to routine_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT routine_declarator';
            }
            else {
                $x = 'ALTLTM routine_declarator';
            }
        }
        else {
            $x = 'ALTLTM routine_declarator';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'routine_declarator:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("routine_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "routine_declarator", @gather);
    };
    @result;
}
;
## token category:regex_declarator { <sym> }
sub category__S_024regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('category__S_024regex_declarator', $retree) }
sub category__S_024regex_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_024regex_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "regex_declarator";
$self->_MATCHIFYr($S, "category__S_024regex_declarator", $C->_EXACT("regex_declarator"));
}
;
## token regex_declarator (:$*endsym = 'spacey') { <...> }
sub regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator:*',$retree); }
sub regex_declarator {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE regex_declarator');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'regex_declarator') {
                $C->deb("Fate passed to regex_declarator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT regex_declarator';
            }
            else {
                $x = 'ALTLTM regex_declarator';
            }
        }
        else {
            $x = 'ALTLTM regex_declarator';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'regex_declarator:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("regex_declarator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "regex_declarator", @gather);
    };
    @result;
}
;
## token category:statement_prefix { <sym> }
sub category__S_025statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('category__S_025statement_prefix', $retree) }
sub category__S_025statement_prefix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_025statement_prefix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "statement_prefix";
$self->_MATCHIFYr($S, "category__S_025statement_prefix", $C->_EXACT("statement_prefix"));
}
;
## rule  statement_prefix () { <...> }
sub statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix:*',$retree); }
sub statement_prefix {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE statement_prefix');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'statement_prefix') {
                $C->deb("Fate passed to statement_prefix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT statement_prefix';
            }
            else {
                $x = 'ALTLTM statement_prefix';
            }
        }
        else {
            $x = 'ALTLTM statement_prefix';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'statement_prefix:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("statement_prefix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "statement_prefix", @gather);
    };
    @result;
}
;
## token category:statement_control { <sym> }
sub category__S_026statement_control__PEEK { $_[0]->_AUTOLEXpeek('category__S_026statement_control', $retree) }
sub category__S_026statement_control {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_026statement_control");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "statement_control";
$self->_MATCHIFYr($S, "category__S_026statement_control", $C->_EXACT("statement_control"));
}
;
## rule  statement_control (:$*endsym = 'spacey') { <...> }
sub statement_control__PEEK { $_[0]->_AUTOLEXpeek('statement_control:*',$retree); }
sub statement_control {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE statement_control');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'statement_control') {
                $C->deb("Fate passed to statement_control: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT statement_control';
            }
            else {
                $x = 'ALTLTM statement_control';
            }
        }
        else {
            $x = 'ALTLTM statement_control';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'statement_control:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("statement_control trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "statement_control", @gather);
    };
    @result;
}
;
## token category:statement_mod_cond { <sym> }
sub category__S_027statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('category__S_027statement_mod_cond', $retree) }
sub category__S_027statement_mod_cond {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_027statement_mod_cond");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "statement_mod_cond";
$self->_MATCHIFYr($S, "category__S_027statement_mod_cond", $C->_EXACT("statement_mod_cond"));
}
;
## rule  statement_mod_cond (:$*endsym = 'nofun') { <...> }
sub statement_mod_cond__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond:*',$retree); }
sub statement_mod_cond {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE statement_mod_cond');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'statement_mod_cond') {
                $C->deb("Fate passed to statement_mod_cond: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT statement_mod_cond';
            }
            else {
                $x = 'ALTLTM statement_mod_cond';
            }
        }
        else {
            $x = 'ALTLTM statement_mod_cond';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'statement_mod_cond:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("statement_mod_cond trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "statement_mod_cond", @gather);
    };
    @result;
}
;
## token category:statement_mod_loop { <sym> }
sub category__S_028statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('category__S_028statement_mod_loop', $retree) }
sub category__S_028statement_mod_loop {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_028statement_mod_loop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "statement_mod_loop";
$self->_MATCHIFYr($S, "category__S_028statement_mod_loop", $C->_EXACT("statement_mod_loop"));
}
;
## rule  statement_mod_loop (:$*endsym = 'nofun') { <...> }
sub statement_mod_loop__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop:*',$retree); }
sub statement_mod_loop {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE statement_mod_loop');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'statement_mod_loop') {
                $C->deb("Fate passed to statement_mod_loop: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT statement_mod_loop';
            }
            else {
                $x = 'ALTLTM statement_mod_loop';
            }
        }
        else {
            $x = 'ALTLTM statement_mod_loop';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'statement_mod_loop:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("statement_mod_loop trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "statement_mod_loop", @gather);
    };
    @result;
}
;
## token category:infix_prefix_meta_operator { <sym> }
sub category__S_029infix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_029infix_prefix_meta_operator', $retree) }
sub category__S_029infix_prefix_meta_operator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_029infix_prefix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "infix_prefix_meta_operator";
$self->_MATCHIFYr($S, "category__S_029infix_prefix_meta_operator", $C->_EXACT("infix_prefix_meta_operator"));
}
;
## token infix_prefix_meta_operator is binary { <...> }
sub infix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator:*',$retree); }
sub infix_prefix_meta_operator {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE infix_prefix_meta_operator');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'infix_prefix_meta_operator') {
                $C->deb("Fate passed to infix_prefix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT infix_prefix_meta_operator';
            }
            else {
                $x = 'ALTLTM infix_prefix_meta_operator';
            }
        }
        else {
            $x = 'ALTLTM infix_prefix_meta_operator';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'infix_prefix_meta_operator:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("infix_prefix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "infix_prefix_meta_operator", @gather);
    };
    @result;
}
;
## token category:infix_postfix_meta_operator { <sym> }
sub category__S_030infix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_030infix_postfix_meta_operator', $retree) }
sub category__S_030infix_postfix_meta_operator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_030infix_postfix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "infix_postfix_meta_operator";
$self->_MATCHIFYr($S, "category__S_030infix_postfix_meta_operator", $C->_EXACT("infix_postfix_meta_operator"));
}
;
## token infix_postfix_meta_operator ($op) is binary { <...> }
sub infix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_postfix_meta_operator:*',$retree); }
sub infix_postfix_meta_operator {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE infix_postfix_meta_operator');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'infix_postfix_meta_operator') {
                $C->deb("Fate passed to infix_postfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT infix_postfix_meta_operator';
            }
            else {
                $x = 'ALTLTM infix_postfix_meta_operator';
            }
        }
        else {
            $x = 'ALTLTM infix_postfix_meta_operator';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'infix_postfix_meta_operator:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("infix_postfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "infix_postfix_meta_operator", @gather);
    };
    @result;
}
;
## token category:infix_circumfix_meta_operator { <sym> }
sub category__S_031infix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_031infix_circumfix_meta_operator', $retree) }
sub category__S_031infix_circumfix_meta_operator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_031infix_circumfix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "infix_circumfix_meta_operator";
$self->_MATCHIFYr($S, "category__S_031infix_circumfix_meta_operator", $C->_EXACT("infix_circumfix_meta_operator"));
}
;
## token infix_circumfix_meta_operator is binary { <...> }
sub infix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator:*',$retree); }
sub infix_circumfix_meta_operator {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE infix_circumfix_meta_operator');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'infix_circumfix_meta_operator') {
                $C->deb("Fate passed to infix_circumfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT infix_circumfix_meta_operator';
            }
            else {
                $x = 'ALTLTM infix_circumfix_meta_operator';
            }
        }
        else {
            $x = 'ALTLTM infix_circumfix_meta_operator';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'infix_circumfix_meta_operator:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("infix_circumfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "infix_circumfix_meta_operator", @gather);
    };
    @result;
}
;
## token category:postfix_prefix_meta_operator { <sym> }
sub category__S_032postfix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_032postfix_prefix_meta_operator', $retree) }
sub category__S_032postfix_prefix_meta_operator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_032postfix_prefix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "postfix_prefix_meta_operator";
$self->_MATCHIFYr($S, "category__S_032postfix_prefix_meta_operator", $C->_EXACT("postfix_prefix_meta_operator"));
}
;
## token postfix_prefix_meta_operator is unary { <...> }
sub postfix_prefix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('postfix_prefix_meta_operator:*',$retree); }
sub postfix_prefix_meta_operator {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE postfix_prefix_meta_operator');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'postfix_prefix_meta_operator') {
                $C->deb("Fate passed to postfix_prefix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT postfix_prefix_meta_operator';
            }
            else {
                $x = 'ALTLTM postfix_prefix_meta_operator';
            }
        }
        else {
            $x = 'ALTLTM postfix_prefix_meta_operator';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'postfix_prefix_meta_operator:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("postfix_prefix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "postfix_prefix_meta_operator", @gather);
    };
    @result;
}
;
## token category:prefix_postfix_meta_operator { <sym> }
sub category__S_033prefix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_033prefix_postfix_meta_operator', $retree) }
sub category__S_033prefix_postfix_meta_operator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_033prefix_postfix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "prefix_postfix_meta_operator";
$self->_MATCHIFYr($S, "category__S_033prefix_postfix_meta_operator", $C->_EXACT("prefix_postfix_meta_operator"));
}
;
## token prefix_postfix_meta_operator is unary { <...> }
sub prefix_postfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('prefix_postfix_meta_operator:*',$retree); }
sub prefix_postfix_meta_operator {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE prefix_postfix_meta_operator');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'prefix_postfix_meta_operator') {
                $C->deb("Fate passed to prefix_postfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT prefix_postfix_meta_operator';
            }
            else {
                $x = 'ALTLTM prefix_postfix_meta_operator';
            }
        }
        else {
            $x = 'ALTLTM prefix_postfix_meta_operator';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'prefix_postfix_meta_operator:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("prefix_postfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "prefix_postfix_meta_operator", @gather);
    };
    @result;
}
;
## token category:prefix_circumfix_meta_operator { <sym> }
sub category__S_034prefix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('category__S_034prefix_circumfix_meta_operator', $retree) }
sub category__S_034prefix_circumfix_meta_operator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_034prefix_circumfix_meta_operator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "prefix_circumfix_meta_operator";
$self->_MATCHIFYr($S, "category__S_034prefix_circumfix_meta_operator", $C->_EXACT("prefix_circumfix_meta_operator"));
}
;
## token prefix_circumfix_meta_operator is unary { <...> }
sub prefix_circumfix_meta_operator__PEEK { $_[0]->_AUTOLEXpeek('prefix_circumfix_meta_operator:*',$retree); }
sub prefix_circumfix_meta_operator {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE prefix_circumfix_meta_operator');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'prefix_circumfix_meta_operator') {
                $C->deb("Fate passed to prefix_circumfix_meta_operator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT prefix_circumfix_meta_operator';
            }
            else {
                $x = 'ALTLTM prefix_circumfix_meta_operator';
            }
        }
        else {
            $x = 'ALTLTM prefix_circumfix_meta_operator';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'prefix_circumfix_meta_operator:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("prefix_circumfix_meta_operator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "prefix_circumfix_meta_operator", @gather);
    };
    @result;
}
;
## token category:terminator { <sym> }
sub category__S_035terminator__PEEK { $_[0]->_AUTOLEXpeek('category__S_035terminator', $retree) }
sub category__S_035terminator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_035terminator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "terminator";
$self->_MATCHIFYr($S, "category__S_035terminator", $C->_EXACT("terminator"));
}
;
## token terminator { <...> }
sub terminator__PEEK { $_[0]->_AUTOLEXpeek('terminator:*',$retree); }
sub terminator {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE terminator');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'terminator') {
                $C->deb("Fate passed to terminator: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT terminator';
            }
            else {
                $x = 'ALTLTM terminator';
            }
        }
        else {
            $x = 'ALTLTM terminator';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'terminator:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("terminator trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "terminator", @gather);
    };
    @result;
}
;
## token unspacey { <.unsp>? }
sub unspacey__PEEK { $_[0]->_AUTOLEXpeek('unspacey', $retree) }
sub unspacey {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unspacey");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unspacey", $C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}));
}
;
## token begid { <?before \w> }
sub begid__PEEK { $_[0]->_AUTOLEXpeek('begid', $retree) }
sub begid {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE begid");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "begid", $C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) { ($C) } else { () }
}));
}
;
## token endid { <?before <-[ \- \' \w ]> > }
sub endid__PEEK { $_[0]->_AUTOLEXpeek('endid', $retree) }
sub endid {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE endid");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "endid", $C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[^\-\'\w]/)
}))) { ($C) } else { () }
}));
}
;
## token spacey { <?before <[ \s \# ]> > }
sub spacey__PEEK { $_[0]->_AUTOLEXpeek('spacey', $retree) }
sub spacey {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE spacey");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "spacey", $C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\s\#]/)
}))) { ($C) } else { () }
}));
}
;
## token nofun { <!before '(' | '.(' | '\\' | '\'' | '-' | "'" | \w > }
sub nofun__PEEK { $_[0]->_AUTOLEXpeek('nofun', $retree) }
sub nofun {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE nofun");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "nofun", $C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'nofun_0') {
        $C->deb("Fate passed to nofun_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT nofun_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM nofun_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'nofun_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("nofun_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\(")
},
sub {
my $C=shift;
$C->_EXACT("\.\(")
},
sub {
my $C=shift;
$C->_EXACT("\\")
},
sub {
my $C=shift;
$C->_EXACT("\'")
},
sub {
my $C=shift;
$C->_EXACT("\-")
},
sub {
my $C=shift;
$C->_EXACT("\'")
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}));
}
;
## token sigil:sym<$>  { <sym> }
sub sigil__S_036Dollar__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_036Dollar', $retree) }
sub sigil__S_036Dollar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigil__S_036Dollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$";
$self->_MATCHIFYr($S, "sigil__S_036Dollar", $C->_EXACT("\$"));
}
;
## token sigil:sym<@>  { <sym> }
sub sigil__S_037At__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_037At', $retree) }
sub sigil__S_037At {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigil__S_037At");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@";
$self->_MATCHIFYr($S, "sigil__S_037At", $C->_EXACT("\@"));
}
;
## token sigil:sym<%>  { <sym> }
sub sigil__S_038Percent__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_038Percent', $retree) }
sub sigil__S_038Percent {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigil__S_038Percent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%";
$self->_MATCHIFYr($S, "sigil__S_038Percent", $C->_EXACT("\%"));
}
;
## token sigil:sym<&>  { <sym> }
sub sigil__S_039Amp__PEEK { $_[0]->_AUTOLEXpeek('sigil__S_039Amp', $retree) }
sub sigil__S_039Amp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigil__S_039Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&";
$self->_MATCHIFYr($S, "sigil__S_039Amp", $C->_EXACT("\&"));
}
;
## token twigil:sym<.> { <sym> }
sub twigil__S_040Dot__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_040Dot', $retree) }
sub twigil__S_040Dot {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_040Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.";
$self->_MATCHIFYr($S, "twigil__S_040Dot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\."))
and ($C) = ($C->begid)) {
$C
} else { () }
});
}
;
## token twigil:sym<!> { <sym> }
sub twigil__S_041Bang__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_041Bang', $retree) }
sub twigil__S_041Bang {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_041Bang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!";
$self->_MATCHIFYr($S, "twigil__S_041Bang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!"))
and ($C) = ($C->begid)) {
$C
} else { () }
});
}
;
## token twigil:sym<^> { <sym> }
sub twigil__S_042Caret__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_042Caret', $retree) }
sub twigil__S_042Caret {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_042Caret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^";
$self->_MATCHIFYr($S, "twigil__S_042Caret", do {
my $C = $C;
if (($C) = ($C->_EXACT("\^"))
and ($C) = ($C->begid)) {
$C
} else { () }
});
}
;
## token twigil:sym<:> { <sym> }
sub twigil__S_043Colon__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_043Colon', $retree) }
sub twigil__S_043Colon {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_043Colon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:";
$self->_MATCHIFYr($S, "twigil__S_043Colon", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->begid)) {
$C
} else { () }
});
}
;
## token twigil:sym<*> { <sym> }
sub twigil__S_044Star__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_044Star', $retree) }
sub twigil__S_044Star {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_044Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*";
$self->_MATCHIFYr($S, "twigil__S_044Star", do {
my $C = $C;
if (($C) = ($C->_EXACT("\*"))
and ($C) = ($C->begid)) {
$C
} else { () }
});
}
;
## token twigil:sym<?> { <sym> }
sub twigil__S_045Question__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_045Question', $retree) }
sub twigil__S_045Question {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_045Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?";
$self->_MATCHIFYr($S, "twigil__S_045Question", do {
my $C = $C;
if (($C) = ($C->_EXACT("\?"))
and ($C) = ($C->begid)) {
$C
} else { () }
});
}
;
## token twigil:sym<=> { <sym> }
sub twigil__S_046Equal__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_046Equal', $retree) }
sub twigil__S_046Equal {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_046Equal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=";
$self->_MATCHIFYr($S, "twigil__S_046Equal", do {
my $C = $C;
if (($C) = ($C->_EXACT("\="))
and ($C) = ($C->begid)) {
$C
} else { () }
});
}
;
## token twigil:sym<~> { <sym> }
sub twigil__S_047Tilde__PEEK { $_[0]->_AUTOLEXpeek('twigil__S_047Tilde', $retree) }
sub twigil__S_047Tilde {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE twigil__S_047Tilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~";
$self->_MATCHIFYr($S, "twigil__S_047Tilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~"))
and ($C) = ($C->begid)) {
$C
} else { () }
});
}
;
## token stopper { <!> }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
;
## regex stdstopper {
sub stdstopper__PEEK { $_[0]->_AUTOLEXpeek('stdstopper', $retree) }
sub stdstopper {
no warnings 'recursion';
my $self = shift;

my @stub = return $self if exists $::MEMOS[$self->{'_pos'}]->{'endstmt'};

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stdstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFY($S, "stdstopper", LazyMap::lazymap(sub {
my $C=shift;
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'endstmt'} ||= 1}, $C)
},
$C->_BRACKET(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'stdstopper_0') {
        $C->deb("Fate passed to stdstopper_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT stdstopper_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM stdstopper_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'stdstopper_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("stdstopper_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->terminator
})
},
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->unitstopper
})
},
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_SUBSUME(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\z/)
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})));
}
;
## token longname {
sub longname__PEEK { $_[0]->_AUTOLEXpeek('longname', $retree) }
sub longname {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE longname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];
$self->_MATCHIFYr($S, "longname", do {
if (my ($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\:\{")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
} else { () }
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token name {
sub name__PEEK { $_[0]->_AUTOLEXpeek('name', $retree) }
sub name {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE name");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'morename'} = [];
$self->_MATCHIFYr($S, "name", $C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'name_0') {
        $C->deb("Fate passed to name_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT name_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM name_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'name_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("name_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
$C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['morename'], sub {
my $C = shift;
$C->morename
})
})
} else { () }
},
sub {
my $C=shift;
$C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['morename'], sub {
my $C = shift;
$C->morename
})
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}));
}
;
## token morename {
sub morename__PEEK { $_[0]->_AUTOLEXpeek('morename', $retree) }
sub morename {
no warnings 'recursion';
my $self = shift;

local $::QSIGIL = '';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE morename");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'EXPR'} = [];
$C->{'identifier'} = [];
$self->_MATCHIFYr($S, "morename", do {
if (my ($C) = ($C->_EXACT("\:\:"))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'morename_0') {
        $C->deb("Fate passed to morename_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT morename_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM morename_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'morename_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("morename_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\(")
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'morename_1') {
        $C->deb("Fate passed to morename_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT morename_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM morename_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'morename_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("morename_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'indirect name', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\:\:")
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Name component may not be null"))) {
$C
} else { () }
}
};
@gather;
}
}))) { ($C) } else { () }
})
} else { () }
});
}
;
our %open2close = (
"\x{0028}" => "\x{0029}",
"\x{003C}" => "\x{003E}",
"\x{005B}" => "\x{005D}",
"\x{007B}" => "\x{007D}",
"\x{00AB}" => "\x{00BB}",
"\x{0F3A}" => "\x{0F3B}",
"\x{0F3C}" => "\x{0F3D}",
"\x{169B}" => "\x{169C}",
"\x{2018}" => "\x{2019}",
"\x{201A}" => "\x{2019}",
"\x{201B}" => "\x{2019}",
"\x{201C}" => "\x{201D}",
"\x{201E}" => "\x{201D}",
"\x{201F}" => "\x{201D}",
"\x{2039}" => "\x{203A}",
"\x{2045}" => "\x{2046}",
"\x{207D}" => "\x{207E}",
"\x{208D}" => "\x{208E}",
"\x{2208}" => "\x{220B}",
"\x{2209}" => "\x{220C}",
"\x{220A}" => "\x{220D}",
"\x{2215}" => "\x{29F5}",
"\x{223C}" => "\x{223D}",
"\x{2243}" => "\x{22CD}",
"\x{2252}" => "\x{2253}",
"\x{2254}" => "\x{2255}",
"\x{2264}" => "\x{2265}",
"\x{2266}" => "\x{2267}",
"\x{2268}" => "\x{2269}",
"\x{226A}" => "\x{226B}",
"\x{226E}" => "\x{226F}",
"\x{2270}" => "\x{2271}",
"\x{2272}" => "\x{2273}",
"\x{2274}" => "\x{2275}",
"\x{2276}" => "\x{2277}",
"\x{2278}" => "\x{2279}",
"\x{227A}" => "\x{227B}",
"\x{227C}" => "\x{227D}",
"\x{227E}" => "\x{227F}",
"\x{2280}" => "\x{2281}",
"\x{2282}" => "\x{2283}",
"\x{2284}" => "\x{2285}",
"\x{2286}" => "\x{2287}",
"\x{2288}" => "\x{2289}",
"\x{228A}" => "\x{228B}",
"\x{228F}" => "\x{2290}",
"\x{2291}" => "\x{2292}",
"\x{2298}" => "\x{29B8}",
"\x{22A2}" => "\x{22A3}",
"\x{22A6}" => "\x{2ADE}",
"\x{22A8}" => "\x{2AE4}",
"\x{22A9}" => "\x{2AE3}",
"\x{22AB}" => "\x{2AE5}",
"\x{22B0}" => "\x{22B1}",
"\x{22B2}" => "\x{22B3}",
"\x{22B4}" => "\x{22B5}",
"\x{22B6}" => "\x{22B7}",
"\x{22C9}" => "\x{22CA}",
"\x{22CB}" => "\x{22CC}",
"\x{22D0}" => "\x{22D1}",
"\x{22D6}" => "\x{22D7}",
"\x{22D8}" => "\x{22D9}",
"\x{22DA}" => "\x{22DB}",
"\x{22DC}" => "\x{22DD}",
"\x{22DE}" => "\x{22DF}",
"\x{22E0}" => "\x{22E1}",
"\x{22E2}" => "\x{22E3}",
"\x{22E4}" => "\x{22E5}",
"\x{22E6}" => "\x{22E7}",
"\x{22E8}" => "\x{22E9}",
"\x{22EA}" => "\x{22EB}",
"\x{22EC}" => "\x{22ED}",
"\x{22F0}" => "\x{22F1}",
"\x{22F2}" => "\x{22FA}",
"\x{22F3}" => "\x{22FB}",
"\x{22F4}" => "\x{22FC}",
"\x{22F6}" => "\x{22FD}",
"\x{22F7}" => "\x{22FE}",
"\x{2308}" => "\x{2309}",
"\x{230A}" => "\x{230B}",
"\x{2329}" => "\x{232A}",
"\x{23B4}" => "\x{23B5}",
"\x{2768}" => "\x{2769}",
"\x{276A}" => "\x{276B}",
"\x{276C}" => "\x{276D}",
"\x{276E}" => "\x{276F}",
"\x{2770}" => "\x{2771}",
"\x{2772}" => "\x{2773}",
"\x{2774}" => "\x{2775}",
"\x{27C3}" => "\x{27C4}",
"\x{27C5}" => "\x{27C6}",
"\x{27D5}" => "\x{27D6}",
"\x{27DD}" => "\x{27DE}",
"\x{27E2}" => "\x{27E3}",
"\x{27E4}" => "\x{27E5}",
"\x{27E6}" => "\x{27E7}",
"\x{27E8}" => "\x{27E9}",
"\x{27EA}" => "\x{27EB}",
"\x{2983}" => "\x{2984}",
"\x{2985}" => "\x{2986}",
"\x{2987}" => "\x{2988}",
"\x{2989}" => "\x{298A}",
"\x{298B}" => "\x{298C}",
"\x{298D}" => "\x{298E}",
"\x{298F}" => "\x{2990}",
"\x{2991}" => "\x{2992}",
"\x{2993}" => "\x{2994}",
"\x{2995}" => "\x{2996}",
"\x{2997}" => "\x{2998}",
"\x{29C0}" => "\x{29C1}",
"\x{29C4}" => "\x{29C5}",
"\x{29CF}" => "\x{29D0}",
"\x{29D1}" => "\x{29D2}",
"\x{29D4}" => "\x{29D5}",
"\x{29D8}" => "\x{29D9}",
"\x{29DA}" => "\x{29DB}",
"\x{29F8}" => "\x{29F9}",
"\x{29FC}" => "\x{29FD}",
"\x{2A2B}" => "\x{2A2C}",
"\x{2A2D}" => "\x{2A2E}",
"\x{2A34}" => "\x{2A35}",
"\x{2A3C}" => "\x{2A3D}",
"\x{2A64}" => "\x{2A65}",
"\x{2A79}" => "\x{2A7A}",
"\x{2A7D}" => "\x{2A7E}",
"\x{2A7F}" => "\x{2A80}",
"\x{2A81}" => "\x{2A82}",
"\x{2A83}" => "\x{2A84}",
"\x{2A8B}" => "\x{2A8C}",
"\x{2A91}" => "\x{2A92}",
"\x{2A93}" => "\x{2A94}",
"\x{2A95}" => "\x{2A96}",
"\x{2A97}" => "\x{2A98}",
"\x{2A99}" => "\x{2A9A}",
"\x{2A9B}" => "\x{2A9C}",
"\x{2AA1}" => "\x{2AA2}",
"\x{2AA6}" => "\x{2AA7}",
"\x{2AA8}" => "\x{2AA9}",
"\x{2AAA}" => "\x{2AAB}",
"\x{2AAC}" => "\x{2AAD}",
"\x{2AAF}" => "\x{2AB0}",
"\x{2AB3}" => "\x{2AB4}",
"\x{2ABB}" => "\x{2ABC}",
"\x{2ABD}" => "\x{2ABE}",
"\x{2ABF}" => "\x{2AC0}",
"\x{2AC1}" => "\x{2AC2}",
"\x{2AC3}" => "\x{2AC4}",
"\x{2AC5}" => "\x{2AC6}",
"\x{2ACD}" => "\x{2ACE}",
"\x{2ACF}" => "\x{2AD0}",
"\x{2AD1}" => "\x{2AD2}",
"\x{2AD3}" => "\x{2AD4}",
"\x{2AD5}" => "\x{2AD6}",
"\x{2AEC}" => "\x{2AED}",
"\x{2AF7}" => "\x{2AF8}",
"\x{2AF9}" => "\x{2AFA}",
"\x{2E02}" => "\x{2E03}",
"\x{2E04}" => "\x{2E05}",
"\x{2E09}" => "\x{2E0A}",
"\x{2E0C}" => "\x{2E0D}",
"\x{2E1C}" => "\x{2E1D}",
"\x{2E20}" => "\x{2E21}",
"\x{3008}" => "\x{3009}",
"\x{300A}" => "\x{300B}",
"\x{300C}" => "\x{300D}",
"\x{300E}" => "\x{300F}",
"\x{3010}" => "\x{3011}",
"\x{3014}" => "\x{3015}",
"\x{3016}" => "\x{3017}",
"\x{3018}" => "\x{3019}",
"\x{301A}" => "\x{301B}",
"\x{301D}" => "\x{301E}",
"\x{FD3E}" => "\x{FD3F}",
"\x{FE17}" => "\x{FE18}",
"\x{FE35}" => "\x{FE36}",
"\x{FE37}" => "\x{FE38}",
"\x{FE39}" => "\x{FE3A}",
"\x{FE3B}" => "\x{FE3C}",
"\x{FE3D}" => "\x{FE3E}",
"\x{FE3F}" => "\x{FE40}",
"\x{FE41}" => "\x{FE42}",
"\x{FE43}" => "\x{FE44}",
"\x{FE47}" => "\x{FE48}",
"\x{FE59}" => "\x{FE5A}",
"\x{FE5B}" => "\x{FE5C}",
"\x{FE5D}" => "\x{FE5E}",
"\x{FF08}" => "\x{FF09}",
"\x{FF1C}" => "\x{FF1E}",
"\x{FF3B}" => "\x{FF3D}",
"\x{FF5B}" => "\x{FF5D}",
"\x{FF5F}" => "\x{FF60}",
"\x{FF62}" => "\x{FF63}",
);
our %close2open = reverse %open2close;
## token opener {
sub opener__PEEK { $_[0]->_AUTOLEXpeek('opener', $retree) }
sub opener {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE opener");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "opener", $C->_PATTERN(qr/\G[\x{0028}\x{003C}\x{005B}\x{007B}\x{00AB}\x{0F3A}\x{0F3C}\x{169B}\x{2018}\x{201A}\x{201B}\x{201C}\x{201E}\x{201F}\x{2039}\x{2045}\x{207D}\x{208D}\x{2208}\x{2209}\x{220A}\x{2215}\x{223C}\x{2243}\x{2252}\x{2254}\x{2264}\x{2266}\x{2268}\x{226A}\x{226E}\x{2270}\x{2272}\x{2274}\x{2276}\x{2278}\x{227A}\x{227C}\x{227E}\x{2280}\x{2282}\x{2284}\x{2286}\x{2288}\x{228A}\x{228F}\x{2291}\x{2298}\x{22A2}\x{22A6}\x{22A8}\x{22A9}\x{22AB}\x{22B0}\x{22B2}\x{22B4}\x{22B6}\x{22C9}\x{22CB}\x{22D0}\x{22D6}\x{22D8}\x{22DA}\x{22DC}\x{22DE}\x{22E0}\x{22E2}\x{22E4}\x{22E6}\x{22E8}\x{22EA}\x{22EC}\x{22F0}\x{22F2}\x{22F3}\x{22F4}\x{22F6}\x{22F7}\x{2308}\x{230A}\x{2329}\x{23B4}\x{2768}\x{276A}\x{276C}\x{276E}\x{2770}\x{2772}\x{2774}\x{27C3}\x{27C5}\x{27D5}\x{27DD}\x{27E2}\x{27E4}\x{27E6}\x{27E8}\x{27EA}\x{2983}\x{2985}\x{2987}\x{2989}\x{298B}\x{298D}\x{298F}\x{2991}\x{2993}\x{2995}\x{2997}\x{29C0}\x{29C4}\x{29CF}\x{29D1}\x{29D4}\x{29D8}\x{29DA}\x{29F8}\x{29FC}\x{2A2B}\x{2A2D}\x{2A34}\x{2A3C}\x{2A64}\x{2A79}\x{2A7D}\x{2A7F}\x{2A81}\x{2A83}\x{2A8B}\x{2A91}\x{2A93}\x{2A95}\x{2A97}\x{2A99}\x{2A9B}\x{2AA1}\x{2AA6}\x{2AA8}\x{2AAA}\x{2AAC}\x{2AAF}\x{2AB3}\x{2ABB}\x{2ABD}\x{2ABF}\x{2AC1}\x{2AC3}\x{2AC5}\x{2ACD}\x{2ACF}\x{2AD1}\x{2AD3}\x{2AD5}\x{2AEC}\x{2AF7}\x{2AF9}\x{2E02}\x{2E04}\x{2E09}\x{2E0C}\x{2E1C}\x{2E20}\x{3008}\x{300A}\x{300C}\x{300E}\x{3010}\x{3014}\x{3016}\x{3018}\x{301A}\x{301D}\x{FD3E}\x{FE17}\x{FE35}\x{FE37}\x{FE39}\x{FE3B}\x{FE3D}\x{FE3F}\x{FE41}\x{FE43}\x{FE47}\x{FE59}\x{FE5B}\x{FE5D}\x{FF08}\x{FF1C}\x{FF3B}\x{FF5B}\x{FF5F}\x{FF62}]/));
}
;
## method peek_delimiters
sub peek_delimiters {
no warnings 'recursion';
my $self = shift;
my $pos = $self->{'_pos'};
my $startpos = $pos;
my $char = substr($::ORIG,$pos++,1);
if ($char =~ /^\s$/) {
$self->panic("Whitespace character is not allowed as delimiter")}
elsif ($char =~ /^\w$/) {
$self->panic("Alphanumeric character is not allowed as delimiter")}
elsif ($close2open{$char}) {
$self->panic("Use of a closing delimiter for an opener is reserved")}
elsif ($char eq ':') {
$self->panic("Colons may not be used to delimit quoting constructs")};
my $rightbrack = $open2close{$char};
if (not defined $rightbrack) {
return $char, $char};
while (substr($::ORIG,$pos,1) eq $char) {
$pos++}
    ;
my $len = $pos - $startpos;
my $start = $char x $len;
my $stop = $rightbrack x $len;
return $start, $stop;
};
{     package STD::startstop;
    require "mangle.pl";
    our %INSTANTIATED;
    sub __instantiate__ { my $self = shift;
        my ($start, $stop) = @_;
        my $mangle = ::mangle($start, $stop);
        my $mixin = "STD::startstop::" . $mangle;
        return $mixin if $INSTANTIATED{$mixin}++;
        ::deb("         instantiating $mixin") if $::DEBUG & DEBUG::mixins;
        my $eval = "package $mixin" . q{;
	    sub _PARAMS { { '$start' => $start, '$stop' => $stop } }
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
starter: !!perl/hash:RE_ast
  dba: starter
  min: 0
  re: !!perl/hash:RE_var
    min: 0
    var: $start
stopper: !!perl/hash:RE_ast
  dba: stopper
  min: 0
  re: !!perl/hash:RE_var
    min: 0
    var: $stop
RETREE_END
## token starter { $start }
sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter', $retree) }
sub starter {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE starter");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "starter", $C->_EXACT($start));
}
;
## token stopper { $stop }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", $C->_EXACT($stop));
}
;
	};
	eval $eval;
	die $@ if $@;
	return $mixin;
    }
  1; };
{     package STD::stop;
    require "mangle.pl";
    our %INSTANTIATED;
    sub __instantiate__ { my $self = shift;
        my ($stop) = @_;
        my $mangle = ::mangle($stop);
        my $mixin = "STD::stop::" . $mangle;
        return $mixin if $INSTANTIATED{$mixin}++;
        ::deb("         instantiating $mixin") if $::DEBUG & DEBUG::mixins;
        my $eval = "package $mixin" . q{;
	    sub _PARAMS { { '$stop' => $stop } }
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
starter: !!perl/hash:RE_ast
  dba: starter
  min: 0
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      min: 0
      nobind: 1
stopper: !!perl/hash:RE_ast
  dba: stopper
  min: 0
  re: !!perl/hash:RE_var
    min: 0
    var: $stop
RETREE_END
## token starter { <!> }
sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter', $retree) }
sub starter {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE starter");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "starter", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
;
## token stopper { $stop }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", $C->_EXACT($stop));
}
;
	};
	eval $eval;
	die $@ if $@;
	return $mixin;
    }
  1; };
{     package STD::unitstop;
    require "mangle.pl";
    our %INSTANTIATED;
    sub __instantiate__ { my $self = shift;
        my ($stop) = @_;
        my $mangle = ::mangle($stop);
        my $mixin = "STD::unitstop::" . $mangle;
        return $mixin if $INSTANTIATED{$mixin}++;
        ::deb("         instantiating $mixin") if $::DEBUG & DEBUG::mixins;
        my $eval = "package $mixin" . q{;
	    sub _PARAMS { { '$stop' => $stop } }
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
unitstopper: !!perl/hash:RE_ast
  dba: unitstopper
  min: 0
  re: !!perl/hash:RE_var
    min: 0
    var: $stop
RETREE_END
## token unitstopper { $stop }
sub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper', $retree) }
sub unitstopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unitstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unitstopper", $C->_EXACT($stop));
}
	};
	eval $eval;
	die $@ if $@;
	return $mixin;
    }
  1; };
## token unitstopper { $ }
sub unitstopper__PEEK { $_[0]->_AUTOLEXpeek('unitstopper', $retree) }
sub unitstopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unitstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unitstopper", $C->_PATTERN(qr/\G\z/));
}
;
## method balanced ($start,$stop)
sub balanced {
no warnings 'recursion';
my $self = shift;
die 'Required argument start omitted' unless @_;
my $start = @_ ? shift() : undef;
die 'Required argument stop omitted' unless @_;
my $stop = @_ ? shift() : undef;
$self->mixin( STD::startstop->__instantiate__($start,$stop) )};
## method unbalanced ($stop)
sub unbalanced {
no warnings 'recursion';
my $self = shift;
die 'Required argument stop omitted' unless @_;
my $stop = @_ ? shift() : undef;
$self->mixin( STD::stop->__instantiate__($stop) )};
## method unitstop ($stop)
sub unitstop {
no warnings 'recursion';
my $self = shift;
die 'Required argument stop omitted' unless @_;
my $stop = @_ ? shift() : undef;
$self->mixin( STD::unitstop->__instantiate__($stop) )};
## method truly ($bool,$opt)
sub truly {
no warnings 'recursion';
my $self = shift;
die 'Required argument bool omitted' unless @_;
my $bool = @_ ? shift() : undef;
die 'Required argument opt omitted' unless @_;
my $opt = @_ ? shift() : undef;
return $self if $bool;
$self->sorry("Can't negate $opt adverb");
$self;
};
## token charname {
sub charname__PEEK { $_[0]->_AUTOLEXpeek('charname', $retree) }
sub charname {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE charname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "charname", do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'charname_0') {
        $C->deb("Fate passed to charname_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT charname_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM charname_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'charname_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("charname_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['radint'], sub {
my $C = shift;
$C->radint
})
},
sub {
my $C=shift;
if (my ($C) = (do {
if (my ($C) = ($C->_PATTERN(qr/\G[a-zA-Z]/))) {
LazyMap::lazymap(sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G[a-zA-Z)]/))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s*+[\],\#]/)
}))) { ($C) } else { () }
}))) {
$C
} else { () }
},
$C->_STARf(sub {
my $C=shift;
$C->_PATTERN(qr/\G[^\],\#]/)
}))
} else { () }
})) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = (do {
if (my ($C) = ($C->sorry("Unrecognized character name"))) {
LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->terminator)) { ($C) } else { () }
}))) { ($C) } else { () }
},
$C->_SCANf())
} else { () }
})) { ($C) } else { () }
}
};
@gather;
});
}
;
## token charnames { [<.ws><charname><.ws>] ** ',' }
sub charnames__PEEK { $_[0]->_AUTOLEXpeek('charnames', $retree) }
sub charnames {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE charnames");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'charname'} = [];
$self->_MATCHIFYr($S, "charnames", $C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\,")
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['charname'], sub {
my $C = shift;
$C->charname
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}));
}
;
## token charspec {
sub charspec__PEEK { $_[0]->_AUTOLEXpeek('charspec', $retree) }
sub charspec {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE charspec");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "charspec", $C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'charspec_0') {
        $C->deb("Fate passed to charspec_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT charspec_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM charspec_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'charspec_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("charspec_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['charnames'], sub {
my $C = shift;
$C->charnames
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'character name', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G[?-Z\\-_]/)
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
$C
}))
and ($C) = ($C->sorry("Unrecognized \\c character"))) {
$C->cursor_incr()
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}));
}
;
## token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE backslash');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'backslash') {
                $C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT backslash';
            }
            else {
                $x = 'ALTLTM backslash';
            }
        }
        else {
            $x = 'ALTLTM backslash';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'backslash:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "backslash", @gather);
    };
    @result;
}
;
## token escape { <...> }
sub escape__PEEK { $_[0]->_AUTOLEXpeek('escape:*',$retree); }
sub escape {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE escape');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'escape') {
                $C->deb("Fate passed to escape: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT escape';
            }
            else {
                $x = 'ALTLTM escape';
            }
        }
        else {
            $x = 'ALTLTM escape';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD', 'escape:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("escape trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "escape", @gather);
    };
    @result;
}
;
## token starter { <!> }
sub starter__PEEK { $_[0]->_AUTOLEXpeek('starter', $retree) }
sub starter {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE starter");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "starter", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
;
## token escape:none { <!> }
sub escape__S_048none__PEEK { $_[0]->_AUTOLEXpeek('escape__S_048none', $retree) }
sub escape__S_048none {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_048none");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "none";
$self->_MATCHIFYr($S, "escape__S_048none", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
;
## method nibble ($lang)
sub nibble {
no warnings 'recursion';
my $self = shift;
die 'Required argument lang omitted' unless @_;
my $lang = @_ ? shift() : undef;
$self->cursor_fresh($lang)->nibbler};
## token nibbler {
sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler', $retree) }
sub nibbler {
no warnings 'recursion';
my $self = shift;

my $text = '';
my $from = $self->{'_pos'};
my $to = $from;
my @nibbles = ();
my $multiline = 0;
my $nibble;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE nibbler");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'escape'} = [];
$C->{'nibbler'} = [];
$C->{'starter'} = [];
$C->{'stopper'} = [];
$self->_MATCHIFYr($S, "nibbler", do {
my $C = $C;
if (($C) = (scalar(do {
my $M = $C;
$M->{'_from'} = $self->{'_pos'}}, $C))
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'stopper'} = [];
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))
and ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))
and ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
scalar(do {
my $M = $C;
{
push @nibbles, $C->makestr(TEXT => $text, _from => $from, _pos => $to ) if $from != $to;
my $n = $M->{'nibbler'}->[-1]->{'nibbles'};
my @n = @$n;
push @nibbles, $M->{'starter'};
push @nibbles, @n;
push @nibbles, $M->{'stopper'};
$text = '';
$to = $from = $C->{'_pos'};
}}, $C)
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['escape'], sub {
my $C = shift;
$C->escape
}))) {
scalar(do {
my $M = $C;
{
push @nibbles, $C->makestr(TEXT => $text, _from => $from, _pos => $to ) if $from != $to;
push @nibbles, $M->{'escape'}->[-1];
$text = '';
$to = $from = $C->{'_pos'};
}}, $C)
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->cursor_incr())) {
scalar(do {
{
my $ch = substr($::ORIG, $C->{'_pos'}-1, 1);
$text .= $ch;
$to = $C->{'_pos'};
if ($ch =~ "\n") {
$multiline++};
}}, $C)
} else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
{
push @nibbles, $C->makestr(TEXT => $text, _from => $from, _pos => $to ) if $from != $to or !@nibbles;
$M->{'nibbles'} = \@nibbles;
$M->{'_pos'} = $C->{'_pos'};
delete $M->{'nibbler'};
delete $M->{'escape'};
delete $M->{'starter'};
delete $M->{'stopper'};
$::LAST_NIBBLE = $C;
$::LAST_NIBBLE_MULTILINE = $C if $multiline;
}}, $C)
} else { () }
});
}
;
## token babble ($l) {
sub babble__PEEK { $_[0]->_AUTOLEXpeek('babble', $retree) }
sub babble {
no warnings 'recursion';
my $self = shift;

die 'Required argument l omitted' unless @_;
my $l = @_ ? shift() : undef;
my $lang = $l;
my $start;
my $stop;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE babble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'quotepair'} = [];
$self->_MATCHIFYr($S, "babble", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
my $kv = $M->{'quotepair'}->[-1];
$lang = ($lang->tweak($kv->{'k'}, $kv->{'v'})
                or $lang->sorry("Unrecognized adverb :" . $kv->{'k'} . '(' . $kv->{'v'} . ')'));
}, $C)
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
($start,$stop) = $C->peek_delimiters();
$lang = $start ne $stop ? $lang->balanced($start,$stop)
                                : $lang->unbalanced($stop);
$M->{'B'} = [$lang,$start,$stop];
}, $C)
} else { () }
});
}
;
our @herestub_queue;
{ package STD::Herestub;
use Moose ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

moose_has 'delim' => (isa => 'Str', is => 'rw');
moose_has 'orignode' => (is => 'rw');
moose_has 'lang' => (is => 'rw');
  1; };
{ package STD::herestop;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
stopper: !!perl/hash:RE_ast
  dba: stopper
  min: 0
  re: !!perl/hash:RE_sequence
    min: 0
    zyg:
    - !!perl/hash:RE_meta
      min: 0
      text: ^^
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_paren
        min: 0
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \h
          min: 0
          quant:
          - '*'
      min: 0
    - !!perl/hash:RE_var
      min: 0
      var: $::DELIM
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      min: 0
      quant:
      - '*'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: unv
        rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_meta
      min: 0
      text: $$
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \v
      min: 0
      quant:
      - '?'
RETREE_END
## token stopper { ^^ {} $<ws>=(\h*?) $*DELIM \h* <.unv>?? $$ \v? }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?m:^)/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['ws'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_STARf(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]/)
})

})
}))
and ($C) = ($C->_EXACT($::DELIM))
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))) {
LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?m:$)\n?+/)
},
$C->_OPTf(sub {
my $C=shift;
if (my ($C) = ($C->unv)) { ($C) } else { () }
}))
} else { () }
});
}
  1; };
## method heredoc ()
sub heredoc {
no warnings 'recursion';
my $self = shift;
local $::CTX = $self->callm if $::DEBUG & DEBUG::trace_call;
my $here = $self;
while (my $herestub = shift @herestub_queue) {
local $::DELIM = $herestub->delim;
my $lang = $herestub->lang->mixin( 'STD::herestop' );
my $doc;
if (($doc) = $here->nibble($lang)) {
$here = $doc->trim_heredoc();
$herestub->orignode->{'doc'} = $doc;
}
else {
$self->panic("Ending delimiter $::DELIM not found")};
}
    ;
return $self->cursor($here->{'_pos'});
};
## token quibble ($l) {
sub quibble__PEEK { $_[0]->_AUTOLEXpeek('quibble', $retree) }
sub quibble {
no warnings 'recursion';
my $self = shift;

die 'Required argument l omitted' unless @_;
my $l = @_ ? shift() : undef;
my ($lang, $start, $stop);

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quibble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "quibble", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))
and ($C) = (scalar(do {
my $M = $C;
my $B = $M->{'babble'}->{'B'};
($lang,$start,$stop) = @$B;
}, $C))
and ($C) = ($C->_EXACT($start))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($lang)
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_EXACT($stop))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Couldn't find terminator $stop"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
scalar(do {
my $M = $C;
{
if ($lang->{'_herelang'}) {
push @herestub_queue,
                'STD::Herestub'->new(
                    delim => $M->{'nibble'}->{'nibbles'}->[0]->{'TEXT'},
                    orignode => $C,
                    lang => $lang->{'_herelang'},
                )}}}, $C)
} else { () }
});
}
;
## token quotepair {
sub quotepair__PEEK { $_[0]->_AUTOLEXpeek('quotepair', $retree) }
sub quotepair {
no warnings 'recursion';
my $self = shift;

my $key;
my $value;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quotepair");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'circumfix'} = [];
$self->_MATCHIFYr($S, "quotepair", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'quotepair_0') {
        $C->deb("Fate passed to quotepair_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT quotepair_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM quotepair_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'quotepair_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("quotepair_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\!"))
and ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Argument not allowed on negated pair"))) {
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
$key = $M->{'identifier'}->Str;
$value = 0;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = (scalar(do {
my $M = $C;
$key = $M->{'identifier'}->Str}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
}))) {
scalar(do {
my $M = $C;
$value = $M->{'circumfix'}}, $C)
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$value = 1}, $C)
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['n'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))
and ($C) = ($C->_SUBSUMEr(['id'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G(?:[a-z])++/)

})
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("2nd argument not allowed on pair"))) {
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
$key = $M->{'id'}->Str;
$value = $M->{'n'}->Str;
}, $C)
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
scalar(do {
my $M = $C;
$M->{'k'} = $key;
$M->{'v'} = $value;
}, $C)
} else { () }
});
}
;
## token quote:sym<' '>   { :dba('single quotes') "'" ~ "'" <nibble($¢.cursor_fresh( %*LANG<Q> ).tweak(
sub quote__S_049Single_Single__PEEK { $_[0]->_AUTOLEXpeek('quote__S_049Single_Single', $retree) }
sub quote__S_049Single_Single {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_049Single_Single");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\'\ \'";
$self->_MATCHIFYr($S, "quote__S_049Single_Single", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\'";
my $goalpos = $C;
my $newlang = $C->unbalanced($::GOAL);
$C = bless($C, (ref($newlang) || $newlang))
;

if (($C) = ($C->_EXACT("\'"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->unbalanced("'"))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\'")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'single quotes', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token quote:sym<" ">   { :dba('double quotes') '"' ~ '"' <nibble($¢.cursor_fresh( %*LANG<Q> ).tweak(
sub quote__S_050Double_Double__PEEK { $_[0]->_AUTOLEXpeek('quote__S_050Double_Double', $retree) }
sub quote__S_050Double_Double {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_050Double_Double");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\"\ \"";
$self->_MATCHIFYr($S, "quote__S_050Double_Double", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\"";
my $goalpos = $C;
my $newlang = $C->unbalanced($::GOAL);
$C = bless($C, (ref($newlang) || $newlang))
;

if (($C) = ($C->_EXACT("\""))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->unbalanced('"'))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\"")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'double quotes', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token circumfix:sym<« »>   { :dba('shell-quote words') '«' ~ '»' <nibble($¢.cursor_fresh( %*LANG<Q> 
sub circumfix__S_051Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_051Fre_Nch', $retree) }
sub circumfix__S_051Fre_Nch {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_051Fre_Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "«\ »";
$self->_MATCHIFYr($S, "circumfix__S_051Fre_Nch", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "»";
my $goalpos = $C;
my $newlang = $C->unbalanced($::GOAL);
$C = bless($C, (ref($newlang) || $newlang))
;

if (($C) = ($C->_EXACT("«"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('«','»'))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("»")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'shell-quote words', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token circumfix:sym«<< >>» { :dba('shell-quote words') '<<' ~ '>>' <nibble($¢.cursor_fresh( %*LANG<Q
sub circumfix__S_052LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_052LtLt_GtGt', $retree) }
sub circumfix__S_052LtLt_GtGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_052LtLt_GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\<\ \>\>";
$self->_MATCHIFYr($S, "circumfix__S_052LtLt_GtGt", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\>\>";
my $goalpos = $C;
my $newlang = $C->unbalanced($::GOAL);
$C = bless($C, (ref($newlang) || $newlang))
;

if (($C) = ($C->_EXACT("\<\<"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('<<','>>'))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\>\>")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'shell-quote words', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token circumfix:sym«< >»   { :dba('quote words') '<' ~ '>'
sub circumfix__S_053Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_053Lt_Gt', $retree) }
sub circumfix__S_053Lt_Gt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_053Lt_Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\ \>";
$self->_MATCHIFYr($S, "circumfix__S_053Lt_Gt", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\>";
my $goalpos = $C;
my $newlang = $C->unbalanced($::GOAL);
$C = bless($C, (ref($newlang) || $newlang))
;

if (($C) = ($C->_EXACT("\<"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("STDIN\>")
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('<STDIN>', '$' . '*IN.lines'))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('<>', "lines() to read input,\n  or ('') to represent the null string,\n  or () to represent Nil"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->tweak('w' => 1)->balanced('<','>'))
})
} else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\>")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'quote words', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token ws {
sub ws__PEEK { $_[0]->_AUTOLEXpeek('ws', $retree) }
sub ws {
no warnings 'recursion';
my $self = shift;

my @stub = return $self if exists $::MEMOS[$self->{'_pos'}]->{'ws'};
my $startpos = $self->{'_pos'};
local $::HIGHEXPECT = {
};

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE ws");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "ws", do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_0') {
        $C->deb("Fate passed to ws_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT ws_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM ws_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'ws_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("ws_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]++/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\#\s\\]/)
}))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'ws'} = $startpos}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->after(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?<=\w)/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_COMMITRULE())
and ($C) = (scalar(do {
delete $::MEMOS[$startpos]->{'ws'}}, $C))
and ($C) = ($C->sorry("Whitespace is required between alphanumeric tokens"))) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_1') {
        $C->deb("Fate passed to ws_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT ws_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM ws_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'ws_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("ws_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->vws)
and ($C) = ($C->heredoc)) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->unv)) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
scalar(do {
$C->moreinput }, $C)
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
}))) {
scalar(do {
{
if (($C->{'_pos'} == $startpos)) {
delete $::MEMOS[$C->{'_pos'}]->{'ws'}}
else {
$::MEMOS[$C->{'_pos'}]->{'ws'} = $startpos;
$::MEMOS[$C->{'_pos'}]->{'endstmt'} = $::MEMOS[$startpos]->{'endstmt'}
                if exists $::MEMOS[$startpos]->{'endstmt'};
}}}, $C)
} else { () }
}
};
@gather;
});
}
;
## token unsp {
sub unsp__PEEK { $_[0]->_AUTOLEXpeek('unsp', $retree) }
sub unsp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unsp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unsp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'unsp_0') {
        $C->deb("Fate passed to unsp_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT unsp_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM unsp_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'unsp_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("unsp_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\#")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'unsp_1') {
        $C->deb("Fate passed to unsp_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT unsp_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM unsp_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'unsp_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("unsp_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->vws)) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->unv)) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G\z/))) {
scalar(do {
$C->moreinput }, $C)
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token vws {
sub vws__PEEK { $_[0]->_AUTOLEXpeek('vws', $retree) }
sub vws {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE vws");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "vws", $C->_PLUSr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'vws_0') {
        $C->deb("Fate passed to vws_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT vws_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM vws_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'vws_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("vws_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\n/)
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\#DEBUG\ \-1"))
and ($C) = (scalar(do {
say "DEBUG";
$::DEBUG = -1;
}, $C))) {
$C->_PATTERN(qr/\G[^\n]*+\n/)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\<\<\<\<\<\<\<"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G\n\=\=\=\=\=\=\=/)
},
$C->_SCANf())
}))) {
LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G\n\>\>\>\>\>\>\>/)
},
$C->_SCANf())
} else { () }
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry('Found a version control conflict marker'))) {
$C->_PATTERN(qr/\G[^\n]*+\n/)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = (do {
my $C = $C;
if (($C) = ($C->_EXACT("\=\=\=\=\=\=\="))
and ($C) = ($C->_COMMITLTM())) {
LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G\n\>\>\>\>\>\>\>[^\n]*+\n/)
},
$C->_SCANf())
} else { () }
})) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})
}))) { ($C) } else { () }
}));
}
;
## method moreinput ()
sub moreinput {
no warnings 'recursion';
my $self = shift;
$::moreinput->() if $::moreinput;
$self;
};
## token unv {
sub unv__PEEK { $_[0]->_AUTOLEXpeek('unv', $retree) }
sub unv {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unv");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unv", $C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'unv_0') {
        $C->deb("Fate passed to unv_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT unv_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM unv_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'unv_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("unv_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]++/)
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+\=/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'unv_1') {
        $C->deb("Fate passed to unv_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT unv_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM unv_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'unv_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("unv_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
},
sub {
my $C=shift;
$C->_EXACT("\\")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->_PATTERN(qr/\G(?m:^)/))
and ($C) = ($C->pod_comment)) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))) {
$C->_SUBSUMEr(['comment'], sub {
my $C = shift;
$C->comment
})
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}));
}
;
## token comment:sym<#`(...)> {
sub comment__S_054SharpGraveParenDotDotDotThesis__PEEK { $_[0]->_AUTOLEXpeek('comment__S_054SharpGraveParenDotDotDotThesis', $retree) }
sub comment__S_054SharpGraveParenDotDotDotThesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE comment__S_054SharpGraveParenDotDotDotThesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\#\`\(\.\.\.\)";
$self->_MATCHIFYr($S, "comment__S_054SharpGraveParenDotDotDotThesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\#\`"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->opener)) { ($C) } else { () }
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Opening bracket is required for #` comment"))) { ($C) } else { () }
}
};
@gather;
}
}))
and ($C) = ($C->quibble($C->cursor_fresh( $::LANG{'Q'} )))) {
$C
} else { () }
});
}
;
## token comment:sym<#(...)> {
sub comment__S_055SharpParenDotDotDotThesis__PEEK { $_[0]->_AUTOLEXpeek('comment__S_055SharpParenDotDotDotThesis', $retree) }
sub comment__S_055SharpParenDotDotDotThesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE comment__S_055SharpParenDotDotDotThesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\#\(\.\.\.\)";
$self->_MATCHIFYr($S, "comment__S_055SharpParenDotDotDotThesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\#"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->opener)) { ($C) } else { () }
}))
and ($C) = ($C->suppose(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} ))
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?:[,;:])*+[\x20\t\r]*+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'comment__S_055SharpParenDotDotDotThesis_0') {
        $C->deb("Fate passed to comment__S_055SharpParenDotDotDotThesis_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT comment__S_055SharpParenDotDotDotThesis_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM comment__S_055SharpParenDotDotDotThesis_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'comment__S_055SharpParenDotDotDotThesis_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("comment__S_055SharpParenDotDotDotThesis_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\#")
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G(?m:$)/)
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))) {
$C
} else { () }
};
}))
and ($C) = ($C->worry("Embedded comment seems to be missing backtick"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) {
$C
} else { () }
});
}
;
## token comment:sym<#=(...)> {
sub comment__S_056SharpEqualParenDotDotDotThesis__PEEK { $_[0]->_AUTOLEXpeek('comment__S_056SharpEqualParenDotDotDotThesis', $retree) }
sub comment__S_056SharpEqualParenDotDotDotThesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE comment__S_056SharpEqualParenDotDotDotThesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\#\=\(\.\.\.\)";
$self->_MATCHIFYr($S, "comment__S_056SharpEqualParenDotDotDotThesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\#\="))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->opener)) { ($C) } else { () }
}))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} ))
})
} else { () }
});
}
;
## token comment:sym<#=> {
sub comment__S_057SharpEqual__PEEK { $_[0]->_AUTOLEXpeek('comment__S_057SharpEqual', $retree) }
sub comment__S_057SharpEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE comment__S_057SharpEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\#\=";
$self->_MATCHIFYr($S, "comment__S_057SharpEqual", do {
my $C = $C;
if (($C) = ($C->_EXACT("\#\="))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['attachment'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
})
})
} else { () }
});
}
;
## token comment:sym<#> {
sub comment__S_058Sharp__PEEK { $_[0]->_AUTOLEXpeek('comment__S_058Sharp', $retree) }
sub comment__S_058Sharp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE comment__S_058Sharp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\#";
$self->_MATCHIFYr($S, "comment__S_058Sharp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\#"))
and ($C) = (scalar(do {
}, $C))) {
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }
});
}
;
## token ident {
sub ident__PEEK { $_[0]->_AUTOLEXpeek('ident', $retree) }
sub ident {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE ident");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "ident", $C->_PATTERN(qr/\G[_[:alpha:]]\w*+/));
}
;
## token apostrophe {
sub apostrophe__PEEK { $_[0]->_AUTOLEXpeek('apostrophe', $retree) }
sub apostrophe {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE apostrophe");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "apostrophe", $C->_PATTERN(qr/\G['\-]/));
}
;
## token identifier {
sub identifier__PEEK { $_[0]->_AUTOLEXpeek('identifier', $retree) }
sub identifier {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE identifier");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "identifier", do {
if (my ($C) = ($C->ident)) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->apostrophe)
and ($C) = ($C->ident)) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token pod_comment {
sub pod_comment__PEEK { $_[0]->_AUTOLEXpeek('pod_comment', $retree) }
sub pod_comment {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE pod_comment");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "pod_comment", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?m:^)[\x20\t\r]*+\=/))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'pod_comment_0') {
        $C->deb("Fate passed to pod_comment_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT pod_comment_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM pod_comment_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'pod_comment_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("pod_comment_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\Gbegin[\x20\t\r]++/))
and ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\n"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+\=/))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_PATTERN(qr/\Gend[\x20\t\r]++/))
and ($C) = ($C->_BACKREFn('identifier'))
and ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }
}))) {
$C
} else { () }
},
$C->_SCANf()))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'identifier'}->Str eq 'END'})
}))) {
$C->_STARr(sub {
my $C=shift;
$C->cursor_incr()
})
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
my $M = $C;
my $id = $M->{'identifier'}->Str;
$self->panic("=begin $id without matching =end $id");
}, $C)
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\Gbegin\b/))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G(?m:$)/)
}
or $xact->[-2] or
do {
push @gather, $C->_EXACT("\#")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Unrecognized token after =begin"))) {
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }
}
};
@gather;
}
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\n"))
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+\=/))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_PATTERN(qr/\Gend\b/))) {
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }
},
$C->_SCANf()))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$self->panic("=begin without matching =end")}, $C)
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\Gfor\b/))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
}
or $xact->[-2] or
do {
push @gather, $C->_PATTERN(qr/\G(?m:$)/)
}
or $xact->[-2] or
do {
push @gather, $C->_EXACT("\#")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Unrecognized token after =for"))) {
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }
}
};
@gather;
}
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?m:^)[\x20\t\r]*+(?m:$)/)
},
$C->_SCANf()))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, $C->_STARr(sub {
my $C=shift;
$C->cursor_incr()
})
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_COMMITLTM())
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?m:^)\=cut\b/)
},
$C->_SCANf()))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Obsolescent pod format, please use =begin/=end instead"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G[_[:alpha:]]/)
}
or $xact->[-2] or
do {
push @gather, $C->_PATTERN(qr/\G\s/)
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Illegal pod directive"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C->_STARr(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token embeddedblock {
sub embeddedblock__PEEK { $_[0]->_AUTOLEXpeek('embeddedblock', $retree) }
sub embeddedblock {
no warnings 'recursion';
my $self = shift;

local %::LANG = %::LANG;
local $::SIGNUM;
local $::GOAL = '}';
local $::CURPAD = $::CURPAD;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE embeddedblock");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "embeddedblock", do {
my $C = $C;
if (($C) = ($C->newpad)
and ($C) = ($C->finishpad)
and ($C) = ($C->_EXACT("\{"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
;

$C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unable to parse statement list; couldn't find right brace"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## token binints { [<.ws><binint><.ws>] ** ',' }
sub binints__PEEK { $_[0]->_AUTOLEXpeek('binints', $retree) }
sub binints {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE binints");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'binint'} = [];
$self->_MATCHIFYr($S, "binints", $C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\,")
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['binint'], sub {
my $C = shift;
$C->binint
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}));
}
;
## token binint {
sub binint__PEEK { $_[0]->_AUTOLEXpeek('binint', $retree) }
sub binint {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE binint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "binint", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?:[0-1])++/))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G_(?:[0-1])++/)
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token octints { [<.ws><octint><.ws>] ** ',' }
sub octints__PEEK { $_[0]->_AUTOLEXpeek('octints', $retree) }
sub octints {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE octints");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'octint'} = [];
$self->_MATCHIFYr($S, "octints", $C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\,")
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}));
}
;
## token octint {
sub octint__PEEK { $_[0]->_AUTOLEXpeek('octint', $retree) }
sub octint {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE octint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "octint", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?:[0-7])++/))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G_(?:[0-7])++/)
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token hexints { [<.ws><hexint><.ws>] ** ',' }
sub hexints__PEEK { $_[0]->_AUTOLEXpeek('hexints', $retree) }
sub hexints {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE hexints");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'hexint'} = [];
$self->_MATCHIFYr($S, "hexints", $C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\,")
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}));
}
;
## token hexint {
sub hexint__PEEK { $_[0]->_AUTOLEXpeek('hexint', $retree) }
sub hexint {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE hexint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "hexint", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?:[0-9a-fA-F])++/))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G_(?:[0-9a-fA-F])++/)
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token decints { [<.ws><decint><.ws>] ** ',' }
sub decints__PEEK { $_[0]->_AUTOLEXpeek('decints', $retree) }
sub decints {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE decints");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'decint'} = [];
$self->_MATCHIFYr($S, "decints", $C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\,")
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}));
}
;
## token decint {
sub decint__PEEK { $_[0]->_AUTOLEXpeek('decint', $retree) }
sub decint {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE decint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "decint", do {
if (my ($C) = ($C->_PATTERN(qr/\G\d++/))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G_\d++/)
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token integer {
sub integer__PEEK { $_[0]->_AUTOLEXpeek('integer', $retree) }
sub integer {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE integer");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "integer", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_0') {
        $C->deb("Fate passed to integer_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT integer_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM integer_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'integer_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("integer_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("0"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_1') {
        $C->deb("Fate passed to integer_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT integer_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM integer_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'integer_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("integer_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("b"))) {
$C->_SUBSUMEr(['binint'], sub {
my $C = shift;
$C->binint
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("o"))) {
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("x"))) {
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("d"))) {
$C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$C->worry("Leading 0 does not indicate octal in Perl 6") })
}))) { ($C) } else { () }
}))) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\."))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'terminator'} = [];
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'integer_2') {
        $C->deb("Fate passed to integer_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT integer_2';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM integer_2'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'integer_2', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("integer_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Decimal point must be followed by digit"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G__++\d/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Only isolated underscores are allowed inside numbers"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token radint {
sub radint__PEEK { $_[0]->_AUTOLEXpeek('radint', $retree) }
sub radint {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE radint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "radint", $C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'radint_0') {
        $C->deb("Fate passed to radint_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT radint_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM radint_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'radint_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("radint_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['integer'], sub {
my $C = shift;
$C->integer
})
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\:\d/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['rad_number'], sub {
my $C = shift;
$C->rad_number
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
defined $M->{'rad_number'}->{'intpart'}
                        and
                        not defined $M->{'rad_number'}->{'fracpart'}
                    })
}))) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}));
}
;
## token escale {
sub escale__PEEK { $_[0]->_AUTOLEXpeek('escale', $retree) }
sub escale {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escale");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "escale", do {
if (my ($C) = ($C->_PATTERN(qr/\G[Ee](?:[+\-])?+/))) {
$C->_SUBSUMEr(['decint'], sub {
my $C = shift;
$C->decint
})
} else { () }
});
}
;
## token dec_number {
sub dec_number__PEEK { $_[0]->_AUTOLEXpeek('dec_number', $retree) }
sub dec_number {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE dec_number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'escale'} = [];
$self->_MATCHIFYr($S, "dec_number", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'dec_number_0') {
        $C->deb("Fate passed to dec_number_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT dec_number_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM dec_number_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'dec_number_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("dec_number_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\."))) {
$C->_SUBSUMEr(['frac'], sub {
my $C = shift;
$C->decint
})
} else { () }
})
}))) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['int'], sub {
my $C = shift;
$C->decint
}))
and ($C) = ($C->_EXACT("\."))) {
$C->_SUBSUMEr(['frac'], sub {
my $C = shift;
$C->decint
})
} else { () }
})
}))) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_SUBSUMEr(['int'], sub {
my $C = shift;
$C->decint
})
})
}))) {
$C->_SUBSUMEr(['escale'], sub {
my $C = shift;
$C->escale
})
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\.\d/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Number contains two decimal points (missing 'v' for version number?)"))) {
$C->_PLUSr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\.\d++/)
}))) { ($C) } else { () }
})
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G__++\d/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Only isolated underscores are allowed inside numbers"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token alnumint {
sub alnumint__PEEK { $_[0]->_AUTOLEXpeek('alnumint', $retree) }
sub alnumint {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE alnumint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "alnumint", $C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G(?:[0-9a-zA-Z])++/))) {
$C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G_(?:[0-9a-zA-Z])++/)
}))) { ($C) } else { () }
})
} else { () }
}));
}
;
## token rad_number {
sub rad_number__PEEK { $_[0]->_AUTOLEXpeek('rad_number', $retree) }
sub rad_number {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE rad_number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'base'} = [];
$C->{'exp'} = [];
$self->_MATCHIFYr($S, "rad_number", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_SUBSUMEr(['radix'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)
})
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("\<"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'rad_number_0') {
        $C->deb("Fate passed to rad_number_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT rad_number_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM rad_number_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD', 'rad_number_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("rad_number_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\."))) {
$C->_SUBSUMEr(['frac'], sub {
my $C = shift;
$C->alnumint
})
} else { () }
})
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['int'], sub {
my $C = shift;
$C->alnumint
}))
and ($C) = ($C->_EXACT("\."))) {
$C->_SUBSUMEr(['frac'], sub {
my $C = shift;
$C->alnumint
})
} else { () }
})
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['coeff'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_SUBSUMEr(['int'], sub {
my $C = shift;
$C->alnumint
})
})
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\*"))
and ($C) = ($C->_SUBSUMEr(['base'], sub {
my $C = shift;
$C->radint
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_EXACT("\*\*"))) {
$C->_SUBSUMEr(['exp'], sub {
my $C = shift;
$C->radint
})
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Base is missing ** exponent part"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_EXACT("\>")
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\[")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed radix number"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## token terminator:sym<)>
sub terminator__S_059Thesis__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_059Thesis', $retree) }
sub terminator__S_059Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_059Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\)";
$self->_MATCHIFYr($S, "terminator__S_059Thesis", do {
if (my ($C) = ($C->_EXACT("\)"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }
});
}
;
## token terminator:sym<]>
sub terminator__S_060Ket__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_060Ket', $retree) }
sub terminator__S_060Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_060Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\]";
$self->_MATCHIFYr($S, "terminator__S_060Ket", do {
if (my ($C) = ($C->_EXACT("\]"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }
});
}
;
## token terminator:sym<}>
sub terminator__S_061Ly__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_061Ly', $retree) }
sub terminator__S_061Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_061Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\}";
$self->_MATCHIFYr($S, "terminator__S_061Ly", do {
if (my ($C) = ($C->_EXACT("\}"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }
});
}
;
{ package STD::P6;
use Moose ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc
moose_extends('STD');

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
POST: !!perl/hash:RE_ast
  dba: postfix
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        min: 12345
        name: stdstopper
        rest: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_block
        min: 0
        nobind: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 1
        re: &1 !!perl/hash:RE_any
          altname: POST_0
          dba: POST
          min: 1
          zyg:
          - !!perl/hash:RE_method
            alt: POST_0 0
            min: 12345
            name: unsp
            rest: ''
          - !!perl/hash:RE_string
            alt: POST_0 1
            i: 0
            min: 1
            text: \
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 1
              re: !!perl/hash:RE_sequence
                min: 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: .
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: unsp
                    rest: ''
                  min: 0
                  quant:
                  - '?'
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_method
            min: 12345
            name: postfix_prefix_meta_operator
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              min: 12345
              name: unsp
              rest: ''
            min: 0
            quant:
            - '?'
      min: 0
      quant:
      - '*'
    - !!perl/hash:RE_bracket
      min: 12345
      re: &2 !!perl/hash:RE_any
        altname: POST_1
        dba: postfix
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          alt: POST_1 0
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: dotty
            rest: ''
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          alt: POST_1 1
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: privop
            rest: ''
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          alt: POST_1 2
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: postop
            rest: ''
          - !!perl/hash:RE_block
            min: 0
    - !!perl/hash:RE_block
      min: 0
POST_0: *1
POST_1: *2
PRE: !!perl/hash:RE_ast
  dba: prefix or meta-prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_bracket
      min: 12345
      re: &3 !!perl/hash:RE_any
        altname: PRE_0
        dba: prefix or meta-prefix
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          alt: PRE_0 0
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: prefix
            rest: ''
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          alt: PRE_0 1
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: prefix_circumfix_meta_operator
            rest: ''
          - !!perl/hash:RE_block
            min: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: prefix_postfix_meta_operator
        rest: ''
      min: 0
      quant:
      - '*'
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
PRE_0: *3
arglist: !!perl/hash:RE_ast
  dba: argument list
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 0
      re: &4 !!perl/hash:RE_any
        altname: arglist_0
        dba: argument list
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          alt: arglist_0 0
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method
            min: 12345
            name: stdstopper
            rest: ''
        - !!perl/hash:RE_sequence
          alt: arglist_0 1
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: EXPR
            rest: 1
          - !!perl/hash:RE_block
            min: 0
arglist_0: *4
args: !!perl/hash:RE_ast
  dba: 'extra arglist after (...):'
  min: 0
  re: !!perl/hash:RE_sequence
    min: 0
    zyg:
    - !!perl/hash:RE_bracket
      min: 0
      re: &5 !!perl/hash:RE_any
        altname: args_0
        dba: argument list
        min: 0
        zyg:
        - !!perl/hash:RE_bracket
          alt: args_0 0
          min: 12347
          re: !!perl/hash:RE_sequence
            min: 12347
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: (
            - !!perl/hash:RE_block
              min: 0
            - !!perl/hash:RE_method
              min: 12345
              name: semiarglist
              rest: ''
            - !!perl/hash:RE_bracket
              min: 1
              re: !!perl/hash:RE_first
                min: 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: )
                - !!perl/hash:RE_method
                  min: 12345
                  name: FAILGOAL
                  rest: 1
        - !!perl/hash:RE_sequence
          alt: args_0 1
          min: 24692
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: unsp
            rest: ''
          - !!perl/hash:RE_bracket
            min: 12347
            re: !!perl/hash:RE_sequence
              min: 12347
              zyg:
              - !!perl/hash:RE_string
                i: 0
                min: 1
                text: (
              - !!perl/hash:RE_block
                min: 0
              - !!perl/hash:RE_method
                min: 12345
                name: semiarglist
                rest: ''
              - !!perl/hash:RE_bracket
                min: 1
                re: !!perl/hash:RE_first
                  min: 1
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: )
                  - !!perl/hash:RE_method
                    min: 12345
                    name: FAILGOAL
                    rest: 1
        - !!perl/hash:RE_sequence
          alt: args_0 2
          min: 0
          zyg:
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 24690
              re: !!perl/hash:RE_sequence
                min: 24690
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_meta
                      min: 1
                      text: \s
                - !!perl/hash:RE_assertion
                  assert: '!'
                  min: 0
                  re: !!perl/hash:RE_block
                    min: 0
                    nobind: 1
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_assertion
                  assert: '!'
                  min: 0
                  re: !!perl/hash:RE_method
                    min: 12345
                    name: infixstopper
                    rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: arglist
                  rest: ''
            min: 0
            quant:
            - '?'
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_block
            min: 0
            nobind: 1
        - !!perl/hash:RE_sequence
          min: 12346
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: ':'
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: \s
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              min: 12345
              name: arglist
              rest: ''
            min: 12345
        - !!perl/hash:RE_block
          min: 0
args_0: *5
blast: !!perl/hash:RE_ast
  dba: blast
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 12345
      re: &6 !!perl/hash:RE_any
        altname: blast_0
        dba: blast
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          alt: blast_0 0
          min: 12345
          name: block
          rest: ''
        - !!perl/hash:RE_method
          alt: blast_0 1
          min: 12345
          name: statement
          rest: ''
blast_0: *6
block: !!perl/hash:RE_ast
  dba: scoped block
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 1
              text: '{'
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: newpad
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: blockoid
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: checkyada
      rest: ''
blockoid: !!perl/hash:RE_ast
  dba: blockoid
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: finishpad
      rest: ''
    - !!perl/hash:RE_bracket
      min: 12345
      re: &7 !!perl/hash:RE_any
        altname: blockoid_0
        dba: block
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          alt: blockoid_0 0
          min: 24692
          zyg:
          - !!perl/hash:RE_bracket
            min: 12347
            re: !!perl/hash:RE_sequence
              min: 12347
              zyg:
              - !!perl/hash:RE_string
                i: 0
                min: 1
                text: '{'
              - !!perl/hash:RE_block
                min: 0
              - !!perl/hash:RE_method
                min: 12345
                name: statementlist
                rest: ''
              - !!perl/hash:RE_bracket
                min: 1
                re: !!perl/hash:RE_first
                  min: 1
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: '}'
                  - !!perl/hash:RE_method
                    min: 12345
                    name: FAILGOAL
                    rest: 1
          - !!perl/hash:RE_meta
            min: 0
            text: '::'
          - !!perl/hash:RE_method
            min: 12345
            name: curlycheck
            rest: ''
        - !!perl/hash:RE_sequence
          alt: blockoid_0 1
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method
              min: 12345
              name: terminator
              rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          alt: blockoid_0 2
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_noop
              min: 0
              nobind: 1
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
blockoid_0: *7
capterm: !!perl/hash:RE_ast
  dba: capterm
  min: 3
  re: !!perl/hash:RE_sequence
    min: 3
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: \
    - !!perl/hash:RE_bracket
      min: 2
      re: &8 !!perl/hash:RE_any
        altname: capterm_0
        dba: capterm
        min: 2
        zyg:
        - !!perl/hash:RE_sequence
          alt: capterm_0 0
          min: 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: (
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              min: 12345
              name: capture
              rest: ''
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: )
        - !!perl/hash:RE_sequence
          alt: capterm_0 1
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: \S
          - !!perl/hash:RE_method
            min: 12345
            name: termish
            rest: ''
        - !!perl/hash:RE_sequence
          alt: capterm_0 2
          min: 12345
          zyg:
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
capterm_0: *8
capture: !!perl/hash:RE_ast
  dba: capture
  min: 49380
  re: !!perl/hash:RE_sequence
    min: 49380
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: EXPR
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
circumfix__S_191sigil: !!perl/hash:RE_ast
  dba: contextualizer
  min: 37037
  re: !!perl/hash:RE_sequence
    min: 37037
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: sigil
      rest: ''
    - !!perl/hash:RE_bracket
      min: 12347
      re: !!perl/hash:RE_sequence
        min: 12347
        zyg:
        - !!perl/hash:RE_string
          i: 0
          min: 1
          text: (
        - !!perl/hash:RE_block
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: semilist
          rest: ''
        - !!perl/hash:RE_bracket
          min: 1
          re: !!perl/hash:RE_first
            min: 1
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: )
            - !!perl/hash:RE_method
              min: 12345
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
circumfix__S_192Paren_Thesis: !!perl/hash:RE_ast
  dba: parenthesized expression
  min: 24692
  re: !!perl/hash:RE_sequence
    min: 24692
    zyg:
    - !!perl/hash:RE_bracket
      min: 12347
      re: !!perl/hash:RE_sequence
        min: 12347
        zyg:
        - !!perl/hash:RE_string
          i: 0
          min: 1
          text: (
        - !!perl/hash:RE_block
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: semilist
          rest: ''
        - !!perl/hash:RE_bracket
          min: 1
          re: !!perl/hash:RE_first
            min: 1
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: )
            - !!perl/hash:RE_method
              min: 12345
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
circumfix__S_193Bra_Ket: !!perl/hash:RE_ast
  dba: array composer
  min: 24692
  re: !!perl/hash:RE_sequence
    min: 24692
    zyg:
    - !!perl/hash:RE_bracket
      min: 12347
      re: !!perl/hash:RE_sequence
        min: 12347
        zyg:
        - !!perl/hash:RE_string
          i: 0
          min: 1
          text: '['
        - !!perl/hash:RE_block
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: semilist
          rest: ''
        - !!perl/hash:RE_bracket
          min: 1
          re: !!perl/hash:RE_first
            min: 1
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: ']'
            - !!perl/hash:RE_method
              min: 12345
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
    - !!perl/hash:RE_block
      min: 0
circumfix__S_214Cur_Ly: !!perl/hash:RE_ast
  dba: circumfix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: '{'
    - !!perl/hash:RE_method
      min: 12345
      name: pblock
      rest: ''
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
coloncircumfix: !!perl/hash:RE_ast
  dba: coloncircumfix
  min: 12345
  re: !!perl/hash:RE_bracket
    min: 12345
    re: &9 !!perl/hash:RE_any
      altname: coloncircumfix_0
      dba: coloncircumfix
      min: 12345
      zyg:
      - !!perl/hash:RE_sequence
        alt: coloncircumfix_0 0
        min: 12347
        zyg:
        - !!perl/hash:RE_string
          i: 0
          min: 2
          text: <>
        - !!perl/hash:RE_method
          min: 12345
          name: worry
          rest: 1
      - !!perl/hash:RE_method
        alt: coloncircumfix_0 1
        min: 12345
        name: circumfix
        rest: ''
coloncircumfix_0: *9
colonpair: !!perl/hash:RE_ast
  dba: colon pair
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: ':'
    - !!perl/hash:RE_bracket
      min: 12345
      re: &10 !!perl/hash:RE_any
        altname: colonpair_0
        dba: signature
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          alt: colonpair_0 0
          min: 12346
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: '!'
          - !!perl/hash:RE_meta
            min: 0
            text: '::'
          - !!perl/hash:RE_bracket
            min: 12345
            re: !!perl/hash:RE_first
              min: 12345
              zyg:
              - !!perl/hash:RE_method
                min: 12345
                name: identifier
                rest: ''
              - !!perl/hash:RE_method
                min: 12345
                name: panic
                rest: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 12345
              re: !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_cclass
                      i: 0
                      min: 1
                      text: '[ \[ \( \< \{ ]'
                - !!perl/hash:RE_method
                  min: 12345
                  name: panic
                  rest: 1
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          alt: colonpair_0 1
          min: 12346
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              min: 1
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \d
                min: 1
                quant:
                - +
            min: 1
          - !!perl/hash:RE_method
            min: 12345
            name: identifier
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 24690
              re: !!perl/hash:RE_sequence
                min: 24690
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_cclass
                      i: 0
                      min: 1
                      text: '[ \[ \( \< \{ ]'
                - !!perl/hash:RE_method
                  min: 12345
                  name: sorry
                  rest: 1
                - !!perl/hash:RE_method
                  min: 12345
                  name: circumfix
                  rest: ''
            min: 0
            quant:
            - '?'
        - !!perl/hash:RE_sequence
          alt: colonpair_0 2
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: identifier
            rest: ''
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_bracket
            min: 0
            re: !!perl/hash:RE_first
              min: 0
              zyg:
              - !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: unsp
                    rest: ''
                  min: 0
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  min: 12345
                  name: coloncircumfix
                  rest: 1
                - !!perl/hash:RE_block
                  min: 0
              - !!perl/hash:RE_block
                min: 0
        - !!perl/hash:RE_bracket
          alt: colonpair_0 3
          min: 12347
          re: !!perl/hash:RE_sequence
            min: 12347
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: (
            - !!perl/hash:RE_block
              min: 0
            - !!perl/hash:RE_method
              min: 12345
              name: fakesignature
              rest: ''
            - !!perl/hash:RE_bracket
              min: 1
              re: !!perl/hash:RE_first
                min: 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: )
                - !!perl/hash:RE_method
                  min: 12345
                  name: FAILGOAL
                  rest: 1
        - !!perl/hash:RE_sequence
          alt: colonpair_0 4
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: coloncircumfix
            rest: 1
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          alt: colonpair_0 5
          min: 24690
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_paren
              min: 24690
              re: !!perl/hash:RE_sequence
                min: 24690
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: sigil
                  rest: ''
                - !!perl/hash:RE_block
                  min: 0
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: twigil
                    rest: ''
                  min: 0
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  min: 12345
                  name: desigilname
                  rest: ''
            min: 24690
          - !!perl/hash:RE_block
            min: 0
    - !!perl/hash:RE_block
      min: 0
colonpair_0: *10
comp_unit: !!perl/hash:RE_ast
  dba: comp_unit
  min: 419730
  re: !!perl/hash:RE_sequence
    min: 419730
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: statementlist
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 24690
      re: !!perl/hash:RE_first
        min: 24690
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method
            min: 12345
            name: unitstopper
            rest: ''
        - !!perl/hash:RE_sequence
          min: 37035
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
    - !!perl/hash:RE_block
      min: 0
curlycheck: !!perl/hash:RE_ast
  dba: curlycheck
  min: 0
  re: !!perl/hash:RE_bracket
    min: 0
    re: !!perl/hash:RE_first
      min: 0
      zyg:
      - !!perl/hash:RE_sequence
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              min: 0
              zyg:
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \h
                min: 0
                quant:
                - '*'
              - !!perl/hash:RE_meta
                min: 0
                text: $$
        - !!perl/hash:RE_block
          min: 0
      - !!perl/hash:RE_assertion
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method_re
          min: 12345
          name: before
          nobind: 1
          re: !!perl/hash:RE_sequence
            min: 1
            zyg:
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                min: 1
                text: \h
              min: 0
              quant:
              - '*'
            - !!perl/hash:RE_cclass
              i: 0
              min: 1
              text: '[\\,:]'
      - !!perl/hash:RE_sequence
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          min: 12345
          name: unv
          rest: ''
        - !!perl/hash:RE_meta
          min: 0
          text: $$
        - !!perl/hash:RE_block
          min: 0
      - !!perl/hash:RE_sequence
        min: 0
        zyg:
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            min: 12345
            name: unsp
            rest: ''
          min: 0
          quant:
          - '?'
        - !!perl/hash:RE_block
          min: 0
declarator: !!perl/hash:RE_ast
  dba: declarator
  min: 12345
  re: !!perl/hash:RE_bracket
    min: 12345
    re: &11 !!perl/hash:RE_any
      altname: declarator_0
      dba: declarator
      min: 12345
      zyg:
      - !!perl/hash:RE_sequence
        alt: declarator_0 0
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          min: 12345
          name: variable_declarator
          rest: ''
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_bracket
            min: 0
            re: !!perl/hash:RE_assertion
              assert: '?'
              min: 0
              re: !!perl/hash:RE_method_re
                min: 12345
                name: before
                nobind: 1
                re: !!perl/hash:RE_sequence
                  min: 24691
                  zyg:
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: ','
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_block
                    min: 0
          min: 0
          quant:
          - '?'
      - !!perl/hash:RE_sequence
        alt: declarator_0 1
        min: 12347
        zyg:
        - !!perl/hash:RE_bracket
          min: 12347
          re: !!perl/hash:RE_sequence
            min: 12347
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: (
            - !!perl/hash:RE_block
              min: 0
            - !!perl/hash:RE_method
              min: 12345
              name: signature
              rest: ''
            - !!perl/hash:RE_bracket
              min: 1
              re: !!perl/hash:RE_first
                min: 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: )
                - !!perl/hash:RE_method
                  min: 12345
                  name: FAILGOAL
                  rest: 1
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            min: 12345
            name: trait
            rest: ''
          min: 0
          quant:
          - '*'
      - !!perl/hash:RE_method
        alt: declarator_0 2
        min: 12345
        name: routine_declarator
        rest: ''
      - !!perl/hash:RE_method
        alt: declarator_0 3
        min: 12345
        name: regex_declarator
        rest: ''
      - !!perl/hash:RE_method
        alt: declarator_0 4
        min: 12345
        name: type_declarator
        rest: ''
declarator_0: *11
default_value: !!perl/hash:RE_ast
  dba: default_value
  min: 61726
  re: !!perl/hash:RE_sequence
    min: 61726
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: =
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: EXPR
      rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
deflongname: !!perl/hash:RE_ast
  dba: new name to be defined
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: name
      rest: ''
    - !!perl/hash:RE_bracket
      min: 0
      re: &12 !!perl/hash:RE_any
        altname: deflongname_0
        dba: new name to be defined
        min: 0
        zyg:
        - !!perl/hash:RE_sequence
          alt: deflongname_0 0
          min: 12345
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              min: 12345
              name: colonpair
              rest: ''
            min: 12345
            quant:
            - +
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_block
          alt: deflongname_0 1
          min: 0
deflongname_0: *12
desigilname: !!perl/hash:RE_ast
  dba: desigilname
  min: 12345
  re: !!perl/hash:RE_bracket
    min: 12345
    re: &13 !!perl/hash:RE_any
      altname: desigilname_0
      dba: desigilname
      min: 12345
      zyg:
      - !!perl/hash:RE_sequence
        alt: desigilname_0 0
        min: 12345
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 1
              text: $
        - !!perl/hash:RE_method
          min: 12345
          name: variable
          rest: ''
        - !!perl/hash:RE_block
          min: 0
      - !!perl/hash:RE_sequence
        alt: desigilname_0 1
        min: 12345
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              min: 2
              zyg:
              - !!perl/hash:RE_cclass
                i: 0
                min: 1
                text: '[\@\%\&]'
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_method
                  min: 12345
                  name: sigil
                  rest: ''
                min: 0
                quant:
                - '*'
              - !!perl/hash:RE_meta
                min: 1
                text: \w
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
      - !!perl/hash:RE_method
        alt: desigilname_0 2
        min: 12345
        name: longname
        rest: ''
desigilname_0: *13
dotty__S_194DotStar: !!perl/hash:RE_ast
  dba: dotty
  min: 37037
  re: !!perl/hash:RE_sequence
    min: 37037
    zyg:
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        min: 2
        re: !!perl/hash:RE_sequence
          min: 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: .
          - !!perl/hash:RE_bracket
            min: 1
            re: &14 !!perl/hash:RE_any
              altname: dotty__S_194DotStar_0
              dba: dotty
              min: 1
              zyg:
              - !!perl/hash:RE_cclass
                alt: dotty__S_194DotStar_0 0
                i: 0
                min: 1
                text: '[+*?=]'
              - !!perl/hash:RE_sequence
                alt: dotty__S_194DotStar_0 1
                min: 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: ^
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: '!'
                  min: 0
                  quant:
                  - '?'
      min: 2
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_method
      min: 12345
      name: unspacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: dottyop
      rest: ''
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
dotty__S_194DotStar_0: *14
dotty__S_195Dot: !!perl/hash:RE_ast
  dba: dotty
  min: 49380
  re: !!perl/hash:RE_sequence
    min: 49380
    zyg:
    - !!perl/hash:RE_method
      endsym: unspacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: .
    - !!perl/hash:RE_method
      min: 12345
      name: unspacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: dottyop
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
dottyop: !!perl/hash:RE_ast
  dba: dotty method or postfix
  min: 12345
  re: !!perl/hash:RE_bracket
    min: 12345
    re: &15 !!perl/hash:RE_any
      altname: dottyop_0
      dba: dotty method or postfix
      min: 12345
      zyg:
      - !!perl/hash:RE_method
        alt: dottyop_0 0
        min: 12345
        name: methodop
        rest: ''
      - !!perl/hash:RE_method
        alt: dottyop_0 1
        min: 12345
        name: colonpair
        rest: ''
      - !!perl/hash:RE_sequence
        alt: dottyop_0 2
        min: 12345
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_method
            min: 12345
            name: alpha
            rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: postop
          rest: ''
        - !!perl/hash:RE_block
          min: 0
dottyop_0: *15
dottyopish: !!perl/hash:RE_ast
  dba: dottyopish
  min: 12345
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_method
      min: 12345
      name: dottyop
      rest: ''
    min: 12345
eat_terminator: !!perl/hash:RE_ast
  dba: eat_terminator
  min: 0
  re: !!perl/hash:RE_bracket
    min: 0
    re: !!perl/hash:RE_first
      min: 0
      zyg:
      - !!perl/hash:RE_string
        i: 0
        min: 1
        text: ;
      - !!perl/hash:RE_sequence
        min: 12345
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_block
            min: 0
            nobind: 1
        - !!perl/hash:RE_method
          min: 12345
          name: ws
          rest: ''
      - !!perl/hash:RE_assertion
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method_re
          min: 12345
          name: before
          nobind: 1
          re: &16 !!perl/hash:RE_any
            altname: eat_terminator_0
            dba: eat_terminator
            min: 1
            zyg:
            - !!perl/hash:RE_string
              alt: eat_terminator_0 0
              i: 0
              min: 1
              text: )
            - !!perl/hash:RE_string
              alt: eat_terminator_0 1
              i: 0
              min: 1
              text: ']'
            - !!perl/hash:RE_string
              alt: eat_terminator_0 2
              i: 0
              min: 1
              text: '}'
      - !!perl/hash:RE_meta
        min: 0
        text: $
      - !!perl/hash:RE_assertion
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method
          min: 12345
          name: stopper
          rest: ''
      - !!perl/hash:RE_sequence
        min: 24690
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_method_re
              min: 12345
              name: suppose
              nobind: 1
              re: !!perl/hash:RE_method
                min: 12345
                name: statement_control
                rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: backup_ws
          rest: ''
        - !!perl/hash:RE_block
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
      - !!perl/hash:RE_method
        min: 12345
        name: panic
        rest: 1
eat_terminator_0: *16
fakesignature: !!perl/hash:RE_ast
  dba: fakesignature
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: newpad
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: signature
      rest: ''
fatarrow: !!perl/hash:RE_ast
  dba: fatarrow
  min: 37037
  re: !!perl/hash:RE_sequence
    min: 37037
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        min: 12345
        name: identifier
        rest: ''
      min: 12345
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      min: 0
      quant:
      - '*'
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: =>
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        min: 12345
        name: EXPR
        rest: 1
      min: 12345
infix__S_190lambda: !!perl/hash:RE_ast
  dba: infix
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &17 !!perl/hash:RE_any
          altname: infix__S_190lambda_0
          dba: infix
          min: 1
          zyg:
          - !!perl/hash:RE_string
            alt: infix__S_190lambda_0 0
            i: 0
            min: 1
            text: '{'
          - !!perl/hash:RE_string
            alt: infix__S_190lambda_0 1
            i: 0
            min: 2
            text: ->
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_block
        min: 0
        nobind: 1
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_190lambda_0: *17
infix__S_216Dot: !!perl/hash:RE_ast
  dba: infix
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: .
    - !!perl/hash:RE_cclass
      i: 0
      min: 1
      text: '[\]\)\},:\s\$"'']'
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
infix__S_222StarStar: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '**'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_237Star: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '*'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_238Slash: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: /
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_239div: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: div
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_240Percent: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '%'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_241mod: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: mod
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_242PlusAmp: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: +&
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_243LtLt: !!perl/hash:RE_ast
  dba: infix
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: <<
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_block
        min: 0
        nobind: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      min: 12345
      name: sorryobs
      rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_244GtGt: !!perl/hash:RE_ast
  dba: infix
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '>>'
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_block
        min: 0
        nobind: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      min: 12345
      name: sorryobs
      rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_245TildeAmp: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ~&
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_246QuestionAmp: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ?&
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_247TildeLt: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ~<
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_block
            min: 0
            nobind: 1
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 2
              text: <<
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 1
              text: <
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_248TildeGt: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ~>
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_block
            min: 0
            nobind: 1
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 2
              text: '>>'
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 1
              text: '>'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_249PlusLt: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: +<
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_block
            min: 0
            nobind: 1
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 2
              text: <<
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 1
              text: <
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_250PlusGt: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: +>
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_block
            min: 0
            nobind: 1
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 2
              text: '>>'
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 1
              text: '>'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_251Plus: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: +
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: +
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_252Minus: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '-'
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: '-'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_253PlusVert: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: +|
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_254PlusCaret: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: +^
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_255TildeVert: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ~|
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_256TildeCaret: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ~^
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_257QuestionVert: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ?|
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_258QuestionCaret: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ?^
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_259x: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: x
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_260xx: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: xx
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_261Tilde: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '~'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_262Amp: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '&'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_263Vert: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '|'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_264Caret: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ^
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_269LtEqualGt: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: <=>
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_270cmp: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: cmp
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_271leg: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: leg
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_272but: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: but
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_273does: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: does
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_274DotDot: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ..
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: &18 !!perl/hash:RE_any
                altname: infix__S_274DotDot_0
                dba: infix
                min: 1
                zyg:
                - !!perl/hash:RE_string
                  alt: infix__S_274DotDot_0 0
                  i: 0
                  min: 1
                  text: )
                - !!perl/hash:RE_string
                  alt: infix__S_274DotDot_0 1
                  i: 0
                  min: 1
                  text: ']'
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_274DotDot_0: *18
infix__S_275CaretDotDot: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ^..
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_276DotDotCaret: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ..^
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_277CaretDotDotCaret: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ^..^
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_278EqualEqual: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ==
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: =
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_279BangEqual: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '!='
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_280Lt: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: <
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_281LtEqual: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: <=
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_282Gt: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '>'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_283GtEqual: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '>='
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_284TildeTilde: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ~~
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_assertion
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method_re
          min: 12345
          name: before
          nobind: 1
          re: !!perl/hash:RE_sequence
            min: 12349
            zyg:
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                min: 1
                text: \h
              min: 0
              quant:
              - '*'
            - !!perl/hash:RE_bindpos
              atom: !!perl/hash:RE_paren
                min: 4
                re: &19 !!perl/hash:RE_any
                  altname: infix__S_284TildeTilde_0
                  dba: infix
                  min: 4
                  zyg:
                  - !!perl/hash:RE_string
                    alt: infix__S_284TildeTilde_0 0
                    i: 0
                    min: 4
                    text: True
                  - !!perl/hash:RE_string
                    alt: infix__S_284TildeTilde_0 1
                    i: 0
                    min: 5
                    text: False
              min: 4
            - !!perl/hash:RE_meta
              min: 0
              text: »
            - !!perl/hash:RE_method
              min: 12345
              name: dumbsmart
              rest: 1
      min: 0
      quant:
      - '?'
infix__S_284TildeTilde_0: *19
infix__S_285BangTilde: !!perl/hash:RE_ast
  dba: infix
  min: 37036
  re: !!perl/hash:RE_sequence
    min: 37036
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '!~'
    - !!perl/hash:RE_meta
      min: 1
      text: \s
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_286EqualTilde: !!perl/hash:RE_ast
  dba: infix
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: =~
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_287eq: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: eq
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_288ne: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ne
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_289lt: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: lt
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_290le: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: le
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_291gt: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: gt
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_292ge: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ge
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_293EqualColonEqual: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: =:=
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_294EqualEqualEqual: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ===
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_295eqv: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: eqv
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_296before: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: before
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_297after: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: after
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_298AmpAmp: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '&&'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_299VertVert: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '||'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_300CaretCaret: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ^^
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_301SlashSlash: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: //
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_302min: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: min
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_303max: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: max
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_304QuestionQuestion_BangBang: !!perl/hash:RE_ast
  dba: infix
  min: 37039
  re: !!perl/hash:RE_sequence
    min: 37039
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: ??
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: EXPR
      rest: 1
    - !!perl/hash:RE_bracket
      min: 2
      re: !!perl/hash:RE_first
        min: 2
        zyg:
        - !!perl/hash:RE_string
          i: 0
          min: 2
          text: '!!'
        - !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                min: 3
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 2
                  text: '::'
                - !!perl/hash:RE_cclass
                  i: 0
                  min: 1
                  text: -[=]
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: infixish
            rest: ''
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          min: 24692
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                min: 0
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \N
                  min: 0
                  quant:
                  - '*'
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    min: 1
                    re: !!perl/hash:RE_sequence
                      min: 1
                      zyg:
                      - !!perl/hash:RE_meta
                        min: 1
                        text: \n
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_meta
                          min: 1
                          text: \N
                        min: 0
                        quant:
                        - '*'
                  min: 0
                  quant:
                  - '?'
          - !!perl/hash:RE_string
            i: 0
            min: 2
            text: '!!'
          - !!perl/hash:RE_method
            min: 12345
            name: sorry
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          min: 24690
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: sorry
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_305BangBang: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '!!'
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_first
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          min: 24690
          zyg:
          - !!perl/hash:RE_method_re
            min: 12345
            name: suppose
            nobind: 1
            re: !!perl/hash:RE_method
              min: 12345
              name: infixish
              rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
infix__S_306Question: !!perl/hash:RE_ast
  dba: infix
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '?'
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: '?'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          min: 1
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              i: 0
              min: 1
              text: -[;]
            min: 0
            quant:
            - '*'
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: ':'
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_307ff: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ff
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_308Caretff: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ^ff
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_309ffCaret: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ff^
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_310CaretffCaret: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ^ff^
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_311fff: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: fff
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_312Caretfff: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ^fff
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_313fffCaret: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: fff^
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_314CaretfffCaret: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ^fff^
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_315Equal: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: =
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_first
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
          - !!perl/hash:RE_method
            min: 12345
            name: O
            rest: 1
        - !!perl/hash:RE_method
          min: 12345
          name: O
          rest: 1
infix__S_316ColonEqual: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: :=
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_317ColonColonEqual: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ::=
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_318DotEqual: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: .=
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_319EqualGt: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: =>
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_322Comma: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ','
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_323Colon: !!perl/hash:RE_ast
  dba: infix
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: ':'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &20 !!perl/hash:RE_any
          altname: infix__S_323Colon_0
          dba: infix
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: infix__S_323Colon_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_method
            alt: infix__S_323Colon_0 1
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_323Colon_0: *20
infix__S_324X: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: X
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_325Z: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: Z
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_326minmax: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: minmax
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_327DotDotDot: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '...'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_333and: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: and
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_334andthen: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: andthen
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_335or: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: or
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_336orelse: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: orelse
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_337xor: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: xor
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_338LtEqualEqual: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: <==
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_339EqualEqualGt: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ==>
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_340LtLtEqualEqual: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: <<==
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix__S_341EqualEqualGtGt: !!perl/hash:RE_ast
  dba: infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ==>>
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix_circumfix_meta_operator__S_204Fre_Nch: !!perl/hash:RE_ast
  dba: infix_circumfix_meta_operator
  min: 24692
  re: !!perl/hash:RE_sequence
    min: 24692
    zyg:
    - !!perl/hash:RE_bracket
      min: 1
      re: &21 !!perl/hash:RE_any
        altname: infix_circumfix_meta_operator__S_204Fre_Nch_0
        dba: infix_circumfix_meta_operator
        min: 1
        zyg:
        - !!perl/hash:RE_string
          alt: infix_circumfix_meta_operator__S_204Fre_Nch_0 0
          i: 0
          min: 1
          text: «
        - !!perl/hash:RE_string
          alt: infix_circumfix_meta_operator__S_204Fre_Nch_0 1
          i: 0
          min: 1
          text: »
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: infixish
      rest: 1
    - !!perl/hash:RE_bracket
      min: 1
      re: !!perl/hash:RE_first
        min: 1
        zyg:
        - &22 !!perl/hash:RE_any
          altname: infix_circumfix_meta_operator__S_204Fre_Nch_1
          dba: infix_circumfix_meta_operator
          min: 1
          zyg:
          - !!perl/hash:RE_string
            alt: infix_circumfix_meta_operator__S_204Fre_Nch_1 0
            i: 0
            min: 1
            text: «
          - !!perl/hash:RE_string
            alt: infix_circumfix_meta_operator__S_204Fre_Nch_1 1
            i: 0
            min: 1
            text: »
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: can_meta
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_block
        min: 0
        nobind: 1
infix_circumfix_meta_operator__S_204Fre_Nch_0: *21
infix_circumfix_meta_operator__S_204Fre_Nch_1: *22
infix_circumfix_meta_operator__S_205LtLt_GtGt: !!perl/hash:RE_ast
  dba: infix_circumfix_meta_operator
  min: 24694
  re: !!perl/hash:RE_sequence
    min: 24694
    zyg:
    - !!perl/hash:RE_bracket
      min: 2
      re: &23 !!perl/hash:RE_any
        altname: infix_circumfix_meta_operator__S_205LtLt_GtGt_0
        dba: infix_circumfix_meta_operator
        min: 2
        zyg:
        - !!perl/hash:RE_string
          alt: infix_circumfix_meta_operator__S_205LtLt_GtGt_0 0
          i: 0
          min: 2
          text: <<
        - !!perl/hash:RE_string
          alt: infix_circumfix_meta_operator__S_205LtLt_GtGt_0 1
          i: 0
          min: 2
          text: '>>'
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: infixish
      rest: 1
    - !!perl/hash:RE_bracket
      min: 2
      re: !!perl/hash:RE_first
        min: 2
        zyg:
        - &24 !!perl/hash:RE_any
          altname: infix_circumfix_meta_operator__S_205LtLt_GtGt_1
          dba: infix_circumfix_meta_operator
          min: 2
          zyg:
          - !!perl/hash:RE_string
            alt: infix_circumfix_meta_operator__S_205LtLt_GtGt_1 0
            i: 0
            min: 2
            text: <<
          - !!perl/hash:RE_string
            alt: infix_circumfix_meta_operator__S_205LtLt_GtGt_1 1
            i: 0
            min: 2
            text: '>>'
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: can_meta
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_block
        min: 0
        nobind: 1
infix_circumfix_meta_operator__S_205LtLt_GtGt_0: *23
infix_circumfix_meta_operator__S_205LtLt_GtGt_1: *24
infix_postfix_meta_operator__S_206Equal: !!perl/hash:RE_ast
  dba: infix_postfix_meta_operator
  min: 24691
  re: !!perl/hash:RE_sequence
    min: 24691
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: =
    - !!perl/hash:RE_method
      min: 12345
      name: can_meta
      rest: 1
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_block
            min: 0
            nobind: 1
        - !!perl/hash:RE_method
          min: 12345
          name: sorry
          rest: 1
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix_prefix_meta_operator__S_199Bang: !!perl/hash:RE_ast
  dba: infix_prefix_meta_operator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '!'
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: '!'
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_first
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          min: 12345
          name: infixish
          rest: 1
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_first
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
          - !!perl/hash:RE_method
            min: 12345
            name: O
            rest: 1
        - !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: can_meta
            rest: 1
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
        - !!perl/hash:RE_method
          min: 12345
          name: sorry
          rest: 1
infix_prefix_meta_operator__S_200R: !!perl/hash:RE_ast
  dba: infix_prefix_meta_operator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: R
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: infixish
      rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: can_meta
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_block
        min: 0
        nobind: 1
infix_prefix_meta_operator__S_201S: !!perl/hash:RE_ast
  dba: infix_prefix_meta_operator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: S
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: infixish
      rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: can_meta
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_block
        min: 0
        nobind: 1
infix_prefix_meta_operator__S_202X: !!perl/hash:RE_ast
  dba: infix_prefix_meta_operator
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: X
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \S
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 24690
        re: !!perl/hash:RE_sequence
          min: 24690
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: infixish
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: can_meta
            rest: 1
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infix_prefix_meta_operator__S_203Z: !!perl/hash:RE_ast
  dba: infix_prefix_meta_operator
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: Z
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \S
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 24690
        re: !!perl/hash:RE_sequence
          min: 24690
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: infixish
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: can_meta
            rest: 1
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
infixish: !!perl/hash:RE_ast
  dba: infix or meta-infix
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        min: 12345
        name: stdstopper
        rest: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        min: 12345
        name: infixstopper
        rest: ''
    - !!perl/hash:RE_bracket
      min: 12345
      re: &25 !!perl/hash:RE_any
        altname: infixish_0
        dba: infix or meta-infix
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          alt: infixish_0 0
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: colonpair
            rest: ''
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          alt: infixish_0 1
          min: 12345
          zyg:
          - !!perl/hash:RE_bracket
            min: 12345
            re: &26 !!perl/hash:RE_any
              altname: infixish_1
              dba: bracketed infix
              min: 12345
              zyg:
              - !!perl/hash:RE_sequence
                alt: infixish_1 0
                min: 12347
                zyg:
                - !!perl/hash:RE_bracket
                  min: 12347
                  re: !!perl/hash:RE_sequence
                    min: 12347
                    zyg:
                    - !!perl/hash:RE_string
                      i: 0
                      min: 1
                      text: '['
                    - !!perl/hash:RE_block
                      min: 0
                    - !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        min: 12345
                        name: infixish
                        rest: 1
                      min: 12345
                    - !!perl/hash:RE_bracket
                      min: 1
                      re: !!perl/hash:RE_first
                        min: 1
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          min: 1
                          text: ']'
                        - !!perl/hash:RE_method
                          min: 12345
                          name: FAILGOAL
                          rest: 1
                - !!perl/hash:RE_block
                  min: 0
              - !!perl/hash:RE_sequence
                alt: infixish_1 1
                min: 12345
                zyg:
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: infix_circumfix_meta_operator
                    rest: ''
                  min: 12345
                - !!perl/hash:RE_block
                  min: 0
              - !!perl/hash:RE_sequence
                alt: infixish_1 2
                min: 12345
                zyg:
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: infix_prefix_meta_operator
                    rest: ''
                  min: 12345
                - !!perl/hash:RE_block
                  min: 0
              - !!perl/hash:RE_sequence
                alt: infixish_1 3
                min: 12345
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: infix
                  rest: ''
                - !!perl/hash:RE_block
                  min: 0
              - !!perl/hash:RE_sequence
                alt: infixish_1 4
                min: 12345
                zyg:
                - !!perl/hash:RE_block
                  min: 0
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method
                    min: 12345
                    name: dotty
                    rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: panic
                  rest: 1
              - !!perl/hash:RE_sequence
                alt: infixish_1 5
                min: 12345
                zyg:
                - !!perl/hash:RE_block
                  min: 0
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method
                    min: 12345
                    name: postfix
                    rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: panic
                  rest: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 12345
              re: !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      min: 1
                      text: =
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_block
                    min: 0
                    nobind: 1
                - !!perl/hash:RE_method
                  min: 12345
                  name: infix_postfix_meta_operator
                  rest: 1
                - !!perl/hash:RE_block
                  min: 0
            min: 0
            quant:
            - '?'
infixish_0: *25
infixish_1: *26
infixstopper: !!perl/hash:RE_ast
  dba: infix stopper
  min: 0
  re: !!perl/hash:RE_bracket
    min: 0
    re: &27 !!perl/hash:RE_any
      altname: infixstopper_0
      dba: infix stopper
      min: 0
      zyg:
      - !!perl/hash:RE_assertion
        alt: infixstopper_0 0
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method_re
          min: 12345
          name: before
          nobind: 1
          re: !!perl/hash:RE_method
            min: 12345
            name: stopper
            rest: ''
      - !!perl/hash:RE_sequence
        alt: infixstopper_0 1
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 2
              text: '!!'
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_block
            min: 0
            nobind: 1
      - !!perl/hash:RE_sequence
        alt: infixstopper_0 2
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: &28 !!perl/hash:RE_any
              altname: infixstopper_1
              dba: infix stopper
              min: 1
              zyg:
              - !!perl/hash:RE_string
                alt: infixstopper_1 0
                i: 0
                min: 1
                text: '{'
              - !!perl/hash:RE_method
                alt: infixstopper_1 1
                min: 12345
                name: lambda
                rest: ''
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_block
            min: 0
            nobind: 1
      - !!perl/hash:RE_assertion
        alt: infixstopper_0 3
        assert: '?'
        min: 0
        re: !!perl/hash:RE_block
          min: 0
          nobind: 1
infixstopper_0: *27
infixstopper_1: *28
label: !!perl/hash:RE_ast
  dba: label
  min: 24691
  re: !!perl/hash:RE_sequence
    min: 24691
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: identifier
      rest: ''
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: ':'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
          - !!perl/hash:RE_method
            min: 12345
            name: sorry
            rest: 1
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_block
      min: 0
lambda: !!perl/hash:RE_ast
  dba: lambda
  min: 2
  re: &29 !!perl/hash:RE_any
    altname: lambda_0
    dba: lambda
    min: 2
    zyg:
    - !!perl/hash:RE_string
      alt: lambda_0 0
      i: 0
      min: 2
      text: ->
    - !!perl/hash:RE_string
      alt: lambda_0 1
      i: 0
      min: 3
      text: <->
lambda_0: *29
macro_def: !!perl/hash:RE_ast
  dba: macro_def
  min: 37035
  re: !!perl/hash:RE_first
    min: 37035
    zyg:
    - !!perl/hash:RE_sequence
      min: 197520
      zyg:
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
      - !!perl/hash:RE_bracket
        min: 135795
        re: !!perl/hash:RE_sequence
          min: 135795
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 24691
              re: &30 !!perl/hash:RE_any
                altname: macro_def_0
                dba: macro_def
                min: 24691
                zyg:
                - !!perl/hash:RE_sequence
                  alt: macro_def_0 0
                  min: 24691
                  zyg:
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: '&'
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_method
                      min: 12345
                      name: deflongname
                      rest: ''
                    min: 0
                    quant:
                    - '?'
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                - !!perl/hash:RE_sequence
                  alt: macro_def_0 1
                  min: 37035
                  zyg:
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_method
                    min: 12345
                    name: deflongname
                    rest: ''
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: newpad
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 37035
              re: &31 !!perl/hash:RE_any
                altname: macro_def_1
                dba: macro_def
                min: 37035
                zyg:
                - !!perl/hash:RE_sequence
                  alt: macro_def_1 0
                  min: 37035
                  zyg:
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_method
                    min: 12345
                    name: multisig
                    rest: ''
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                - !!perl/hash:RE_sequence
                  alt: macro_def_1 1
                  min: 37035
                  zyg:
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_method
                    min: 12345
                    name: trait
                    rest: ''
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
            min: 0
            quant:
            - '*'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 49380
              re: !!perl/hash:RE_sequence
                min: 49380
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_assertion
                  assert: '!'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_sequence
                      min: 12346
                      zyg:
                      - !!perl/hash:RE_method
                        min: 12345
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        min: 1
                        text: '{'
                - !!perl/hash:RE_method
                  min: 12345
                  name: panic
                  rest: 1
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: blockoid
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: checkyada
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: getsig
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: getdecl
            rest: ''
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
    - !!perl/hash:RE_sequence
      min: 37035
      zyg:
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        min: 12345
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
macro_def_0: *30
macro_def_1: *31
method_def: !!perl/hash:RE_ast
  dba: method_def
  min: 37035
  re: !!perl/hash:RE_first
    min: 37035
    zyg:
    - !!perl/hash:RE_sequence
      min: 197520
      zyg:
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        min: 12345
        name: newpad
        rest: 1
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
      - !!perl/hash:RE_bracket
        min: 111105
        re: !!perl/hash:RE_sequence
          min: 111105
          zyg:
          - !!perl/hash:RE_bracket
            min: 24690
            re: &32 !!perl/hash:RE_any
              altname: method_def_0
              dba: subscript signature
              min: 24690
              zyg:
              - !!perl/hash:RE_sequence
                alt: method_def_0 0
                min: 49380
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_cclass
                    i: 0
                    min: 1
                    text: '[ ! ^ ]'
                  min: 0
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  min: 12345
                  name: longname
                  rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    min: 37035
                    re: &33 !!perl/hash:RE_any
                      altname: method_def_1
                      dba: method_def
                      min: 37035
                      zyg:
                      - !!perl/hash:RE_sequence
                        alt: method_def_1 0
                        min: 37035
                        zyg:
                        - !!perl/hash:RE_method
                          min: 12345
                          name: ws
                          rest: ''
                        - !!perl/hash:RE_method
                          min: 12345
                          name: multisig
                          rest: ''
                        - !!perl/hash:RE_method
                          min: 12345
                          name: ws
                          rest: ''
                      - !!perl/hash:RE_sequence
                        alt: method_def_1 1
                        min: 37035
                        zyg:
                        - !!perl/hash:RE_method
                          min: 12345
                          name: ws
                          rest: ''
                        - !!perl/hash:RE_method
                          min: 12345
                          name: trait
                          rest: ''
                        - !!perl/hash:RE_method
                          min: 12345
                          name: ws
                          rest: ''
                  min: 0
                  quant:
                  - '*'
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: method_def_0 1
                min: 49380
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: multisig
                  rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: trait
                    rest: ''
                  min: 0
                  quant:
                  - '*'
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: method_def_0 2
                min: 123453
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: sigil
                  rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: .
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_bracket
                  min: 37037
                  re: &34 !!perl/hash:RE_any
                    altname: method_def_2
                    dba: subscript signature
                    min: 37037
                    zyg:
                    - !!perl/hash:RE_sequence
                      alt: method_def_2 0
                      min: 37037
                      zyg:
                      - !!perl/hash:RE_bracket
                        min: 12347
                        re: !!perl/hash:RE_sequence
                          min: 12347
                          zyg:
                          - !!perl/hash:RE_string
                            i: 0
                            min: 1
                            text: (
                          - !!perl/hash:RE_block
                            min: 0
                          - !!perl/hash:RE_method
                            min: 12345
                            name: signature
                            rest: ''
                          - !!perl/hash:RE_bracket
                            min: 1
                            re: !!perl/hash:RE_first
                              min: 1
                              zyg:
                              - !!perl/hash:RE_string
                                i: 0
                                min: 1
                                text: )
                              - !!perl/hash:RE_method
                                min: 12345
                                name: FAILGOAL
                                rest: 1
                      - !!perl/hash:RE_method
                        min: 12345
                        name: ws
                        rest: ''
                    - !!perl/hash:RE_sequence
                      alt: method_def_2 1
                      min: 37037
                      zyg:
                      - !!perl/hash:RE_bracket
                        min: 12347
                        re: !!perl/hash:RE_sequence
                          min: 12347
                          zyg:
                          - !!perl/hash:RE_string
                            i: 0
                            min: 1
                            text: '['
                          - !!perl/hash:RE_block
                            min: 0
                          - !!perl/hash:RE_method
                            min: 12345
                            name: signature
                            rest: ''
                          - !!perl/hash:RE_bracket
                            min: 1
                            re: !!perl/hash:RE_first
                              min: 1
                              zyg:
                              - !!perl/hash:RE_string
                                i: 0
                                min: 1
                                text: ']'
                              - !!perl/hash:RE_method
                                min: 12345
                                name: FAILGOAL
                                rest: 1
                      - !!perl/hash:RE_method
                        min: 12345
                        name: ws
                        rest: ''
                    - !!perl/hash:RE_sequence
                      alt: method_def_2 2
                      min: 37037
                      zyg:
                      - !!perl/hash:RE_bracket
                        min: 12347
                        re: !!perl/hash:RE_sequence
                          min: 12347
                          zyg:
                          - !!perl/hash:RE_string
                            i: 0
                            min: 1
                            text: '{'
                          - !!perl/hash:RE_block
                            min: 0
                          - !!perl/hash:RE_method
                            min: 12345
                            name: signature
                            rest: ''
                          - !!perl/hash:RE_bracket
                            min: 1
                            re: !!perl/hash:RE_first
                              min: 1
                              zyg:
                              - !!perl/hash:RE_string
                                i: 0
                                min: 1
                                text: '}'
                              - !!perl/hash:RE_method
                                min: 12345
                                name: FAILGOAL
                                rest: 1
                      - !!perl/hash:RE_method
                        min: 12345
                        name: ws
                        rest: ''
                    - !!perl/hash:RE_sequence
                      alt: method_def_2 3
                      min: 49380
                      zyg:
                      - !!perl/hash:RE_assertion
                        assert: '?'
                        min: 0
                        re: !!perl/hash:RE_method_re
                          min: 12345
                          name: before
                          nobind: 1
                          re: !!perl/hash:RE_sequence
                            min: 12346
                            zyg:
                            - !!perl/hash:RE_method
                              min: 12345
                              name: ws
                              rest: ''
                            - !!perl/hash:RE_string
                              i: 0
                              min: 1
                              text: <
                      - !!perl/hash:RE_method
                        min: 12345
                        name: postcircumfix
                        rest: ''
                      - !!perl/hash:RE_method
                        min: 12345
                        name: ws
                        rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: trait
                    rest: ''
                  min: 0
                  quant:
                  - '*'
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
              - !!perl/hash:RE_assertion
                alt: method_def_0 3
                assert: '?'
                min: 0
                re: !!perl/hash:RE_noop
                  min: 0
                  nobind: 1
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: blockoid
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: checkyada
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: getsig
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: getdecl
            rest: ''
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
    - !!perl/hash:RE_sequence
      min: 37035
      zyg:
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        min: 12345
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
method_def_0: *32
method_def_1: *33
method_def_2: *34
methodop: !!perl/hash:RE_ast
  dba: method arguments
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_bracket
      min: 12345
      re: &35 !!perl/hash:RE_any
        altname: methodop_0
        dba: methodop
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          alt: methodop_0 0
          min: 12345
          name: longname
          rest: ''
        - !!perl/hash:RE_sequence
          alt: methodop_0 1
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: &36 !!perl/hash:RE_any
                altname: methodop_1
                dba: methodop
                min: 1
                zyg:
                - !!perl/hash:RE_string
                  alt: methodop_1 0
                  i: 0
                  min: 1
                  text: $
                - !!perl/hash:RE_string
                  alt: methodop_1 1
                  i: 0
                  min: 1
                  text: '@'
                - !!perl/hash:RE_string
                  alt: methodop_1 2
                  i: 0
                  min: 1
                  text: '&'
          - !!perl/hash:RE_method
            min: 12345
            name: variable
            rest: ''
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          alt: methodop_0 2
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_cclass
                i: 0
                min: 1
                text: '[ '' " ]'
          - !!perl/hash:RE_bracket
            min: 0
            re: !!perl/hash:RE_first
              min: 0
              zyg:
              - !!perl/hash:RE_assertion
                assert: '!'
                min: 0
                re: !!perl/hash:RE_block
                  min: 0
                  nobind: 1
              - !!perl/hash:RE_assertion
                assert: '!'
                min: 0
                re: !!perl/hash:RE_method_re
                  min: 12345
                  name: before
                  nobind: 1
                  re: !!perl/hash:RE_sequence
                    min: 2
                    zyg:
                    - !!perl/hash:RE_string
                      i: 0
                      min: 1
                      text: '"'
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_cclass
                        i: 0
                        min: 1
                        text: -["]
                      min: 0
                      quant:
                      - '*'
                    - !!perl/hash:RE_meta
                      min: 1
                      text: \s
          - !!perl/hash:RE_method
            min: 12345
            name: quote
            rest: ''
          - !!perl/hash:RE_bracket
            min: 0
            re: !!perl/hash:RE_first
              min: 0
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                min: 0
                re: !!perl/hash:RE_method_re
                  min: 12345
                  name: before
                  nobind: 1
                  re: &37 !!perl/hash:RE_any
                    altname: methodop_2
                    dba: methodop
                    min: 1
                    zyg:
                    - !!perl/hash:RE_string
                      alt: methodop_2 0
                      i: 0
                      min: 1
                      text: (
                    - !!perl/hash:RE_string
                      alt: methodop_2 1
                      i: 0
                      min: 2
                      text: .(
                    - !!perl/hash:RE_string
                      alt: methodop_2 2
                      i: 0
                      min: 1
                      text: \
              - !!perl/hash:RE_method
                min: 12345
                name: obs
                rest: 1
          - !!perl/hash:RE_block
            min: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: unsp
        rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 0
        re: &38 !!perl/hash:RE_any
          altname: methodop_3
          dba: method arguments
          min: 0
          zyg:
          - !!perl/hash:RE_sequence
            alt: methodop_3 0
            min: 12346
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: ':'
            - !!perl/hash:RE_assertion
              assert: '?'
              min: 0
              re: !!perl/hash:RE_method_re
                min: 12345
                name: before
                nobind: 1
                re: &39 !!perl/hash:RE_any
                  altname: methodop_4
                  dba: method arguments
                  min: 1
                  zyg:
                  - !!perl/hash:RE_meta
                    alt: methodop_4 0
                    min: 1
                    text: \s
                  - !!perl/hash:RE_string
                    alt: methodop_4 1
                    i: 0
                    min: 1
                    text: '{'
            - !!perl/hash:RE_assertion
              assert: '!'
              min: 0
              re: !!perl/hash:RE_block
                min: 0
                nobind: 1
            - !!perl/hash:RE_method
              min: 12345
              name: arglist
              rest: ''
          - !!perl/hash:RE_sequence
            alt: methodop_3 1
            min: 12345
            zyg:
            - !!perl/hash:RE_assertion
              assert: '?'
              min: 0
              re: !!perl/hash:RE_cclass
                i: 0
                min: 1
                nobind: 1
                text: '[\\(]'
            - !!perl/hash:RE_method
              min: 12345
              name: args
              rest: ''
          - !!perl/hash:RE_block
            alt: methodop_3 2
            min: 0
      min: 0
      quant:
      - '?'
methodop_0: *35
methodop_1: *36
methodop_2: *37
methodop_3: *38
methodop_4: *39
modifier_expr: !!perl/hash:RE_ast
  dba: modifier_expr
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: EXPR
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
module_name__S_039normal: !!perl/hash:RE_ast
  dba: module_name
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: longname
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12347
        re: !!perl/hash:RE_sequence
          min: 12347
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                min: 1
                text: '['
          - !!perl/hash:RE_bracket
            min: 12347
            re: !!perl/hash:RE_sequence
              min: 12347
              zyg:
              - !!perl/hash:RE_string
                i: 0
                min: 1
                text: '['
              - !!perl/hash:RE_block
                min: 0
              - !!perl/hash:RE_method
                min: 12345
                name: arglist
                rest: ''
              - !!perl/hash:RE_bracket
                min: 1
                re: !!perl/hash:RE_first
                  min: 1
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: ']'
                  - !!perl/hash:RE_method
                    min: 12345
                    name: FAILGOAL
                    rest: 1
      min: 0
      quant:
      - '?'
multi_declarator__S_058multi: !!perl/hash:RE_ast
  dba: multi_declarator
  min: 49380
  re: !!perl/hash:RE_sequence
    min: 49380
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: multi
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_first
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          min: 12345
          name: declarator
          rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: routine_def
          rest: 1
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
multi_declarator__S_059proto: !!perl/hash:RE_ast
  dba: multi_declarator
  min: 49380
  re: !!perl/hash:RE_sequence
    min: 49380
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: proto
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_first
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          min: 12345
          name: declarator
          rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: routine_def
          rest: 1
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
multi_declarator__S_060only: !!perl/hash:RE_ast
  dba: multi_declarator
  min: 49380
  re: !!perl/hash:RE_sequence
    min: 49380
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: only
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_first
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          min: 12345
          name: declarator
          rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: routine_def
          rest: 1
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
multi_declarator__S_061null: !!perl/hash:RE_ast
  dba: multi_declarator
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: declarator
    rest: ''
multisig: !!perl/hash:RE_ast
  dba: signature
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 37037
        re: !!perl/hash:RE_sequence
          min: 37037
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_string
              i: 0
              min: 1
              text: ':'
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_bracket
            min: 12347
            re: !!perl/hash:RE_sequence
              min: 12347
              zyg:
              - !!perl/hash:RE_string
                i: 0
                min: 1
                text: (
              - !!perl/hash:RE_block
                min: 0
              - !!perl/hash:RE_method
                min: 12345
                name: signature
                rest: 1
              - !!perl/hash:RE_bracket
                min: 1
                re: !!perl/hash:RE_first
                  min: 1
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: )
                  - !!perl/hash:RE_method
                    min: 12345
                    name: FAILGOAL
                    rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
      min: 12345
      quant:
      - '**'
      - ':'
      - !!perl/hash:RE_string
        a: 0
        dba: signature
        i: 0
        i_needed: 1
        min: 1
        r: 1
        s: 1
        text: '|'
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
named_param: !!perl/hash:RE_ast
  dba: named_param
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: ':'
    - !!perl/hash:RE_bracket
      min: 12345
      re: &40 !!perl/hash:RE_any
        altname: named_param_0
        dba: named_param
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          alt: named_param_0 0
          min: 37037
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              min: 12345
              name: identifier
              rest: ''
            min: 12345
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: (
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_bracket
            min: 12345
            re: &41 !!perl/hash:RE_any
              altname: named_param_1
              dba: named_param
              min: 12345
              zyg:
              - !!perl/hash:RE_method
                alt: named_param_1 0
                min: 12345
                name: named_param
                rest: ''
              - !!perl/hash:RE_sequence
                alt: named_param_1 1
                min: 24690
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: param_var
                  rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
          - !!perl/hash:RE_bracket
            min: 1
            re: !!perl/hash:RE_first
              min: 1
              zyg:
              - !!perl/hash:RE_string
                i: 0
                min: 1
                text: )
              - !!perl/hash:RE_method
                min: 12345
                name: panic
                rest: 1
        - !!perl/hash:RE_method
          alt: named_param_0 1
          min: 12345
          name: param_var
          rest: ''
named_param_0: *40
named_param_1: *41
nullterm: !!perl/hash:RE_ast
  dba: nullterm
  min: 0
  re: !!perl/hash:RE_assertion
    assert: '?'
    min: 0
    re: !!perl/hash:RE_noop
      min: 0
      nobind: 1
nulltermish: !!perl/hash:RE_ast
  dba: null term
  min: 0
  re: !!perl/hash:RE_bracket
    min: 0
    re: &42 !!perl/hash:RE_any
      altname: nulltermish_0
      dba: null term
      min: 0
      zyg:
      - !!perl/hash:RE_assertion
        alt: nulltermish_0 0
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method
          min: 12345
          name: stdstopper
          rest: ''
      - !!perl/hash:RE_sequence
        alt: nulltermish_0 1
        min: 12345
        zyg:
        - !!perl/hash:RE_bindnamed
          atom: !!perl/hash:RE_method
            min: 12345
            name: termish
            rest: ''
          min: 12345
        - !!perl/hash:RE_block
          min: 0
      - !!perl/hash:RE_assertion
        alt: nulltermish_0 2
        assert: '?'
        min: 0
        re: !!perl/hash:RE_noop
          min: 0
          nobind: 1
nulltermish_0: *42
number: !!perl/hash:RE_ast
  dba: number
  min: 3
  re: !!perl/hash:RE_bracket
    min: 3
    re: &43 !!perl/hash:RE_any
      altname: number_0
      dba: number
      min: 3
      zyg:
      - !!perl/hash:RE_sequence
        alt: number_0 0
        min: 3
        zyg:
        - !!perl/hash:RE_string
          i: 0
          min: 3
          text: 'NaN'
        - !!perl/hash:RE_meta
          min: 0
          text: »
      - !!perl/hash:RE_method
        alt: number_0 1
        min: 12345
        name: integer
        rest: ''
      - !!perl/hash:RE_method
        alt: number_0 2
        min: 12345
        name: dec_number
        rest: ''
      - !!perl/hash:RE_method
        alt: number_0 3
        min: 12345
        name: rad_number
        rest: ''
      - !!perl/hash:RE_sequence
        alt: number_0 4
        min: 3
        zyg:
        - !!perl/hash:RE_string
          i: 0
          min: 3
          text: 'Inf'
        - !!perl/hash:RE_meta
          min: 0
          text: »
number_0: *43
old_rx_mods: !!perl/hash:RE_ast
  dba: old_rx_mods
  min: 1
  re: !!perl/hash:RE_sequence
    min: 1
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: after
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        min: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_qw
            min: 1
            text: < i g s m x c e >
          min: 1
          quant:
          - +
      min: 1
    - !!perl/hash:RE_block
      min: 0
old_tr_mods: !!perl/hash:RE_ast
  dba: old_tr_mods
  min: 1
  re: !!perl/hash:RE_sequence
    min: 1
    zyg:
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        min: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_qw
            min: 1
            text: < c d s ] >
          min: 1
          quant:
          - +
      min: 1
    - !!perl/hash:RE_block
      min: 0
package_declarator__S_048class: !!perl/hash:RE_ast
  dba: package_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: class
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: package_def
      rest: ''
package_declarator__S_049grammar: !!perl/hash:RE_ast
  dba: package_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: grammar
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: package_def
      rest: ''
package_declarator__S_050module: !!perl/hash:RE_ast
  dba: package_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: module
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: package_def
      rest: ''
package_declarator__S_051package: !!perl/hash:RE_ast
  dba: package_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: package
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: package_def
      rest: ''
package_declarator__S_052role: !!perl/hash:RE_ast
  dba: package_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: role
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: package_def
      rest: ''
package_declarator__S_053knowhow: !!perl/hash:RE_ast
  dba: package_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: knowhow
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: package_def
      rest: ''
package_declarator__S_054slang: !!perl/hash:RE_ast
  dba: package_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: slang
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: package_def
      rest: ''
package_declarator__S_055require: !!perl/hash:RE_ast
  dba: package_declarator
  min: 49380
  re: !!perl/hash:RE_sequence
    min: 49380
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: require
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_first
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: module_name
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              min: 12345
              name: EXPR
              rest: ''
            min: 0
            quant:
            - '?'
        - !!perl/hash:RE_method
          min: 12345
          name: EXPR
          rest: ''
package_declarator__S_056trusts: !!perl/hash:RE_ast
  dba: package_declarator
  min: 49380
  re: !!perl/hash:RE_sequence
    min: 49380
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: trusts
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: module_name
      rest: ''
package_declarator__S_057does: !!perl/hash:RE_ast
  dba: package_declarator
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: does
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: typename
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
package_def: !!perl/hash:RE_ast
  dba: package_def
  min: 37035
  re: !!perl/hash:RE_first
    min: 37035
    zyg:
    - !!perl/hash:RE_sequence
      min: 283935
      zyg:
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
      - !!perl/hash:RE_block
        min: 0
      - !!perl/hash:RE_bracket
        min: 148140
        re: !!perl/hash:RE_sequence
          min: 148140
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 49380
              re: !!perl/hash:RE_sequence
                min: 49380
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: longname
                  rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_block
                  min: 0
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: newpad
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 74072
              re: !!perl/hash:RE_sequence
                min: 74072
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_block
                    min: 0
                    nobind: 1
                - !!perl/hash:RE_bracket
                  min: 12347
                  re: !!perl/hash:RE_sequence
                    min: 12347
                    zyg:
                    - !!perl/hash:RE_string
                      i: 0
                      min: 1
                      text: '['
                    - !!perl/hash:RE_block
                      min: 0
                    - !!perl/hash:RE_method
                      min: 12345
                      name: signature
                      rest: ''
                    - !!perl/hash:RE_bracket
                      min: 1
                      re: !!perl/hash:RE_first
                        min: 1
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          min: 1
                          text: ']'
                        - !!perl/hash:RE_method
                          min: 12345
                          name: FAILGOAL
                          rest: 1
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_block
                  min: 0
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              min: 12345
              name: trait
              rest: ''
            min: 0
            quant:
            - '*'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: getdecl
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_bracket
            min: 37035
            re: !!perl/hash:RE_first
              min: 37035
              zyg:
              - !!perl/hash:RE_sequence
                min: 111105
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_sequence
                      min: 12346
                      zyg:
                      - !!perl/hash:RE_method
                        min: 12345
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        min: 1
                        text: '{'
                - !!perl/hash:RE_bracket
                  min: 74070
                  re: !!perl/hash:RE_sequence
                    min: 74070
                    zyg:
                    - !!perl/hash:RE_block
                      min: 0
                    - !!perl/hash:RE_method
                      min: 12345
                      name: blockoid
                      rest: ''
                    - !!perl/hash:RE_method
                      min: 12345
                      name: ws
                      rest: ''
                    - !!perl/hash:RE_method
                      min: 12345
                      name: checkyada
                      rest: ''
                    - !!perl/hash:RE_method
                      min: 12345
                      name: ws
                      rest: ''
              - !!perl/hash:RE_sequence
                min: 74070
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_sequence
                      min: 12346
                      zyg:
                      - !!perl/hash:RE_method
                        min: 12345
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        min: 1
                        text: ;
                - !!perl/hash:RE_bracket
                  min: 37035
                  re: !!perl/hash:RE_first
                    min: 37035
                    zyg:
                    - !!perl/hash:RE_sequence
                      min: 61725
                      zyg:
                      - !!perl/hash:RE_assertion
                        assert: '?'
                        min: 0
                        re: !!perl/hash:RE_block
                          min: 0
                          nobind: 1
                      - !!perl/hash:RE_block
                        min: 0
                      - !!perl/hash:RE_method
                        min: 12345
                        name: statementlist
                        rest: ''
                      - !!perl/hash:RE_method
                        min: 12345
                        name: ws
                        rest: ''
                    - !!perl/hash:RE_sequence
                      min: 37035
                      zyg:
                      - !!perl/hash:RE_method
                        min: 12345
                        name: panic
                        rest: 1
                      - !!perl/hash:RE_method
                        min: 12345
                        name: ws
                        rest: ''
              - !!perl/hash:RE_sequence
                min: 37035
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: panic
                  rest: 1
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
    - !!perl/hash:RE_sequence
      min: 37035
      zyg:
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        min: 12345
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
param_sep: !!perl/hash:RE_ast
  dba: param_sep
  min: 24691
  re: !!perl/hash:RE_sequence
    min: 24691
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 1
      re: &44 !!perl/hash:RE_any
        altname: param_sep_0
        dba: param_sep
        min: 1
        zyg:
        - !!perl/hash:RE_string
          alt: param_sep_0 0
          i: 0
          min: 1
          text: ','
        - !!perl/hash:RE_string
          alt: param_sep_0 1
          i: 0
          min: 1
          text: ':'
        - !!perl/hash:RE_string
          alt: param_sep_0 2
          i: 0
          min: 1
          text: ;
        - !!perl/hash:RE_string
          alt: param_sep_0 3
          i: 0
          min: 2
          text: ;;
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
param_sep_0: *44
param_var: !!perl/hash:RE_ast
  dba: formal parameter
  min: 12345
  re: !!perl/hash:RE_bracket
    min: 12345
    re: &45 !!perl/hash:RE_any
      altname: param_var_0
      dba: formal parameter
      min: 12345
      zyg:
      - !!perl/hash:RE_bracket
        alt: param_var_0 0
        min: 12347
        re: !!perl/hash:RE_sequence
          min: 12347
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: '['
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: signature
            rest: ''
          - !!perl/hash:RE_bracket
            min: 1
            re: !!perl/hash:RE_first
              min: 1
              zyg:
              - !!perl/hash:RE_string
                i: 0
                min: 1
                text: ']'
              - !!perl/hash:RE_method
                min: 12345
                name: FAILGOAL
                rest: 1
      - !!perl/hash:RE_bracket
        alt: param_var_0 1
        min: 12347
        re: !!perl/hash:RE_sequence
          min: 12347
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: (
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: signature
            rest: ''
          - !!perl/hash:RE_bracket
            min: 1
            re: !!perl/hash:RE_first
              min: 1
              zyg:
              - !!perl/hash:RE_string
                i: 0
                min: 1
                text: )
              - !!perl/hash:RE_method
                min: 12345
                name: FAILGOAL
                rest: 1
      - !!perl/hash:RE_sequence
        alt: param_var_0 2
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          min: 12345
          name: sigil
          rest: ''
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            min: 12345
            name: twigil
            rest: ''
          min: 0
          quant:
          - '?'
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_bracket
            min: 1
            re: !!perl/hash:RE_first
              min: 1
              zyg:
              - !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_block
                    min: 0
                    nobind: 1
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method
                    min: 12345
                    name: ident
                    rest: ''
                - !!perl/hash:RE_block
                  min: 0
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: sublongname
                    rest: ''
                  min: 12345
              - !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_block
                    min: 0
                    nobind: 1
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bindnamed
                    atom: !!perl/hash:RE_method
                      min: 12345
                      name: identifier
                      rest: ''
                    min: 12345
                  min: 0
                  quant:
                  - '?'
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_cclass
                      i: 0
                      min: 1
                      text: '[ \< \( \[ \{ ]'
                - !!perl/hash:RE_method
                  min: 12345
                  name: postcircumfix
                  rest: ''
              - !!perl/hash:RE_bindnamed
                atom: !!perl/hash:RE_method
                  min: 12345
                  name: identifier
                  rest: ''
                min: 12345
              - !!perl/hash:RE_bindnamed
                atom: !!perl/hash:RE_bracket
                  min: 1
                  re: !!perl/hash:RE_cclass
                    i: 0
                    min: 1
                    text: '[/!]'
                min: 1
          min: 0
          quant:
          - '?'
        - !!perl/hash:RE_block
          min: 0
param_var_0: *45
parameter: !!perl/hash:RE_ast
  dba: parameter
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_bracket
      min: 12345
      re: &46 !!perl/hash:RE_any
        altname: parameter_0
        dba: parameter
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          alt: parameter_0 0
          min: 12345
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              min: 12345
              name: type_constraint
              rest: ''
            min: 12345
            quant:
            - +
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_bracket
            min: 0
            re: &47 !!perl/hash:RE_any
              altname: parameter_1
              dba: parameter
              min: 0
              zyg:
              - !!perl/hash:RE_sequence
                alt: parameter_1 0
                min: 12347
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 2
                  text: '**'
                - !!perl/hash:RE_method
                  min: 12345
                  name: param_var
                  rest: ''
                - !!perl/hash:RE_block
                  min: 0
              - !!perl/hash:RE_sequence
                alt: parameter_1 1
                min: 12346
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: '*'
                - !!perl/hash:RE_method
                  min: 12345
                  name: param_var
                  rest: ''
                - !!perl/hash:RE_block
                  min: 0
              - !!perl/hash:RE_sequence
                alt: parameter_1 2
                min: 12346
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: '|'
                - !!perl/hash:RE_method
                  min: 12345
                  name: param_var
                  rest: ''
                - !!perl/hash:RE_block
                  min: 0
              - !!perl/hash:RE_sequence
                alt: parameter_1 3
                min: 12346
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: \
                - !!perl/hash:RE_method
                  min: 12345
                  name: param_var
                  rest: ''
                - !!perl/hash:RE_block
                  min: 0
              - !!perl/hash:RE_sequence
                alt: parameter_1 4
                min: 12345
                zyg:
                - !!perl/hash:RE_bracket
                  min: 12345
                  re: &48 !!perl/hash:RE_any
                    altname: parameter_2
                    dba: parameter
                    min: 12345
                    zyg:
                    - !!perl/hash:RE_sequence
                      alt: parameter_2 0
                      min: 12345
                      zyg:
                      - !!perl/hash:RE_method
                        min: 12345
                        name: param_var
                        rest: ''
                      - !!perl/hash:RE_block
                        min: 0
                    - !!perl/hash:RE_sequence
                      alt: parameter_2 1
                      min: 12345
                      zyg:
                      - !!perl/hash:RE_method
                        min: 12345
                        name: named_param
                        rest: ''
                      - !!perl/hash:RE_block
                        min: 0
                - !!perl/hash:RE_bracket
                  min: 0
                  re: &49 !!perl/hash:RE_any
                    altname: parameter_3
                    dba: parameter
                    min: 0
                    zyg:
                    - !!perl/hash:RE_sequence
                      alt: parameter_3 0
                      min: 1
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        min: 1
                        text: '?'
                      - !!perl/hash:RE_block
                        min: 0
                    - !!perl/hash:RE_sequence
                      alt: parameter_3 1
                      min: 1
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        min: 1
                        text: '!'
                      - !!perl/hash:RE_block
                        min: 0
                    - !!perl/hash:RE_assertion
                      alt: parameter_3 2
                      assert: '?'
                      min: 0
                      re: !!perl/hash:RE_noop
                        min: 0
                        nobind: 1
              - !!perl/hash:RE_sequence
                alt: parameter_1 5
                min: 0
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_noop
                    min: 0
                    nobind: 1
                - !!perl/hash:RE_block
                  min: 0
        - !!perl/hash:RE_sequence
          alt: parameter_0 1
          min: 12347
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 2
            text: '**'
          - !!perl/hash:RE_method
            min: 12345
            name: param_var
            rest: ''
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          alt: parameter_0 2
          min: 12346
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: '*'
          - !!perl/hash:RE_method
            min: 12345
            name: param_var
            rest: ''
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          alt: parameter_0 3
          min: 12346
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: '|'
          - !!perl/hash:RE_method
            min: 12345
            name: param_var
            rest: ''
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          alt: parameter_0 4
          min: 12346
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: \
          - !!perl/hash:RE_method
            min: 12345
            name: param_var
            rest: ''
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          alt: parameter_0 5
          min: 12345
          zyg:
          - !!perl/hash:RE_bracket
            min: 12345
            re: &50 !!perl/hash:RE_any
              altname: parameter_4
              dba: parameter
              min: 12345
              zyg:
              - !!perl/hash:RE_sequence
                alt: parameter_4 0
                min: 12345
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: param_var
                  rest: ''
                - !!perl/hash:RE_block
                  min: 0
              - !!perl/hash:RE_sequence
                alt: parameter_4 1
                min: 12345
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: named_param
                  rest: ''
                - !!perl/hash:RE_block
                  min: 0
          - !!perl/hash:RE_bracket
            min: 0
            re: &51 !!perl/hash:RE_any
              altname: parameter_5
              dba: parameter
              min: 0
              zyg:
              - !!perl/hash:RE_sequence
                alt: parameter_5 0
                min: 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: '?'
                - !!perl/hash:RE_block
                  min: 0
              - !!perl/hash:RE_sequence
                alt: parameter_5 1
                min: 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: '!'
                - !!perl/hash:RE_block
                  min: 0
              - !!perl/hash:RE_assertion
                alt: parameter_5 2
                assert: '?'
                min: 0
                re: !!perl/hash:RE_noop
                  min: 0
                  nobind: 1
        - !!perl/hash:RE_sequence
          alt: parameter_0 6
          min: 24690
          zyg:
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: longname
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: trait
        rest: ''
      min: 0
      quant:
      - '*'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: post_constraint
        rest: ''
      min: 0
      quant:
      - '*'
    - !!perl/hash:RE_method
      min: 12345
      name: getdecl
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: default_value
            rest: ''
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 12345
              re: !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      min: 1
                      text: ':'
                - !!perl/hash:RE_method
                  min: 12345
                  name: sorry
                  rest: 1
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 12345
              re: !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '!'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_cclass
                      i: 0
                      min: 1
                      text: '[,;)\]\{\-]'
                - !!perl/hash:RE_method
                  min: 12345
                  name: sorry
                  rest: 1
            min: 0
            quant:
            - '?'
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                min: 1
                text: ':'
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
          - !!perl/hash:RE_method
            min: 12345
            name: sorry
            rest: 1
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_block
      min: 0
parameter_0: *46
parameter_1: *47
parameter_2: *48
parameter_3: *49
parameter_4: *50
parameter_5: *51
pblock: !!perl/hash:RE_ast
  dba: parameterized block
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: &52 !!perl/hash:RE_any
              altname: pblock_0
              dba: parameterized block
              min: 1
              zyg:
              - !!perl/hash:RE_method
                alt: pblock_0 0
                min: 12345
                name: lambda
                rest: ''
              - !!perl/hash:RE_string
                alt: pblock_0 1
                i: 0
                min: 1
                text: '{'
        - !!perl/hash:RE_block
          min: 0
    - !!perl/hash:RE_bracket
      min: 37035
      re: &53 !!perl/hash:RE_any
        altname: pblock_1
        dba: parameterized block
        min: 37035
        zyg:
        - !!perl/hash:RE_sequence
          alt: pblock_1 0
          min: 61725
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: lambda
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: newpad
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: signature
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: blockoid
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: getsig
            rest: ''
        - !!perl/hash:RE_sequence
          alt: pblock_1 1
          min: 37035
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                min: 1
                text: '{'
          - !!perl/hash:RE_method
            min: 12345
            name: newpad
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: blockoid
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: getsig
            rest: ''
pblock_0: *52
pblock_1: *53
post_constraint: !!perl/hash:RE_ast
  dba: constraint
  min: 86417
  re: !!perl/hash:RE_sequence
    min: 86417
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 37037
      re: &54 !!perl/hash:RE_any
        altname: post_constraint_0
        dba: constraint
        min: 37037
        zyg:
        - !!perl/hash:RE_sequence
          alt: post_constraint_0 0
          min: 37037
          zyg:
          - !!perl/hash:RE_bracket
            min: 12347
            re: !!perl/hash:RE_sequence
              min: 12347
              zyg:
              - !!perl/hash:RE_string
                i: 0
                min: 1
                text: '['
              - !!perl/hash:RE_block
                min: 0
              - !!perl/hash:RE_method
                min: 12345
                name: signature
                rest: ''
              - !!perl/hash:RE_bracket
                min: 1
                re: !!perl/hash:RE_first
                  min: 1
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: ']'
                  - !!perl/hash:RE_method
                    min: 12345
                    name: FAILGOAL
                    rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          alt: post_constraint_0 1
          min: 37037
          zyg:
          - !!perl/hash:RE_bracket
            min: 12347
            re: !!perl/hash:RE_sequence
              min: 12347
              zyg:
              - !!perl/hash:RE_string
                i: 0
                min: 1
                text: (
              - !!perl/hash:RE_block
                min: 0
              - !!perl/hash:RE_method
                min: 12345
                name: signature
                rest: ''
              - !!perl/hash:RE_bracket
                min: 1
                re: !!perl/hash:RE_first
                  min: 1
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: )
                  - !!perl/hash:RE_method
                    min: 12345
                    name: FAILGOAL
                    rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          alt: post_constraint_0 2
          min: 49385
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: w
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: h
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: e
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: r
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: e
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: EXPR
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
post_constraint_0: *54
postcircumfix__S_207Paren_Thesis: !!perl/hash:RE_ast
  dba: argument list
  min: 24692
  re: !!perl/hash:RE_sequence
    min: 24692
    zyg:
    - !!perl/hash:RE_bracket
      min: 12347
      re: !!perl/hash:RE_sequence
        min: 12347
        zyg:
        - !!perl/hash:RE_string
          i: 0
          min: 1
          text: (
        - !!perl/hash:RE_block
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: semiarglist
          rest: ''
        - !!perl/hash:RE_bracket
          min: 1
          re: !!perl/hash:RE_first
            min: 1
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: )
            - !!perl/hash:RE_method
              min: 12345
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
postcircumfix__S_208Bra_Ket: !!perl/hash:RE_ast
  dba: subscript
  min: 24692
  re: !!perl/hash:RE_sequence
    min: 24692
    zyg:
    - !!perl/hash:RE_bracket
      min: 12347
      re: !!perl/hash:RE_sequence
        min: 12347
        zyg:
        - !!perl/hash:RE_string
          i: 0
          min: 1
          text: '['
        - !!perl/hash:RE_block
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: semilist
          rest: ''
        - !!perl/hash:RE_bracket
          min: 1
          re: !!perl/hash:RE_first
            min: 1
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: ']'
            - !!perl/hash:RE_method
              min: 12345
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
postcircumfix__S_209Cur_Ly: !!perl/hash:RE_ast
  dba: subscript
  min: 37037
  re: !!perl/hash:RE_sequence
    min: 37037
    zyg:
    - !!perl/hash:RE_bracket
      min: 12347
      re: !!perl/hash:RE_sequence
        min: 12347
        zyg:
        - !!perl/hash:RE_string
          i: 0
          min: 1
          text: '{'
        - !!perl/hash:RE_block
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: semilist
          rest: ''
        - !!perl/hash:RE_bracket
          min: 1
          re: !!perl/hash:RE_first
            min: 1
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: '}'
            - !!perl/hash:RE_method
              min: 12345
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: curlycheck
      rest: ''
postcircumfix__S_210Lt_Gt: !!perl/hash:RE_ast
  dba: postcircumfix
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: <
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_sequence
          min: 12346
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: nibble
            rest: 1
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: '>'
        - !!perl/hash:RE_sequence
          min: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                min: 1
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  min: 0
                  quant:
                  - '*'
                - !!perl/hash:RE_bracket
                  min: 1
                  re: &55 !!perl/hash:RE_any
                    altname: postcircumfix__S_210Lt_Gt_0
                    dba: postcircumfix
                    min: 1
                    zyg:
                    - !!perl/hash:RE_meta
                      alt: postcircumfix__S_210Lt_Gt_0 0
                      min: 1
                      text: \d
                    - !!perl/hash:RE_method
                      alt: postcircumfix__S_210Lt_Gt_0 1
                      min: 12345
                      name: sigil
                      rest: ''
                    - !!perl/hash:RE_string
                      alt: postcircumfix__S_210Lt_Gt_0 2
                      i: 0
                      min: 1
                      text: ':'
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_block
          min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
postcircumfix__S_210Lt_Gt_0: *55
postcircumfix__S_211LtLt_GtGt: !!perl/hash:RE_ast
  dba: postcircumfix
  min: 24694
  re: !!perl/hash:RE_sequence
    min: 24694
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: <<
    - !!perl/hash:RE_method
      min: 12345
      name: nibble
      rest: 1
    - !!perl/hash:RE_bracket
      min: 2
      re: !!perl/hash:RE_first
        min: 2
        zyg:
        - !!perl/hash:RE_string
          i: 0
          min: 2
          text: '>>'
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
postcircumfix__S_212Fre_Nch: !!perl/hash:RE_ast
  dba: postcircumfix
  min: 24692
  re: !!perl/hash:RE_sequence
    min: 24692
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: «
    - !!perl/hash:RE_method
      min: 12345
      name: nibble
      rest: 1
    - !!perl/hash:RE_bracket
      min: 1
      re: !!perl/hash:RE_first
        min: 1
        zyg:
        - !!perl/hash:RE_string
          i: 0
          min: 1
          text: »
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
postfix__S_215i: !!perl/hash:RE_ast
  dba: postfix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: i
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
postfix__S_217MinusGt: !!perl/hash:RE_ast
  dba: postfix
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: ->
    - !!perl/hash:RE_bracket
      min: 12345
      re: &56 !!perl/hash:RE_any
        altname: postfix__S_217MinusGt_0
        dba: postfix
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          alt: postfix__S_217MinusGt_0 0
          min: 12346
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_cclass
              i: 0
              min: 1
              text: '[ \[ \{ \( ]'
            min: 1
          - !!perl/hash:RE_method
            min: 12345
            name: obs
            rest: 1
        - !!perl/hash:RE_method
          alt: postfix__S_217MinusGt_0 1
          min: 12345
          name: obs
          rest: 1
postfix__S_217MinusGt_0: *56
postfix__S_218PlusPlus: !!perl/hash:RE_ast
  dba: postfix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ++
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
postfix__S_219MinusMinus: !!perl/hash:RE_ast
  dba: postfix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: --
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
postfix_prefix_meta_operator__S_198Nch: !!perl/hash:RE_ast
  dba: postfix_prefix_meta_operator
  min: 2
  re: !!perl/hash:RE_sequence
    min: 2
    zyg:
    - !!perl/hash:RE_bracket
      min: 2
      re: &57 !!perl/hash:RE_any
        altname: postfix_prefix_meta_operator__S_198Nch_0
        dba: postfix_prefix_meta_operator
        min: 2
        zyg:
        - !!perl/hash:RE_method
          alt: postfix_prefix_meta_operator__S_198Nch_0 0
          i: 0
          min: 12345
          name: sym
          rest: ''
          sym: »
        - !!perl/hash:RE_string
          alt: postfix_prefix_meta_operator__S_198Nch_0 1
          i: 0
          min: 2
          text: '>>'
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_block
            min: 0
            nobind: 1
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 1
              text: (
postfix_prefix_meta_operator__S_198Nch_0: *57
postop: !!perl/hash:RE_ast
  dba: postop
  min: 12345
  re: &58 !!perl/hash:RE_any
    altname: postop_0
    dba: postop
    min: 12345
    zyg:
    - !!perl/hash:RE_sequence
      alt: postop_0 0
      min: 12345
      zyg:
      - !!perl/hash:RE_method
        min: 12345
        name: postfix
        rest: ''
      - !!perl/hash:RE_block
        min: 0
    - !!perl/hash:RE_sequence
      alt: postop_0 1
      min: 12345
      zyg:
      - !!perl/hash:RE_method
        min: 12345
        name: postcircumfix
        rest: ''
      - !!perl/hash:RE_block
        min: 0
postop_0: *58
prefix__S_220PlusPlus: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ++
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_221MinusMinus: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: --
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_223Bang: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '!'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_224Plus: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: +
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_225Minus: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '-'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_226TildeTilde: !!perl/hash:RE_ast
  dba: prefix
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ~~
    - !!perl/hash:RE_method
      min: 12345
      name: badinfix
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_227Tilde: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '~'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_228QuestionQuestion: !!perl/hash:RE_ast
  dba: prefix
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ??
    - !!perl/hash:RE_method
      min: 12345
      name: badinfix
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_229Question: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '?'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_230TildeCaret: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ~^
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_231PlusCaret: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: +^
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_232QuestionCaret: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ?^
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_233CaretCaret: !!perl/hash:RE_ast
  dba: prefix
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ^^
    - !!perl/hash:RE_method
      min: 12345
      name: badinfix
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_234Caret: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ^
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_235VertVert: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '||'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_236Vert: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '|'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_265sleep: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: sleep
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \s
          min: 0
          quant:
          - '*'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_266abs: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: abs
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \s
          min: 0
          quant:
          - '*'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_267let: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: let
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \s
          min: 0
          quant:
          - '*'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_268temp: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: temp
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \s
          min: 0
          quant:
          - '*'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_320so: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: so
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix__S_321not: !!perl/hash:RE_ast
  dba: prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: not
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
prefix_circumfix_meta_operator__S_196reduce: !!perl/hash:RE_ast
  dba: prefix_circumfix_meta_operator
  min: 24692
  re: !!perl/hash:RE_sequence
    min: 24692
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          min: 3
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: '['
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \S
            min: 1
            quant:
            - +
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: ']'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_paren
        min: 2
        re: !!perl/hash:RE_sequence
          min: 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: '['
          - !!perl/hash:RE_bracket
            min: 0
            re: !!perl/hash:RE_first
              min: 0
              zyg:
              - !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: infixish
                    rest: 1
                  min: 12345
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      min: 1
                      text: ']'
              - !!perl/hash:RE_sequence
                min: 12346
                zyg:
                - !!perl/hash:RE_meta
                  min: 1
                  text: \\
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: infixish
                    rest: 1
                  min: 12345
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      min: 1
                      text: ']'
              - !!perl/hash:RE_assertion
                assert: '!'
                min: 0
                re: !!perl/hash:RE_noop
                  min: 0
                  nobind: 1
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: ']'
          - !!perl/hash:RE_bracket
            min: 0
            re: &59 !!perl/hash:RE_any
              altname: prefix_circumfix_meta_operator__S_196reduce_0
              dba: prefix_circumfix_meta_operator
              min: 0
              zyg:
              - !!perl/hash:RE_string
                alt: prefix_circumfix_meta_operator__S_196reduce_0 0
                i: 0
                min: 1
                text: «
              - !!perl/hash:RE_assertion
                alt: prefix_circumfix_meta_operator__S_196reduce_0 1
                assert: '?'
                min: 0
                re: !!perl/hash:RE_noop
                  min: 0
                  nobind: 1
      min: 2
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: can_meta
      rest: 1
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_block
            min: 0
            nobind: 1
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_block
            min: 0
            nobind: 1
        - !!perl/hash:RE_method
          min: 12345
          name: sorry
          rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 1
              text: (
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              min: 1
              zyg:
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \s
                min: 1
                quant:
                - +
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_bracket
                  min: 0
                  re: !!perl/hash:RE_sequence
                    min: 0
                    zyg:
                    - !!perl/hash:RE_assertion
                      assert: '?'
                      min: 0
                      re: !!perl/hash:RE_method
                        min: 12345
                        name: stdstopper
                        rest: ''
                    - !!perl/hash:RE_block
                      min: 0
                min: 0
                quant:
                - '?'
        - !!perl/hash:RE_block
          min: 0
prefix_circumfix_meta_operator__S_196reduce_0: *59
prefix_postfix_meta_operator__S_197Fre: !!perl/hash:RE_ast
  dba: prefix_postfix_meta_operator
  min: 2
  re: &60 !!perl/hash:RE_any
    altname: prefix_postfix_meta_operator__S_197Fre_0
    dba: prefix_postfix_meta_operator
    min: 2
    zyg:
    - !!perl/hash:RE_method
      alt: prefix_postfix_meta_operator__S_197Fre_0 0
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: «
    - !!perl/hash:RE_string
      alt: prefix_postfix_meta_operator__S_197Fre_0 1
      i: 0
      min: 2
      text: <<
prefix_postfix_meta_operator__S_197Fre_0: *60
privop: !!perl/hash:RE_ast
  dba: privop
  min: 24691
  re: !!perl/hash:RE_sequence
    min: 24691
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: '!'
    - !!perl/hash:RE_method
      min: 12345
      name: methodop
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
quasiquibble: !!perl/hash:RE_ast
  dba: quasiquibble
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: babble
      rest: 1
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_first
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
          - !!perl/hash:RE_bracket
            min: 12345
            re: !!perl/hash:RE_sequence
              min: 12345
              zyg:
              - !!perl/hash:RE_decl
                min: 0
              - !!perl/hash:RE_method
                min: 12345
                name: block
                rest: ''
        - !!perl/hash:RE_bracket
          min: 37035
          re: !!perl/hash:RE_sequence
            min: 37035
            zyg:
            - !!perl/hash:RE_decl
              min: 0
            - !!perl/hash:RE_method
              min: 12345
              name: starter
              rest: ''
            - !!perl/hash:RE_method
              min: 12345
              name: statementlist
              rest: ''
            - !!perl/hash:RE_bracket
              min: 12345
              re: !!perl/hash:RE_first
                min: 12345
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: stopper
                  rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: panic
                  rest: 1
quote__S_141SlashSlash: !!perl/hash:RE_ast
  dba: quote
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: /
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \s
      min: 0
      quant:
      - '*'
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: /
    - !!perl/hash:RE_method
      min: 12345
      name: sorry
      rest: 1
quote__S_142Slash_Slash: !!perl/hash:RE_ast
  dba: quote
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: /
    - !!perl/hash:RE_method
      min: 12345
      name: nibble
      rest: 1
    - !!perl/hash:RE_bracket
      min: 1
      re: !!perl/hash:RE_first
        min: 1
        zyg:
        - !!perl/hash:RE_string
          i: 0
          min: 1
          text: /
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: old_rx_mods
        rest: ''
      min: 0
      quant:
      - '?'
quote__S_143qq: !!perl/hash:RE_ast
  dba: quote
  min: 24692
  re: !!perl/hash:RE_sequence
    min: 24692
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: qq
    - !!perl/hash:RE_bracket
      min: 24690
      re: &61 !!perl/hash:RE_any
        altname: quote__S_143qq_0
        dba: quote
        min: 24690
        zyg:
        - !!perl/hash:RE_sequence
          alt: quote__S_143qq_0 0
          min: 37035
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: quote_mod
            rest: ''
          - !!perl/hash:RE_meta
            min: 0
            text: »
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                min: 1
                text: (
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: quibble
            rest: 1
        - !!perl/hash:RE_sequence
          alt: quote__S_143qq_0 1
          min: 24690
          zyg:
          - !!perl/hash:RE_meta
            min: 0
            text: »
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                min: 1
                text: (
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: quibble
            rest: 1
quote__S_143qq_0: *61
quote__S_144q: !!perl/hash:RE_ast
  dba: quote
  min: 24691
  re: !!perl/hash:RE_sequence
    min: 24691
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: q
    - !!perl/hash:RE_bracket
      min: 24690
      re: &62 !!perl/hash:RE_any
        altname: quote__S_144q_0
        dba: quote
        min: 24690
        zyg:
        - !!perl/hash:RE_sequence
          alt: quote__S_144q_0 0
          min: 24690
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: quote_mod
            rest: ''
          - !!perl/hash:RE_meta
            min: 0
            text: »
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                min: 1
                text: (
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: quibble
            rest: 1
        - !!perl/hash:RE_sequence
          alt: quote__S_144q_0 1
          min: 24690
          zyg:
          - !!perl/hash:RE_meta
            min: 0
            text: »
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                min: 1
                text: (
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: quibble
            rest: 1
quote__S_144q_0: *62
quote__S_145Q: !!perl/hash:RE_ast
  dba: quote
  min: 24691
  re: !!perl/hash:RE_sequence
    min: 24691
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: Q
    - !!perl/hash:RE_bracket
      min: 24690
      re: &63 !!perl/hash:RE_any
        altname: quote__S_145Q_0
        dba: quote
        min: 24690
        zyg:
        - !!perl/hash:RE_sequence
          alt: quote__S_145Q_0 0
          min: 24690
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: quote_mod
            rest: ''
          - !!perl/hash:RE_meta
            min: 0
            text: »
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                min: 1
                text: (
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: quibble
            rest: 1
        - !!perl/hash:RE_sequence
          alt: quote__S_145Q_0 1
          min: 24690
          zyg:
          - !!perl/hash:RE_meta
            min: 0
            text: »
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                min: 1
                text: (
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: quibble
            rest: 1
quote__S_145Q_0: *63
quote__S_157rx: !!perl/hash:RE_ast
  dba: quote
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: rx
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: (
    - !!perl/hash:RE_method
      min: 12345
      name: quibble
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        min: 12345
        name: old_rx_mods
        rest: ''
quote__S_158m: !!perl/hash:RE_ast
  dba: quote
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: m
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: (
    - !!perl/hash:RE_method
      min: 12345
      name: quibble
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        min: 12345
        name: old_rx_mods
        rest: ''
quote__S_159mm: !!perl/hash:RE_ast
  dba: quote
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: mm
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: (
    - !!perl/hash:RE_method
      min: 12345
      name: quibble
      rest: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        min: 12345
        name: old_rx_mods
        rest: ''
quote__S_160s: !!perl/hash:RE_ast
  dba: quote
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: s
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: (
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        min: 12345
        name: sibble
        rest: 1
      min: 12345
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        min: 12345
        name: old_rx_mods
        rest: ''
quote__S_161ss: !!perl/hash:RE_ast
  dba: quote
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ss
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: (
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        min: 12345
        name: sibble
        rest: 1
      min: 12345
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        min: 12345
        name: old_rx_mods
        rest: ''
quote__S_162tr: !!perl/hash:RE_ast
  dba: quote
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: tr
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: (
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        min: 12345
        name: tribble
        rest: 1
      min: 12345
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        min: 12345
        name: old_tr_mods
        rest: ''
quote__S_163y: !!perl/hash:RE_ast
  dba: quote
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: y
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_block
        min: 0
        nobind: 1
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: (
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          min: 1
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            min: 0
            quant:
            - '*'
          - !!perl/hash:RE_meta
            min: 1
            text: \W
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
quote__S_164quasi: !!perl/hash:RE_ast
  dba: quote
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: quasi
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: (
    - !!perl/hash:RE_method
      min: 12345
      name: quasiquibble
      rest: 1
quote_mod__S_146w: !!perl/hash:RE_ast
  dba: quote_mod
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: w
quote_mod__S_147ww: !!perl/hash:RE_ast
  dba: quote_mod
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: ww
quote_mod__S_148p: !!perl/hash:RE_ast
  dba: quote_mod
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: p
quote_mod__S_149x: !!perl/hash:RE_ast
  dba: quote_mod
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: x
quote_mod__S_150to: !!perl/hash:RE_ast
  dba: quote_mod
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: to
quote_mod__S_151s: !!perl/hash:RE_ast
  dba: quote_mod
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: s
quote_mod__S_152a: !!perl/hash:RE_ast
  dba: quote_mod
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: a
quote_mod__S_153h: !!perl/hash:RE_ast
  dba: quote_mod
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: h
quote_mod__S_154f: !!perl/hash:RE_ast
  dba: quote_mod
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: f
quote_mod__S_155c: !!perl/hash:RE_ast
  dba: quote_mod
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: c
quote_mod__S_156b: !!perl/hash:RE_ast
  dba: quote_mod
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: b
regex_block: !!perl/hash:RE_ast
  dba: regex_block
  min: 24692
  re: !!perl/hash:RE_sequence
    min: 24692
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 24690
        re: !!perl/hash:RE_sequence
          min: 24690
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: quotepair
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_block
            min: 0
      min: 0
      quant:
      - '*'
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: '{'
    - !!perl/hash:RE_method
      min: 12345
      name: nibble
      rest: 1
    - !!perl/hash:RE_bracket
      min: 1
      re: !!perl/hash:RE_first
        min: 1
        zyg:
        - !!perl/hash:RE_string
          i: 0
          min: 1
          text: '}'
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: curlycheck
      rest: ''
regex_declarator__S_066regex: !!perl/hash:RE_ast
  dba: regex_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: regex
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: regex_def
      rest: 1
regex_declarator__S_067token: !!perl/hash:RE_ast
  dba: regex_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: token
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: regex_def
      rest: 1
regex_declarator__S_068rule: !!perl/hash:RE_ast
  dba: regex_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: rule
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: regex_def
      rest: 1
regex_def: !!perl/hash:RE_ast
  dba: regex_def
  min: 37035
  re: !!perl/hash:RE_first
    min: 37035
    zyg:
    - !!perl/hash:RE_sequence
      min: 234555
      zyg:
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
      - !!perl/hash:RE_block
        min: 0
      - !!perl/hash:RE_bracket
        min: 148140
        re: !!perl/hash:RE_sequence
          min: 148140
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 24691
              re: &64 !!perl/hash:RE_any
                altname: regex_def_0
                dba: regex_def
                min: 24691
                zyg:
                - !!perl/hash:RE_sequence
                  alt: regex_def_0 0
                  min: 24691
                  zyg:
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: '&'
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_method
                      min: 12345
                      name: deflongname
                      rest: ''
                    min: 0
                    quant:
                    - '?'
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                - !!perl/hash:RE_sequence
                  alt: regex_def_0 1
                  min: 37035
                  zyg:
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_method
                    min: 12345
                    name: deflongname
                    rest: ''
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: newpad
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 37035
              re: &65 !!perl/hash:RE_any
                altname: regex_def_1
                dba: regex_def
                min: 37035
                zyg:
                - !!perl/hash:RE_sequence
                  alt: regex_def_1 0
                  min: 74072
                  zyg:
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_bracket
                    min: 49382
                    re: !!perl/hash:RE_sequence
                      min: 49382
                      zyg:
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_string
                          i: 0
                          min: 1
                          text: ':'
                        min: 0
                        quant:
                        - '?'
                      - !!perl/hash:RE_string
                        i: 0
                        min: 1
                        text: (
                      - !!perl/hash:RE_method
                        min: 12345
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_method
                        min: 12345
                        name: signature
                        rest: 1
                      - !!perl/hash:RE_method
                        min: 12345
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        min: 1
                        text: )
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                - !!perl/hash:RE_sequence
                  alt: regex_def_1 1
                  min: 37035
                  zyg:
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_method
                    min: 12345
                    name: trait
                    rest: ''
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
            min: 0
            quant:
            - '*'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 49380
              re: !!perl/hash:RE_sequence
                min: 49380
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_assertion
                  assert: '!'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_sequence
                      min: 12346
                      zyg:
                      - !!perl/hash:RE_method
                        min: 12345
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        min: 1
                        text: '{'
                - !!perl/hash:RE_method
                  min: 12345
                  name: panic
                  rest: 1
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: finishpad
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: regex_block
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: getsig
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: getdecl
            rest: ''
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
    - !!perl/hash:RE_sequence
      min: 37035
      zyg:
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        min: 12345
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
regex_def_0: *64
regex_def_1: *65
routine_declarator__S_062sub: !!perl/hash:RE_ast
  dba: routine_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: sub
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: routine_def
      rest: 1
routine_declarator__S_063method: !!perl/hash:RE_ast
  dba: routine_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: method
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: method_def
      rest: ''
routine_declarator__S_064submethod: !!perl/hash:RE_ast
  dba: routine_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: submethod
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: method_def
      rest: ''
routine_declarator__S_065macro: !!perl/hash:RE_ast
  dba: routine_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: macro
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: macro_def
      rest: ''
routine_def: !!perl/hash:RE_ast
  dba: routine_def
  min: 37035
  re: !!perl/hash:RE_first
    min: 37035
    zyg:
    - !!perl/hash:RE_sequence
      min: 197520
      zyg:
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
      - !!perl/hash:RE_bracket
        min: 135795
        re: !!perl/hash:RE_sequence
          min: 135795
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 37035
              re: &66 !!perl/hash:RE_any
                altname: routine_def_0
                dba: routine_def
                min: 37035
                zyg:
                - !!perl/hash:RE_sequence
                  alt: routine_def_0 0
                  min: 37036
                  zyg:
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_bindnamed
                    atom: !!perl/hash:RE_bracket
                      min: 1
                      re: !!perl/hash:RE_sequence
                        min: 1
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          min: 1
                          text: '&'
                        - !!perl/hash:RE_quantified_atom
                          atom: !!perl/hash:RE_string
                            i: 0
                            min: 1
                            text: '*'
                          min: 0
                          quant:
                          - '?'
                    min: 1
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_method
                      min: 12345
                      name: deflongname
                      rest: ''
                    min: 0
                    quant:
                    - '?'
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                - !!perl/hash:RE_sequence
                  alt: routine_def_0 1
                  min: 37035
                  zyg:
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_method
                    min: 12345
                    name: deflongname
                    rest: ''
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: newpad
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 37035
              re: &67 !!perl/hash:RE_any
                altname: routine_def_1
                dba: routine_def
                min: 37035
                zyg:
                - !!perl/hash:RE_sequence
                  alt: routine_def_1 0
                  min: 37035
                  zyg:
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_method
                    min: 12345
                    name: multisig
                    rest: ''
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                - !!perl/hash:RE_sequence
                  alt: routine_def_1 1
                  min: 37035
                  zyg:
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_method
                    min: 12345
                    name: trait
                    rest: ''
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
            min: 0
            quant:
            - '*'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 49380
              re: !!perl/hash:RE_sequence
                min: 49380
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_assertion
                  assert: '!'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_sequence
                      min: 12346
                      zyg:
                      - !!perl/hash:RE_method
                        min: 12345
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        min: 1
                        text: '{'
                - !!perl/hash:RE_method
                  min: 12345
                  name: panic
                  rest: 1
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
          - !!perl/hash:RE_method
            min: 12345
            name: blockoid
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: checkyada
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: getsig
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: getdecl
            rest: ''
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
    - !!perl/hash:RE_sequence
      min: 37035
      zyg:
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        min: 12345
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
routine_def_0: *66
routine_def_1: *67
scope_declarator__S_041my: !!perl/hash:RE_ast
  dba: scope_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: my
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: scoped
      rest: 1
scope_declarator__S_042our: !!perl/hash:RE_ast
  dba: scope_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: our
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: scoped
      rest: 1
scope_declarator__S_043anon: !!perl/hash:RE_ast
  dba: scope_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: anon
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: scoped
      rest: 1
scope_declarator__S_044state: !!perl/hash:RE_ast
  dba: scope_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: state
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: scoped
      rest: 1
scope_declarator__S_045has: !!perl/hash:RE_ast
  dba: scope_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: has
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: scoped
      rest: 1
scope_declarator__S_046augment: !!perl/hash:RE_ast
  dba: scope_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: augment
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: scoped
      rest: 1
scope_declarator__S_047supersede: !!perl/hash:RE_ast
  dba: scope_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: supersede
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: scoped
      rest: 1
scoped: !!perl/hash:RE_ast
  dba: scoped declarator
  min: 37035
  re: !!perl/hash:RE_first
    min: 37035
    zyg:
    - !!perl/hash:RE_sequence
      min: 74070
      zyg:
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
      - !!perl/hash:RE_bracket
        min: 37035
        re: &68 !!perl/hash:RE_any
          altname: scoped_0
          dba: scoped declarator
          min: 37035
          zyg:
          - !!perl/hash:RE_sequence
            alt: scoped_0 0
            min: 37035
            zyg:
            - !!perl/hash:RE_method
              min: 12345
              name: declarator
              rest: ''
            - !!perl/hash:RE_method
              min: 12345
              name: ws
              rest: ''
          - !!perl/hash:RE_sequence
            alt: scoped_0 1
            min: 37035
            zyg:
            - !!perl/hash:RE_method
              min: 12345
              name: regex_declarator
              rest: ''
            - !!perl/hash:RE_method
              min: 12345
              name: ws
              rest: ''
          - !!perl/hash:RE_sequence
            alt: scoped_0 2
            min: 37035
            zyg:
            - !!perl/hash:RE_method
              min: 12345
              name: package_declarator
              rest: ''
            - !!perl/hash:RE_method
              min: 12345
              name: ws
              rest: ''
          - !!perl/hash:RE_sequence
            alt: scoped_0 3
            min: 86415
            zyg:
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_bracket
                min: 24690
                re: !!perl/hash:RE_sequence
                  min: 24690
                  zyg:
                  - !!perl/hash:RE_method
                    min: 12345
                    name: typename
                    rest: ''
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
              min: 24690
              quant:
              - +
            - !!perl/hash:RE_method
              min: 12345
              name: ws
              rest: ''
            - !!perl/hash:RE_block
              min: 0
            - !!perl/hash:RE_method
              min: 12345
              name: multi_declarator
              rest: ''
            - !!perl/hash:RE_method
              min: 12345
              name: ws
              rest: ''
          - !!perl/hash:RE_sequence
            alt: scoped_0 4
            min: 37035
            zyg:
            - !!perl/hash:RE_method
              min: 12345
              name: multi_declarator
              rest: ''
            - !!perl/hash:RE_method
              min: 12345
              name: ws
              rest: ''
    - !!perl/hash:RE_sequence
      min: 49380
      zyg:
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
      - !!perl/hash:RE_assertion
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method_re
          min: 12345
          name: before
          nobind: 1
          re: !!perl/hash:RE_sequence
            min: 12346
            zyg:
            - !!perl/hash:RE_method
              min: 12345
              name: ws
              rest: ''
            - !!perl/hash:RE_cclass
              i: 0
              min: 1
              text: '[A..Z]'
      - !!perl/hash:RE_method
        min: 12345
        name: longname
        rest: ''
      - !!perl/hash:RE_block
        min: 0
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
      - !!perl/hash:RE_assertion
        assert: '!'
        min: 0
        re: !!perl/hash:RE_noop
          min: 0
          nobind: 1
    - !!perl/hash:RE_sequence
      min: 37035
      zyg:
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        min: 12345
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
scoped_0: *68
semiarglist: !!perl/hash:RE_ast
  dba: semiarglist
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: arglist
        rest: ''
      min: 12345
      quant:
      - '**'
      - ':'
      - !!perl/hash:RE_string
        a: 0
        dba: semiarglist
        i: 0
        i_needed: 1
        min: 1
        r: 1
        s: 0
        text: ;
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
semilist: !!perl/hash:RE_ast
  dba: semicolon list
  min: 74070
  re: !!perl/hash:RE_sequence
    min: 74070
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 24690
      re: &69 !!perl/hash:RE_any
        altname: semilist_0
        dba: semicolon list
        min: 24690
        zyg:
        - !!perl/hash:RE_assertion
          alt: semilist_0 0
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              min: 12346
              zyg:
              - !!perl/hash:RE_method
                min: 12345
                name: ws
                rest: ''
              - !!perl/hash:RE_cclass
                i: 0
                min: 1
                text: '[\)\]\}]'
        - !!perl/hash:RE_sequence
          alt: semilist_0 1
          min: 24690
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 37035
              re: !!perl/hash:RE_sequence
                min: 37035
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: statement
                  rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: eat_terminator
                  rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
            min: 0
            quant:
            - '*'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
semilist_0: *69
sibble: !!perl/hash:RE_ast
  dba: sibble
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: babble
      rest: 1
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_var
      min: 0
      var: $start
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        min: 12345
        name: nibble
        rest: 1
      min: 12345
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_var
          min: 0
          var: $stop
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_first
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          min: 49380
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_bracket
            min: 12345
            re: !!perl/hash:RE_first
              min: 12345
              zyg:
              - !!perl/hash:RE_method
                min: 12345
                name: infixish
                rest: ''
              - !!perl/hash:RE_method
                min: 12345
                name: panic
                rest: 1
          - !!perl/hash:RE_bracket
            min: 0
            re: !!perl/hash:RE_first
              min: 0
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                min: 0
                re: !!perl/hash:RE_block
                  min: 0
                  nobind: 1
              - !!perl/hash:RE_method
                min: 12345
                name: panic
                rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              min: 12345
              name: EXPR
              rest: 1
            min: 12345
        - !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              min: 12345
              name: nibble
              rest: 1
            min: 12345
          - !!perl/hash:RE_var
            min: 0
            var: $stop
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
signature: !!perl/hash:RE_ast
  dba: signature
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 0
        re: &70 !!perl/hash:RE_any
          altname: signature_0
          dba: signature
          min: 0
          zyg:
          - !!perl/hash:RE_assertion
            alt: signature_0 0
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: &71 !!perl/hash:RE_any
                altname: signature_1
                dba: signature
                min: 1
                zyg:
                - !!perl/hash:RE_string
                  alt: signature_1 0
                  i: 0
                  min: 3
                  text: -->
                - !!perl/hash:RE_string
                  alt: signature_1 1
                  i: 0
                  min: 1
                  text: )
                - !!perl/hash:RE_string
                  alt: signature_1 2
                  i: 0
                  min: 1
                  text: ']'
                - !!perl/hash:RE_string
                  alt: signature_1 3
                  i: 0
                  min: 1
                  text: '{'
                - !!perl/hash:RE_sequence
                  alt: signature_1 4
                  min: 2
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: ':'
                  - !!perl/hash:RE_meta
                    min: 1
                    text: \s
          - !!perl/hash:RE_bracket
            alt: signature_0 1
            min: 12345
            re: !!perl/hash:RE_first
              min: 12345
              zyg:
              - !!perl/hash:RE_method
                min: 12345
                name: parameter
                rest: ''
              - !!perl/hash:RE_method
                min: 12345
                name: panic
                rest: 1
      min: 0
      quant:
      - '**'
      - ':'
      - !!perl/hash:RE_method
        a: 0
        dba: signature
        i: 0
        min: 12345
        name: param_sep
        need_match: 0
        r: 1
        rest: ~
        s: 0
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 37038
        re: !!perl/hash:RE_sequence
          min: 37038
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 3
            text: -->
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: typename
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 12345
              re: !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_block
                    min: 0
                    nobind: 1
                - !!perl/hash:RE_method
                  min: 12345
                  name: sorry
                  rest: 1
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_block
            min: 0
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_block
      min: 0
signature_0: *70
signature_1: *71
sigterm: !!perl/hash:RE_ast
  dba: signature
  min: 12348
  re: !!perl/hash:RE_bracket
    min: 12348
    re: !!perl/hash:RE_sequence
      min: 12348
      zyg:
      - !!perl/hash:RE_string
        i: 0
        min: 2
        text: :(
      - !!perl/hash:RE_block
        min: 0
      - !!perl/hash:RE_method
        min: 12345
        name: fakesignature
        rest: ''
      - !!perl/hash:RE_bracket
        min: 1
        re: !!perl/hash:RE_first
          min: 1
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: )
          - !!perl/hash:RE_method
            min: 12345
            name: FAILGOAL
            rest: 1
special_variable__S_091Dollar_a2_: !!perl/hash:RE_ast
  dba: special_variable
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: $¢
special_variable__S_092DollarBang: !!perl/hash:RE_ast
  dba: special_variable
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $!
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \w
special_variable__S_093DollarBangCur_Ly: !!perl/hash:RE_ast
  dba: special_variable
  min: 12349
  re: !!perl/hash:RE_sequence
    min: 12349
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: $!
    - !!perl/hash:RE_bracket
      min: 12347
      re: !!perl/hash:RE_sequence
        min: 12347
        zyg:
        - !!perl/hash:RE_string
          i: 0
          min: 1
          text: '{'
        - !!perl/hash:RE_block
          min: 0
        - !!perl/hash:RE_bracket
          min: 12345
          re: &72 !!perl/hash:RE_any
            altname: special_variable__S_093DollarBangCur_Ly_0
            dba: special_variable
            min: 12345
            zyg:
            - !!perl/hash:RE_method
              alt: special_variable__S_093DollarBangCur_Ly_0 0
              min: 12345
              name: identifier
              rest: ''
            - !!perl/hash:RE_method
              alt: special_variable__S_093DollarBangCur_Ly_0 1
              min: 12345
              name: statementlist
              rest: ''
        - !!perl/hash:RE_bracket
          min: 1
          re: !!perl/hash:RE_first
            min: 1
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: '}'
            - !!perl/hash:RE_method
              min: 12345
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_block
      min: 0
special_variable__S_093DollarBangCur_Ly_0: *72
special_variable__S_094DollarSlash: !!perl/hash:RE_ast
  dba: special_variable
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $/
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                min: 1
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  min: 0
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: =
                - !!perl/hash:RE_assertion
                  assert: '!'
                  min: 0
                  re: !!perl/hash:RE_cclass
                    i: 0
                    min: 1
                    nobind: 1
                    text: '[=]'
          - !!perl/hash:RE_method
            min: 12345
            name: obs
            rest: 1
      min: 0
      quant:
      - '?'
special_variable__S_095DollarTilde: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $~
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &73 !!perl/hash:RE_any
          altname: special_variable__S_095DollarTilde_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_095DollarTilde_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_095DollarTilde_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_095DollarTilde_0 2
            i: 0
            min: 1
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_095DollarTilde_0 3
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_095DollarTilde_0: *73
special_variable__S_096DollarGrave: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $`
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &74 !!perl/hash:RE_any
          altname: special_variable__S_096DollarGrave_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_096DollarGrave_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_096DollarGrave_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_096DollarGrave_0 2
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_096DollarGrave_0: *74
special_variable__S_097DollarAt: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $@
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \W
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_098DollarSharp: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $#
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_first
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          min: 12346
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              min: 1
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \w
                min: 1
                quant:
                - +
            min: 1
          - !!perl/hash:RE_method
            min: 12345
            name: obs
            rest: 1
        - !!perl/hash:RE_method
          min: 12345
          name: obs
          rest: 1
special_variable__S_099DollarDollar: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $$
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        min: 12345
        name: alpha
        rest: ''
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &75 !!perl/hash:RE_any
          altname: special_variable__S_099DollarDollar_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_099DollarDollar_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_099DollarDollar_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_099DollarDollar_0 2
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_099DollarDollar_0: *75
special_variable__S_100DollarPercent: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $%
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \w
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        min: 12345
        name: sigil
        rest: ''
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_101DollarCaretX: !!perl/hash:RE_ast
  dba: special_variable
  min: 24693
  re: !!perl/hash:RE_sequence
    min: 24693
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: sigil
      rest: ''
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: ^
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        min: 1
        re: !!perl/hash:RE_cclass
          i: 0
          min: 1
          text: '[A..Z]'
      min: 1
    - !!perl/hash:RE_meta
      min: 1
      text: \W
    - !!perl/hash:RE_method
      min: 12345
      name: obscaret
      rest: 1
special_variable__S_102DollarCaret: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $^
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &76 !!perl/hash:RE_any
          altname: special_variable__S_102DollarCaret_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_102DollarCaret_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_102DollarCaret_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_102DollarCaret_0 2
            i: 0
            min: 1
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_102DollarCaret_0 3
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_102DollarCaret_0: *76
special_variable__S_103DollarAmp: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $&
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &77 !!perl/hash:RE_any
          altname: special_variable__S_103DollarAmp_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_103DollarAmp_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_103DollarAmp_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_103DollarAmp_0 2
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_103DollarAmp_0: *77
special_variable__S_104DollarStar: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $*
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &78 !!perl/hash:RE_any
          altname: special_variable__S_104DollarStar_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_104DollarStar_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_104DollarStar_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_104DollarStar_0 2
            i: 0
            min: 1
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_104DollarStar_0 3
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_104DollarStar_0: *78
special_variable__S_105DollarThesis: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $)
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_block
        min: 0
        nobind: 1
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &79 !!perl/hash:RE_any
          altname: special_variable__S_105DollarThesis_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_105DollarThesis_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_105DollarThesis_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_105DollarThesis_0 2
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_105DollarThesis_0: *79
special_variable__S_106DollarMinus: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $-
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &80 !!perl/hash:RE_any
          altname: special_variable__S_106DollarMinus_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_106DollarMinus_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_106DollarMinus_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_106DollarMinus_0 2
            i: 0
            min: 1
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_106DollarMinus_0 3
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_106DollarMinus_0: *80
special_variable__S_107DollarEqual: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $=
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &81 !!perl/hash:RE_any
          altname: special_variable__S_107DollarEqual_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_107DollarEqual_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_107DollarEqual_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_107DollarEqual_0 2
            i: 0
            min: 1
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_107DollarEqual_0 3
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_107DollarEqual_0: *81
special_variable__S_108AtPlus: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '@+'
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &82 !!perl/hash:RE_any
          altname: special_variable__S_108AtPlus_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_108AtPlus_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_108AtPlus_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_108AtPlus_0 2
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_108AtPlus_0: *82
special_variable__S_109PercentPlus: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '%+'
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &83 !!perl/hash:RE_any
          altname: special_variable__S_109PercentPlus_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_109PercentPlus_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_109PercentPlus_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_109PercentPlus_0 2
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_109PercentPlus_0: *83
special_variable__S_110DollarPlusBra_Ket: !!perl/hash:RE_ast
  dba: special_variable
  min: 12348
  re: !!perl/hash:RE_sequence
    min: 12348
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 3
      text: $+[
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_111AtPlusBra_Ket: !!perl/hash:RE_ast
  dba: special_variable
  min: 12348
  re: !!perl/hash:RE_sequence
    min: 12348
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 3
      text: '@+['
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_112AtPlusCur_Ly: !!perl/hash:RE_ast
  dba: special_variable
  min: 12348
  re: !!perl/hash:RE_sequence
    min: 12348
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 3
      text: '@+{'
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_113AtMinus: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '@-'
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &84 !!perl/hash:RE_any
          altname: special_variable__S_113AtMinus_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_113AtMinus_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_113AtMinus_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_113AtMinus_0 2
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_113AtMinus_0: *84
special_variable__S_114PercentMinus: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '%-'
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &85 !!perl/hash:RE_any
          altname: special_variable__S_114PercentMinus_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_114PercentMinus_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_114PercentMinus_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_114PercentMinus_0 2
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_114PercentMinus_0: *85
special_variable__S_115DollarMinusBra_Ket: !!perl/hash:RE_ast
  dba: special_variable
  min: 12348
  re: !!perl/hash:RE_sequence
    min: 12348
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 3
      text: $-[
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_116AtMinusBra_Ket: !!perl/hash:RE_ast
  dba: special_variable
  min: 12348
  re: !!perl/hash:RE_sequence
    min: 12348
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 3
      text: '@-['
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_117PercentMinusCur_Ly: !!perl/hash:RE_ast
  dba: special_variable
  min: 12348
  re: !!perl/hash:RE_sequence
    min: 12348
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 3
      text: '@-{'
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_118DollarPlus: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $+
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &86 !!perl/hash:RE_any
          altname: special_variable__S_118DollarPlus_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_118DollarPlus_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_118DollarPlus_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_118DollarPlus_0 2
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_118DollarPlus_0: *86
special_variable__S_119DollarCurCaret_Ly: !!perl/hash:RE_ast
  dba: special_variable
  min: 24693
  re: !!perl/hash:RE_sequence
    min: 24693
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: sigil
      rest: ''
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: '{^'
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        min: 0
        re: !!perl/hash:RE_meta
          min: 0
          text: .*?
      min: 0
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: '}'
    - !!perl/hash:RE_method
      min: 12345
      name: obscaret
      rest: 1
special_variable__S_120ColonColonCur_Ly: !!perl/hash:RE_ast
  dba: special_variable
  min: 2
  re: !!perl/hash:RE_sequence
    min: 2
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: '{'
special_variable__S_121DollarCur_Ly: !!perl/hash:RE_ast
  dba: special_variable
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: sigil
      rest: ''
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: '{'
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        min: 0
        re: !!perl/hash:RE_meta
          min: 0
          text: .*?
      min: 0
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: '}'
    - !!perl/hash:RE_block
      min: 0
special_variable__S_122DollarBra: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $[
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &87 !!perl/hash:RE_any
          altname: special_variable__S_122DollarBra_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_122DollarBra_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_122DollarBra_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_122DollarBra_0 2
            i: 0
            min: 1
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_122DollarBra_0 3
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_122DollarBra_0: *87
special_variable__S_123DollarKet: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $]
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &88 !!perl/hash:RE_any
          altname: special_variable__S_123DollarKet_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_123DollarKet_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_123DollarKet_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_123DollarKet_0 2
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_123DollarKet_0: *88
special_variable__S_124DollarBack: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $\
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &89 !!perl/hash:RE_any
          altname: special_variable__S_124DollarBack_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_124DollarBack_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_124DollarBack_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_124DollarBack_0 2
            i: 0
            min: 1
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_124DollarBack_0 3
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_124DollarBack_0: *89
special_variable__S_125DollarVert: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $|
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &90 !!perl/hash:RE_any
          altname: special_variable__S_125DollarVert_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_125DollarVert_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_125DollarVert_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_125DollarVert_0 2
            i: 0
            min: 1
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_125DollarVert_0 3
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_125DollarVert_0: *90
special_variable__S_126DollarColon: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '$:'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_cclass
          i: 0
          min: 1
          text: '[\x20\t\n\],=)}]'
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_127DollarSemi: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $;
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &91 !!perl/hash:RE_any
          altname: special_variable__S_127DollarSemi_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_127DollarSemi_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_127DollarSemi_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_127DollarSemi_0 2
            i: 0
            min: 1
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_127DollarSemi_0 3
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_127DollarSemi_0: *91
special_variable__S_128DollarSingle: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $'
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &92 !!perl/hash:RE_any
          altname: special_variable__S_128DollarSingle_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_128DollarSingle_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_128DollarSingle_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_128DollarSingle_0 2
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_128DollarSingle_0: *92
special_variable__S_129DollarDouble: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $"
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_block
        min: 0
        nobind: 1
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &93 !!perl/hash:RE_any
          altname: special_variable__S_129DollarDouble_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_129DollarDouble_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_129DollarDouble_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_string
            alt: special_variable__S_129DollarDouble_0 2
            i: 0
            min: 1
            text: =
          - !!perl/hash:RE_method
            alt: special_variable__S_129DollarDouble_0 3
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_129DollarDouble_0: *93
special_variable__S_130DollarComma: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $,
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &94 !!perl/hash:RE_any
          altname: special_variable__S_130DollarComma_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_130DollarComma_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_130DollarComma_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_130DollarComma_0 2
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_130DollarComma_0: *94
special_variable__S_131DollarLt: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $<
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          min: 1
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            min: 0
            quant:
            - '*'
          - !!perl/hash:RE_cclass
            i: 0
            min: 1
            text: '[ = , ; ? : ! ) \] } ]'
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                min: 1
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \S
                  min: 0
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: '>'
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_132DollarGt: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $>
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &95 !!perl/hash:RE_any
          altname: special_variable__S_132DollarGt_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_132DollarGt_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_132DollarGt_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_132DollarGt_0 2
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_132DollarGt_0: *95
special_variable__S_133DollarDot: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $.
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &96 !!perl/hash:RE_any
          altname: special_variable__S_133DollarDot_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_133DollarDot_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_133DollarDot_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_133DollarDot_0 2
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_133DollarDot_0: *96
special_variable__S_134DollarQuestion: !!perl/hash:RE_ast
  dba: special_variable
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $?
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &97 !!perl/hash:RE_any
          altname: special_variable__S_134DollarQuestion_0
          dba: special_variable
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: special_variable__S_134DollarQuestion_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: special_variable__S_134DollarQuestion_0 1
            i: 0
            min: 1
            text: ','
          - !!perl/hash:RE_method
            alt: special_variable__S_134DollarQuestion_0 2
            min: 12345
            name: terminator
            rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
special_variable__S_134DollarQuestion_0: *97
statement: !!perl/hash:RE_ast
  dba: statement
  min: 0
  re: !!perl/hash:RE_sequence
    min: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_cclass
          i: 0
          min: 1
          text: '[\)\]\}]'
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_assertion
        assert: '!'
        min: 0
        nobind: 1
        re: !!perl/hash:RE_block
          min: 0
          nobind: 1
    - !!perl/hash:RE_bracket
      min: 0
      re: &98 !!perl/hash:RE_any
        altname: statement_0
        dba: statement end
        min: 0
        zyg:
        - !!perl/hash:RE_sequence
          alt: statement_0 0
          min: 24690
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: label
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: statement
            rest: ''
        - !!perl/hash:RE_method
          alt: statement_0 1
          min: 12345
          name: statement_control
          rest: ''
        - !!perl/hash:RE_sequence
          alt: statement_0 2
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: EXPR
            rest: ''
          - !!perl/hash:RE_bracket
            min: 0
            re: !!perl/hash:RE_first
              min: 0
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                min: 0
                re: !!perl/hash:RE_block
                  min: 0
                  nobind: 1
              - !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    min: 12345
                    re: &99 !!perl/hash:RE_any
                      altname: statement_1
                      dba: statement modifier loop
                      min: 12345
                      zyg:
                      - !!perl/hash:RE_sequence
                        alt: statement_1 0
                        min: 12345
                        zyg:
                        - !!perl/hash:RE_method
                          min: 12345
                          name: statement_mod_loop
                          rest: ''
                        - !!perl/hash:RE_block
                          min: 0
                      - !!perl/hash:RE_sequence
                        alt: statement_1 1
                        min: 12345
                        zyg:
                        - !!perl/hash:RE_method
                          min: 12345
                          name: statement_mod_cond
                          rest: ''
                        - !!perl/hash:RE_bracket
                          min: 0
                          re: !!perl/hash:RE_first
                            min: 0
                            zyg:
                            - !!perl/hash:RE_assertion
                              assert: '?'
                              min: 0
                              re: !!perl/hash:RE_block
                                min: 0
                                nobind: 1
                            - !!perl/hash:RE_sequence
                              min: 12345
                              zyg:
                              - !!perl/hash:RE_method
                                min: 12345
                                name: ws
                                rest: ''
                              - !!perl/hash:RE_quantified_atom
                                atom: !!perl/hash:RE_method
                                  min: 12345
                                  name: statement_mod_loop
                                  rest: ''
                                min: 0
                                quant:
                                - '?'
                  min: 0
                  quant:
                  - '?'
        - !!perl/hash:RE_assertion
          alt: statement_0 3
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 1
              text: ;
        - !!perl/hash:RE_assertion
          alt: statement_0 4
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_method
              min: 12345
              name: stopper
              rest: ''
        - !!perl/hash:RE_sequence
          alt: statement_0 5
          min: 12345
          zyg:
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \h
            min: 0
            quant:
            - '*'
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: &100 !!perl/hash:RE_any
                altname: statement_2
                dba: statement
                min: 1
                zyg:
                - !!perl/hash:RE_string
                  alt: statement_2 0
                  i: 0
                  min: 1
                  text: ;
                - !!perl/hash:RE_string
                  alt: statement_2 1
                  i: 0
                  min: 1
                  text: )
                - !!perl/hash:RE_string
                  alt: statement_2 2
                  i: 0
                  min: 1
                  text: ']'
                - !!perl/hash:RE_string
                  alt: statement_2 3
                  i: 0
                  min: 1
                  text: '}'
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_method
              min: 12345
              name: infixstopper
              rest: ''
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
      min: 0
      quant:
      - '?'
statement_0: *98
statement_1: *99
statement_2: *100
statement_control__S_000need: !!perl/hash:RE_ast
  dba: statement_control
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: need
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 24690
        re: &101 !!perl/hash:RE_any
          altname: statement_control__S_000need_0
          dba: statement_control
          min: 24690
          zyg:
          - !!perl/hash:RE_sequence
            alt: statement_control__S_000need_0 0
            min: 24690
            zyg:
            - !!perl/hash:RE_method
              min: 12345
              name: version
              rest: ''
            - !!perl/hash:RE_method
              min: 12345
              name: ws
              rest: ''
          - !!perl/hash:RE_sequence
            alt: statement_control__S_000need_0 1
            min: 37035
            zyg:
            - !!perl/hash:RE_method
              min: 12345
              name: module_name
              rest: ''
            - !!perl/hash:RE_method
              min: 12345
              name: ws
              rest: ''
            - !!perl/hash:RE_block
              min: 0
      min: 12345
      quant:
      - '**'
      - ':'
      - !!perl/hash:RE_string
        a: 0
        dba: statement_control
        i: 0
        i_needed: 1
        min: 1
        r: 1
        s: 1
        text: ','
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_control__S_000need_0: *101
statement_control__S_001import: !!perl/hash:RE_ast
  dba: statement_control
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: import
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: term
      rest: ''
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_sequence
          min: 24690
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: spacey
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: arglist
            rest: ''
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_block
          min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_control__S_002use: !!perl/hash:RE_ast
  dba: statement_control
  min: 74070
  re: !!perl/hash:RE_sequence
    min: 74070
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: use
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 12345
      re: &102 !!perl/hash:RE_any
        altname: statement_control__S_002use_0
        dba: statement_control
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          alt: statement_control__S_002use_0 0
          min: 12345
          name: version
          rest: ''
        - !!perl/hash:RE_sequence
          alt: statement_control__S_002use_0 1
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: module_name
            rest: ''
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_bracket
            min: 0
            re: !!perl/hash:RE_first
              min: 0
              zyg:
              - !!perl/hash:RE_sequence
                min: 24690
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: spacey
                  rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: arglist
                  rest: ''
                - !!perl/hash:RE_block
                  min: 0
              - !!perl/hash:RE_block
                min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: explain_mystery
      rest: ''
statement_control__S_002use_0: *102
statement_control__S_003no: !!perl/hash:RE_ast
  dba: statement_control
  min: 74070
  re: !!perl/hash:RE_sequence
    min: 74070
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: no
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: module_name
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 24690
        re: !!perl/hash:RE_sequence
          min: 24690
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: spacey
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: arglist
            rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: explain_mystery
      rest: ''
statement_control__S_004if: !!perl/hash:RE_ast
  dba: statement_control
  min: 86415
  re: !!perl/hash:RE_sequence
    min: 86415
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: if
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 74075
        re: !!perl/hash:RE_sequence
          min: 74075
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_bracket
            min: 49385
            re: &103 !!perl/hash:RE_any
              altname: statement_control__S_004if_0
              dba: statement_control
              min: 49385
              zyg:
              - !!perl/hash:RE_sequence
                alt: statement_control__S_004if_0 0
                min: 49386
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 4
                  text: else
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  min: 0
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  min: 2
                  text: if
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: sorry
                  rest: 1
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
              - !!perl/hash:RE_sequence
                alt: statement_control__S_004if_0 1
                min: 49385
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 5
                  text: elsif
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method
                    min: 12345
                    name: spacey
                    rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_bindnamed
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: xblock
                    rest: ''
                  min: 12345
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
      min: 0
      quant:
      - '*'
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 49384
        re: !!perl/hash:RE_sequence
          min: 49384
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_string
            i: 0
            min: 4
            text: else
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method
              min: 12345
              name: spacey
              rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              min: 12345
              name: pblock
              rest: ''
            min: 12345
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_control__S_004if_0: *103
statement_control__S_005unless: !!perl/hash:RE_ast
  dba: statement_control
  min: 98760
  re: !!perl/hash:RE_sequence
    min: 98760
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: unless
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 24690
      re: !!perl/hash:RE_first
        min: 24690
        zyg:
        - !!perl/hash:RE_assertion
          assert: '!'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              min: 12349
              zyg:
              - !!perl/hash:RE_method
                min: 12345
                name: ws
                rest: ''
              - !!perl/hash:RE_string
                i: 0
                min: 4
                text: else
        - !!perl/hash:RE_sequence
          min: 37035
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
statement_control__S_006while: !!perl/hash:RE_ast
  dba: statement_control
  min: 74070
  re: !!perl/hash:RE_sequence
    min: 74070
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: while
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 49380
        re: !!perl/hash:RE_sequence
          min: 49380
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                min: 74075
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: (
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    min: 24693
                    re: !!perl/hash:RE_sequence
                      min: 24693
                      zyg:
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_string
                          i: 0
                          min: 2
                          text: my
                        min: 0
                        quant:
                        - '?'
                      - !!perl/hash:RE_method
                        min: 12345
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        min: 1
                        text: $
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_meta
                          min: 1
                          text: \w
                        min: 1
                        quant:
                        - +
                      - !!perl/hash:RE_method
                        min: 12345
                        name: ws
                        rest: ''
                      - !!perl/hash:RE_string
                        i: 0
                        min: 1
                        text: =
                  min: 0
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: <
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: $
                  min: 0
                  quant:
                  - '?'
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \w
                  min: 1
                  quant:
                  - +
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: '>'
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: )
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_control__S_007until: !!perl/hash:RE_ast
  dba: statement_control
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: until
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_control__S_008repeat: !!perl/hash:RE_ast
  dba: statement_control
  min: 111110
  re: !!perl/hash:RE_sequence
    min: 111110
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: repeat
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 61730
      re: &104 !!perl/hash:RE_any
        altname: statement_control__S_008repeat_0
        dba: statement_control
        min: 61730
        zyg:
        - !!perl/hash:RE_sequence
          alt: statement_control__S_008repeat_0 0
          min: 61730
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              min: 5
              re: &105 !!perl/hash:RE_any
                altname: statement_control__S_008repeat_1
                dba: statement_control
                min: 5
                zyg:
                - !!perl/hash:RE_string
                  alt: statement_control__S_008repeat_1 0
                  i: 0
                  min: 5
                  text: while
                - !!perl/hash:RE_string
                  alt: statement_control__S_008repeat_1 1
                  i: 0
                  min: 5
                  text: until
            min: 5
          - !!perl/hash:RE_method
            min: 12345
            name: spacey
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: xblock
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          alt: statement_control__S_008repeat_0 1
          min: 86420
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: pblock
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_bracket
              min: 5
              re: &106 !!perl/hash:RE_any
                altname: statement_control__S_008repeat_2
                dba: statement_control
                min: 5
                zyg:
                - !!perl/hash:RE_string
                  alt: statement_control__S_008repeat_2 0
                  i: 0
                  min: 5
                  text: while
                - !!perl/hash:RE_string
                  alt: statement_control__S_008repeat_2 1
                  i: 0
                  min: 5
                  text: until
            min: 5
          - !!perl/hash:RE_bracket
            min: 12345
            re: !!perl/hash:RE_first
              min: 12345
              zyg:
              - !!perl/hash:RE_method
                min: 12345
                name: spacey
                rest: ''
              - !!perl/hash:RE_method
                min: 12345
                name: panic
                rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: EXPR
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
statement_control__S_008repeat_0: *104
statement_control__S_008repeat_1: *105
statement_control__S_008repeat_2: *106
statement_control__S_009loop: !!perl/hash:RE_ast
  dba: statement_control
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: loop
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_quantified_atom
        atom: !!perl/hash:RE_paren
          min: 12346
          re: !!perl/hash:RE_sequence
            min: 12346
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: (
            - !!perl/hash:RE_bracket
              min: 12345
              re: !!perl/hash:RE_first
                min: 12345
                zyg:
                - !!perl/hash:RE_sequence
                  min: 74073
                  zyg:
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        min: 12345
                        name: EXPR
                        rest: ''
                      min: 12345
                    min: 0
                    quant:
                    - '?'
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: ;
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        min: 12345
                        name: EXPR
                        rest: ''
                      min: 12345
                    min: 0
                    quant:
                    - '?'
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: ;
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_quantified_atom
                    atom: !!perl/hash:RE_bindnamed
                      atom: !!perl/hash:RE_method
                        min: 12345
                        name: EXPR
                        rest: ''
                      min: 12345
                    min: 0
                    quant:
                    - '?'
                  - !!perl/hash:RE_method
                    min: 12345
                    name: ws
                    rest: ''
                  - !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: )
                - !!perl/hash:RE_method
                  min: 12345
                  name: panic
                  rest: 1
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_bracket
                min: 12345
                re: !!perl/hash:RE_sequence
                  min: 12345
                  zyg:
                  - !!perl/hash:RE_assertion
                    assert: '?'
                    min: 0
                    re: !!perl/hash:RE_method_re
                      min: 12345
                      name: before
                      nobind: 1
                      re: !!perl/hash:RE_string
                        i: 0
                        min: 1
                        text: '{'
                  - !!perl/hash:RE_method
                    min: 12345
                    name: sorry
                    rest: 1
              min: 0
              quant:
              - '?'
        min: 0
        quant:
        - '?'
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: block
      rest: ''
statement_control__S_010for: !!perl/hash:RE_ast
  dba: statement_control
  min: 86415
  re: !!perl/hash:RE_sequence
    min: 86415
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: for
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 49380
        re: !!perl/hash:RE_sequence
          min: 49380
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                min: 49383
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    min: 2
                    text: my
                  min: 0
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: $
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \w
                  min: 1
                  quant:
                  - +
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: (
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 49380
        re: !!perl/hash:RE_sequence
          min: 49380
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                min: 98764
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: (
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: EXPR
                    rest: ''
                  min: 0
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: ;
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: EXPR
                    rest: ''
                  min: 0
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: ;
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: EXPR
                    rest: ''
                  min: 0
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: )
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: obs
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_control__S_011foreach: !!perl/hash:RE_ast
  dba: statement_control
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: foreach
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
statement_control__S_012given: !!perl/hash:RE_ast
  dba: statement_control
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: given
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_control__S_013when: !!perl/hash:RE_ast
  dba: statement_control
  min: 74070
  re: !!perl/hash:RE_sequence
    min: 74070
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: when
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_assertion
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method_re
          min: 12345
          name: before
          nobind: 1
          re: !!perl/hash:RE_sequence
            min: 24694
            zyg:
            - !!perl/hash:RE_method
              min: 12345
              name: ws
              rest: ''
            - !!perl/hash:RE_bindpos
              atom: !!perl/hash:RE_paren
                min: 4
                re: &107 !!perl/hash:RE_any
                  altname: statement_control__S_013when_0
                  dba: statement_control
                  min: 4
                  zyg:
                  - !!perl/hash:RE_string
                    alt: statement_control__S_013when_0 0
                    i: 0
                    min: 4
                    text: True
                  - !!perl/hash:RE_string
                    alt: statement_control__S_013when_0 1
                    i: 0
                    min: 5
                    text: False
              min: 4
            - !!perl/hash:RE_meta
              min: 0
              text: »
            - !!perl/hash:RE_method
              min: 12345
              name: dumbsmart
              rest: 1
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: xblock
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_control__S_013when_0: *107
statement_control__S_014default: !!perl/hash:RE_ast
  dba: statement_control
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: default
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: block
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_control__S_029CATCH: !!perl/hash:RE_ast
  dba: statement_control
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: CATCH
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: block
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_control__S_030CONTROL: !!perl/hash:RE_ast
  dba: statement_control
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: CONTROL
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: block
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_control__S_031TEMP: !!perl/hash:RE_ast
  dba: statement_control
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: TEMP
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: block
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_mod_cond__S_032if: !!perl/hash:RE_ast
  dba: statement_mod_cond
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: if
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_mod_cond__S_033unless: !!perl/hash:RE_ast
  dba: statement_mod_cond
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: unless
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_mod_cond__S_034when: !!perl/hash:RE_ast
  dba: statement_mod_cond
  min: 74070
  re: !!perl/hash:RE_sequence
    min: 74070
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: when
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_assertion
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method_re
          min: 12345
          name: before
          nobind: 1
          re: !!perl/hash:RE_sequence
            min: 24694
            zyg:
            - !!perl/hash:RE_method
              min: 12345
              name: ws
              rest: ''
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                min: 1
                text: \h
              min: 0
              quant:
              - '*'
            - !!perl/hash:RE_bindpos
              atom: !!perl/hash:RE_paren
                min: 4
                re: &108 !!perl/hash:RE_any
                  altname: statement_mod_cond__S_034when_0
                  dba: statement_mod_cond
                  min: 4
                  zyg:
                  - !!perl/hash:RE_string
                    alt: statement_mod_cond__S_034when_0 0
                    i: 0
                    min: 4
                    text: True
                  - !!perl/hash:RE_string
                    alt: statement_mod_cond__S_034when_0 1
                    i: 0
                    min: 5
                    text: False
              min: 4
            - !!perl/hash:RE_meta
              min: 0
              text: »
            - !!perl/hash:RE_method
              min: 12345
              name: dumbsmart
              rest: 1
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_mod_cond__S_034when_0: *108
statement_mod_loop__S_035while: !!perl/hash:RE_ast
  dba: statement_mod_loop
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: while
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_mod_loop__S_036until: !!perl/hash:RE_ast
  dba: statement_mod_loop
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: until
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_mod_loop__S_037for: !!perl/hash:RE_ast
  dba: statement_mod_loop
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: for
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_mod_loop__S_038given: !!perl/hash:RE_ast
  dba: statement_mod_loop
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: nofun
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: given
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: modifier_expr
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
statement_prefix__S_015BEGIN: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: BEGIN
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: explain_mystery
      rest: ''
statement_prefix__S_016CHECK: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: CHECK
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_017INIT: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: INIT
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_018START: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: START
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_019ENTER: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ENTER
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_020FIRST: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: FIRST
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_021END: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: END
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_022LEAVE: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: LEAVE
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_023KEEP: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: KEEP
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_024UNDO: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: UNDO
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_025NEXT: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: NEXT
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_026LAST: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: LAST
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_027PRE: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: PRE
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_028POST: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: POST
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_168sink: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: sink
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_169try: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: try
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_170quietly: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: quietly
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_171gather: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: gather
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_172contend: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: contend
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_173async: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: async
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_174maybe: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: maybe
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_175lazy: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: lazy
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_176do: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: do
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statement_prefix__S_177lift: !!perl/hash:RE_ast
  dba: statement_prefix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: lift
    - !!perl/hash:RE_method
      min: 12345
      name: blast
      rest: ''
statementlist: !!perl/hash:RE_ast
  dba: statement list
  min: 86415
  re: !!perl/hash:RE_sequence
    min: 86415
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 24690
      re: &109 !!perl/hash:RE_any
        altname: statementlist_0
        dba: statement list
        min: 24690
        zyg:
        - !!perl/hash:RE_sequence
          alt: statementlist_0 0
          min: 24690
          zyg:
          - !!perl/hash:RE_meta
            min: 0
            text: $
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
        - !!perl/hash:RE_assertion
          alt: statementlist_0 1
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              min: 12346
              zyg:
              - !!perl/hash:RE_method
                min: 12345
                name: ws
                rest: ''
              - !!perl/hash:RE_cclass
                i: 0
                min: 1
                text: '[\)\]\}]'
        - !!perl/hash:RE_sequence
          alt: statementlist_0 2
          min: 37035
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 37035
              re: !!perl/hash:RE_sequence
                min: 37035
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: statement
                  rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: eat_terminator
                  rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
            min: 0
            quant:
            - '*'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_block
            min: 0
statementlist_0: *109
strtonum__S_138rational: !!perl/hash:RE_ast
  dba: strtonum
  min: 24691
  re: !!perl/hash:RE_sequence
    min: 24691
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        i: 0
        min: 1
        text: '[+\-]'
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        min: 12345
        name: integer
        rest: ''
      min: 12345
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: /
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        min: 12345
        name: integer
        rest: ''
      min: 12345
strtonum__S_139complex: !!perl/hash:RE_ast
  dba: strtonum
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_cclass
              i: 0
              min: 1
              text: '[+\-]'
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              min: 12345
              name: number
              rest: ''
            min: 12345
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_cclass
      i: 0
      min: 1
      text: '[+\-]'
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        min: 12345
        name: number
        rest: ''
      min: 12345
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        min: 1
        text: \
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: i
strtonum__S_140number: !!perl/hash:RE_ast
  dba: strtonum
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_cclass
        i: 0
        min: 1
        text: '[+\-]'
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: number
      rest: ''
sublongname: !!perl/hash:RE_ast
  dba: sublongname
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: subshortname
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: sigterm
        rest: ''
      min: 0
      quant:
      - '?'
subshortname: !!perl/hash:RE_ast
  dba: subshortname
  min: 12345
  re: !!perl/hash:RE_bracket
    min: 12345
    re: &110 !!perl/hash:RE_any
      altname: subshortname_0
      dba: subshortname
      min: 12345
      zyg:
      - !!perl/hash:RE_sequence
        alt: subshortname_0 0
        min: 24690
        zyg:
        - !!perl/hash:RE_method
          min: 12345
          name: category
          rest: ''
        - !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_method
            min: 12345
            name: colonpair
            rest: ''
          min: 12345
          quant:
          - +
      - !!perl/hash:RE_method
        alt: subshortname_0 1
        min: 12345
        name: desigilname
        rest: ''
subshortname_0: *110
term__S_076fatarrow: !!perl/hash:RE_ast
  dba: term
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: fatarrow
    rest: ''
term__S_077variable: !!perl/hash:RE_ast
  dba: term
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: variable
      rest: ''
    - !!perl/hash:RE_block
      min: 0
term__S_078package_declarator: !!perl/hash:RE_ast
  dba: term
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: package_declarator
    rest: ''
term__S_079scope_declarator: !!perl/hash:RE_ast
  dba: term
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: scope_declarator
    rest: ''
term__S_080multi_declarator: !!perl/hash:RE_ast
  dba: term
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &111 !!perl/hash:RE_any
          altname: term__S_080multi_declarator_0
          dba: term
          min: 4
          zyg:
          - !!perl/hash:RE_string
            alt: term__S_080multi_declarator_0 0
            i: 0
            min: 5
            text: multi
          - !!perl/hash:RE_string
            alt: term__S_080multi_declarator_0 1
            i: 0
            min: 5
            text: proto
          - !!perl/hash:RE_string
            alt: term__S_080multi_declarator_0 2
            i: 0
            min: 4
            text: only
    - !!perl/hash:RE_method
      min: 12345
      name: multi_declarator
      rest: ''
term__S_080multi_declarator_0: *111
term__S_081routine_declarator: !!perl/hash:RE_ast
  dba: term
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: routine_declarator
    rest: ''
term__S_082regex_declarator: !!perl/hash:RE_ast
  dba: term
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: regex_declarator
    rest: ''
term__S_083type_declarator: !!perl/hash:RE_ast
  dba: term
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: type_declarator
    rest: ''
term__S_084circumfix: !!perl/hash:RE_ast
  dba: term
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: circumfix
    rest: ''
term__S_085dotty: !!perl/hash:RE_ast
  dba: term
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: dotty
    rest: ''
term__S_086value: !!perl/hash:RE_ast
  dba: term
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: value
    rest: ''
term__S_087capterm: !!perl/hash:RE_ast
  dba: term
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: capterm
    rest: ''
term__S_088sigterm: !!perl/hash:RE_ast
  dba: term
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: sigterm
    rest: ''
term__S_089statement_prefix: !!perl/hash:RE_ast
  dba: term
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: statement_prefix
    rest: ''
term__S_090colonpair: !!perl/hash:RE_ast
  dba: term
  min: 24690
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_bracket
      min: 24690
      re: !!perl/hash:RE_sequence
        min: 24690
        zyg:
        - !!perl/hash:RE_method
          min: 12345
          name: colonpair
          rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: ws
          rest: ''
    min: 24690
    quant:
    - +
term__S_178YOU_ARE_HERE: !!perl/hash:RE_ast
  dba: term
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: YOU_ARE_HERE
    - !!perl/hash:RE_method
      min: 12345
      name: you_are_here
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
term__S_179new: !!perl/hash:RE_ast
  dba: term
  min: 24694
  re: !!perl/hash:RE_sequence
    min: 24694
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 3
      text: new
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      min: 1
      quant:
      - +
    - !!perl/hash:RE_method
      min: 12345
      name: longname
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \h
      min: 0
      quant:
      - '*'
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: ':'
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
term__S_180ColonColonQuestionIDENT: !!perl/hash:RE_ast
  dba: term
  min: 24693
  re: !!perl/hash:RE_sequence
    min: 24693
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        min: 12348
        re: !!perl/hash:RE_sequence
          min: 12348
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 3
            text: ::?
          - !!perl/hash:RE_method
            min: 12345
            name: identifier
            rest: ''
      min: 12348
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
term__S_181Object: !!perl/hash:RE_ast
  dba: term
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: Object
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
term__S_182undef: !!perl/hash:RE_ast
  dba: term
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: undef
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                min: 2
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  min: 0
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  min: 2
                  text: $/
          - !!perl/hash:RE_method
            min: 12345
            name: obs
            rest: 1
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_bracket
                min: 1
                re: !!perl/hash:RE_first
                  min: 1
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: (
                  - !!perl/hash:RE_sequence
                    min: 12346
                    zyg:
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_meta
                        min: 1
                        text: \h
                      min: 0
                      quant:
                      - '*'
                    - !!perl/hash:RE_method
                      min: 12345
                      name: sigil
                      rest: ''
                    - !!perl/hash:RE_quantified_atom
                      atom: !!perl/hash:RE_method
                        min: 12345
                        name: twigil
                        rest: ''
                      min: 0
                      quant:
                      - '?'
                    - !!perl/hash:RE_meta
                      min: 1
                      text: \w
          - !!perl/hash:RE_method
            min: 12345
            name: obs
            rest: 1
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
term__S_183proceed: !!perl/hash:RE_ast
  dba: term
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: proceed
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
term__S_184now: !!perl/hash:RE_ast
  dba: term
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: now
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
term__S_185self: !!perl/hash:RE_ast
  dba: term
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: self
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
term__S_186defer: !!perl/hash:RE_ast
  dba: term
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: defer
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
term__S_187rand: !!perl/hash:RE_ast
  dba: term
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: rand
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                min: 1
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: (
                  min: 0
                  quant:
                  - '?'
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \h
                  min: 0
                  quant:
                  - '*'
                - !!perl/hash:RE_bracket
                  min: 1
                  re: &112 !!perl/hash:RE_any
                    altname: term__S_187rand_0
                    dba: term
                    min: 1
                    zyg:
                    - !!perl/hash:RE_meta
                      alt: term__S_187rand_0 0
                      min: 1
                      text: \d
                    - !!perl/hash:RE_string
                      alt: term__S_187rand_0 1
                      i: 0
                      min: 1
                      text: $
          - !!perl/hash:RE_method
            min: 12345
            name: obs
            rest: 1
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                min: 2
                text: ()
          - !!perl/hash:RE_method
            min: 12345
            name: obs
            rest: 1
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
term__S_187rand_0: *112
term__S_188Star: !!perl/hash:RE_ast
  dba: term
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '*'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
term__S_189StarStar: !!perl/hash:RE_ast
  dba: term
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '**'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
term__S_213lambda: !!perl/hash:RE_ast
  dba: term
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_method
          min: 12345
          name: lambda
          rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: pblock
      rest: ''
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
term__S_328DotDotDot: !!perl/hash:RE_ast
  dba: term
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '...'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: args
        rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
term__S_329QuestionQuestionQuestion: !!perl/hash:RE_ast
  dba: term
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ???
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: args
        rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
term__S_330BangBangBang: !!perl/hash:RE_ast
  dba: term
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '!!!'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: args
        rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
term__S_331identifier: !!perl/hash:RE_ast
  dba: term
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: identifier
      rest: ''
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_bracket
            min: 1
            re: &113 !!perl/hash:RE_any
              altname: term__S_331identifier_0
              dba: term
              min: 1
              zyg:
              - !!perl/hash:RE_method
                alt: term__S_331identifier_0 0
                min: 12345
                name: unsp
                rest: ''
              - !!perl/hash:RE_string
                alt: term__S_331identifier_0 1
                i: 0
                min: 1
                text: (
          min: 0
          quant:
          - '?'
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_cclass
        i: 0
        min: 1
        nobind: 1
        text: '[:]'
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: args
      rest: 1
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
term__S_331identifier_0: *113
term__S_332name: !!perl/hash:RE_ast
  dba: term
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: longname
      rest: ''
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_sequence
          min: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              min: 12345
              name: unsp
              rest: ''
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 12345
              re: !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      min: 1
                      text: '['
                - !!perl/hash:RE_method
                  min: 12345
                  name: postcircumfix
                  rest: ''
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 12345
              re: !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: after
                    nobind: 1
                    re: !!perl/hash:RE_string
                      i: 0
                      min: 2
                      text: '::'
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: before
                    nobind: 1
                    re: !!perl/hash:RE_bracket
                      min: 1
                      re: &114 !!perl/hash:RE_any
                        altname: term__S_332name_0
                        dba: namespace variable lookup
                        min: 1
                        zyg:
                        - !!perl/hash:RE_string
                          alt: term__S_332name_0 0
                          i: 0
                          min: 1
                          text: «
                        - !!perl/hash:RE_string
                          alt: term__S_332name_0 1
                          i: 0
                          min: 1
                          text: <
                        - !!perl/hash:RE_string
                          alt: term__S_332name_0 2
                          i: 0
                          min: 1
                          text: '{'
                        - !!perl/hash:RE_string
                          alt: term__S_332name_0 3
                          i: 0
                          min: 2
                          text: <<
                - !!perl/hash:RE_method
                  min: 12345
                  name: postcircumfix
                  rest: ''
                - !!perl/hash:RE_block
                  min: 0
            min: 0
            quant:
            - '?'
        - !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: args
            rest: ''
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_block
            min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
term__S_332name_0: *114
terminator__S_342Semi: !!perl/hash:RE_ast
  dba: terminator
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: ;
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
terminator__S_343if: !!perl/hash:RE_ast
  dba: terminator
  min: 24692
  re: !!perl/hash:RE_sequence
    min: 24692
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: if
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
terminator__S_344unless: !!perl/hash:RE_ast
  dba: terminator
  min: 24696
  re: !!perl/hash:RE_sequence
    min: 24696
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 6
      text: unless
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
terminator__S_345while: !!perl/hash:RE_ast
  dba: terminator
  min: 24695
  re: !!perl/hash:RE_sequence
    min: 24695
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 5
      text: while
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
terminator__S_346until: !!perl/hash:RE_ast
  dba: terminator
  min: 24695
  re: !!perl/hash:RE_sequence
    min: 24695
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 5
      text: until
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
terminator__S_347for: !!perl/hash:RE_ast
  dba: terminator
  min: 24693
  re: !!perl/hash:RE_sequence
    min: 24693
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 3
      text: for
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
terminator__S_348given: !!perl/hash:RE_ast
  dba: terminator
  min: 24695
  re: !!perl/hash:RE_sequence
    min: 24695
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 5
      text: given
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
terminator__S_349when: !!perl/hash:RE_ast
  dba: terminator
  min: 24694
  re: !!perl/hash:RE_sequence
    min: 24694
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 4
      text: when
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_method
      min: 12345
      name: nofun
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
terminator__S_350MinusMinusGt: !!perl/hash:RE_ast
  dba: terminator
  min: 12348
  re: !!perl/hash:RE_sequence
    min: 12348
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 3
      text: -->
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
terminator__S_351BangBang: !!perl/hash:RE_ast
  dba: terminator
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: '!!'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_block
        min: 0
        nobind: 1
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
termish: !!perl/hash:RE_ast
  dba: postfix
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_bracket
      min: 12345
      re: &115 !!perl/hash:RE_any
        altname: termish_0
        dba: prefix or term
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          alt: termish_0 0
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: PRE
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 12345
              re: !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '!'
                  min: 0
                  re: !!perl/hash:RE_block
                    min: 0
                    nobind: 1
                - !!perl/hash:RE_method
                  min: 12345
                  name: PRE
                  rest: ''
            min: 0
            quant:
            - '*'
          - !!perl/hash:RE_bracket
            min: 0
            re: !!perl/hash:RE_first
              min: 0
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                min: 0
                re: !!perl/hash:RE_block
                  min: 0
                  nobind: 1
              - !!perl/hash:RE_method
                min: 12345
                name: term
                rest: ''
              - !!perl/hash:RE_method
                min: 12345
                name: panic
                rest: 1
        - !!perl/hash:RE_method
          alt: termish_0 1
          min: 12345
          name: term
          rest: ''
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_sequence
          min: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
          - !!perl/hash:RE_bracket
            min: 0
            re: !!perl/hash:RE_first
              min: 0
              zyg:
              - !!perl/hash:RE_sequence
                min: 0
                zyg:
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_block
                    min: 0
                    nobind: 1
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    min: 12345
                    re: !!perl/hash:RE_sequence
                      min: 12345
                      zyg:
                      - !!perl/hash:RE_quantified_atom
                        atom: !!perl/hash:RE_bracket
                          min: 12345
                          re: !!perl/hash:RE_sequence
                            min: 12345
                            zyg:
                            - !!perl/hash:RE_assertion
                              assert: '!'
                              min: 0
                              re: !!perl/hash:RE_method_re
                                min: 12345
                                name: before
                                nobind: 1
                                re: !!perl/hash:RE_string
                                  i: 0
                                  min: 1
                                  text: \
                            - !!perl/hash:RE_method
                              min: 12345
                              name: POST
                              rest: ''
                        min: 12345
                        quant:
                        - +
                      - !!perl/hash:RE_assertion
                        assert: '?'
                        min: 0
                        re: !!perl/hash:RE_method_re
                          min: 12345
                          name: after
                          nobind: 1
                          re: !!perl/hash:RE_cclass
                            i: 0
                            min: 1
                            text: '[ \] } > ) ]'
                  min: 0
                  quant:
                  - '?'
              - !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_bracket
                    min: 12345
                    re: !!perl/hash:RE_sequence
                      min: 12345
                      zyg:
                      - !!perl/hash:RE_assertion
                        assert: '!'
                        min: 0
                        re: !!perl/hash:RE_method_re
                          min: 12345
                          name: before
                          nobind: 1
                          re: !!perl/hash:RE_string
                            i: 0
                            min: 1
                            text: \
                      - !!perl/hash:RE_method
                        min: 12345
                        name: POST
                        rest: ''
                  min: 12345
                  quant:
                  - +
                - !!perl/hash:RE_assertion
                  assert: '?'
                  min: 0
                  re: !!perl/hash:RE_method_re
                    min: 12345
                    name: after
                    nobind: 1
                    re: !!perl/hash:RE_cclass
                      i: 0
                      min: 1
                      text: '[ \] } > ) ]'
              - !!perl/hash:RE_block
                min: 0
        - !!perl/hash:RE_sequence
          min: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '!'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              min: 12345
              name: POST
              rest: ''
            min: 0
            quant:
            - '*'
    - !!perl/hash:RE_block
      min: 0
termish_0: *115
trait: !!perl/hash:RE_ast
  dba: trait
  min: 74070
  re: !!perl/hash:RE_sequence
    min: 74070
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 37035
      re: &116 !!perl/hash:RE_any
        altname: trait_0
        dba: trait
        min: 37035
        zyg:
        - !!perl/hash:RE_sequence
          alt: trait_0 0
          min: 37035
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: trait_mod
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          alt: trait_0 1
          min: 37035
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: colonpair
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
trait_0: *116
trait_mod__S_069is: !!perl/hash:RE_ast
  dba: trait_mod
  min: 74070
  re: !!perl/hash:RE_sequence
    min: 74070
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: is
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: longname
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: circumfix
        rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_block
      min: 0
trait_mod__S_070hides: !!perl/hash:RE_ast
  dba: trait_mod
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: hides
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: module_name
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
trait_mod__S_071does: !!perl/hash:RE_ast
  dba: trait_mod
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: does
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: module_name
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
trait_mod__S_072will: !!perl/hash:RE_ast
  dba: trait_mod
  min: 86415
  re: !!perl/hash:RE_sequence
    min: 86415
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: will
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: identifier
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: pblock
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
trait_mod__S_073of: !!perl/hash:RE_ast
  dba: trait_mod
  min: 61727
  re: !!perl/hash:RE_sequence
    min: 61727
    zyg:
    - !!perl/hash:RE_bracket
      min: 2
      re: &117 !!perl/hash:RE_any
        altname: trait_mod__S_073of_0
        dba: trait_mod
        min: 2
        zyg:
        - !!perl/hash:RE_string
          alt: trait_mod__S_073of_0 0
          i: 0
          min: 2
          text: of
        - !!perl/hash:RE_string
          alt: trait_mod__S_073of_0 1
          i: 0
          min: 7
          text: returns
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: typename
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 49380
        re: !!perl/hash:RE_sequence
          min: 49380
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
          - !!perl/hash:RE_method
            min: 12345
            name: sorry
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_block
      min: 0
trait_mod__S_073of_0: *117
trait_mod__S_074as: !!perl/hash:RE_ast
  dba: trait_mod
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: as
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: typename
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
trait_mod__S_075handles: !!perl/hash:RE_ast
  dba: trait_mod
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: handles
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: term
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
tribble: !!perl/hash:RE_ast
  dba: tribble
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: babble
      rest: 1
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_var
      min: 0
      var: $start
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        min: 12345
        name: nibble
        rest: 1
      min: 12345
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_var
          min: 0
          var: $stop
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_first
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          min: 24690
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: quibble
            rest: 1
        - !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_block
            min: 0
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              min: 12345
              name: nibble
              rest: 1
            min: 12345
          - !!perl/hash:RE_var
            min: 0
            var: $stop
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
type_constraint: !!perl/hash:RE_ast
  dba: type_constraint
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_bracket
      min: 12345
      re: &118 !!perl/hash:RE_any
        altname: type_constraint_0
        dba: type_constraint
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          alt: type_constraint_0 0
          min: 12345
          name: value
          rest: ''
        - !!perl/hash:RE_method
          alt: type_constraint_0 1
          min: 12345
          name: typename
          rest: ''
        - !!perl/hash:RE_sequence
          alt: type_constraint_0 2
          min: 24695
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: w
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: h
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: e
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: r
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: e
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: EXPR
            rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
type_constraint_0: *118
type_declarator__S_165subset: !!perl/hash:RE_ast
  dba: type_declarator
  min: 37035
  re: !!perl/hash:RE_first
    min: 37035
    zyg:
    - !!perl/hash:RE_sequence
      min: 98760
      zyg:
      - !!perl/hash:RE_method
        endsym: spacey
        i: 0
        min: 12345
        name: sym
        rest: ''
        sym: subset
      - !!perl/hash:RE_method
        min: 12345
        name: spacey
        rest: ''
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
      - !!perl/hash:RE_bracket
        min: 49380
        re: !!perl/hash:RE_sequence
          min: 49380
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 49380
              re: !!perl/hash:RE_sequence
                min: 49380
                zyg:
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: longname
                  rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_block
                  min: 0
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              min: 12345
              name: trait
              rest: ''
            min: 0
            quant:
            - '*'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 37040
              re: !!perl/hash:RE_sequence
                min: 37040
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: w
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: h
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: e
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: r
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: e
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
                - !!perl/hash:RE_method
                  min: 12345
                  name: EXPR
                  rest: 1
                - !!perl/hash:RE_method
                  min: 12345
                  name: ws
                  rest: ''
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
    - !!perl/hash:RE_sequence
      min: 37035
      zyg:
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
      - !!perl/hash:RE_method
        min: 12345
        name: panic
        rest: 1
      - !!perl/hash:RE_method
        min: 12345
        name: ws
        rest: ''
type_declarator__S_166enum: !!perl/hash:RE_ast
  dba: type_declarator
  min: 74070
  re: !!perl/hash:RE_sequence
    min: 74070
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: enum
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 0
      re: &119 !!perl/hash:RE_any
        altname: type_declarator__S_166enum_0
        dba: type_declarator
        min: 0
        zyg:
        - !!perl/hash:RE_sequence
          alt: type_declarator__S_166enum_0 0
          min: 12345
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              min: 12345
              name: longname
              rest: ''
            min: 12345
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          alt: type_declarator__S_166enum_0 1
          min: 12345
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              min: 12345
              name: variable
              rest: ''
            min: 12345
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_assertion
          alt: type_declarator__S_166enum_0 2
          assert: '?'
          min: 0
          re: !!perl/hash:RE_noop
            min: 0
            nobind: 1
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: trait
        rest: ''
      min: 0
      quant:
      - '*'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_cclass
          i: 0
          min: 1
          text: '[ < ( « ]'
    - !!perl/hash:RE_method
      min: 12345
      name: term
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_block
      min: 0
type_declarator__S_166enum_0: *119
type_declarator__S_167constant: !!perl/hash:RE_ast
  dba: type_declarator
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      endsym: spacey
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: constant
    - !!perl/hash:RE_method
      min: 12345
      name: spacey
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 0
      re: &120 !!perl/hash:RE_any
        altname: type_declarator__S_167constant_0
        dba: type_declarator
        min: 0
        zyg:
        - !!perl/hash:RE_sequence
          alt: type_declarator__S_167constant_0 0
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: identifier
            rest: ''
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          alt: type_declarator__S_167constant_0 1
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: variable
            rest: ''
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_assertion
          alt: type_declarator__S_167constant_0 2
          assert: '?'
          min: 0
          re: !!perl/hash:RE_noop
            min: 0
            nobind: 1
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: trait
        rest: ''
      min: 0
      quant:
      - '*'
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 1
              text: =
        - !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                min: 1
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_cclass
                    i: 0
                    min: 1
                    text: -[\n=]
                  min: 0
                  quant:
                  - '*'
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: =
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
        - !!perl/hash:RE_method
          min: 12345
          name: sorry
          rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: getdecl
      rest: ''
type_declarator__S_167constant_0: *120
typename: !!perl/hash:RE_ast
  dba: typename
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_bracket
      min: 12345
      re: &121 !!perl/hash:RE_any
        altname: typename_0
        dba: typename
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          alt: typename_0 0
          min: 12348
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 3
            text: ::?
          - !!perl/hash:RE_method
            min: 12345
            name: identifier
            rest: ''
        - !!perl/hash:RE_sequence
          alt: typename_0 1
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: longname
            rest: ''
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: unsp
        rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                min: 1
                text: '['
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              min: 12345
              name: postcircumfix
              rest: ''
            min: 12345
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: unsp
        rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                min: 1
                text: '{'
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_method
              min: 12345
              name: postcircumfix
              rest: ''
            min: 12345
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 37037
        re: !!perl/hash:RE_sequence
          min: 37037
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_string
            i: 0
            min: 2
            text: of
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: typename
            rest: ''
      min: 0
      quant:
      - '?'
typename_0: *121
value__S_135quote: !!perl/hash:RE_ast
  dba: value
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: quote
    rest: ''
value__S_136number: !!perl/hash:RE_ast
  dba: value
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: number
    rest: ''
value__S_137version: !!perl/hash:RE_ast
  dba: value
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: version
    rest: ''
variable: !!perl/hash:RE_ast
  dba: variable
  min: 0
  re: !!perl/hash:RE_sequence
    min: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: sigil
            rest: ''
          - !!perl/hash:RE_block
            min: 0
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_sequence
          min: 24690
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: sigil
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              min: 12345
              name: twigil
              rest: ''
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                min: 3
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 2
                  text: '::'
                - !!perl/hash:RE_bracket
                  min: 1
                  re: &122 !!perl/hash:RE_any
                    altname: variable_0
                    dba: variable
                    min: 1
                    zyg:
                    - !!perl/hash:RE_string
                      alt: variable_0 0
                      i: 0
                      min: 1
                      text: '{'
                    - !!perl/hash:RE_string
                      alt: variable_0 1
                      i: 0
                      min: 1
                      text: <
                    - !!perl/hash:RE_string
                      alt: variable_0 2
                      i: 0
                      min: 1
                      text: (
          - !!perl/hash:RE_method
            min: 12345
            name: longname
            rest: ''
        - !!perl/hash:RE_sequence
          min: 12346
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: '&'
          - !!perl/hash:RE_bracket
            min: 12345
            re: &123 !!perl/hash:RE_any
              altname: variable_1
              dba: infix noun
              min: 12345
              zyg:
              - !!perl/hash:RE_sequence
                alt: variable_1 0
                min: 12345
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_method
                    min: 12345
                    name: twigil
                    rest: ''
                  min: 0
                  quant:
                  - '?'
                - !!perl/hash:RE_method
                  min: 12345
                  name: sublongname
                  rest: ''
                - !!perl/hash:RE_block
                  min: 0
              - !!perl/hash:RE_bracket
                alt: variable_1 1
                min: 12347
                re: !!perl/hash:RE_sequence
                  min: 12347
                  zyg:
                  - !!perl/hash:RE_string
                    i: 0
                    min: 1
                    text: '['
                  - !!perl/hash:RE_block
                    min: 0
                  - !!perl/hash:RE_method
                    min: 12345
                    name: infixish
                    rest: 1
                  - !!perl/hash:RE_bracket
                    min: 1
                    re: !!perl/hash:RE_first
                      min: 1
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        min: 1
                        text: ']'
                      - !!perl/hash:RE_method
                        min: 12345
                        name: FAILGOAL
                        rest: 1
        - !!perl/hash:RE_sequence
          min: 3
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 3
            text: '$::'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              min: 12345
              name: name
              rest: ''
            min: 0
            quant:
            - '?'
        - !!perl/hash:RE_sequence
          min: 12347
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 2
            text: '$:'
          - !!perl/hash:RE_method
            min: 12345
            name: name
            rest: ''
        - !!perl/hash:RE_bracket
          min: 0
          re: &124 !!perl/hash:RE_any
            altname: variable_2
            dba: variable
            min: 0
            zyg:
            - !!perl/hash:RE_sequence
              alt: variable_2 0
              min: 24690
              zyg:
              - !!perl/hash:RE_method
                min: 12345
                name: sigil
                rest: ''
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_method
                  min: 12345
                  name: twigil
                  rest: ''
                min: 0
                quant:
                - '?'
              - !!perl/hash:RE_method
                min: 12345
                name: desigilname
                rest: ''
              - !!perl/hash:RE_block
                min: 0
            - !!perl/hash:RE_method
              alt: variable_2 1
              min: 12345
              name: special_variable
              rest: ''
            - !!perl/hash:RE_sequence
              alt: variable_2 2
              min: 24690
              zyg:
              - !!perl/hash:RE_method
                min: 12345
                name: sigil
                rest: ''
              - !!perl/hash:RE_bindnamed
                atom: !!perl/hash:RE_method
                  min: 12345
                  name: decint
                  rest: ''
                min: 12345
            - !!perl/hash:RE_sequence
              alt: variable_2 3
              min: 24690
              zyg:
              - !!perl/hash:RE_method
                min: 12345
                name: sigil
                rest: ''
              - !!perl/hash:RE_assertion
                assert: '?'
                min: 0
                re: !!perl/hash:RE_method_re
                  min: 12345
                  name: before
                  nobind: 1
                  re: &125 !!perl/hash:RE_any
                    altname: variable_3
                    dba: variable
                    min: 1
                    zyg:
                    - !!perl/hash:RE_string
                      alt: variable_3 0
                      i: 0
                      min: 1
                      text: <
                    - !!perl/hash:RE_string
                      alt: variable_3 1
                      i: 0
                      min: 1
                      text: (
              - !!perl/hash:RE_method
                min: 12345
                name: postcircumfix
                rest: ''
            - !!perl/hash:RE_sequence
              alt: variable_2 4
              min: 12345
              zyg:
              - !!perl/hash:RE_method
                min: 12345
                name: sigil
                rest: ''
              - !!perl/hash:RE_assertion
                assert: '?'
                min: 0
                re: !!perl/hash:RE_block
                  min: 0
                  nobind: 1
            - !!perl/hash:RE_sequence
              alt: variable_2 5
              min: 0
              zyg:
              - !!perl/hash:RE_assertion
                assert: '?'
                min: 0
                re: !!perl/hash:RE_noop
                  min: 0
                  nobind: 1
              - !!perl/hash:RE_block
                min: 0
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
          - !!perl/hash:RE_bracket
            min: 0
            re: &126 !!perl/hash:RE_any
              altname: variable_4
              dba: variable
              min: 0
              zyg:
              - !!perl/hash:RE_method
                alt: variable_4 0
                min: 12345
                name: unsp
                rest: ''
              - !!perl/hash:RE_string
                alt: variable_4 1
                i: 0
                min: 1
                text: \
              - !!perl/hash:RE_assertion
                alt: variable_4 2
                assert: '?'
                min: 0
                re: !!perl/hash:RE_noop
                  min: 0
                  nobind: 1
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                min: 1
                text: (
          - !!perl/hash:RE_method
            min: 12345
            name: postcircumfix
            rest: ''
      min: 0
      quant:
      - '?'
variable_0: *122
variable_1: *123
variable_2: *124
variable_3: *125
variable_4: *126
variable_declarator: !!perl/hash:RE_ast
  dba: variable_declarator
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: variable
      rest: ''
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 0
        re: !!perl/hash:RE_sequence
          min: 0
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_method
              min: 12345
              name: unsp
              rest: ''
            min: 0
            quant:
            - '?'
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_bracket
                min: 12345
                re: &127 !!perl/hash:RE_any
                  altname: variable_declarator_0
                  dba: shape definition
                  min: 12345
                  zyg:
                  - !!perl/hash:RE_sequence
                    alt: variable_declarator_0 0
                    min: 12347
                    zyg:
                    - !!perl/hash:RE_bracket
                      min: 12347
                      re: !!perl/hash:RE_sequence
                        min: 12347
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          min: 1
                          text: (
                        - !!perl/hash:RE_block
                          min: 0
                        - !!perl/hash:RE_method
                          min: 12345
                          name: signature
                          rest: ''
                        - !!perl/hash:RE_bracket
                          min: 1
                          re: !!perl/hash:RE_first
                            min: 1
                            zyg:
                            - !!perl/hash:RE_string
                              i: 0
                              min: 1
                              text: )
                            - !!perl/hash:RE_method
                              min: 12345
                              name: FAILGOAL
                              rest: 1
                    - !!perl/hash:RE_block
                      min: 0
                  - !!perl/hash:RE_bracket
                    alt: variable_declarator_0 1
                    min: 12347
                    re: !!perl/hash:RE_sequence
                      min: 12347
                      zyg:
                      - !!perl/hash:RE_string
                        i: 0
                        min: 1
                        text: '['
                      - !!perl/hash:RE_block
                        min: 0
                      - !!perl/hash:RE_method
                        min: 12345
                        name: semilist
                        rest: ''
                      - !!perl/hash:RE_bracket
                        min: 1
                        re: !!perl/hash:RE_first
                          min: 1
                          zyg:
                          - !!perl/hash:RE_string
                            i: 0
                            min: 1
                            text: ']'
                          - !!perl/hash:RE_method
                            min: 12345
                            name: FAILGOAL
                            rest: 1
                  - !!perl/hash:RE_sequence
                    alt: variable_declarator_0 2
                    min: 24692
                    zyg:
                    - !!perl/hash:RE_bracket
                      min: 12347
                      re: !!perl/hash:RE_sequence
                        min: 12347
                        zyg:
                        - !!perl/hash:RE_string
                          i: 0
                          min: 1
                          text: '{'
                        - !!perl/hash:RE_block
                          min: 0
                        - !!perl/hash:RE_method
                          min: 12345
                          name: semilist
                          rest: ''
                        - !!perl/hash:RE_bracket
                          min: 1
                          re: !!perl/hash:RE_first
                            min: 1
                            zyg:
                            - !!perl/hash:RE_string
                              i: 0
                              min: 1
                              text: '}'
                            - !!perl/hash:RE_method
                              min: 12345
                              name: FAILGOAL
                              rest: 1
                    - !!perl/hash:RE_method
                      min: 12345
                      name: curlycheck
                      rest: ''
                  - !!perl/hash:RE_sequence
                    alt: variable_declarator_0 3
                    min: 12345
                    zyg:
                    - !!perl/hash:RE_assertion
                      assert: '?'
                      min: 0
                      re: !!perl/hash:RE_method_re
                        min: 12345
                        name: before
                        nobind: 1
                        re: !!perl/hash:RE_string
                          i: 0
                          min: 1
                          text: <
                    - !!perl/hash:RE_method
                      min: 12345
                      name: postcircumfix
                      rest: ''
              min: 0
              quant:
              - '*'
            min: 0
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: trait
        rest: ''
      min: 0
      quant:
      - '*'
    - !!perl/hash:RE_method
      min: 12345
      name: getdecl
      rest: ''
variable_declarator_0: *127
version__S_040v: !!perl/hash:RE_ast
  dba: version
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: v
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          min: 1
          quant:
          - +
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: vnum
        rest: ''
      min: 12345
      quant:
      - '**'
      - ':'
      - !!perl/hash:RE_string
        a: 0
        dba: version
        i: 0
        i_needed: 1
        min: 1
        r: 1
        s: 0
        text: .
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        min: 1
        text: +
      min: 0
      quant:
      - '?'
vnum: !!perl/hash:RE_ast
  dba: vnum
  min: 1
  re: &128 !!perl/hash:RE_any
    altname: vnum_0
    dba: vnum
    min: 1
    zyg:
    - !!perl/hash:RE_quantified_atom
      alt: vnum_0 0
      atom: !!perl/hash:RE_meta
        min: 1
        text: \d
      min: 1
      quant:
      - +
    - !!perl/hash:RE_string
      alt: vnum_0 1
      i: 0
      min: 1
      text: '*'
vnum_0: *128
xblock: !!perl/hash:RE_ast
  dba: xblock
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: EXPR
      rest: ''
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: pblock
      rest: ''
RETREE_END
## rule comp_unit {
sub comp_unit__PEEK { $_[0]->_AUTOLEXpeek('comp_unit', $retree) }
sub comp_unit {
no warnings 'recursion';
my $self = shift;

local $::begin_compunit = 1;
local $::endargs = -1;
local %::LANG;
local $::PKGDECL = "";
local $::IN_DECL = '';
local $::DECLARAND;
local $::NEWPKG;
local $::NEWPAD;
local $::QSIGIL = '';
local $::IN_META = '';
local $::QUASIMODO;
local $::SCOPE = "";
local $::LEFTSIGIL;
local $::PRECLIM;
local %::MYSTERY = ();
local $::INVOCANT_OK;
local $::INVOCANT_IS;
local $::CURPAD;
local $::MULTINESS = '';
local $::SIGNUM = 0;
local $::MONKEY_TYPING = 0;
local %::WORRIES;
local @::WORRIES;
local $::FATALS = 0;
local $::IN_SUPPOSE = 0;
local $::CURPKG;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE comp_unit");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "comp_unit", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = (scalar(do {
{
$::LANG{'MAIN'}    = 'STD::P6' ;
$::LANG{'Q'}       = 'STD::Q' ;
$::LANG{'Quasi'}   = 'STD::Quasi' ;
$::LANG{'Regex'}   = 'STD::Regex' ;
$::LANG{'P5'}      = 'STD::P5' ;
$::LANG{'P5Regex'} = 'STD::P5::Regex' ;
@::WORRIES = ();
$self->load_setting($::SETTINGNAME);
my $oid = $::SETTING->id;
my $id = 'MY:file<' . $::FILE->{'name'} . '>';
$::CURPAD = Stash->new(
                'OUTER::' => [$oid],
                '!file' => $::FILE, '!line' => 0,
                '!id' => [$id],
            );
$ALL->{$id} = $::CURPAD;
$::UNIT = $::CURPAD;
$ALL->{'UNIT'} = $::UNIT;
$self->finishpad;
}}, $C))
and ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->unitstopper)) { ($C) } else { () }
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic( "Confused"))
and ($C) = ($C->ws)) {
$C
} else { () }
}
};
@gather;
}
}))) {
scalar(do {
{
$C->explain_mystery();
if (@::WORRIES) {
print STDERR "Potential difficulties:\n  " . join( "\n  ", @::WORRIES) . "\n"};
die "Check failed\n" if $::FATALS;
}}, $C)
} else { () }
});
}
;
## token pblock () {
sub pblock__PEEK { $_[0]->_AUTOLEXpeek('pblock', $retree) }
sub pblock {
no warnings 'recursion';
my $self = shift;

local $::CURPAD = $::CURPAD;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE pblock");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "pblock", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'pblock_0') {
        $C->deb("Fate passed to pblock_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT pblock_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM pblock_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'pblock_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("pblock_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->lambda)) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_EXACT("\{")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
{
if ($::BORG and $::BORG->{'block'}) {
if ($::BORG->{'name'}) {
my $m = "Function '" . $::BORG->{'name'} . "' needs parens to avoid gobbling block" . $::BORG->{'culprit'}->locmess;
$::BORG->{'block'}->panic($m . "\nMissing block (apparently gobbled by '" . $::BORG->{'name'} . "')");
}
else {
my $m = "Expression needs parens to avoid gobbling block" . $::BORG->{'culprit'}->locmess;
$::BORG->{'block'}->panic($m . "\nMissing block (apparently gobbled by expression)");
}}
elsif (%::MYSTERY) {
$C->panic("Missing block (apparently gobbled by undeclared routine?)")}
else {
$C->panic("Missing block")}}}, $C)
};
@gather;
}
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'pblock_1') {
        $C->deb("Fate passed to pblock_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT pblock_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM pblock_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'pblock_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("pblock_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['lambda'], sub {
my $C = shift;
$C->lambda
}))
and ($C) = ($C->newpad(1))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature(1)
}))
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->getsig)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))
and ($C) = ($C->newpad(1))
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->getsig)) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token lambda { '->' | '<->' }
sub lambda__PEEK { $_[0]->_AUTOLEXpeek('lambda', $retree) }
sub lambda {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE lambda");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "lambda", do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'lambda_0') {
        $C->deb("Fate passed to lambda_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT lambda_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM lambda_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'lambda_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("lambda_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\-\>")
},
sub {
my $C=shift;
$C->_EXACT("\<\-\>")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
});
}
;
## token xblock {
sub xblock__PEEK { $_[0]->_AUTOLEXpeek('xblock', $retree) }
sub xblock {
no warnings 'recursion';
my $self = shift;

local $::GOAL = '{';
local $::BORG = {
};

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE xblock");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "xblock", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = (scalar(do {
my $M = $C;
$::BORG->{'culprit'} //= $M->{'EXPR'}->cursor($self->{'_pos'}) }, $C))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
})
} else { () }
});
}
;
## token block () {
sub block__PEEK { $_[0]->_AUTOLEXpeek('block', $retree) }
sub block {
no warnings 'recursion';
my $self = shift;

local $::CURPAD = $::CURPAD;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE block");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "block", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Missing block"))) { ($C) } else { () }
}
};
@gather;
}
}))
and ($C) = ($C->newpad)
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->checkyada)) {
$C
} else { () }
});
}
;
## token blockoid {
sub blockoid__PEEK { $_[0]->_AUTOLEXpeek('blockoid', $retree) }
sub blockoid {
no warnings 'recursion';
my $self = shift;

local %::LANG = %::LANG;
local $::SIGNUM;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE blockoid");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "blockoid", do {
my $C = $C;
if (($C) = ($C->finishpad)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'blockoid_0') {
        $C->deb("Fate passed to blockoid_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT blockoid_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM blockoid_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'blockoid_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("blockoid_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\}";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\{"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'block', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->curlycheck)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->terminator)) { ($C) } else { () }
}))
and ($C) = ($C->panic('Missing block'))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
$C
}))
and ($C) = ($C->panic("Malformed block"))) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token curlycheck {
sub curlycheck__PEEK { $_[0]->_AUTOLEXpeek('curlycheck', $retree) }
sub curlycheck {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE curlycheck");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "curlycheck", $C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]*+(?m:$)/)
}))) { ($C) } else { () }
}))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'endstmt'} = 2}, $C)
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]*+[\\,:]/)
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->unv)
and ($C) = ($C->_PATTERN(qr/\G(?m:$)/))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'endstmt'} = 2}, $C)
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'endargs'} = 1}, $C)
} else { () }
}
};
@gather;
}
}));
}
;
## token regex_block {
sub regex_block__PEEK { $_[0]->_AUTOLEXpeek('regex_block', $retree) }
sub regex_block {
no warnings 'recursion';
my $self = shift;

local %::LANG = %::LANG;
local %::RX = %::RX;
my $lang = $::LANG{'Regex'};
local $::GOAL = '}';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_block");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'quotepair'} = [];
$self->_MATCHIFYr($S, "regex_block", do {
my $C = $C;
if (($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
my $kv = $M->{'quotepair'}->[-1];
$lang = ($lang->tweak($kv->{'k'}, $kv->{'v'})
                    or $lang->panic("Unrecognized adverb :" . $kv->{'k'} . '(' . $kv->{'v'} . ')'));
}, $C)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_EXACT("\{"))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble( $C->cursor_fresh($lang)->unbalanced('}') )
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unable to parse regex; couldn't find right brace"))) { ($C) } else { () }
}
};
@gather;
}
}))
and ($C) = ($C->curlycheck)) {
$C
} else { () }
});
}
;
## rule statementlist {
sub statementlist__PEEK { $_[0]->_AUTOLEXpeek('statementlist', $retree) }
sub statementlist {
no warnings 'recursion';
my $self = shift;

local $::INVOCANT_OK = 0;
local $::MONKEY_TYPING = $::MONKEY_TYPING;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statementlist");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'eat_terminator'} = [];
$C->{'statement'} = [];
$self->_MATCHIFYr($S, "statementlist", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'statementlist_0') {
        $C->deb("Fate passed to statementlist_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT statementlist_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM statementlist_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'statementlist_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("statementlist_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\z/))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_PATTERN(qr/\G[\)\]\}]/)
} else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))
and ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
$self->mark_sinks($M->{'statement'}) }, $C)
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## rule semilist {
sub semilist__PEEK { $_[0]->_AUTOLEXpeek('semilist', $retree) }
sub semilist {
no warnings 'recursion';
my $self = shift;

local $::INVOCANT_OK = 0;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE semilist");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'eat_terminator'} = [];
$C->{'statement'} = [];
$self->_MATCHIFYr($S, "semilist", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'semilist_0') {
        $C->deb("Fate passed to semilist_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT semilist_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM semilist_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'semilist_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("semilist_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_PATTERN(qr/\G[\)\]\}]/)
} else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))
and ($C) = ($C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token label {
sub label__PEEK { $_[0]->_AUTOLEXpeek('label', $retree) }
sub label {
no warnings 'recursion';
my $self = shift;

my $label;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE label");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "label", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->_EXACT("\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$C->is_name($label = $M->{'identifier'}->Str) })
}))
and ($C) = ($C->sorry("Illegal redeclaration of '$label'"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
{
$C->add_constant($label,$self->label_id)}}, $C)
} else { () }
});
}
;
## token statement {
sub statement__PEEK { $_[0]->_AUTOLEXpeek('statement', $retree) }
sub statement {
no warnings 'recursion';
my $self = shift;

local $::endargs = -1;
local $::QSIGIL = 0;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'statement_mod_cond'} = [];
$C->{'statement_mod_loop'} = [];
$self->_MATCHIFYr($S, "statement", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\)\]\}]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::LASTSTATE = $C->{'_pos'};
$C = $::LANG{'MAIN'}->bless($C);
})
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_0') {
        $C->deb("Fate passed to statement_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT statement_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM statement_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'statement_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("statement_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['label'], sub {
my $C = shift;
$C->label
}))) {
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
})
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['statement_control'], sub {
my $C = shift;
$C->statement_control
})
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
($::MEMOS[$C->{'_pos'}]->{'endstmt'} // 0) == 2 })
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_1') {
        $C->deb("Fate passed to statement_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT statement_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM statement_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'statement_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("statement_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['statement_mod_loop'], sub {
my $C = shift;
$C->statement_mod_loop
}))) {
scalar(do {
my $M = $C;
{
my $sp = $M->{'EXPR'}->{'statement_prefix'};
if ($sp and $sp->{'sym'} eq 'do') {
my $s = $M->{'statement_mod_loop'}->[0]->{'sym'};
$C->obs("do...$s" ,"repeat...$s");
};
}}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['statement_mod_cond'], sub {
my $C = shift;
$C->statement_mod_cond
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
($::MEMOS[$C->{'_pos'}]->{'endstmt'} // 0) == 2 })
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->ws)) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['statement_mod_loop'], sub {
my $C = shift;
$C->statement_mod_loop
})
})
} else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
})
} else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\;")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->panic("Bogus statement"))) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
($::MEMOS[$::MEMOS[$C->{'_pos'}]->{'ws'}//$C->{'_pos'}]->{'endargs'}//0) == 1 })
}))
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_2') {
        $C->deb("Fate passed to statement_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT statement_2';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM statement_2'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'statement_2', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("statement_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\;")
},
sub {
my $C=shift;
$C->_EXACT("\)")
},
sub {
my $C=shift;
$C->_EXACT("\]")
},
sub {
my $C=shift;
$C->_EXACT("\}")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->infixstopper)) { ($C) } else { () }
}))
and ($C) = (scalar(do {
$::HIGHWATER = $C->{'_pos'} = $::MEMOS[$C->{'_pos'}]->{'ws'}//$C->{'_pos'}}, $C))
and ($C) = ($C->panic("Strange text after block (missing comma, semicolon, comment marker?)"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token eat_terminator {
sub eat_terminator__PEEK { $_[0]->_AUTOLEXpeek('eat_terminator', $retree) }
sub eat_terminator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE eat_terminator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "eat_terminator", $C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\;")
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
($::MEMOS[$C->{'_pos'}]->{'endstmt'}//0) >= 2 })
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'eat_terminator_0') {
        $C->deb("Fate passed to eat_terminator_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT eat_terminator_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM eat_terminator_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'eat_terminator_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("eat_terminator_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\)")
},
sub {
my $C=shift;
$C->_EXACT("\]")
},
sub {
my $C=shift;
$C->_EXACT("\}")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, $C->_PATTERN(qr/\G\z/)
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->stopper)) { ($C) } else { () }
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->suppose(sub {
my $C=shift;
$C->_SUBSUMEr(['statement_control'], sub {
my $C = shift;
$C->statement_control
})
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->backup_ws)
and ($C) = (scalar(do {
$::HIGHWATER = -1}, $C))
and ($C) = ($C->panic("Missing semicolon"))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Confused"))) { ($C) } else { () }
}
};
@gather;
}
}));
}
;
## method backup_ws ()
sub backup_ws {
no warnings 'recursion';
my $self = shift;
if ($::MEMOS[$self->{'_pos'}]->{'ws'}) {
return $self->cursor($::MEMOS[$self->{'_pos'}]->{'ws'})};
return $self;
};
## token statement_control:need {
sub statement_control__S_000need__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_000need', $retree) }
sub statement_control__S_000need {
no warnings 'recursion';
my $self = shift;

;
my $longname;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_000need");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'module_name'} = [];
$C->{'version'} = [];
$C->{sym} = "need";
$self->_MATCHIFYr($S, "statement_control__S_000need", do {
my $C = $C;
if (($C) = ($C->_EXACT("need"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\,")
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_000need_0') {
        $C->deb("Fate passed to statement_control__S_000need_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT statement_control__S_000need_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM statement_control__S_000need_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'statement_control__S_000need_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("statement_control__S_000need_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
{
local $::IN_DECL = 'use';
local $::SCOPE = 'use';
$longname = $M->{'module_name'}->[-1]->{'longname'};
$C->do_need($longname);
}}, $C)
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token statement_control:import {
sub statement_control__S_001import__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_001import', $retree) }
sub statement_control__S_001import {
no warnings 'recursion';
my $self = shift;

;
my $longname;
local $::IN_DECL = 'use';
local $::SCOPE = 'use';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_001import");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "import";
$self->_MATCHIFYr($S, "statement_control__S_001import", do {
my $C = $C;
if (($C) = ($C->_EXACT("import"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->spacey)
and ($C) = ($C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
}))) {
scalar(do {
my $M = $C;
{
local %::MYSTERY;
$C->do_import($M->{'term'}, $M->{'arglist'});
$C->explain_mystery();
}}, $C)
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
my $M = $C;
{
$C->do_import($M->{'term'}, '')}}, $C)
};
@gather;
}
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token statement_control:use {
sub statement_control__S_002use__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_002use', $retree) }
sub statement_control__S_002use {
no warnings 'recursion';
my $self = shift;

;
my $longname;
local $::IN_DECL = 'use';
local $::SCOPE = 'use';
local %::MYSTERY;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_002use");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "use";
$self->_MATCHIFYr($S, "statement_control__S_002use", do {
my $C = $C;
if (($C) = ($C->_EXACT("use"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_002use_0') {
        $C->deb("Fate passed to statement_control__S_002use_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT statement_control__S_002use_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM statement_control__S_002use_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'statement_control__S_002use_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("statement_control__S_002use_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
})
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))
and ($C) = (scalar(do {
my $M = $C;
{
$longname = $M->{'module_name'}->{'longname'};
if ($longname->Str eq 'MONKEY_TYPING') {
$::MONKEY_TYPING = 1};
}}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->spacey)
and ($C) = ($C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
}))) {
scalar(do {
my $M = $C;
{
$C->do_use($longname, $M->{'arglist'})}}, $C)
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
{
$C->do_use($longname, '')}}, $C)
};
@gather;
}
}))) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->ws)
and ($C) = ($C->explain_mystery)) {
$C
} else { () }
});
}
;
## token statement_control:no {
sub statement_control__S_003no__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_003no', $retree) }
sub statement_control__S_003no {
no warnings 'recursion';
my $self = shift;

;
local %::MYSTERY;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_003no");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{sym} = "no";
$self->_MATCHIFYr($S, "statement_control__S_003no", do {
my $C = $C;
if (($C) = ($C->_EXACT("no"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->explain_mystery)) {
$C
} else { () }
});
}
;
## token statement_control:if {
sub statement_control__S_004if__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_004if', $retree) }
sub statement_control__S_004if {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_004if");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'else'} = [];
$C->{'elsif'} = [];
$C->{sym} = "if";
$self->_MATCHIFYr($S, "statement_control__S_004if", do {
my $C = $C;
if (($C) = ($C->_EXACT("if"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_004if_0') {
        $C->deb("Fate passed to statement_control__S_004if_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT statement_control__S_004if_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM statement_control__S_004if_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'statement_control__S_004if_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("statement_control__S_004if_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\Gelse[\x20\t\r]*+if/))
and ($C) = ($C->ws)
and ($C) = ($C->sorry( "Please use 'elsif'"))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("elsif"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->spacey)) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['elsif'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_EXACT("else"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->spacey)) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['else'], sub {
my $C = shift;
$C->pblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token statement_control:unless {
sub statement_control__S_005unless__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_005unless', $retree) }
sub statement_control__S_005unless {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_005unless");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "unless";
$self->_MATCHIFYr($S, "statement_control__S_005unless", do {
my $C = $C;
if (($C) = ($C->_EXACT("unless"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_EXACT("else")
} else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic( "\"unless\" does not take \"else\" in Perl 6; please rewrite using \"if\""))
and ($C) = ($C->ws)) {
$C
} else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## token statement_control:while {
sub statement_control__S_006while__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_006while', $retree) }
sub statement_control__S_006while {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_006while");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "while";
$self->_MATCHIFYr($S, "statement_control__S_006while", do {
my $C = $C;
if (($C) = ($C->_EXACT("while"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_EXACT("\("))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G(?:my)?+/))
and ($C) = ($C->ws)
and ($C) = ($C->_PATTERN(qr/\G\$\w++/))
and ($C) = ($C->ws)) {
$C->_EXACT("\=")
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\<"))
and ($C) = ($C->ws)
and ($C) = ($C->_PATTERN(qr/\G\$?+\w++/))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\>"))
and ($C) = ($C->ws)) {
$C->_EXACT("\)")
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic( "This appears to be Perl 5 code"))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token statement_control:until {
sub statement_control__S_007until__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_007until', $retree) }
sub statement_control__S_007until {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_007until");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "until";
$self->_MATCHIFYr($S, "statement_control__S_007until", do {
my $C = $C;
if (($C) = ($C->_EXACT("until"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token statement_control:repeat {
sub statement_control__S_008repeat__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_008repeat', $retree) }
sub statement_control__S_008repeat {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_008repeat");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "repeat";
$self->_MATCHIFYr($S, "statement_control__S_008repeat", do {
my $C = $C;
if (($C) = ($C->_EXACT("repeat"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_008repeat_0') {
        $C->deb("Fate passed to statement_control__S_008repeat_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT statement_control__S_008repeat_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM statement_control__S_008repeat_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'statement_control__S_008repeat_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("statement_control__S_008repeat_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['wu'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_008repeat_1') {
        $C->deb("Fate passed to statement_control__S_008repeat_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT statement_control__S_008repeat_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM statement_control__S_008repeat_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'statement_control__S_008repeat_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("statement_control__S_008repeat_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("while")
},
sub {
my $C=shift;
$C->_EXACT("until")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})
}))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['wu'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_008repeat_2') {
        $C->deb("Fate passed to statement_control__S_008repeat_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT statement_control__S_008repeat_2';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM statement_control__S_008repeat_2'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'statement_control__S_008repeat_2', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("statement_control__S_008repeat_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("while")
},
sub {
my $C=shift;
$C->_EXACT("until")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->spacey)) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic( "Whitespace required after keyword"))) { ($C) } else { () }
}
};
@gather;
}
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token statement_control:loop {
sub statement_control__S_009loop__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_009loop', $retree) }
sub statement_control__S_009loop {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_009loop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "loop";
$self->_MATCHIFYr($S, "statement_control__S_009loop", do {
my $C = $C;
if (($C) = ($C->_EXACT("loop"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['eee'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_EXACT("\("))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['e1'], sub {
my $C = shift;
$C->EXPR
})
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\;"))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['e2'], sub {
my $C = shift;
$C->EXPR
})
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\;"))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['e3'], sub {
my $C = shift;
$C->EXPR
})
}))
and ($C) = ($C->ws)) {
$C->_EXACT("\)")
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic( "Malformed loop spec"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Whitespace required before block"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
};

})
})
}))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
} else { () }
});
}
;
## token statement_control:for {
sub statement_control__S_010for__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_010for', $retree) }
sub statement_control__S_010for {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_010for");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "for";
$self->_MATCHIFYr($S, "statement_control__S_010for", do {
my $C = $C;
if (($C) = ($C->_EXACT("for"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_PATTERN(qr/\G(?:my)?+/))
and ($C) = ($C->ws)
and ($C) = ($C->_PATTERN(qr/\G\$\w++/))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\("))
and ($C) = ($C->ws)) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic( "This appears to be Perl 5 code"))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_EXACT("\("))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->EXPR)) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\;"))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->EXPR)) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\;"))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->EXPR)) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\)"))
and ($C) = ($C->ws)) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('C-style "for (;;)" loop', '"loop (;;)"'))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token statement_control:foreach {
sub statement_control__S_011foreach__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_011foreach', $retree) }
sub statement_control__S_011foreach {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_011foreach");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "foreach";
$self->_MATCHIFYr($S, "statement_control__S_011foreach", do {
my $C = $C;
if (($C) = ($C->_EXACT("foreach"))
and ($C) = ($C->spacey)
and ($C) = ($C->obs("'foreach'", "'for'"))) {
$C
} else { () }
});
}
;
## token statement_control:given {
sub statement_control__S_012given__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_012given', $retree) }
sub statement_control__S_012given {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_012given");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "given";
$self->_MATCHIFYr($S, "statement_control__S_012given", do {
my $C = $C;
if (($C) = ($C->_EXACT("given"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token statement_control:when {
sub statement_control__S_013when__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_013when', $retree) }
sub statement_control__S_013when {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_013when");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "when";
$self->_MATCHIFYr($S, "statement_control__S_013when", do {
my $C = $C;
if (($C) = ($C->_EXACT("when"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'0'} = [];
do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_control__S_013when_0') {
        $C->deb("Fate passed to statement_control__S_013when_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT statement_control__S_013when_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM statement_control__S_013when_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'statement_control__S_013when_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("statement_control__S_013when_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("True")
},
sub {
my $C=shift;
$C->_EXACT("False")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }

})
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = (do {
my $M = $C;
$C->dumbsmart($M->{0}->Str)
})) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['xblock'], sub {
my $C = shift;
$C->xblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## rule statement_control:default {<sym> <block> }
sub statement_control__S_014default__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_014default', $retree) }
sub statement_control__S_014default {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_014default");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "default";
$self->_MATCHIFYr($S, "statement_control__S_014default", do {
my $C = $C;
if (($C) = ($C->_EXACT("default"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token statement_prefix:BEGIN   { :my %*MYSTERY; <sym> <blast> <.explain_mystery> }
sub statement_prefix__S_015BEGIN__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_015BEGIN', $retree) }
sub statement_prefix__S_015BEGIN {
no warnings 'recursion';
my $self = shift;

local %::MYSTERY;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_015BEGIN");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "BEGIN";
$self->_MATCHIFYr($S, "statement_prefix__S_015BEGIN", do {
my $C = $C;
if (($C) = ($C->_EXACT("BEGIN"))
and ($C) = ($C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
}))
and ($C) = ($C->explain_mystery)) {
$C
} else { () }
});
}
;
## token statement_prefix:CHECK   { <sym> <blast> }
sub statement_prefix__S_016CHECK__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_016CHECK', $retree) }
sub statement_prefix__S_016CHECK {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_016CHECK");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "CHECK";
$self->_MATCHIFYr($S, "statement_prefix__S_016CHECK", do {
if (my ($C) = ($C->_EXACT("CHECK"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:INIT    { <sym> <blast> }
sub statement_prefix__S_017INIT__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_017INIT', $retree) }
sub statement_prefix__S_017INIT {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_017INIT");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "INIT";
$self->_MATCHIFYr($S, "statement_prefix__S_017INIT", do {
if (my ($C) = ($C->_EXACT("INIT"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:START   { <sym> <blast> }
sub statement_prefix__S_018START__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_018START', $retree) }
sub statement_prefix__S_018START {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_018START");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "START";
$self->_MATCHIFYr($S, "statement_prefix__S_018START", do {
if (my ($C) = ($C->_EXACT("START"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:ENTER   { <sym> <blast> }
sub statement_prefix__S_019ENTER__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_019ENTER', $retree) }
sub statement_prefix__S_019ENTER {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_019ENTER");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ENTER";
$self->_MATCHIFYr($S, "statement_prefix__S_019ENTER", do {
if (my ($C) = ($C->_EXACT("ENTER"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:FIRST   { <sym> <blast> }
sub statement_prefix__S_020FIRST__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_020FIRST', $retree) }
sub statement_prefix__S_020FIRST {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_020FIRST");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "FIRST";
$self->_MATCHIFYr($S, "statement_prefix__S_020FIRST", do {
if (my ($C) = ($C->_EXACT("FIRST"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:END     { <sym> <blast> }
sub statement_prefix__S_021END__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_021END', $retree) }
sub statement_prefix__S_021END {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_021END");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "END";
$self->_MATCHIFYr($S, "statement_prefix__S_021END", do {
if (my ($C) = ($C->_EXACT("END"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:LEAVE   { <sym> <blast> }
sub statement_prefix__S_022LEAVE__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_022LEAVE', $retree) }
sub statement_prefix__S_022LEAVE {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_022LEAVE");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "LEAVE";
$self->_MATCHIFYr($S, "statement_prefix__S_022LEAVE", do {
if (my ($C) = ($C->_EXACT("LEAVE"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:KEEP    { <sym> <blast> }
sub statement_prefix__S_023KEEP__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_023KEEP', $retree) }
sub statement_prefix__S_023KEEP {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_023KEEP");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "KEEP";
$self->_MATCHIFYr($S, "statement_prefix__S_023KEEP", do {
if (my ($C) = ($C->_EXACT("KEEP"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:UNDO    { <sym> <blast> }
sub statement_prefix__S_024UNDO__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_024UNDO', $retree) }
sub statement_prefix__S_024UNDO {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_024UNDO");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "UNDO";
$self->_MATCHIFYr($S, "statement_prefix__S_024UNDO", do {
if (my ($C) = ($C->_EXACT("UNDO"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:NEXT    { <sym> <blast> }
sub statement_prefix__S_025NEXT__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_025NEXT', $retree) }
sub statement_prefix__S_025NEXT {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_025NEXT");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "NEXT";
$self->_MATCHIFYr($S, "statement_prefix__S_025NEXT", do {
if (my ($C) = ($C->_EXACT("NEXT"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:LAST    { <sym> <blast> }
sub statement_prefix__S_026LAST__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_026LAST', $retree) }
sub statement_prefix__S_026LAST {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_026LAST");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "LAST";
$self->_MATCHIFYr($S, "statement_prefix__S_026LAST", do {
if (my ($C) = ($C->_EXACT("LAST"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:PRE     { <sym> <blast> }
sub statement_prefix__S_027PRE__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_027PRE', $retree) }
sub statement_prefix__S_027PRE {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_027PRE");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "PRE";
$self->_MATCHIFYr($S, "statement_prefix__S_027PRE", do {
if (my ($C) = ($C->_EXACT("PRE"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:POST    { <sym> <blast> }
sub statement_prefix__S_028POST__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_028POST', $retree) }
sub statement_prefix__S_028POST {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_028POST");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "POST";
$self->_MATCHIFYr($S, "statement_prefix__S_028POST", do {
if (my ($C) = ($C->_EXACT("POST"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## rule statement_control:CATCH   {<sym> <block> }
sub statement_control__S_029CATCH__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_029CATCH', $retree) }
sub statement_control__S_029CATCH {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_029CATCH");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "CATCH";
$self->_MATCHIFYr($S, "statement_control__S_029CATCH", do {
my $C = $C;
if (($C) = ($C->_EXACT("CATCH"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## rule statement_control:CONTROL {<sym> <block> }
sub statement_control__S_030CONTROL__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_030CONTROL', $retree) }
sub statement_control__S_030CONTROL {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_030CONTROL");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "CONTROL";
$self->_MATCHIFYr($S, "statement_control__S_030CONTROL", do {
my $C = $C;
if (($C) = ($C->_EXACT("CONTROL"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## rule statement_control:TEMP    {<sym> <block> }
sub statement_control__S_031TEMP__PEEK { $_[0]->_AUTOLEXpeek('statement_control__S_031TEMP', $retree) }
sub statement_control__S_031TEMP {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_control__S_031TEMP");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "TEMP";
$self->_MATCHIFYr($S, "statement_control__S_031TEMP", do {
my $C = $C;
if (($C) = ($C->_EXACT("TEMP"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## rule modifier_expr { <EXPR> }
sub modifier_expr__PEEK { $_[0]->_AUTOLEXpeek('modifier_expr', $retree) }
sub modifier_expr {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE modifier_expr");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "modifier_expr", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## rule statement_mod_cond:if     {<sym> <modifier_expr> }
sub statement_mod_cond__S_032if__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_032if', $retree) }
sub statement_mod_cond__S_032if {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_cond__S_032if");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "if";
$self->_MATCHIFYr($S, "statement_mod_cond__S_032if", do {
my $C = $C;
if (($C) = ($C->_EXACT("if"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## rule statement_mod_cond:unless {<sym> <modifier_expr> }
sub statement_mod_cond__S_033unless__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_033unless', $retree) }
sub statement_mod_cond__S_033unless {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_cond__S_033unless");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "unless";
$self->_MATCHIFYr($S, "statement_mod_cond__S_033unless", do {
my $C = $C;
if (($C) = ($C->_EXACT("unless"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## rule statement_mod_cond:when   {<sym> <?before \h*('True'|'False')»<.dumbsmart($0[0].Str)>>? <modifi
sub statement_mod_cond__S_034when__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_cond__S_034when', $retree) }
sub statement_mod_cond__S_034when {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_cond__S_034when");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "when";
$self->_MATCHIFYr($S, "statement_mod_cond__S_034when", do {
my $C = $C;
if (($C) = ($C->_EXACT("when"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'0'} = [];
do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'statement_mod_cond__S_034when_0') {
        $C->deb("Fate passed to statement_mod_cond__S_034when_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT statement_mod_cond__S_034when_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM statement_mod_cond__S_034when_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'statement_mod_cond__S_034when_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("statement_mod_cond__S_034when_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("True")
},
sub {
my $C=shift;
$C->_EXACT("False")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }

})
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = (do {
my $M = $C;
$C->dumbsmart($M->{0}->[0]->Str)
})) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## rule statement_mod_loop:while {<sym> <modifier_expr> }
sub statement_mod_loop__S_035while__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_035while', $retree) }
sub statement_mod_loop__S_035while {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_loop__S_035while");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "while";
$self->_MATCHIFYr($S, "statement_mod_loop__S_035while", do {
my $C = $C;
if (($C) = ($C->_EXACT("while"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## rule statement_mod_loop:until {<sym> <modifier_expr> }
sub statement_mod_loop__S_036until__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_036until', $retree) }
sub statement_mod_loop__S_036until {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_loop__S_036until");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "until";
$self->_MATCHIFYr($S, "statement_mod_loop__S_036until", do {
my $C = $C;
if (($C) = ($C->_EXACT("until"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## rule statement_mod_loop:for   {<sym> <modifier_expr> }
sub statement_mod_loop__S_037for__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_037for', $retree) }
sub statement_mod_loop__S_037for {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_loop__S_037for");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "for";
$self->_MATCHIFYr($S, "statement_mod_loop__S_037for", do {
my $C = $C;
if (($C) = ($C->_EXACT("for"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## rule statement_mod_loop:given {<sym> <modifier_expr> }
sub statement_mod_loop__S_038given__PEEK { $_[0]->_AUTOLEXpeek('statement_mod_loop__S_038given', $retree) }
sub statement_mod_loop__S_038given {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_mod_loop__S_038given");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "given";
$self->_MATCHIFYr($S, "statement_mod_loop__S_038given", do {
my $C = $C;
if (($C) = ($C->_EXACT("given"))
and ($C) = ($C->nofun)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['modifier_expr'], sub {
my $C = shift;
$C->modifier_expr
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token module_name:normal {
sub module_name__S_039normal__PEEK { $_[0]->_AUTOLEXpeek('module_name__S_039normal', $retree) }
sub module_name__S_039normal {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE module_name__S_039normal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{sym} = "normal";
$self->_MATCHIFYr($S, "module_name__S_039normal", do {
if (my ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\[")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'generic role', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token vnum {
sub vnum__PEEK { $_[0]->_AUTOLEXpeek('vnum', $retree) }
sub vnum {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE vnum");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "vnum", do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'vnum_0') {
        $C->deb("Fate passed to vnum_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT vnum_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM vnum_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'vnum_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("vnum_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)
},
sub {
my $C=shift;
$C->_EXACT("\*")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
});
}
;
## token version:sym<v> {
sub version__S_040v__PEEK { $_[0]->_AUTOLEXpeek('version__S_040v', $retree) }
sub version__S_040v {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE version__S_040v");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'vnum'} = [];
$C->{sym} = "v";
$self->_MATCHIFYr($S, "version__S_040v", do {
my $C = $C;
if (($C) = ($C->_EXACT("v"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\.")
}, sub {
my $C=shift;
$C->_SUBSUMEr(['vnum'], sub {
my $C = shift;
$C->vnum
})
}))) {
$C->_PATTERN(qr/\G\+?+/)
} else { () }
});
}
;
## token variable_declarator {
sub variable_declarator__PEEK { $_[0]->_AUTOLEXpeek('variable_declarator', $retree) }
sub variable_declarator {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = 'variable';
local $::DECLARAND;
my $var;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE variable_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'postcircumfix'} = [];
$C->{'semilist'} = [];
$C->{'shape'} = [];
$C->{'signature'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "variable_declarator", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))
and ($C) = (scalar(do {
my $M = $C;
$var = $M->{'variable'}->Str;
$C->add_variable($var);
$::IN_DECL = '';
}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))) {
$C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['shape'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_declarator_0') {
        $C->deb("Fate passed to variable_declarator_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT variable_declarator_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM variable_declarator_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'variable_declarator_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("variable_declarator_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'variable_declarator', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
scalar(do {
{
given (substr($var,0,1)) {
when ('&') {
$C->sorry("The () shape syntax in routine declarations is reserved (maybe use :() to declare a longname?)")}
                        ;
when ('@') {
$C->sorry("The () shape syntax in array declarations is reserved")}
                        ;
when ('%') {
$C->sorry("The () shape syntax in hash declarations is reserved")}
                        ;
default {
$C->sorry("The () shape syntax in variable declarations is reserved")}
                    ;
}
                }}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'shape definition', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\}";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\{"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'shape definition', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->curlycheck)) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})
})
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->getdecl)) {
$C
} else { () }
});
}
;
## rule scoped ($*SCOPE) {
sub scoped__PEEK { $_[0]->_AUTOLEXpeek('scoped', $retree) }
sub scoped {
no warnings 'recursion';
my $self = shift;

die 'Required argument SCOPE omitted' unless @_;
local $::SCOPE = @_ ? shift() : undef;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scoped");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'typename'} = [];
$self->_MATCHIFYr($S, "scoped", do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'scoped_0') {
        $C->deb("Fate passed to scoped_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT scoped_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM scoped_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'scoped_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("scoped_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['package_declarator'], sub {
my $C = shift;
$C->package_declarator
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_PLUSr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = (scalar(do {
my $M = $C;
my $t = $M->{'typename'};
@$t > 1 and $C->sorry("Multiple prefix constraints not yet supported");
$::OFTYPE = $t->[0];
}, $C))
and ($C) = ($C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_PATTERN(qr/\G[A-Z]/)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = (scalar(do {
my $M = $C;
{
my $t = $M->{'longname'}->Str;
if (not $C->is_known($t)) {
$C->sorry("In $::SCOPE declaration, typename '$t' must be predeclared (or marked as declarative with :: prefix)")};
}}, $C))
and ($C) = ($C->ws)
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->panic( "Malformed $::SCOPE"))
and ($C) = ($C->ws)) {
$C
} else { () }
}
};
@gather;
});
}
;
## token scope_declarator:my        { <sym> <scoped('my')> }
sub scope_declarator__S_041my__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_041my', $retree) }
sub scope_declarator__S_041my {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_041my");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "my";
$self->_MATCHIFYr($S, "scope_declarator__S_041my", do {
my $C = $C;
if (($C) = ($C->_EXACT("my"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('my')
})
} else { () }
});
}
;
## token scope_declarator:our       { <sym> <scoped('our')> }
sub scope_declarator__S_042our__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_042our', $retree) }
sub scope_declarator__S_042our {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_042our");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "our";
$self->_MATCHIFYr($S, "scope_declarator__S_042our", do {
my $C = $C;
if (($C) = ($C->_EXACT("our"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('our')
})
} else { () }
});
}
;
## token scope_declarator:anon      { <sym> <scoped('anon')> }
sub scope_declarator__S_043anon__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_043anon', $retree) }
sub scope_declarator__S_043anon {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_043anon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "anon";
$self->_MATCHIFYr($S, "scope_declarator__S_043anon", do {
my $C = $C;
if (($C) = ($C->_EXACT("anon"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('anon')
})
} else { () }
});
}
;
## token scope_declarator:state     { <sym> <scoped('state')> }
sub scope_declarator__S_044state__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_044state', $retree) }
sub scope_declarator__S_044state {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_044state");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "state";
$self->_MATCHIFYr($S, "scope_declarator__S_044state", do {
my $C = $C;
if (($C) = ($C->_EXACT("state"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('state')
})
} else { () }
});
}
;
## token scope_declarator:has       { <sym> <scoped('has')> }
sub scope_declarator__S_045has__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_045has', $retree) }
sub scope_declarator__S_045has {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_045has");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "has";
$self->_MATCHIFYr($S, "scope_declarator__S_045has", do {
my $C = $C;
if (($C) = ($C->_EXACT("has"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('has')
})
} else { () }
});
}
;
## token scope_declarator:augment   { <sym> <scoped('augment')> }
sub scope_declarator__S_046augment__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_046augment', $retree) }
sub scope_declarator__S_046augment {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_046augment");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "augment";
$self->_MATCHIFYr($S, "scope_declarator__S_046augment", do {
my $C = $C;
if (($C) = ($C->_EXACT("augment"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('augment')
})
} else { () }
});
}
;
## token scope_declarator:supersede { <sym> <scoped('supersede')> }
sub scope_declarator__S_047supersede__PEEK { $_[0]->_AUTOLEXpeek('scope_declarator__S_047supersede', $retree) }
sub scope_declarator__S_047supersede {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE scope_declarator__S_047supersede");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "supersede";
$self->_MATCHIFYr($S, "scope_declarator__S_047supersede", do {
my $C = $C;
if (($C) = ($C->_EXACT("supersede"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['scoped'], sub {
my $C = shift;
$C->scoped('supersede')
})
} else { () }
});
}
;
## token package_declarator:class {
sub package_declarator__S_048class__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_048class', $retree) }
sub package_declarator__S_048class {
no warnings 'recursion';
my $self = shift;

;
local $::PKGDECL = 'class';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_048class");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "class";
$self->_MATCHIFYr($S, "package_declarator__S_048class", do {
my $C = $C;
if (($C) = ($C->_EXACT("class"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }
});
}
;
## token package_declarator:grammar {
sub package_declarator__S_049grammar__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_049grammar', $retree) }
sub package_declarator__S_049grammar {
no warnings 'recursion';
my $self = shift;

;
local $::PKGDECL = 'grammar';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_049grammar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "grammar";
$self->_MATCHIFYr($S, "package_declarator__S_049grammar", do {
my $C = $C;
if (($C) = ($C->_EXACT("grammar"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }
});
}
;
## token package_declarator:module {
sub package_declarator__S_050module__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_050module', $retree) }
sub package_declarator__S_050module {
no warnings 'recursion';
my $self = shift;

;
local $::PKGDECL = 'module';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_050module");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "module";
$self->_MATCHIFYr($S, "package_declarator__S_050module", do {
my $C = $C;
if (($C) = ($C->_EXACT("module"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }
});
}
;
## token package_declarator:package {
sub package_declarator__S_051package__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_051package', $retree) }
sub package_declarator__S_051package {
no warnings 'recursion';
my $self = shift;

;
local $::PKGDECL = 'package';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_051package");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "package";
$self->_MATCHIFYr($S, "package_declarator__S_051package", do {
my $C = $C;
if (($C) = ($C->_EXACT("package"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }
});
}
;
## token package_declarator:role {
sub package_declarator__S_052role__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_052role', $retree) }
sub package_declarator__S_052role {
no warnings 'recursion';
my $self = shift;

;
local $::PKGDECL = 'role';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_052role");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "role";
$self->_MATCHIFYr($S, "package_declarator__S_052role", do {
my $C = $C;
if (($C) = ($C->_EXACT("role"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }
});
}
;
## token package_declarator:knowhow {
sub package_declarator__S_053knowhow__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_053knowhow', $retree) }
sub package_declarator__S_053knowhow {
no warnings 'recursion';
my $self = shift;

;
local $::PKGDECL = 'knowhow';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_053knowhow");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "knowhow";
$self->_MATCHIFYr($S, "package_declarator__S_053knowhow", do {
my $C = $C;
if (($C) = ($C->_EXACT("knowhow"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }
});
}
;
## token package_declarator:slang {
sub package_declarator__S_054slang__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_054slang', $retree) }
sub package_declarator__S_054slang {
no warnings 'recursion';
my $self = shift;

;
local $::PKGDECL = 'slang';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_054slang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "slang";
$self->_MATCHIFYr($S, "package_declarator__S_054slang", do {
my $C = $C;
if (($C) = ($C->_EXACT("slang"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['package_def'], sub {
my $C = shift;
$C->package_def
})
} else { () }
});
}
;
## token package_declarator:require {   # here because of declarational aspects
sub package_declarator__S_055require__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_055require', $retree) }
sub package_declarator__S_055require {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_055require");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'EXPR'} = [];
$C->{sym} = "require";
$self->_MATCHIFYr($S, "package_declarator__S_055require", do {
my $C = $C;
if (($C) = ($C->_EXACT("require"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})
})
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
})
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## token package_declarator:trusts {
sub package_declarator__S_056trusts__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_056trusts', $retree) }
sub package_declarator__S_056trusts {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_056trusts");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "trusts";
$self->_MATCHIFYr($S, "package_declarator__S_056trusts", do {
my $C = $C;
if (($C) = ($C->_EXACT("trusts"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
})
} else { () }
});
}
;
## token package_declarator:does {
sub package_declarator__S_057does__PEEK { $_[0]->_AUTOLEXpeek('package_declarator__S_057does', $retree) }
sub package_declarator__S_057does {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_declarator__S_057does");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "does";
$self->_MATCHIFYr($S, "package_declarator__S_057does", do {
my $C = $C;
if (($C) = ($C->_EXACT("does"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## rule package_def {
sub package_def__PEEK { $_[0]->_AUTOLEXpeek('package_def', $retree) }
sub package_def {
no warnings 'recursion';
my $self = shift;

my $longname;
local $::IN_DECL = 'package';
local $::DECLARAND;
local $::NEWPKG;
local $::NEWPAD;
my $outer = $::CURPAD;
local $::CURPKG = $::CURPKG;
local $::CURPAD = $::CURPAD;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE package_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'longname'} = [];
$C->{'signature'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "package_def", do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = (scalar(do {
$::SCOPE ||= 'our'}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
$longname = $M->{'longname'}->[0];
$C->add_name($longname->Str);
}, $C)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->newpad)
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
($::PKGDECL//'') eq 'role' })
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'generic role', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
scalar(do {
$::IN_DECL = ''}, $C)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->ws)
and ($C) = ($C->getdecl)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_EXACT("\{")
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = (scalar(do {
{
if ($longname and $::NEWPKG) {
my $shortname = $longname->{'name'}->Str;
if ($::SCOPE eq 'our') {
$::CURPKG = $::NEWPKG // $::CURPKG->{$shortname . '::'};
$self->deb("added our " . $::CURPKG->id) if $::DEBUG & DEBUG::symtab;
}
else {
$::CURPKG = $::NEWPKG // $::CURPKG->{$shortname . '::'};
$self->deb("added my " . $::CURPKG->id) if $::DEBUG & DEBUG::symtab;
};
};
$::begin_compunit = 0;
}}, $C))
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->ws)
and ($C) = ($C->checkyada)
and ($C) = ($C->ws)) {
$C
} else { () }
}))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_EXACT("\;")
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::begin_compunit })
}))
and ($C) = (scalar(do {
{
$longname  or  $C->panic("Compilation unit cannot be anonymous");
$outer == $::UNIT or $C->panic("Semicolon form of " . $::PKGDECL . " definition not allowed in subscope;\n  please use block form");
my $shortname = $longname->{'name'}->Str;
$::CURPKG = $::NEWPKG // $::CURPKG->{$shortname . '::'};
$::begin_compunit = 0;
$::CURPAD = $outer;
if ($shortname eq 'CORE' and $::CORE->id =~ /NULL/) {
$::UNIT->{'OUTER::'} = [''];
$::CORE = $::UNIT;
$::SETTING = $::UNIT;
$ALL = {
CORE => $::UNIT,
                                SETTING => $::UNIT,
                                $::UNIT->id => $::UNIT,
                            };
};
}}, $C))
and ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic( "Too late for semicolon form of " . $::PKGDECL . " definition"))
and ($C) = ($C->ws)) {
$C
} else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic( "Unable to parse " . $::PKGDECL . " definition"))
and ($C) = ($C->ws)) {
$C
} else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->panic( "Malformed $::PKGDECL"))
and ($C) = ($C->ws)) {
$C
} else { () }
}
};
@gather;
});
}
;
## token declarator {
sub declarator__PEEK { $_[0]->_AUTOLEXpeek('declarator', $retree) }
sub declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "declarator", $C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'declarator_0') {
        $C->deb("Fate passed to declarator_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT declarator_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM declarator_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'declarator_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("declarator_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['variable_declarator'], sub {
my $C = shift;
$C->variable_declarator
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
$C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_EXACT("\,"))
and ($C) = ($C->ws)) {
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'declend'} = $::SCOPE}, $C)
} else { () }
};
}))) { ($C) } else { () }
})
}))) { ($C) } else { () }
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'declarator', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
})
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['routine_declarator'], sub {
my $C = shift;
$C->routine_declarator
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['type_declarator'], sub {
my $C = shift;
$C->type_declarator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}));
}
;
## token multi_declarator:multi {
sub multi_declarator__S_058multi__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_058multi', $retree) }
sub multi_declarator__S_058multi {
no warnings 'recursion';
my $self = shift;

;
local $::MULTINESS = 'multi';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE multi_declarator__S_058multi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "multi";
$self->_MATCHIFYr($S, "multi_declarator__S_058multi", do {
my $C = $C;
if (($C) = ($C->_EXACT("multi"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def('multi')
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic('Malformed multi'))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## token multi_declarator:proto {
sub multi_declarator__S_059proto__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_059proto', $retree) }
sub multi_declarator__S_059proto {
no warnings 'recursion';
my $self = shift;

;
local $::MULTINESS = 'proto';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE multi_declarator__S_059proto");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "proto";
$self->_MATCHIFYr($S, "multi_declarator__S_059proto", do {
my $C = $C;
if (($C) = ($C->_EXACT("proto"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def('proto')
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic('Malformed proto'))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## token multi_declarator:only {
sub multi_declarator__S_060only__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_060only', $retree) }
sub multi_declarator__S_060only {
no warnings 'recursion';
my $self = shift;

;
local $::MULTINESS = 'only';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE multi_declarator__S_060only");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "only";
$self->_MATCHIFYr($S, "multi_declarator__S_060only", do {
my $C = $C;
if (($C) = ($C->_EXACT("only"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
})
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def('only')
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic('Malformed only'))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## token multi_declarator:null {
sub multi_declarator__S_061null__PEEK { $_[0]->_AUTOLEXpeek('multi_declarator__S_061null', $retree) }
sub multi_declarator__S_061null {
no warnings 'recursion';
my $self = shift;

;
local $::MULTINESS = '';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE multi_declarator__S_061null");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "null";
$self->_MATCHIFYr($S, "multi_declarator__S_061null", $C->_SUBSUMEr(['declarator'], sub {
my $C = shift;
$C->declarator
}));
}
;
## token routine_declarator:sub       { <sym> <routine_def('sub')> }
sub routine_declarator__S_062sub__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_062sub', $retree) }
sub routine_declarator__S_062sub {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE routine_declarator__S_062sub");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sub";
$self->_MATCHIFYr($S, "routine_declarator__S_062sub", do {
my $C = $C;
if (($C) = ($C->_EXACT("sub"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['routine_def'], sub {
my $C = shift;
$C->routine_def('sub')
})
} else { () }
});
}
;
## token routine_declarator:method    { <sym> <method_def> }
sub routine_declarator__S_063method__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_063method', $retree) }
sub routine_declarator__S_063method {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE routine_declarator__S_063method");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "method";
$self->_MATCHIFYr($S, "routine_declarator__S_063method", do {
my $C = $C;
if (($C) = ($C->_EXACT("method"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['method_def'], sub {
my $C = shift;
$C->method_def
})
} else { () }
});
}
;
## token routine_declarator:submethod { <sym> <method_def> }
sub routine_declarator__S_064submethod__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_064submethod', $retree) }
sub routine_declarator__S_064submethod {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE routine_declarator__S_064submethod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "submethod";
$self->_MATCHIFYr($S, "routine_declarator__S_064submethod", do {
my $C = $C;
if (($C) = ($C->_EXACT("submethod"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['method_def'], sub {
my $C = shift;
$C->method_def
})
} else { () }
});
}
;
## token routine_declarator:macro     { <sym> <macro_def> }
sub routine_declarator__S_065macro__PEEK { $_[0]->_AUTOLEXpeek('routine_declarator__S_065macro', $retree) }
sub routine_declarator__S_065macro {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE routine_declarator__S_065macro");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "macro";
$self->_MATCHIFYr($S, "routine_declarator__S_065macro", do {
my $C = $C;
if (($C) = ($C->_EXACT("macro"))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['macro_def'], sub {
my $C = shift;
$C->macro_def
})
} else { () }
});
}
;
## token regex_declarator:regex { <sym>       <regex_def(:!r,:!s)> }
sub regex_declarator__S_066regex__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_066regex', $retree) }
sub regex_declarator__S_066regex {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_declarator__S_066regex");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "regex";
$self->_MATCHIFYr($S, "regex_declarator__S_066regex", do {
my $C = $C;
if (($C) = ($C->_EXACT("regex"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def('r' => 0,'s' => 0)
})
} else { () }
});
}
;
## token regex_declarator:token { <sym>       <regex_def(:r,:!s)> }
sub regex_declarator__S_067token__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_067token', $retree) }
sub regex_declarator__S_067token {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_declarator__S_067token");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "token";
$self->_MATCHIFYr($S, "regex_declarator__S_067token", do {
my $C = $C;
if (($C) = ($C->_EXACT("token"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def('r' => 1,'s' => 0)
})
} else { () }
});
}
;
## token regex_declarator:rule  { <sym>       <regex_def(:r,:s)> }
sub regex_declarator__S_068rule__PEEK { $_[0]->_AUTOLEXpeek('regex_declarator__S_068rule', $retree) }
sub regex_declarator__S_068rule {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_declarator__S_068rule");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "rule";
$self->_MATCHIFYr($S, "regex_declarator__S_068rule", do {
my $C = $C;
if (($C) = ($C->_EXACT("rule"))
and ($C) = ($C->spacey)) {
$C->_SUBSUMEr(['regex_def'], sub {
my $C = shift;
$C->regex_def('r' => 1,'s' => 1)
})
} else { () }
});
}
;
## rule multisig {
sub multisig__PEEK { $_[0]->_AUTOLEXpeek('multisig', $retree) }
sub multisig {
no warnings 'recursion';
my $self = shift;

my $signum = 0;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE multisig");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'signature'} = [];
$self->_MATCHIFYr($S, "multisig", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\|")
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_PATTERN(qr/\G\:?+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature(++$signum)
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'signature', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## method checkyada
sub checkyada {
no warnings 'recursion';
my $self = shift;
eval {
my $startsym = $self->{'blockoid'}->{'statementlist'}->{'statement'}->[0]->{'EXPR'}->{'sym'} // '';
if ($startsym eq '...' or $startsym eq '!!!' or $startsym eq '???') {
$::DECLARAND->{'stub'} = 1};
};
return $self;
};
## rule routine_def ($d) {
sub routine_def__PEEK { $_[0]->_AUTOLEXpeek('routine_def', $retree) }
sub routine_def {
no warnings 'recursion';
my $self = shift;

die 'Required argument d omitted' unless @_;
my $d = @_ ? shift() : undef;
local $::CURPAD = $::CURPAD;
local $::IN_DECL = $d;
local $::DECLARAND;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE routine_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'deflongname'} = [];
$C->{'multisig'} = [];
$C->{'sigil'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "routine_def", do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'routine_def_0') {
        $C->deb("Fate passed to routine_def_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT routine_def_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM routine_def_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'routine_def_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("routine_def_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\&\*?+/)
})
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->newpad(1))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'routine_def_1') {
        $C->deb("Fate passed to routine_def_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT routine_def_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM routine_def_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'routine_def_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("routine_def_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_EXACT("\{")
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic( "Malformed block"))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_DECL = ''})
}))
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->checkyada)
and ($C) = ($C->getsig)
and ($C) = ($C->getdecl)) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->panic( "Malformed routine"))
and ($C) = ($C->ws)) {
$C
} else { () }
}
};
@gather;
});
}
;
## rule method_def () {
sub method_def__PEEK { $_[0]->_AUTOLEXpeek('method_def', $retree) }
sub method_def {
no warnings 'recursion';
my $self = shift;

local $::CURPAD = $::CURPAD;
local $::IN_DECL = 'method';
local $::DECLARAND;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE method_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'multisig'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "method_def", do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->newpad(1))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'method_def_0') {
        $C->deb("Fate passed to method_def_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT method_def_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM method_def_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'method_def_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("method_def_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G(?:[!^])?+/))
and ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'method_def_1') {
        $C->deb("Fate passed to method_def_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT method_def_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM method_def_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'method_def_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("method_def_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->ws)
and ($C) = ($C->_EXACT("\."))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'method_def_2') {
        $C->deb("Fate passed to method_def_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT method_def_2';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM method_def_2'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'method_def_2', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("method_def_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'subscript signature', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'subscript signature', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\}";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\{"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'subscript signature', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_EXACT("\<")
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->checkyada)
and ($C) = ($C->getsig)
and ($C) = ($C->getdecl)) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->panic( "Malformed method"))
and ($C) = ($C->ws)) {
$C
} else { () }
}
};
@gather;
});
}
;
## rule regex_def (:$r, :$s) {
sub regex_def__PEEK { $_[0]->_AUTOLEXpeek('regex_def', $retree) }
sub regex_def {
no warnings 'recursion';
my $self = shift;

my %args = @_;
my $r = exists $args{r} ? delete $args{r} : undef;
my $s = exists $args{s} ? delete $args{s} : undef;
local $::CURPAD = $::CURPAD;
local $::IN_DECL = 'regex';
local %::RX = %::RX;
local $::DECLARAND;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'deflongname'} = [];
$C->{'signature'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "regex_def", do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = (scalar(do {
$::RX{'s'} = $s;
$::RX{'r'} = $r;
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'regex_def_0') {
        $C->deb("Fate passed to regex_def_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT regex_def_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM regex_def_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'regex_def_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("regex_def_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_EXACT("\&"))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->newpad(1))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'regex_def_1') {
        $C->deb("Fate passed to regex_def_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT regex_def_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM regex_def_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'regex_def_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("regex_def_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\:?+\(/))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature(1)
}))
and ($C) = ($C->ws)) {
$C->_EXACT("\)")
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_EXACT("\{")
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic( "Malformed block"))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->finishpad)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['regex_block'], sub {
my $C = shift;
$C->regex_block
}))
and ($C) = ($C->getsig)
and ($C) = ($C->getdecl)) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->panic( "Malformed regex"))
and ($C) = ($C->ws)) {
$C
} else { () }
}
};
@gather;
});
}
;
## rule macro_def () {
sub macro_def__PEEK { $_[0]->_AUTOLEXpeek('macro_def', $retree) }
sub macro_def {
no warnings 'recursion';
my $self = shift;

local $::CURPAD = $::CURPAD;
local $::IN_DECL = 'macro';
local $::DECLARAND;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE macro_def");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'deflongname'} = [];
$C->{'multisig'} = [];
$C->{'trait'} = [];
$self->_MATCHIFYr($S, "macro_def", do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'macro_def_0') {
        $C->deb("Fate passed to macro_def_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT macro_def_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM macro_def_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'macro_def_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("macro_def_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_EXACT("\&"))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['deflongname'], sub {
my $C = shift;
$C->deflongname
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->newpad(1))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'macro_def_1') {
        $C->deb("Fate passed to macro_def_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT macro_def_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM macro_def_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'macro_def_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("macro_def_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['multisig'], sub {
my $C = shift;
$C->multisig
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_EXACT("\{")
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic( "Malformed block"))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->_SUBSUMEr(['blockoid'], sub {
my $C = shift;
$C->blockoid
}))
and ($C) = ($C->checkyada)
and ($C) = ($C->getsig)
and ($C) = ($C->getdecl)) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->panic( "Malformed macro"))
and ($C) = ($C->ws)) {
$C
} else { () }
}
};
@gather;
});
}
;
## rule trait {
sub trait__PEEK { $_[0]->_AUTOLEXpeek('trait', $retree) }
sub trait {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = 0;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "trait", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'trait_0') {
        $C->deb("Fate passed to trait_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT trait_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM trait_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'trait_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("trait_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['trait_mod'], sub {
my $C = shift;
$C->trait_mod
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token trait_mod:is {
sub trait_mod__S_069is__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_069is', $retree) }
sub trait_mod__S_069is {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_069is");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'circumfix'} = [];
$C->{sym} = "is";
$self->_MATCHIFYr($S, "trait_mod__S_069is", do {
my $C = $C;
if (($C) = ($C->_EXACT("is"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
{
if ($::DECLARAND) {
my $traitname = $M->{'longname'}->Str;
$::DECLARAND->{$traitname} = $self->gettrait($traitname, $M->{'circumfix'});
}}}, $C)
} else { () }
});
}
;
## token trait_mod:hides {
sub trait_mod__S_070hides__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_070hides', $retree) }
sub trait_mod__S_070hides {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_070hides");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "hides";
$self->_MATCHIFYr($S, "trait_mod__S_070hides", do {
my $C = $C;
if (($C) = ($C->_EXACT("hides"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token trait_mod:does {
sub trait_mod__S_071does__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_071does', $retree) }
sub trait_mod__S_071does {
no warnings 'recursion';
my $self = shift;

;
local $::PKGDECL = 'role';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_071does");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "does";
$self->_MATCHIFYr($S, "trait_mod__S_071does", do {
my $C = $C;
if (($C) = ($C->_EXACT("does"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['module_name'], sub {
my $C = shift;
$C->module_name
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token trait_mod:will {
sub trait_mod__S_072will__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_072will', $retree) }
sub trait_mod__S_072will {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_072will");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "will";
$self->_MATCHIFYr($S, "trait_mod__S_072will", do {
my $C = $C;
if (($C) = ($C->_EXACT("will"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token trait_mod:of {
sub trait_mod__S_073of__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_073of', $retree) }
sub trait_mod__S_073of {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_073of");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "of";
$self->_MATCHIFYr($S, "trait_mod__S_073of", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'trait_mod__S_073of_0') {
        $C->deb("Fate passed to trait_mod__S_073of_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT trait_mod__S_073of_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM trait_mod__S_073of_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'trait_mod__S_073of_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("trait_mod__S_073of_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("of")
},
sub {
my $C=shift;
$C->_EXACT("returns")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::OFTYPE })
}))
and ($C) = ($C->sorry("Extra 'of' type; already declared as type " . $::OFTYPE->Str))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
$::OFTYPE = $M->{'typename'}}, $C)
} else { () }
});
}
;
## token trait_mod:as      { <sym>:s <typename> }
sub trait_mod__S_074as__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_074as', $retree) }
sub trait_mod__S_074as {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_074as");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "as";
$self->_MATCHIFYr($S, "trait_mod__S_074as", do {
my $C = $C;
if (($C) = ($C->_EXACT("as"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token trait_mod:handles { <sym>:s <term> }
sub trait_mod__S_075handles__PEEK { $_[0]->_AUTOLEXpeek('trait_mod__S_075handles', $retree) }
sub trait_mod__S_075handles {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE trait_mod__S_075handles");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "handles";
$self->_MATCHIFYr($S, "trait_mod__S_075handles", do {
my $C = $C;
if (($C) = ($C->_EXACT("handles"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token nullterm {
sub nullterm__PEEK { $_[0]->_AUTOLEXpeek('nullterm', $retree) }
sub nullterm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE nullterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "nullterm", $C->before(sub {
my $C=shift;
$C
}));
}
;
## token nulltermish {
sub nulltermish__PEEK { $_[0]->_AUTOLEXpeek('nulltermish', $retree) }
sub nulltermish {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE nulltermish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "nulltermish", $C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'nulltermish_0') {
        $C->deb("Fate passed to nulltermish_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT nulltermish_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM nulltermish_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'nulltermish_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("nulltermish_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->stdstopper)) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->termish
}))) {
scalar(do {
my $M = $C;
$C->{'PRE'}  = delete $M->{'term'}->{'PRE'};
$C->{'POST'} = delete $M->{'term'}->{'POST'};
$C->{'~CAPS'} = $M->{'term'}->{'~CAPS'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}));
}
;
## token termish {
sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish', $retree) }
sub termish {
no warnings 'recursion';
my $self = shift;

local $::SCOPE = "";
local $::OFTYPE;
local $::VAR;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE termish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'POST'} = [];
$C->{'PRE'} = [];
$self->_MATCHIFYr($S, "termish", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'termish_0') {
        $C->deb("Fate passed to termish_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT termish_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM termish_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'termish_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("termish_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['PRE'], sub {
my $C = shift;
$C->PRE
}))
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
my $p = $M->{'PRE'};
my @p = @$p;
$p[-1]->{'O'}->{'term'} and $M->{'term'} = pop @$p ;
})
}))) {
$C->_SUBSUMEr(['PRE'], sub {
my $C = shift;
$C->PRE
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'term'} })
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Prefix requires an argument"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL })
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL eq '$' })
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->after(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?<=[\]}>)])/)
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
$C->_PLUSg(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\\")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['POST'], sub {
my $C = shift;
$C->POST
})
} else { () }
}))) { ($C) } else { () }
}))
}))) { ($C) } else { () }
})
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->after(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?<=[\]}>)])/)
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
$C->_PLUSg(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\\")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['POST'], sub {
my $C = shift;
$C->POST
})
} else { () }
}))) { ($C) } else { () }
})))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$::VAR = 0}, $C)
};
@gather;
}
}))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL })
}))) {
$C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['POST'], sub {
my $C = shift;
$C->POST
})
})
} else { () }
}
};
@gather;
}
}))) {
scalar(do {
my $M = $C;
$self->check_variable($::VAR) if $::VAR;
$C->{'~CAPS'} = $M->{'term'}->{'~CAPS'};
}, $C)
} else { () }
});
}
;
## token term:fatarrow           { <fatarrow> }
sub term__S_076fatarrow__PEEK { $_[0]->_AUTOLEXpeek('term__S_076fatarrow', $retree) }
sub term__S_076fatarrow {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_076fatarrow");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "fatarrow";
$self->_MATCHIFYr($S, "term__S_076fatarrow", $C->_SUBSUMEr(['fatarrow'], sub {
my $C = shift;
$C->fatarrow
}));
}
;
## token term:variable           { <variable> { $*VAR = $<variable> } }
sub term__S_077variable__PEEK { $_[0]->_AUTOLEXpeek('term__S_077variable', $retree) }
sub term__S_077variable {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_077variable");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "variable";
$self->_MATCHIFYr($S, "term__S_077variable", do {
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;
$::VAR = $M->{'variable'} }, $C)
} else { () }
});
}
;
## token term:package_declarator { <package_declarator> }
sub term__S_078package_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_078package_declarator', $retree) }
sub term__S_078package_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_078package_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "package_declarator";
$self->_MATCHIFYr($S, "term__S_078package_declarator", $C->_SUBSUMEr(['package_declarator'], sub {
my $C = shift;
$C->package_declarator
}));
}
;
## token term:scope_declarator   { <scope_declarator> }
sub term__S_079scope_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_079scope_declarator', $retree) }
sub term__S_079scope_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_079scope_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "scope_declarator";
$self->_MATCHIFYr($S, "term__S_079scope_declarator", $C->_SUBSUMEr(['scope_declarator'], sub {
my $C = shift;
$C->scope_declarator
}));
}
;
## token term:multi_declarator   { <?before 'multi'|'proto'|'only'> <multi_declarator> }
sub term__S_080multi_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_080multi_declarator', $retree) }
sub term__S_080multi_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_080multi_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "multi_declarator";
$self->_MATCHIFYr($S, "term__S_080multi_declarator", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_080multi_declarator_0') {
        $C->deb("Fate passed to term__S_080multi_declarator_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT term__S_080multi_declarator_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM term__S_080multi_declarator_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'term__S_080multi_declarator_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("term__S_080multi_declarator_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("multi")
},
sub {
my $C=shift;
$C->_EXACT("proto")
},
sub {
my $C=shift;
$C->_EXACT("only")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['multi_declarator'], sub {
my $C = shift;
$C->multi_declarator
})
} else { () }
});
}
;
## token term:routine_declarator { <routine_declarator> }
sub term__S_081routine_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_081routine_declarator', $retree) }
sub term__S_081routine_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_081routine_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "routine_declarator";
$self->_MATCHIFYr($S, "term__S_081routine_declarator", $C->_SUBSUMEr(['routine_declarator'], sub {
my $C = shift;
$C->routine_declarator
}));
}
;
## token term:regex_declarator   { <regex_declarator> }
sub term__S_082regex_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_082regex_declarator', $retree) }
sub term__S_082regex_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_082regex_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "regex_declarator";
$self->_MATCHIFYr($S, "term__S_082regex_declarator", $C->_SUBSUMEr(['regex_declarator'], sub {
my $C = shift;
$C->regex_declarator
}));
}
;
## token term:type_declarator    { <type_declarator> }
sub term__S_083type_declarator__PEEK { $_[0]->_AUTOLEXpeek('term__S_083type_declarator', $retree) }
sub term__S_083type_declarator {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_083type_declarator");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "type_declarator";
$self->_MATCHIFYr($S, "term__S_083type_declarator", $C->_SUBSUMEr(['type_declarator'], sub {
my $C = shift;
$C->type_declarator
}));
}
;
## token term:circumfix          { <circumfix> }
sub term__S_084circumfix__PEEK { $_[0]->_AUTOLEXpeek('term__S_084circumfix', $retree) }
sub term__S_084circumfix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_084circumfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "circumfix";
$self->_MATCHIFYr($S, "term__S_084circumfix", $C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
}));
}
;
## token term:dotty              { <dotty> }
sub term__S_085dotty__PEEK { $_[0]->_AUTOLEXpeek('term__S_085dotty', $retree) }
sub term__S_085dotty {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_085dotty");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "dotty";
$self->_MATCHIFYr($S, "term__S_085dotty", $C->_SUBSUMEr(['dotty'], sub {
my $C = shift;
$C->dotty
}));
}
;
## token term:value              { <value> }
sub term__S_086value__PEEK { $_[0]->_AUTOLEXpeek('term__S_086value', $retree) }
sub term__S_086value {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_086value");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "value";
$self->_MATCHIFYr($S, "term__S_086value", $C->_SUBSUMEr(['value'], sub {
my $C = shift;
$C->value
}));
}
;
## token term:capterm            { <capterm> }
sub term__S_087capterm__PEEK { $_[0]->_AUTOLEXpeek('term__S_087capterm', $retree) }
sub term__S_087capterm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_087capterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "capterm";
$self->_MATCHIFYr($S, "term__S_087capterm", $C->_SUBSUMEr(['capterm'], sub {
my $C = shift;
$C->capterm
}));
}
;
## token term:sigterm            { <sigterm> }
sub term__S_088sigterm__PEEK { $_[0]->_AUTOLEXpeek('term__S_088sigterm', $retree) }
sub term__S_088sigterm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_088sigterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sigterm";
$self->_MATCHIFYr($S, "term__S_088sigterm", $C->_SUBSUMEr(['sigterm'], sub {
my $C = shift;
$C->sigterm
}));
}
;
## token term:statement_prefix   { <statement_prefix> }
sub term__S_089statement_prefix__PEEK { $_[0]->_AUTOLEXpeek('term__S_089statement_prefix', $retree) }
sub term__S_089statement_prefix {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_089statement_prefix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "statement_prefix";
$self->_MATCHIFYr($S, "term__S_089statement_prefix", $C->_SUBSUMEr(['statement_prefix'], sub {
my $C = shift;
$C->statement_prefix
}));
}
;
## token term:colonpair          { [ <colonpair> <.ws> ]+ }
sub term__S_090colonpair__PEEK { $_[0]->_AUTOLEXpeek('term__S_090colonpair', $retree) }
sub term__S_090colonpair {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_090colonpair");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];
$C->{sym} = "colonpair";
$self->_MATCHIFYr($S, "term__S_090colonpair", $C->_PLUSr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}));
}
;
## token fatarrow {
sub fatarrow__PEEK { $_[0]->_AUTOLEXpeek('fatarrow', $retree) }
sub fatarrow {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE fatarrow");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "fatarrow", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['key'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+\=\>/))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['val'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
})
} else { () }
});
}
;
## token coloncircumfix ($front) {
sub coloncircumfix__PEEK { $_[0]->_AUTOLEXpeek('coloncircumfix', $retree) }
sub coloncircumfix {
no warnings 'recursion';
my $self = shift;

die 'Required argument front omitted' unless @_;
my $front = @_ ? shift() : undef;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE coloncircumfix");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "coloncircumfix", $C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'coloncircumfix_0') {
        $C->deb("Fate passed to coloncircumfix_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT coloncircumfix_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM coloncircumfix_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'coloncircumfix_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("coloncircumfix_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\<\>"))
and ($C) = ($C->worry("Pair with <> really means a Nil value, not null string; use :$front" . "('') to represent the null string,\n  or :$front" . "() to represent Nil more accurately"))) {
$C
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}));
}
;
## token colonpair {
sub colonpair__PEEK { $_[0]->_AUTOLEXpeek('colonpair', $retree) }
sub colonpair {
no warnings 'recursion';
my $self = shift;

my $key;
my $value;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE colonpair");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "colonpair", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'colonpair_0') {
        $C->deb("Fate passed to colonpair_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT colonpair_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM colonpair_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'colonpair_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("colonpair_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\!"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed False pair; expected identifier"))) { ($C) } else { () }
}
};
@gather;
}
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\[\(\<\{]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Extra argument not allowed; pair already has False argument"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
$key = $M->{'identifier'}->Str;
$value = 0;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['num'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)
})
}))
and ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\[\(\<\{]/)
}))) { ($C) } else { () }
}))
and ($C) = (do {
my $M = $C;
$C->sorry("Extra argument not allowed; pair already has argument of " . $M->{'num'}->Str)
})
and ($C) = ($C->circumfix)) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = (scalar(do {
my $M = $C;
$key = $M->{'identifier'}->Str}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['coloncircumfix'], sub {
my $C = shift;
$C->coloncircumfix($key)
}))) {
scalar(do {
my $M = $C;
$value = $M->{'coloncircumfix'}}, $C)
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$value = 1}, $C)
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['fakesignature'], sub {
my $C = shift;
$C->fakesignature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'signature', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['coloncircumfix'], sub {
my $C = shift;
$C->coloncircumfix('')
}))) {
scalar(do {
my $M = $C;
$key = "";
$value = $M->{'coloncircumfix'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['var'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
} else { () }
};

})
}))) {
scalar(do {
my $M = $C;
$key = $M->{'var'}->{'desigilname'}->Str;
$value = $M->{'var'};
}, $C)
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
scalar(do {
my $M = $C;
$M->{'k'} = $key;
$M->{'v'} = $value;
}, $C)
} else { () }
});
}
;
## token special_variable:sym<$¢> { <sym> }
sub special_variable__S_091Dollar_a2___PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_091Dollar_a2_', $retree) }
sub special_variable__S_091Dollar_a2_ {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_091Dollar_a2_");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$¢";
$self->_MATCHIFYr($S, "special_variable__S_091Dollar_a2_", $C->_EXACT("\$¢"));
}
;
## token special_variable:sym<$!> { <sym> <!before \w> }
sub special_variable__S_092DollarBang__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_092DollarBang', $retree) }
sub special_variable__S_092DollarBang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_092DollarBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\!";
$self->_MATCHIFYr($S, "special_variable__S_092DollarBang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\!"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) { ($C) } else { () }
}))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$!{ }> {
sub special_variable__S_093DollarBangCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_093DollarBangCur_Ly', $retree) }
sub special_variable__S_093DollarBangCur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_093DollarBangCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\!\{\ \}";
$self->_MATCHIFYr($S, "special_variable__S_093DollarBangCur_Ly", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\!"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\}";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\{"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_093DollarBangCur_Ly_0') {
        $C->deb("Fate passed to special_variable__S_093DollarBangCur_Ly_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_093DollarBangCur_Ly_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_093DollarBangCur_Ly_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_093DollarBangCur_Ly_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_093DollarBangCur_Ly_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'special_variable', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
scalar(do {
{
my $all = substr($::ORIG, $self->{'_pos'}, $C->{'_pos'} - $self->{'_pos'});
my ($inside) = $all =~ m!^...\s*(.*?)\s*.$!;
$C->obs("Perl 5's $all construct", "a smartmatch like \$! ~~ $inside" );
}}, $C)
} else { () }
});
}
;
## token special_variable:sym<$/> {
sub special_variable__S_094DollarSlash__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_094DollarSlash', $retree) }
sub special_variable__S_094DollarSlash {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_094DollarSlash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\/";
$self->_MATCHIFYr($S, "special_variable__S_094DollarSlash", do {
if (my ($C) = ($C->_EXACT("\$\/"))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+\=/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C->_PATTERN(qr/\G[=]/)
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$/ variable as input record separator',
                 "the filehandle's :irs attribute"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token special_variable:sym<$~> {
sub special_variable__S_095DollarTilde__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_095DollarTilde', $retree) }
sub special_variable__S_095DollarTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_095DollarTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\~";
$self->_MATCHIFYr($S, "special_variable__S_095DollarTilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\~"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_095DollarTilde_0') {
        $C->deb("Fate passed to special_variable__S_095DollarTilde_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_095DollarTilde_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_095DollarTilde_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_095DollarTilde_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_095DollarTilde_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$~ variable', 'Form module'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$`> {
sub special_variable__S_096DollarGrave__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_096DollarGrave', $retree) }
sub special_variable__S_096DollarGrave {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_096DollarGrave");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\`";
$self->_MATCHIFYr($S, "special_variable__S_096DollarGrave", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\`"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_096DollarGrave_0') {
        $C->deb("Fate passed to special_variable__S_096DollarGrave_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_096DollarGrave_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_096DollarGrave_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_096DollarGrave_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_096DollarGrave_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$` variable', 'explicit pattern before <('))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$@> {
sub special_variable__S_097DollarAt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_097DollarAt', $retree) }
sub special_variable__S_097DollarAt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_097DollarAt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\@";
$self->_MATCHIFYr($S, "special_variable__S_097DollarAt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\@"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\W/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->obs('$@ variable as eval error', '$!'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$#> {
sub special_variable__S_098DollarSharp__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_098DollarSharp', $retree) }
sub special_variable__S_098DollarSharp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_098DollarSharp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\#";
$self->_MATCHIFYr($S, "special_variable__S_098DollarSharp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\#"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\w++/)

})
}))
and ($C) = (do {
my $M = $C;
$C->obs("\$#" . $M->{0}->Str . " variable", '@' . $M->{0}->Str . '.end')
})) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->obs('$# variable', '.fmt'))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$$> {
sub special_variable__S_099DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_099DollarDollar', $retree) }
sub special_variable__S_099DollarDollar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_099DollarDollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\$";
$self->_MATCHIFYr($S, "special_variable__S_099DollarDollar", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\$"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_099DollarDollar_0') {
        $C->deb("Fate passed to special_variable__S_099DollarDollar_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_099DollarDollar_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_099DollarDollar_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_099DollarDollar_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_099DollarDollar_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$$ variable', '$*PID'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$%> {
sub special_variable__S_100DollarPercent__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_100DollarPercent', $retree) }
sub special_variable__S_100DollarPercent {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_100DollarPercent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\%";
$self->_MATCHIFYr($S, "special_variable__S_100DollarPercent", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\%"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->sigil)) { ($C) } else { () }
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->obs('$% variable', 'Form module'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$^X> {
sub special_variable__S_101DollarCaretX__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_101DollarCaretX', $retree) }
sub special_variable__S_101DollarCaretX {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_101DollarCaretX");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\^X";
$self->_MATCHIFYr($S, "special_variable__S_101DollarCaretX", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_EXACT("\^"))
and ($C) = ($C->_SUBSUMEr(['letter'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G[A-Z]/)
})
}))
and ($C) = ($C->_PATTERN(qr/\G\W/))
and ($C) = (do {
my $M = $C;
$C->obscaret($M->{'sigil'}->Str . '^' . $M->{'letter'}->Str, $M->{'sigil'}->Str, $M->{'letter'}->Str)
})) {
$C
} else { () }
});
}
;
## token special_variable:sym<$^> {
sub special_variable__S_102DollarCaret__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_102DollarCaret', $retree) }
sub special_variable__S_102DollarCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_102DollarCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\^";
$self->_MATCHIFYr($S, "special_variable__S_102DollarCaret", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\^"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_102DollarCaret_0') {
        $C->deb("Fate passed to special_variable__S_102DollarCaret_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_102DollarCaret_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_102DollarCaret_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_102DollarCaret_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_102DollarCaret_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$^ variable', 'Form module'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$&> {
sub special_variable__S_103DollarAmp__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_103DollarAmp', $retree) }
sub special_variable__S_103DollarAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_103DollarAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\&";
$self->_MATCHIFYr($S, "special_variable__S_103DollarAmp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\&"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_103DollarAmp_0') {
        $C->deb("Fate passed to special_variable__S_103DollarAmp_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_103DollarAmp_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_103DollarAmp_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_103DollarAmp_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_103DollarAmp_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$& variable', '$/ or $()'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$*> {
sub special_variable__S_104DollarStar__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_104DollarStar', $retree) }
sub special_variable__S_104DollarStar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_104DollarStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\*";
$self->_MATCHIFYr($S, "special_variable__S_104DollarStar", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\*"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_104DollarStar_0') {
        $C->deb("Fate passed to special_variable__S_104DollarStar_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_104DollarStar_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_104DollarStar_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_104DollarStar_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_104DollarStar_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$* variable', '^^ and $$'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$)> {
sub special_variable__S_105DollarThesis__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_105DollarThesis', $retree) }
sub special_variable__S_105DollarThesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_105DollarThesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\)";
$self->_MATCHIFYr($S, "special_variable__S_105DollarThesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\)"))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::GOAL ne ')' })
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_105DollarThesis_0') {
        $C->deb("Fate passed to special_variable__S_105DollarThesis_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_105DollarThesis_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_105DollarThesis_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_105DollarThesis_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_105DollarThesis_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$) variable', '$*EGID'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$-> {
sub special_variable__S_106DollarMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_106DollarMinus', $retree) }
sub special_variable__S_106DollarMinus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_106DollarMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\-";
$self->_MATCHIFYr($S, "special_variable__S_106DollarMinus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\-"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_106DollarMinus_0') {
        $C->deb("Fate passed to special_variable__S_106DollarMinus_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_106DollarMinus_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_106DollarMinus_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_106DollarMinus_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_106DollarMinus_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$- variable', 'Form module'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$=> {
sub special_variable__S_107DollarEqual__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_107DollarEqual', $retree) }
sub special_variable__S_107DollarEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_107DollarEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\=";
$self->_MATCHIFYr($S, "special_variable__S_107DollarEqual", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\="))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_107DollarEqual_0') {
        $C->deb("Fate passed to special_variable__S_107DollarEqual_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_107DollarEqual_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_107DollarEqual_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_107DollarEqual_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_107DollarEqual_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$= variable', 'Form module'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<@+> {
sub special_variable__S_108AtPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_108AtPlus', $retree) }
sub special_variable__S_108AtPlus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_108AtPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@\+";
$self->_MATCHIFYr($S, "special_variable__S_108AtPlus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\@\+"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_108AtPlus_0') {
        $C->deb("Fate passed to special_variable__S_108AtPlus_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_108AtPlus_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_108AtPlus_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_108AtPlus_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_108AtPlus_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('@+ variable', '.to method'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<%+> {
sub special_variable__S_109PercentPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_109PercentPlus', $retree) }
sub special_variable__S_109PercentPlus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_109PercentPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%\+";
$self->_MATCHIFYr($S, "special_variable__S_109PercentPlus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\%\+"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_109PercentPlus_0') {
        $C->deb("Fate passed to special_variable__S_109PercentPlus_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_109PercentPlus_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_109PercentPlus_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_109PercentPlus_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_109PercentPlus_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('%+ variable', '.to method'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$+[ ]> {
sub special_variable__S_110DollarPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_110DollarPlusBra_Ket', $retree) }
sub special_variable__S_110DollarPlusBra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_110DollarPlusBra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\+\[\ \]";
$self->_MATCHIFYr($S, "special_variable__S_110DollarPlusBra_Ket", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\+\["))
and ($C) = ($C->obs('@+ variable', '.to method'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<@+[ ]> {
sub special_variable__S_111AtPlusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_111AtPlusBra_Ket', $retree) }
sub special_variable__S_111AtPlusBra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_111AtPlusBra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@\+\[\ \]";
$self->_MATCHIFYr($S, "special_variable__S_111AtPlusBra_Ket", do {
my $C = $C;
if (($C) = ($C->_EXACT("\@\+\["))
and ($C) = ($C->obs('@+ variable', '.to method'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<@+{ }> {
sub special_variable__S_112AtPlusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_112AtPlusCur_Ly', $retree) }
sub special_variable__S_112AtPlusCur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_112AtPlusCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@\+\{\ \}";
$self->_MATCHIFYr($S, "special_variable__S_112AtPlusCur_Ly", do {
my $C = $C;
if (($C) = ($C->_EXACT("\@\+\{"))
and ($C) = ($C->obs('%+ variable', '.to method'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<@-> {
sub special_variable__S_113AtMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_113AtMinus', $retree) }
sub special_variable__S_113AtMinus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_113AtMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@\-";
$self->_MATCHIFYr($S, "special_variable__S_113AtMinus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\@\-"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_113AtMinus_0') {
        $C->deb("Fate passed to special_variable__S_113AtMinus_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_113AtMinus_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_113AtMinus_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_113AtMinus_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_113AtMinus_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('@- variable', '.from method'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<%-> {
sub special_variable__S_114PercentMinus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_114PercentMinus', $retree) }
sub special_variable__S_114PercentMinus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_114PercentMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%\-";
$self->_MATCHIFYr($S, "special_variable__S_114PercentMinus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\%\-"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_114PercentMinus_0') {
        $C->deb("Fate passed to special_variable__S_114PercentMinus_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_114PercentMinus_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_114PercentMinus_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_114PercentMinus_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_114PercentMinus_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('%- variable', '.from method'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$-[ ]> {
sub special_variable__S_115DollarMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_115DollarMinusBra_Ket', $retree) }
sub special_variable__S_115DollarMinusBra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_115DollarMinusBra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\-\[\ \]";
$self->_MATCHIFYr($S, "special_variable__S_115DollarMinusBra_Ket", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\-\["))
and ($C) = ($C->obs('@- variable', '.from method'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<@-[ ]> {
sub special_variable__S_116AtMinusBra_Ket__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_116AtMinusBra_Ket', $retree) }
sub special_variable__S_116AtMinusBra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_116AtMinusBra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@\-\[\ \]";
$self->_MATCHIFYr($S, "special_variable__S_116AtMinusBra_Ket", do {
my $C = $C;
if (($C) = ($C->_EXACT("\@\-\["))
and ($C) = ($C->obs('@- variable', '.from method'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<%-{ }> {
sub special_variable__S_117PercentMinusCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_117PercentMinusCur_Ly', $retree) }
sub special_variable__S_117PercentMinusCur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_117PercentMinusCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%\-\{\ \}";
$self->_MATCHIFYr($S, "special_variable__S_117PercentMinusCur_Ly", do {
my $C = $C;
if (($C) = ($C->_EXACT("\@\-\{"))
and ($C) = ($C->obs('%- variable', '.from method'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$+> {
sub special_variable__S_118DollarPlus__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_118DollarPlus', $retree) }
sub special_variable__S_118DollarPlus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_118DollarPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\+";
$self->_MATCHIFYr($S, "special_variable__S_118DollarPlus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\+"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_118DollarPlus_0') {
        $C->deb("Fate passed to special_variable__S_118DollarPlus_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_118DollarPlus_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_118DollarPlus_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_118DollarPlus_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_118DollarPlus_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$+ variable', 'Form module'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<${^ }> {
sub special_variable__S_119DollarCurCaret_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_119DollarCurCaret_Ly', $retree) }
sub special_variable__S_119DollarCurCaret_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_119DollarCurCaret_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\{\^\ \}";
$self->_MATCHIFYr($S, "special_variable__S_119DollarCurCaret_Ly", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_EXACT("\{\^"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->_BRACKET(sub {
my $C=shift;
$C->_SCANf()
})
}))
and ($C) = ($C->_EXACT("\}"))
and ($C) = (do {
my $M = $C;
$C->obscaret($M->{'sigil'}->Str . '{^' . $M->{'text'}->Str . '}', $M->{'sigil'}->Str, $M->{'text'}->Str)
})) {
$C
} else { () }
});
}
;
## method obscaret (Str $var, Str $sigil, Str $name)
sub obscaret {
no warnings 'recursion';
my $self = shift;
die 'Required argument var omitted' unless @_;
my $var = @_ ? shift() : undef;
die 'Required argument sigil omitted' unless @_;
my $sigil = @_ ? shift() : undef;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
my $repl;
given ($sigil) {
when ('$') {
given ($name) {
when ('MATCH')         {
$repl = '$/' }
                    ;
when ('PREMATCH')      {
$repl = 'an explicit pattern before <(' }
                    ;
when ('POSTMATCH')     {
$repl = 'an explicit pattern after )>' }
                    ;
when ('ENCODING')      {
$repl = '$?ENCODING' }
                    ;
when ('UNICODE')       {
$repl = '$?UNICODE' }
                    ;
when ('TAINT')         {
$repl = '$*TAINT' }
                    ;
when ('OPEN')          {
$repl = 'filehandle introspection' }
                    ;
when ('N')             {
$repl = '$-1' }
                    ;
when ('L')             {
$repl = 'Form module' }
                    ;
when ('A')             {
$repl = 'Form module' }
                    ;
when ('E')             {
$repl = '$!.extended_os_error' }
                    ;
when ('C')             {
$repl = 'COMPILING namespace' }
                    ;
when ('D')             {
$repl = '$*DEBUGGING' }
                    ;
when ('F')             {
$repl = '$*SYSTEM_FD_MAX' }
                    ;
when ('H')             {
$repl = '$?FOO variables' }
                    ;
when ('I')             {
$repl = '$*INPLACE' }
                    ;
when ('O')             {
$repl = '$?OS or $*OS' }
                    ;
when ('P')             {
$repl = 'whatever debugger Perl 6 comes with' }
                    ;
when ('R')             {
$repl = 'an explicit result variable' }
                    ;
when ('S')             {
$repl = 'the context function' }
                    ;
when ('T')             {
$repl = '$*BASETIME' }
                    ;
when ('V')             {
$repl = '$*PERL_VERSION' }
                    ;
when ('W')             {
$repl = '$*WARNING' }
                    ;
when ('X')             {
$repl = '$*EXECUTABLE_NAME' }
                    ;
default               {
$repl = "a global form such as $sigil*$name" }
                ;
}
            }
            ;
when ('%') {
given ($name) {
when ('H')             {
$repl = '$?FOO variables' }
                    ;
default               {
$repl = "a global form such as $sigil*$name" }
                ;
}
            }
            ;
default {
$repl = "a global form such as $sigil*$name" }
        ;
};
return $self->obs("$var variable", $repl);
};
## token special_variable:sym<::{ }> {
sub special_variable__S_120ColonColonCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_120ColonColonCur_Ly', $retree) }
sub special_variable__S_120ColonColonCur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_120ColonColonCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\:\{\ \}";
$self->_MATCHIFYr($S, "special_variable__S_120ColonColonCur_Ly", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))) {
$C
} else { () }
});
}
;
## regex special_variable:sym<${ }> {
sub special_variable__S_121DollarCur_Ly__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_121DollarCur_Ly', $retree) }
sub special_variable__S_121DollarCur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_121DollarCur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\{\ \}";
$self->_MATCHIFY($S, "special_variable__S_121DollarCur_Ly", LazyMap::lazymap(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\{"))
and ($C) = (scalar(do {
}, $C))) {
LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\}"))) {
scalar(do {
my $M = $C;
{
my $sigil = $M->{'sigil'}->Str;
my $text = $M->{'text'}->Str;
my $bad = $sigil . '{' . $text . '}';
$text = $text - 1 if $text =~ /^\d+$/;
if ($text !~ /^(\w|\:)+$/) {
$C->obs($bad, $sigil . '(' . $text . ')')}
elsif ($::QSIGIL) {
$C->obs($bad, '{' . $sigil . $text . '}')}
else {
$C->obs($bad, $sigil . $text)};
}}, $C)
} else { () }
},
$C->_SUBSUME(['text'], sub {
my $C = shift;
$C->_BRACKET(sub {
my $C=shift;
$C->_SCANf()
})
}))
} else { () }
},
$C->_SUBSUME(['sigil'], sub {
my $C = shift;
$C->sigil
})));
}
;
## token special_variable:sym<$[> {
sub special_variable__S_122DollarBra__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_122DollarBra', $retree) }
sub special_variable__S_122DollarBra {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_122DollarBra");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\[";
$self->_MATCHIFYr($S, "special_variable__S_122DollarBra", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\["))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_122DollarBra_0') {
        $C->deb("Fate passed to special_variable__S_122DollarBra_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_122DollarBra_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_122DollarBra_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_122DollarBra_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_122DollarBra_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$[ variable', 'user-defined array indices'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$]> {
sub special_variable__S_123DollarKet__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_123DollarKet', $retree) }
sub special_variable__S_123DollarKet {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_123DollarKet");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\]";
$self->_MATCHIFYr($S, "special_variable__S_123DollarKet", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\]"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_123DollarKet_0') {
        $C->deb("Fate passed to special_variable__S_123DollarKet_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_123DollarKet_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_123DollarKet_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_123DollarKet_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_123DollarKet_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$] variable', '$*PERL_VERSION'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$\\> {
sub special_variable__S_124DollarBack__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_124DollarBack', $retree) }
sub special_variable__S_124DollarBack {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_124DollarBack");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\\";
$self->_MATCHIFYr($S, "special_variable__S_124DollarBack", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\\"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_124DollarBack_0') {
        $C->deb("Fate passed to special_variable__S_124DollarBack_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_124DollarBack_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_124DollarBack_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_124DollarBack_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_124DollarBack_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$\\ variable', "the filehandle's :ors attribute"))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$|> {
sub special_variable__S_125DollarVert__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_125DollarVert', $retree) }
sub special_variable__S_125DollarVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_125DollarVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\|";
$self->_MATCHIFYr($S, "special_variable__S_125DollarVert", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\|"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_125DollarVert_0') {
        $C->deb("Fate passed to special_variable__S_125DollarVert_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_125DollarVert_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_125DollarVert_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_125DollarVert_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_125DollarVert_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$| variable', ':autoflush on open'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$:> {
sub special_variable__S_126DollarColon__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_126DollarColon', $retree) }
sub special_variable__S_126DollarColon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_126DollarColon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\:";
$self->_MATCHIFYr($S, "special_variable__S_126DollarColon", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\n\],=)}]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$: variable', 'Form module'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$;> {
sub special_variable__S_127DollarSemi__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_127DollarSemi', $retree) }
sub special_variable__S_127DollarSemi {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_127DollarSemi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\;";
$self->_MATCHIFYr($S, "special_variable__S_127DollarSemi", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\;"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_127DollarSemi_0') {
        $C->deb("Fate passed to special_variable__S_127DollarSemi_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_127DollarSemi_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_127DollarSemi_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_127DollarSemi_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_127DollarSemi_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$; variable', 'real multidimensional hashes'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$'> { #'
sub special_variable__S_128DollarSingle__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_128DollarSingle', $retree) }
sub special_variable__S_128DollarSingle {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_128DollarSingle");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\'";
$self->_MATCHIFYr($S, "special_variable__S_128DollarSingle", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\'"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_128DollarSingle_0') {
        $C->deb("Fate passed to special_variable__S_128DollarSingle_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_128DollarSingle_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_128DollarSingle_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_128DollarSingle_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_128DollarSingle_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$' . "'" . 'variable', "explicit pattern after )\x{3E}"))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$"> {
sub special_variable__S_129DollarDouble__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_129DollarDouble', $retree) }
sub special_variable__S_129DollarDouble {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_129DollarDouble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\"";
$self->_MATCHIFYr($S, "special_variable__S_129DollarDouble", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\""))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL })
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_129DollarDouble_0') {
        $C->deb("Fate passed to special_variable__S_129DollarDouble_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_129DollarDouble_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_129DollarDouble_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_129DollarDouble_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_129DollarDouble_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\=")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$" variable', '.join() method'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$,> {
sub special_variable__S_130DollarComma__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_130DollarComma', $retree) }
sub special_variable__S_130DollarComma {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_130DollarComma");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\,";
$self->_MATCHIFYr($S, "special_variable__S_130DollarComma", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\,"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_130DollarComma_0') {
        $C->deb("Fate passed to special_variable__S_130DollarComma_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_130DollarComma_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_130DollarComma_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_130DollarComma_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_130DollarComma_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$, variable', ".join() method"))) {
$C
} else { () }
});
}
;
## token special_variable:sym['$<'] {
sub special_variable__S_131DollarLt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_131DollarLt', $retree) }
sub special_variable__S_131DollarLt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_131DollarLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\<";
$self->_MATCHIFYr($S, "special_variable__S_131DollarLt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\<"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+[=,;?:!)\]}]/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S*+\>/)
}))) { ($C) } else { () }
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$< variable', '$*UID'))) {
$C
} else { () }
});
}
;
## token special_variable:sym«\$>» {
sub special_variable__S_132DollarGt__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_132DollarGt', $retree) }
sub special_variable__S_132DollarGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_132DollarGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\>";
$self->_MATCHIFYr($S, "special_variable__S_132DollarGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\>"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_132DollarGt_0') {
        $C->deb("Fate passed to special_variable__S_132DollarGt_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_132DollarGt_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_132DollarGt_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_132DollarGt_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_132DollarGt_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$> variable', '$*EUID'))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$.> {
sub special_variable__S_133DollarDot__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_133DollarDot', $retree) }
sub special_variable__S_133DollarDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_133DollarDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\.";
$self->_MATCHIFYr($S, "special_variable__S_133DollarDot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\."))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_133DollarDot_0') {
        $C->deb("Fate passed to special_variable__S_133DollarDot_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_133DollarDot_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_133DollarDot_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_133DollarDot_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_133DollarDot_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$. variable', "the filehandle's .line method"))) {
$C
} else { () }
});
}
;
## token special_variable:sym<$?> {
sub special_variable__S_134DollarQuestion__PEEK { $_[0]->_AUTOLEXpeek('special_variable__S_134DollarQuestion', $retree) }
sub special_variable__S_134DollarQuestion {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE special_variable__S_134DollarQuestion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$\?";
$self->_MATCHIFYr($S, "special_variable__S_134DollarQuestion", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$\?"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'special_variable__S_134DollarQuestion_0') {
        $C->deb("Fate passed to special_variable__S_134DollarQuestion_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT special_variable__S_134DollarQuestion_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM special_variable__S_134DollarQuestion_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'special_variable__S_134DollarQuestion_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("special_variable__S_134DollarQuestion_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$? variable as child error', '$!'))) {
$C
} else { () }
});
}
;
## token desigilname {
sub desigilname__PEEK { $_[0]->_AUTOLEXpeek('desigilname', $retree) }
sub desigilname {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE desigilname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "desigilname", $C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'desigilname_0') {
        $C->deb("Fate passed to desigilname_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT desigilname_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM desigilname_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'desigilname_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("desigilname_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\$")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;
$::VAR = $M->{'variable'} }, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'sigil'} = [];
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G[\@\%\&]/))
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) {
$C->_PATTERN(qr/\G\w/)
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Invalid hard reference syntax"))) {
$C
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}));
}
;
## token variable {
sub variable__PEEK { $_[0]->_AUTOLEXpeek('variable', $retree) }
sub variable {
no warnings 'recursion';
my $self = shift;

local $::IN_META = '';
my $sigil = '';
my $twigil = '';
my $name;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE variable");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'name'} = [];
$C->{'postcircumfix'} = [];
$C->{'twigil'} = [];
$self->_MATCHIFYr($S, "variable", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
scalar(do {
my $M = $C;
$sigil = $M->{'sigil'}->Str;
$::LEFTSIGIL ||= $sigil;
}, $C)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_EXACT("\:\:"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_0') {
        $C->deb("Fate passed to variable_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT variable_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM variable_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'variable_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("variable_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\{")
},
sub {
my $C=shift;
$C->_EXACT("\<")
},
sub {
my $C=shift;
$C->_EXACT("\(")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("\&"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_1') {
        $C->deb("Fate passed to variable_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT variable_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM variable_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'variable_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("variable_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
and ($C) = ($C->_SUBSUMEr(['sublongname'], sub {
my $C = shift;
$C->sublongname
}))) {
scalar(do {
my $M = $C;
$name = $M->{'sublongname'}->Str }, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('[]')
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'infix noun', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_EXACT("\$\:\:"))) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
})
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_EXACT("\$\:"))) {
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_2') {
        $C->deb("Fate passed to variable_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT variable_2';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM variable_2'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'variable_2', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("variable_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
and ($C) = ($C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
}))) {
scalar(do {
my $M = $C;
$name = $M->{'desigilname'}->Str }, $C)
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['special_variable'], sub {
my $C = shift;
$C->special_variable
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))) {
$C->_SUBSUMEr(['index'], sub {
my $C = shift;
$C->decint
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_3') {
        $C->deb("Fate passed to variable_3: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT variable_3';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM variable_3'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'variable_3', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("variable_3 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\<")
},
sub {
my $C=shift;
$C->_EXACT("\(")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::IN_DECL })
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) {
scalar(do {
{
if ($::QSIGIL) {
return ()}
else {
$C->sorry("Non-declarative sigil is missing its name")}}}, $C)
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
}
};
@gather;
}
}))
and ($C) = (scalar(do {
my $M = $C;
my $t = $M->{'twigil'};
$twigil = $t->[0]->Str if @$t;
}, $C))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$twigil eq '.' })
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'variable_4') {
        $C->deb("Fate passed to variable_4: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT variable_4';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM variable_4'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'variable_4', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("variable_4 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_EXACT("\\")
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token deflongname {
sub deflongname__PEEK { $_[0]->_AUTOLEXpeek('deflongname', $retree) }
sub deflongname {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE deflongname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];
$self->_MATCHIFYr($S, "deflongname", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'deflongname_0') {
        $C->deb("Fate passed to deflongname_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT deflongname_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM deflongname_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'deflongname_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("deflongname_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
}))) {
scalar(do {
$C->add_categorical(substr($::ORIG, $self->{'_pos'}, $C->{'_pos'} - $self->{'_pos'})) if $::IN_DECL}, $C)
} else { () }
},
sub {
my $C=shift;
scalar(do {
my $M = $C;
$C->add_routine($M->{'name'}->Str) if $::IN_DECL}, $C)
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token subshortname {
sub subshortname__PEEK { $_[0]->_AUTOLEXpeek('subshortname', $retree) }
sub subshortname {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE subshortname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'colonpair'} = [];
$self->_MATCHIFYr($S, "subshortname", $C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'subshortname_0') {
        $C->deb("Fate passed to subshortname_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT subshortname_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM subshortname_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'subshortname_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("subshortname_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['category'], sub {
my $C = shift;
$C->category
}))) {
$C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
})
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}));
}
;
## token sublongname {
sub sublongname__PEEK { $_[0]->_AUTOLEXpeek('sublongname', $retree) }
sub sublongname {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sublongname");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'sigterm'} = [];
$self->_MATCHIFYr($S, "sublongname", do {
if (my ($C) = ($C->_SUBSUMEr(['subshortname'], sub {
my $C = shift;
$C->subshortname
}))) {
$C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['sigterm'], sub {
my $C = shift;
$C->sigterm
})
})
} else { () }
});
}
;
## token value:quote   { <quote> }
sub value__S_135quote__PEEK { $_[0]->_AUTOLEXpeek('value__S_135quote', $retree) }
sub value__S_135quote {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE value__S_135quote");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quote";
$self->_MATCHIFYr($S, "value__S_135quote", $C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
}));
}
;
## token value:number  { <number> }
sub value__S_136number__PEEK { $_[0]->_AUTOLEXpeek('value__S_136number', $retree) }
sub value__S_136number {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE value__S_136number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "number";
$self->_MATCHIFYr($S, "value__S_136number", $C->_SUBSUMEr(['number'], sub {
my $C = shift;
$C->number
}));
}
;
## token value:version { <version> }
sub value__S_137version__PEEK { $_[0]->_AUTOLEXpeek('value__S_137version', $retree) }
sub value__S_137version {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE value__S_137version");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "version";
$self->_MATCHIFYr($S, "value__S_137version", $C->_SUBSUMEr(['version'], sub {
my $C = shift;
$C->version
}));
}
;
## token typename {
sub typename__PEEK { $_[0]->_AUTOLEXpeek('typename', $retree) }
sub typename {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE typename");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'param'} = [];
$C->{'typename'} = [];
$C->{'whence'} = [];
$self->_MATCHIFYr($S, "typename", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'typename_0') {
        $C->deb("Fate passed to typename_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT typename_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM typename_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'typename_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("typename_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\:\:\?"))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
{
my $longname = $M->{'longname'}->Str;
if (substr($longname, 0, 2) eq '::') {
$C->add_my_name(substr($longname, 2))}
else {
$C->is_name($longname)
            };
}})
}))) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\[")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['param'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['whence'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_EXACT("of"))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
})
} else { () }
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token number {
sub number__PEEK { $_[0]->_AUTOLEXpeek('number', $retree) }
sub number {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "number", $C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'number_0') {
        $C->deb("Fate passed to number_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT number_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM number_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'number_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("number_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\GNaN\b/)
},
sub {
my $C=shift;
$C->_SUBSUMEr(['integer'], sub {
my $C = shift;
$C->integer
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['dec_number'], sub {
my $C = shift;
$C->dec_number
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['rad_number'], sub {
my $C = shift;
$C->rad_number
})
},
sub {
my $C=shift;
$C->_PATTERN(qr/\GInf\b/)
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}));
}
;
## token strtonum:rational { <[+\-]>?<nu=.integer>'/'<de=.integer> }
sub strtonum__S_138rational__PEEK { $_[0]->_AUTOLEXpeek('strtonum__S_138rational', $retree) }
sub strtonum__S_138rational {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE strtonum__S_138rational");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "rational";
$self->_MATCHIFYr($S, "strtonum__S_138rational", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?:[+\-])?+/))
and ($C) = ($C->_SUBSUMEr(['nu'], sub {
my $C = shift;
$C->integer
}))
and ($C) = ($C->_EXACT("\/"))) {
$C->_SUBSUMEr(['de'], sub {
my $C = shift;
$C->integer
})
} else { () }
});
}
;
## token strtonum:complex { [<[+\-]>?<re=.number>]? <[+\-]><im=.number>'\\'?'i' }
sub strtonum__S_139complex__PEEK { $_[0]->_AUTOLEXpeek('strtonum__S_139complex', $retree) }
sub strtonum__S_139complex {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE strtonum__S_139complex");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'re'} = [];
$C->{sym} = "complex";
$self->_MATCHIFYr($S, "strtonum__S_139complex", do {
my $C = $C;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G(?:[+\-])?+/))) {
$C->_SUBSUMEr(['re'], sub {
my $C = shift;
$C->number
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_PATTERN(qr/\G[+\-]/))
and ($C) = ($C->_SUBSUMEr(['im'], sub {
my $C = shift;
$C->number
}))) {
$C->_PATTERN(qr/\G\\?+i/)
} else { () }
});
}
;
## token strtonum:number { <[+\-]>?<number> }
sub strtonum__S_140number__PEEK { $_[0]->_AUTOLEXpeek('strtonum__S_140number', $retree) }
sub strtonum__S_140number {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE strtonum__S_140number");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "number";
$self->_MATCHIFYr($S, "strtonum__S_140number", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?:[+\-])?+/))) {
$C->_SUBSUMEr(['number'], sub {
my $C = shift;
$C->number
})
} else { () }
});
}
;
## token sibble ($l, $lang2) {
sub sibble__PEEK { $_[0]->_AUTOLEXpeek('sibble', $retree) }
sub sibble {
no warnings 'recursion';
my $self = shift;

die 'Required argument l omitted' unless @_;
my $l = @_ ? shift() : undef;
die 'Required argument lang2 omitted' unless @_;
my $lang2 = @_ ? shift() : undef;
my ($lang, $start, $stop);

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sibble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "sibble", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))
and ($C) = (scalar(do {
my $M = $C;
my $B = $M->{'babble'}->{'B'};
($lang,$start,$stop) = @$B;
}, $C))
and ($C) = ($C->_EXACT($start))
and ($C) = ($C->_SUBSUMEr(['left'], sub {
my $C = shift;
$C->nibble($lang)
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_EXACT($stop))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Couldn't find terminator $stop"))) { ($C) } else { () }
}
};
@gather;
}
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$start ne $stop })
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
})
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['panic'], sub {
my $C = shift;
$C->panic("Missing assignment operator")
})
};
@gather;
}
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'infixish'}->Str eq '=' || $M->{'infixish'}->{'infix_postfix_meta_operator'} })
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed assignment operator"))) { ($C) } else { () }
}
};
@gather;
}
}))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['right','EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
})
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = (scalar(do {
$lang = $lang2->unbalanced($stop)}, $C))
and ($C) = ($C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->nibble($lang)
}))
and ($C) = ($C->_EXACT($stop))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed replacement part; couldn't find final $stop"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## token tribble ($l, $lang2 = $l) {
sub tribble__PEEK { $_[0]->_AUTOLEXpeek('tribble', $retree) }
sub tribble {
no warnings 'recursion';
my $self = shift;

die 'Required argument l omitted' unless @_;
my $l = @_ ? shift() : undef;
my $lang2 = @_ ? shift() : $l;
my ($lang, $start, $stop);
local $::CCSTATE = '';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE tribble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "tribble", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))
and ($C) = (scalar(do {
my $M = $C;
my $B = $M->{'babble'}->{'B'};
($lang,$start,$stop) = @$B;
}, $C))
and ($C) = ($C->_EXACT($start))
and ($C) = ($C->_SUBSUMEr(['left'], sub {
my $C = shift;
$C->nibble($lang)
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_EXACT($stop))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Couldn't find terminator $stop"))) { ($C) } else { () }
}
};
@gather;
}
}))
and ($C) = (scalar(do {
$::CCSTATE = ''}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$start ne $stop })
}))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($lang2)
})
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = (scalar(do {
$lang = $lang2->unbalanced($stop)}, $C))
and ($C) = ($C->_SUBSUMEr(['right'], sub {
my $C = shift;
$C->nibble($lang)
}))
and ($C) = ($C->_EXACT($stop))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed replacement part; couldn't find final $stop"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## token quasiquibble ($l) {
sub quasiquibble__PEEK { $_[0]->_AUTOLEXpeek('quasiquibble', $retree) }
sub quasiquibble {
no warnings 'recursion';
my $self = shift;

die 'Required argument l omitted' unless @_;
my $l = @_ ? shift() : undef;
local %::LANG = %::LANG;
my ($lang, $start, $stop);
local $::QUASIMODO = 0;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quasiquibble");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "quasiquibble", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['babble'], sub {
my $C = shift;
$C->babble($l)
}))
and ($C) = (scalar(do {
my $M = $C;
my $B = $M->{'babble'}->{'B'};
($lang,$start,$stop) = @$B;
$::LANG{'MAIN'} = $lang;
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$start eq '{' })
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($lang);
$C = bless($C, (ref($newlang) || $newlang));
;

$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
}))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($lang);
$C = bless($C, (ref($newlang) || $newlang));
;

do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))
and ($C) = ($C->_SUBSUMEr(['statementlist'], sub {
my $C = shift;
$C->statementlist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Couldn't find terminator $stop"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}
}))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## token quote:sym<//>   {
sub quote__S_141SlashSlash__PEEK { $_[0]->_AUTOLEXpeek('quote__S_141SlashSlash', $retree) }
sub quote__S_141SlashSlash {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_141SlashSlash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\/\/";
$self->_MATCHIFYr($S, "quote__S_141SlashSlash", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\/\s*+\//))
and ($C) = ($C->sorry("Null regex not allowed"))) {
$C
} else { () }
});
}
;
## token quote:sym</ />   {
sub quote__S_142Slash_Slash__PEEK { $_[0]->_AUTOLEXpeek('quote__S_142Slash_Slash', $retree) }
sub quote__S_142Slash_Slash {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_142Slash_Slash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\/\ \/";
$self->_MATCHIFYr($S, "quote__S_142Slash_Slash", do {
my $C = $C;
if (($C) = ($C->_EXACT("\/"))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble( $C->cursor_fresh( $::LANG{'Regex'} )->unbalanced("/") )
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\/")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unable to parse regex; couldn't find final '/'"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->old_rx_mods)) { ($C) } else { () }
})
} else { () }
});
}
;
## token quote:qq {
sub quote__S_143qq__PEEK { $_[0]->_AUTOLEXpeek('quote__S_143qq', $retree) }
sub quote__S_143qq {
no warnings 'recursion';
my $self = shift;

my $qm;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_143qq");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "qq";
$self->_MATCHIFYr($S, "quote__S_143qq", do {
my $C = $C;
if (($C) = ($C->_EXACT("qq"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'quote__S_143qq_0') {
        $C->deb("Fate passed to quote__S_143qq_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT quote__S_143qq_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM quote__S_143qq_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'quote__S_143qq_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("quote__S_143qq_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$qm = $M->{'quote_mod'}->Str }, $C))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak($qm => 1))
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))
})
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token quote:q {
sub quote__S_144q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_144q', $retree) }
sub quote__S_144q {
no warnings 'recursion';
my $self = shift;

my $qm;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_144q");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "q";
$self->_MATCHIFYr($S, "quote__S_144q", do {
my $C = $C;
if (($C) = ($C->_EXACT("q"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'quote__S_144q_0') {
        $C->deb("Fate passed to quote__S_144q_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT quote__S_144q_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM quote__S_144q_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'quote__S_144q_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("quote__S_144q_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$qm = $M->{'quote_mod'}->Str }, $C))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->tweak($qm => 1))
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1))
})
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token quote:Q {
sub quote__S_145Q__PEEK { $_[0]->_AUTOLEXpeek('quote__S_145Q', $retree) }
sub quote__S_145Q {
no warnings 'recursion';
my $self = shift;

my $qm;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_145Q");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "Q";
$self->_MATCHIFYr($S, "quote__S_145Q", do {
my $C = $C;
if (($C) = ($C->_EXACT("Q"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'quote__S_145Q_0') {
        $C->deb("Fate passed to quote__S_145Q_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT quote__S_145Q_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM quote__S_145Q_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'quote__S_145Q_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("quote__S_145Q_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['quote_mod'], sub {
my $C = shift;
$C->quote_mod
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$qm = $M->{'quote_mod'}->Str }, $C))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak($qm => 1))
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} ))
})
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token quote_mod:w  { <sym> }
sub quote_mod__S_146w__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_146w', $retree) }
sub quote_mod__S_146w {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_146w");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "w";
$self->_MATCHIFYr($S, "quote_mod__S_146w", $C->_EXACT("w"));
}
;
## token quote_mod:ww { <sym> }
sub quote_mod__S_147ww__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_147ww', $retree) }
sub quote_mod__S_147ww {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_147ww");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ww";
$self->_MATCHIFYr($S, "quote_mod__S_147ww", $C->_EXACT("ww"));
}
;
## token quote_mod:p  { <sym> }
sub quote_mod__S_148p__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_148p', $retree) }
sub quote_mod__S_148p {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_148p");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "p";
$self->_MATCHIFYr($S, "quote_mod__S_148p", $C->_EXACT("p"));
}
;
## token quote_mod:x  { <sym> }
sub quote_mod__S_149x__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_149x', $retree) }
sub quote_mod__S_149x {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_149x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "x";
$self->_MATCHIFYr($S, "quote_mod__S_149x", $C->_EXACT("x"));
}
;
## token quote_mod:to { <sym> }
sub quote_mod__S_150to__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_150to', $retree) }
sub quote_mod__S_150to {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_150to");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "to";
$self->_MATCHIFYr($S, "quote_mod__S_150to", $C->_EXACT("to"));
}
;
## token quote_mod:s  { <sym> }
sub quote_mod__S_151s__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_151s', $retree) }
sub quote_mod__S_151s {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_151s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "s";
$self->_MATCHIFYr($S, "quote_mod__S_151s", $C->_EXACT("s"));
}
;
## token quote_mod:a  { <sym> }
sub quote_mod__S_152a__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_152a', $retree) }
sub quote_mod__S_152a {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_152a");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "a";
$self->_MATCHIFYr($S, "quote_mod__S_152a", $C->_EXACT("a"));
}
;
## token quote_mod:h  { <sym> }
sub quote_mod__S_153h__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_153h', $retree) }
sub quote_mod__S_153h {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_153h");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "h";
$self->_MATCHIFYr($S, "quote_mod__S_153h", $C->_EXACT("h"));
}
;
## token quote_mod:f  { <sym> }
sub quote_mod__S_154f__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_154f', $retree) }
sub quote_mod__S_154f {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_154f");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "f";
$self->_MATCHIFYr($S, "quote_mod__S_154f", $C->_EXACT("f"));
}
;
## token quote_mod:c  { <sym> }
sub quote_mod__S_155c__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_155c', $retree) }
sub quote_mod__S_155c {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_155c");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "c";
$self->_MATCHIFYr($S, "quote_mod__S_155c", $C->_EXACT("c"));
}
;
## token quote_mod:b  { <sym> }
sub quote_mod__S_156b__PEEK { $_[0]->_AUTOLEXpeek('quote_mod__S_156b', $retree) }
sub quote_mod__S_156b {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote_mod__S_156b");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "b";
$self->_MATCHIFYr($S, "quote_mod__S_156b", $C->_EXACT("b"));
}
;
## token quote:rx {
sub quote__S_157rx__PEEK { $_[0]->_AUTOLEXpeek('quote__S_157rx', $retree) }
sub quote__S_157rx {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_157rx");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "rx";
$self->_MATCHIFYr($S, "quote__S_157rx", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Grx\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} ) )
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->old_rx_mods)) { ($C) } else { () }
}))) {
$C
} else { () }
});
}
;
## token quote:m  {
sub quote__S_158m__PEEK { $_[0]->_AUTOLEXpeek('quote__S_158m', $retree) }
sub quote__S_158m {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_158m");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "m";
$self->_MATCHIFYr($S, "quote__S_158m", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gm\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} ) )
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->old_rx_mods)) { ($C) } else { () }
}))) {
$C
} else { () }
});
}
;
## token quote:mm {
sub quote__S_159mm__PEEK { $_[0]->_AUTOLEXpeek('quote__S_159mm', $retree) }
sub quote__S_159mm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_159mm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "mm";
$self->_MATCHIFYr($S, "quote__S_159mm", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gmm\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble( $C->cursor_fresh( $::LANG{'Regex'} )->tweak('s' => 1))
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->old_rx_mods)) { ($C) } else { () }
}))) {
$C
} else { () }
});
}
;
## token quote:s {
sub quote__S_160s__PEEK { $_[0]->_AUTOLEXpeek('quote__S_160s', $retree) }
sub quote__S_160s {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_160s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "s";
$self->_MATCHIFYr($S, "quote__S_160s", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gs\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->sibble( $C->cursor_fresh( $::LANG{'Regex'} ), $C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->old_rx_mods)) { ($C) } else { () }
}))) {
$C
} else { () }
});
}
;
## token quote:ss {
sub quote__S_161ss__PEEK { $_[0]->_AUTOLEXpeek('quote__S_161ss', $retree) }
sub quote__S_161ss {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_161ss");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ss";
$self->_MATCHIFYr($S, "quote__S_161ss", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gss\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->sibble( $C->cursor_fresh( $::LANG{'Regex'} )->tweak('s' => 1), $C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1))
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->old_rx_mods)) { ($C) } else { () }
}))) {
$C
} else { () }
});
}
;
## token quote:tr {
sub quote__S_162tr__PEEK { $_[0]->_AUTOLEXpeek('quote__S_162tr', $retree) }
sub quote__S_162tr {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_162tr");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "tr";
$self->_MATCHIFYr($S, "quote__S_162tr", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gtr\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['pat'], sub {
my $C = shift;
$C->tribble( $C->cursor_fresh( $::LANG{'Q'} )->tweak('cc' => 1))
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->old_tr_mods)) { ($C) } else { () }
}))) {
$C
} else { () }
});
}
;
## token quote:y {
sub quote__S_163y__PEEK { $_[0]->_AUTOLEXpeek('quote__S_163y', $retree) }
sub quote__S_163y {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_163y");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "y";
$self->_MATCHIFYr($S, "quote__S_163y", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gy\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$self->is_known('&y') or $self->is_known('y') })
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]*+\W/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('y///','tr///'))) {
$C
} else { () }
});
}
;
## token old_rx_mods {
sub old_rx_mods__PEEK { $_[0]->_AUTOLEXpeek('old_rx_mods', $retree) }
sub old_rx_mods {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE old_rx_mods");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "old_rx_mods", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->after(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?<=\w)/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PLUSr(sub {
my $C=shift;
if (my ($C) = ($C->_ARRAY( qw< i g s m x c e > ))) { ($C) } else { () }
})

})
}))) {
scalar(do {
my $M = $C;
{
given ($M->{0}->Str) {
$_ =~ /i/ and $C->worryobs('/i',':i');
$_ =~ /g/ and $C->worryobs('/g',':g');
$_ =~ /s/ and $C->worryobs('/s','^^ and $$ anchors');
$_ =~ /m/ and $C->worryobs('/m','. or \N');
$_ =~ /x/ and $C->worryobs('/x','normal default whitespace');
$_ =~ /c/ and $C->worryobs('/c',':c or :p');
$_ =~ /e/ and $C->worryobs('/e','interpolated {...} or s{} = ... form');
$C->obs('suffix regex modifiers','prefix adverbs');
}
        }}, $C)
} else { () }
});
}
;
## token old_tr_mods {
sub old_tr_mods__PEEK { $_[0]->_AUTOLEXpeek('old_tr_mods', $retree) }
sub old_tr_mods {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE old_tr_mods");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "old_tr_mods", do {
if (my ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PLUSr(sub {
my $C=shift;
if (my ($C) = ($C->_ARRAY( qw< c d s ] > ))) { ($C) } else { () }
})

})
}))) {
scalar(do {
my $M = $C;
{
given ($M->{0}->Str) {
$_ =~ /c/ and $C->worryobs('/c',':c');
$_ =~ /d/ and $C->worryobs('/g',':d');
$_ =~ /s/ and $C->worryobs('/s',':s');
$C->obs('suffix transliteration modifiers','prefix adverbs');
}
        }}, $C)
} else { () }
});
}
;
## token quote:quasi {
sub quote__S_164quasi__PEEK { $_[0]->_AUTOLEXpeek('quote__S_164quasi', $retree) }
sub quote__S_164quasi {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quote__S_164quasi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quasi";
$self->_MATCHIFYr($S, "quote__S_164quasi", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gquasi\b/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['quasiquibble'], sub {
my $C = shift;
$C->quasiquibble($C->cursor_fresh( $::LANG{'Quasi'} ))
})
} else { () }
});
}
;
## token capterm {
sub capterm__PEEK { $_[0]->_AUTOLEXpeek('capterm', $retree) }
sub capterm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE capterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'capture'} = [];
$self->_MATCHIFYr($S, "capterm", do {
my $C = $C;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'capterm_0') {
        $C->deb("Fate passed to capterm_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT capterm_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM capterm_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'capterm_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("capterm_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\("))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['capture'], sub {
my $C = shift;
$C->capture
})
}))) {
$C->_EXACT("\)")
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['termish'], sub {
my $C = shift;
$C->termish
})
} else { () }
},
sub {
my $C=shift;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->panic("You can't backslash that"))) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## rule capture {
sub capture__PEEK { $_[0]->_AUTOLEXpeek('capture', $retree) }
sub capture {
no warnings 'recursion';
my $self = shift;

local $::INVOCANT_OK = 1;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE capture");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "capture", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token sigterm {
sub sigterm__PEEK { $_[0]->_AUTOLEXpeek('sigterm', $retree) }
sub sigterm {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sigterm");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "sigterm", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\:\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['fakesignature'], sub {
my $C = shift;
$C->fakesignature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'signature', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## rule param_sep { [','|':'|';'|';;'] }
sub param_sep__PEEK { $_[0]->_AUTOLEXpeek('param_sep', $retree) }
sub param_sep {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE param_sep");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "param_sep", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'param_sep_0') {
        $C->deb("Fate passed to param_sep_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT param_sep_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM param_sep_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'param_sep_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("param_sep_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\,")
},
sub {
my $C=shift;
$C->_EXACT("\:")
},
sub {
my $C=shift;
$C->_EXACT("\;")
},
sub {
my $C=shift;
$C->_EXACT("\;\;")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token fakesignature() {
sub fakesignature__PEEK { $_[0]->_AUTOLEXpeek('fakesignature', $retree) }
sub fakesignature {
no warnings 'recursion';
my $self = shift;

local $::CURPAD = $::CURPAD;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE fakesignature");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "fakesignature", do {
if (my ($C) = ($C->newpad)) {
$C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
})
} else { () }
});
}
;
## token signature ($padsig = 0) {
sub signature__PEEK { $_[0]->_AUTOLEXpeek('signature', $retree) }
sub signature {
no warnings 'recursion';
my $self = shift;

my $padsig = @_ ? shift() : 0;
local $::IN_DECL = 'sig';
local $::zone = 'posreq';
my $startpos = $self->{'_pos'};
local $::MULTINESS = 'only';
local $::SIGNUM = $padsig;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE signature");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'param_sep'} = [];
$C->{'parameter'} = [];
$C->{'typename'} = [];
$self->_MATCHIFYr($S, "signature", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_REPSEPr( sub {
my $C=shift;
$C->_SUBSUMEr(['param_sep'], sub {
my $C = shift;
$C->param_sep
})
}, sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'signature_0') {
        $C->deb("Fate passed to signature_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT signature_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM signature_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'signature_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("signature_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'signature_1') {
        $C->deb("Fate passed to signature_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT signature_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM signature_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'signature_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("signature_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\-\-\>")
},
sub {
my $C=shift;
$C->_EXACT("\)")
},
sub {
my $C=shift;
$C->_EXACT("\]")
},
sub {
my $C=shift;
$C->_EXACT("\{")
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\:\s/)
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['parameter'], sub {
my $C = shift;
$C->parameter
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Malformed parameter"))) { ($C) } else { () }
}
};
@gather;
}
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\-\-\>"))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::OFTYPE })
}))
and ($C) = ($C->sorry("Extra 'of' type; already declared as type " . $::OFTYPE->Str))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
$::OFTYPE = $M->{'typename'}->[0]}, $C)
} else { () }
}))) { ($C) } else { () }
}))) {
scalar(do {
{
$::LEFTSIGIL = '@';
if ($padsig) {
$::CURPAD->{'$?SIGNATURE'} .= '|' if $padsig > 1;
$::CURPAD->{'$?SIGNATURE'} .= '(' . substr($::ORIG, $startpos, $C->{'_pos'} - $startpos) . ')';
delete $::CURPAD->{'!NEEDSIG'};
};
}}, $C)
} else { () }
});
}
;
## token type_declarator:subset {
sub type_declarator__S_165subset__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_165subset', $retree) }
sub type_declarator__S_165subset {
no warnings 'recursion';
my $self = shift;

;
local $::IN_DECL = 'subset';
local $::DECLARAND;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE type_declarator__S_165subset");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'EXPR'} = [];
$C->{'longname'} = [];
$C->{'trait'} = [];
$C->{sym} = "subset";
$self->_MATCHIFYr($S, "type_declarator__S_165subset", do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("subset"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
$C->add_name($M->{'longname'}->[0]->Str)}, $C)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("where"))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->panic( "Malformed subset"))
and ($C) = ($C->ws)) {
$C
} else { () }
}
};
@gather;
});
}
;
## token type_declarator:enum {
sub type_declarator__S_166enum__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_166enum', $retree) }
sub type_declarator__S_166enum {
no warnings 'recursion';
my $self = shift;

;
local $::IN_DECL = 'enum';
local $::DECLARAND;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE type_declarator__S_166enum");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{sym} = "enum";
$self->_MATCHIFYr($S, "type_declarator__S_166enum", do {
my $C = $C;
if (($C) = ($C->_EXACT("enum"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'type_declarator__S_166enum_0') {
        $C->deb("Fate passed to type_declarator__S_166enum_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT type_declarator__S_166enum_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM type_declarator__S_166enum_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'type_declarator__S_166enum_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("type_declarator__S_166enum_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['name','longname'], sub {
my $C = shift;
$C->longname
}))) {
scalar(do {
my $M = $C;
$C->add_name($M->{'name'}->Str)}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['name','variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;
$C->add_variable($M->{'name'}->Str)}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[<(«]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->term
}))
and ($C) = ($C->ws)) {
scalar(do {
my $M = $C;
$C->add_enum($M->{'name'}, $M->{'term'}->Str)}, $C)
} else { () }
});
}
;
## token type_declarator:constant {
sub type_declarator__S_167constant__PEEK { $_[0]->_AUTOLEXpeek('type_declarator__S_167constant', $retree) }
sub type_declarator__S_167constant {
no warnings 'recursion';
my $self = shift;

;
local $::IN_DECL = 'constant';
local $::DECLARAND;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE type_declarator__S_167constant");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'trait'} = [];
$C->{sym} = "constant";
$self->_MATCHIFYr($S, "type_declarator__S_167constant", do {
my $C = $C;
if (($C) = ($C->_EXACT("constant"))
and ($C) = ($C->spacey)
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'type_declarator__S_167constant_0') {
        $C->deb("Fate passed to type_declarator__S_167constant_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT type_declarator__S_167constant_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM type_declarator__S_167constant_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'type_declarator__S_167constant_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("type_declarator__S_167constant_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))) {
scalar(do {
my $M = $C;
$C->add_name($M->{'identifier'}->Str)}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;
$C->add_variable($M->{'variable'}->Str)}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = (scalar(do {
$::IN_DECL = ''}, $C))
and ($C) = ($C->ws)
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\=")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?:[^\n=])*+\=/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Malformed constant"))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Missing initializer on constant declaration"))) { ($C) } else { () }
}
};
@gather;
}
}))
and ($C) = ($C->getdecl)) {
$C
} else { () }
});
}
;
## token type_constraint {
sub type_constraint__PEEK { $_[0]->_AUTOLEXpeek('type_constraint', $retree) }
sub type_constraint {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = '';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE type_constraint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "type_constraint", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'type_constraint_0') {
        $C->deb("Fate passed to type_constraint_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT type_constraint_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM type_constraint_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'type_constraint_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("type_constraint_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['value'], sub {
my $C = shift;
$C->value
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['typename'], sub {
my $C = shift;
$C->typename
})
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("where"))
and ($C) = ($C->ws)) {
$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
})
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## rule post_constraint {
sub post_constraint__PEEK { $_[0]->_AUTOLEXpeek('post_constraint', $retree) }
sub post_constraint {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = '';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE post_constraint");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "post_constraint", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'post_constraint_0') {
        $C->deb("Fate passed to post_constraint_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT post_constraint_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM post_constraint_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'post_constraint_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("post_constraint_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'constraint', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'constraint', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("where"))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%chaining)
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token named_param {
sub named_param__PEEK { $_[0]->_AUTOLEXpeek('named_param', $retree) }
sub named_param {
no warnings 'recursion';
my $self = shift;

local $::GOAL = ')';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE named_param");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "named_param", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'named_param_0') {
        $C->deb("Fate passed to named_param_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT named_param_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM named_param_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'named_param_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("named_param_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->_EXACT("\("))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'named_param_1') {
        $C->deb("Fate passed to named_param_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT named_param_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM named_param_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'named_param_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("named_param_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
})
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unable to parse named parameter; couldn't find right parenthesis"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token param_var {
sub param_var__PEEK { $_[0]->_AUTOLEXpeek('param_var', $retree) }
sub param_var {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE param_var");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'name'} = [];
$C->{'postcircumfix'} = [];
$C->{'twigil'} = [];
$self->_MATCHIFYr($S, "param_var", $C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'param_var_0') {
        $C->deb("Fate passed to param_var_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT param_var_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM param_var_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'param_var_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("param_var_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'formal parameter', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['signature'], sub {
my $C = shift;
$C->signature
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'formal parameter', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'sigil'}->Str eq '&' })
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->ident)) { ($C) } else { () }
}))
and ($C) = (scalar(do {
}, $C))) {
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->sublongname
})
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'sigil'}->Str eq '@' || $M->{'sigil'}->Str eq '%' })
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->identifier
})
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\<\(\[\{]/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->identifier
})
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\/!]/)
})
})
};
@gather;
}
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
{
my $vname = $M->{'sigil'}->Str;
my $t = $M->{'twigil'};
my $twigil = '';
$twigil = $t->[0]->Str if @$t;
$vname .= $twigil;
my $n = eval {
$M->{'name'}->[0]->Str } // '';
$vname .= $n;
given ($twigil) {
when ('') {
$self->add_my_name($vname) if $n ne ''}
                    ;
when ('.') {
}
                    ;
when ('!') {
}
                    ;
when ('*') {
}
                    ;
default {
$self->panic("You may not use the $twigil twigil in a signature")}
                ;
}
            ;
}}, $C)
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}));
}
;
## token parameter {
sub parameter__PEEK { $_[0]->_AUTOLEXpeek('parameter', $retree) }
sub parameter {
no warnings 'recursion';
my $self = shift;

my $kind;
my $quant = '';
my $q;
local $::DECLARAND;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE parameter");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'default_value'} = [];
$C->{'post_constraint'} = [];
$C->{'trait'} = [];
$C->{'type_constraint'} = [];
$self->_MATCHIFYr($S, "parameter", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_0') {
        $C->deb("Fate passed to parameter_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT parameter_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM parameter_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'parameter_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("parameter_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['type_constraint'], sub {
my $C = shift;
$C->type_constraint
})
}))
and ($C) = (scalar(do {
my $M = $C;
{
my $t = $M->{'type_constraint'};
my @t = grep {
substr($_->Str,0,2) ne '::' }  @$t;
@t > 1 and $C->sorry("Multiple prefix constraints not yet supported")
            ;
}}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_1') {
        $C->deb("Fate passed to parameter_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT parameter_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM parameter_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'parameter_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("parameter_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\*\*"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '**';
$kind = '*';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\*"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '*';
$kind = '*';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\|"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '|';
$kind = '*';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '\\';
$kind = '!';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_2') {
        $C->deb("Fate passed to parameter_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT parameter_2';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM parameter_2'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'parameter_2', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("parameter_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '';
$kind = '!';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
}))) {
scalar(do {
$quant = '';
$kind = '*';
}, $C)
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_3') {
        $C->deb("Fate passed to parameter_3: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT parameter_3';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM parameter_3'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'parameter_3', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("parameter_3 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\?"))) {
scalar(do {
$quant = '?';
$kind = '?' ;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\!"))) {
scalar(do {
$quant = '!';
$kind //= '!' ;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) {
scalar(do {
$quant = '';
$kind = '!' ;
}, $C)
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\*\*"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '**';
$kind = '*';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\*"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '*';
$kind = '*';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\|"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '|';
$kind = '*';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '\\';
$kind = '!';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_4') {
        $C->deb("Fate passed to parameter_4: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT parameter_4';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM parameter_4'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'parameter_4', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("parameter_4 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['param_var'], sub {
my $C = shift;
$C->param_var
}))) {
scalar(do {
$quant = '';
$kind = '!';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['named_param'], sub {
my $C = shift;
$C->named_param
}))) {
scalar(do {
$quant = '';
$kind = '*';
}, $C)
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'parameter_5') {
        $C->deb("Fate passed to parameter_5: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT parameter_5';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM parameter_5'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'parameter_5', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("parameter_5 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\?"))) {
scalar(do {
$quant = '?';
$kind = '?' ;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\!"))) {
scalar(do {
$quant = '!';
$kind //= '!' ;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = (do {
my $M = $C;
$C->panic("In parameter declaration, typename '" . $M->{'longname'}->Str . "' must be predeclared (or marked as declarative with :: prefix)")
})) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['trait'], sub {
my $C = shift;
$C->trait
})
}))
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['post_constraint'], sub {
my $C = shift;
$C->post_constraint
})
}))
and ($C) = ($C->getdecl)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['default_value'], sub {
my $C = shift;
$C->default_value
}))
and ($C) = (scalar(do {
{
given ($quant) {
when ('!') {
$C->sorry("Can't put a default on a required parameter") }
                  ;
when ('*') {
$C->sorry("Can't put a default on a slurpy parameter") }
                  ;
when ('**') {
$C->sorry("Can't put a default on a slice parameter") }
                  ;
when ('|') {
$C->sorry("Can't put a default on an slurpy capture parameter") }
                  ;
when ('\\') {
$C->sorry("Can't put a default on a capture parameter") }
                ;
}
                ;
$kind = '?' if $kind eq '!';
}}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\:")
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Can't put a default on the invocant parameter"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[,;)\]\{\-]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorry("Default expression must come last"))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\:")
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$kind ne '!' })
}))
and ($C) = ($C->sorry("Invocant is too exotic"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$M->{'quant'} = $quant;
$M->{'kind'} = $kind;
}, $C))) {
scalar(do {
{
given ($kind) {
when ('!') {
given ($::zone) {
when ('posopt') {
$C->sorry("Can't put required parameter after optional parameters")}
                        ;
when ('var') {
$C->sorry("Can't put required parameter after variadic parameters")}
                    ;
}
                }
                ;
when ('?') {
given ($::zone) {
when ('posreq') {
$::zone = 'posopt' }
                        ;
when ('var') {
$C->sorry("Can't put optional positional parameter after variadic parameters")}
                    ;
}
                }
                ;
when ('*') {
$::zone = 'var'}
            ;
}
        }}, $C)
} else { () }
});
}
;
## rule default_value {
sub default_value__PEEK { $_[0]->_AUTOLEXpeek('default_value', $retree) }
sub default_value {
no warnings 'recursion';
my $self = shift;

local $::IN_DECL = '';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE default_value");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "default_value", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_EXACT("\="))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token statement_prefix:sink    { <sym> <blast> }
sub statement_prefix__S_168sink__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_168sink', $retree) }
sub statement_prefix__S_168sink {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_168sink");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sink";
$self->_MATCHIFYr($S, "statement_prefix__S_168sink", do {
if (my ($C) = ($C->_EXACT("sink"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:try     { <sym> <blast> }
sub statement_prefix__S_169try__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_169try', $retree) }
sub statement_prefix__S_169try {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_169try");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "try";
$self->_MATCHIFYr($S, "statement_prefix__S_169try", do {
if (my ($C) = ($C->_EXACT("try"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:quietly { <sym> <blast> }
sub statement_prefix__S_170quietly__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_170quietly', $retree) }
sub statement_prefix__S_170quietly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_170quietly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quietly";
$self->_MATCHIFYr($S, "statement_prefix__S_170quietly", do {
if (my ($C) = ($C->_EXACT("quietly"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:gather  { <sym> <blast> }
sub statement_prefix__S_171gather__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_171gather', $retree) }
sub statement_prefix__S_171gather {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_171gather");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "gather";
$self->_MATCHIFYr($S, "statement_prefix__S_171gather", do {
if (my ($C) = ($C->_EXACT("gather"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:contend { <sym> <blast> }
sub statement_prefix__S_172contend__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_172contend', $retree) }
sub statement_prefix__S_172contend {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_172contend");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "contend";
$self->_MATCHIFYr($S, "statement_prefix__S_172contend", do {
if (my ($C) = ($C->_EXACT("contend"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:async   { <sym> <blast> }
sub statement_prefix__S_173async__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_173async', $retree) }
sub statement_prefix__S_173async {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_173async");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "async";
$self->_MATCHIFYr($S, "statement_prefix__S_173async", do {
if (my ($C) = ($C->_EXACT("async"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:maybe   { <sym> <blast> }
sub statement_prefix__S_174maybe__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_174maybe', $retree) }
sub statement_prefix__S_174maybe {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_174maybe");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "maybe";
$self->_MATCHIFYr($S, "statement_prefix__S_174maybe", do {
if (my ($C) = ($C->_EXACT("maybe"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:lazy    { <sym> <blast> }
sub statement_prefix__S_175lazy__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_175lazy', $retree) }
sub statement_prefix__S_175lazy {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_175lazy");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "lazy";
$self->_MATCHIFYr($S, "statement_prefix__S_175lazy", do {
if (my ($C) = ($C->_EXACT("lazy"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:do      { <sym> <blast> }
sub statement_prefix__S_176do__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_176do', $retree) }
sub statement_prefix__S_176do {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_176do");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "do";
$self->_MATCHIFYr($S, "statement_prefix__S_176do", do {
if (my ($C) = ($C->_EXACT("do"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token statement_prefix:lift    {
sub statement_prefix__S_177lift__PEEK { $_[0]->_AUTOLEXpeek('statement_prefix__S_177lift', $retree) }
sub statement_prefix__S_177lift {
no warnings 'recursion';
my $self = shift;

local $::QUASIMODO = 1;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE statement_prefix__S_177lift");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "lift";
$self->_MATCHIFYr($S, "statement_prefix__S_177lift", do {
if (my ($C) = ($C->_EXACT("lift"))) {
$C->_SUBSUMEr(['blast'], sub {
my $C = shift;
$C->blast
})
} else { () }
});
}
;
## token blast {
sub blast__PEEK { $_[0]->_AUTOLEXpeek('blast', $retree) }
sub blast {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE blast");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "blast", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'blast_0') {
        $C->deb("Fate passed to blast_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT blast_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM blast_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'blast_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("blast_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['block'], sub {
my $C = shift;
$C->block
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token term:YOU_ARE_HERE {
sub term__S_178YOU_ARE_HERE__PEEK { $_[0]->_AUTOLEXpeek('term__S_178YOU_ARE_HERE', $retree) }
sub term__S_178YOU_ARE_HERE {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_178YOU_ARE_HERE");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "YOU_ARE_HERE";
$self->_MATCHIFYr($S, "term__S_178YOU_ARE_HERE", do {
my $C = $C;
if (($C) = ($C->_EXACT("YOU_ARE_HERE"))
and ($C) = ($C->you_are_here)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }
});
}
;
## token term:new {
sub term__S_179new__PEEK { $_[0]->_AUTOLEXpeek('term__S_179new', $retree) }
sub term__S_179new {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_179new");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "new";
$self->_MATCHIFYr($S, "term__S_179new", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gnew[\x20\t\r]++/))
and ($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\:")
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs("C++ constructor syntax", "method call syntax"))) {
$C
} else { () }
});
}
;
## token term:sym<::?IDENT> {
sub term__S_180ColonColonQuestionIDENT__PEEK { $_[0]->_AUTOLEXpeek('term__S_180ColonColonQuestionIDENT', $retree) }
sub term__S_180ColonColonQuestionIDENT {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_180ColonColonQuestionIDENT");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\:\?IDENT";
$self->_MATCHIFYr($S, "term__S_180ColonColonQuestionIDENT", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\:\:\?"))) {
$C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
})
} else { () }
})
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }
});
}
;
## token term:sym<Object> {
sub term__S_181Object__PEEK { $_[0]->_AUTOLEXpeek('term__S_181Object', $retree) }
sub term__S_181Object {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_181Object");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "Object";
$self->_MATCHIFYr($S, "term__S_181Object", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\GObject\b/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->obs('Object', 'Mu as the "most universal" object type'))) {
$C
} else { () }
});
}
;
## token term:sym<undef> {
sub term__S_182undef__PEEK { $_[0]->_AUTOLEXpeek('term__S_182undef', $retree) }
sub term__S_182undef {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_182undef");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "undef";
$self->_MATCHIFYr($S, "term__S_182undef", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gundef\b/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\x20\t\r]*+\$\//)
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('$/ variable as input record separator',
                 "the filehandle's .slurp method"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'sigil'} = [];
$C->{'twigil'} = [];
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\(")
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['twigil'], sub {
my $C = shift;
$C->twigil
})
}))) {
$C->_PATTERN(qr/\G\w/)
} else { () }
}
};
@gather;
}
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('undef as a verb', 'undefine function or assignment of Nil'))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('undef as a value', "something more specific:\n\tMu (the \"most undefined\" type object),\n\tan undefined type object such as Int,\n\tNil as an empty list,\n\t:!defined as a matcher,\n\tAny:U as a type constraint\n\tor fail() as a failure return\n\t   "))) {
$C
} else { () }
});
}
;
## token term:sym<proceed>
sub term__S_183proceed__PEEK { $_[0]->_AUTOLEXpeek('term__S_183proceed', $retree) }
sub term__S_183proceed {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_183proceed");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "proceed";
$self->_MATCHIFYr($S, "term__S_183proceed", do {
if (my ($C) = ($C->_PATTERN(qr/\Gproceed\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }
});
}
;
## token term:sym<now>
sub term__S_184now__PEEK { $_[0]->_AUTOLEXpeek('term__S_184now', $retree) }
sub term__S_184now {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_184now");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "now";
$self->_MATCHIFYr($S, "term__S_184now", do {
if (my ($C) = ($C->_PATTERN(qr/\Gnow\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }
});
}
;
## token term:sym<self>
sub term__S_185self__PEEK { $_[0]->_AUTOLEXpeek('term__S_185self', $retree) }
sub term__S_185self {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_185self");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "self";
$self->_MATCHIFYr($S, "term__S_185self", do {
if (my ($C) = ($C->_PATTERN(qr/\Gself\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }
});
}
;
## token term:sym<defer>
sub term__S_186defer__PEEK { $_[0]->_AUTOLEXpeek('term__S_186defer', $retree) }
sub term__S_186defer {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_186defer");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "defer";
$self->_MATCHIFYr($S, "term__S_186defer", do {
if (my ($C) = ($C->_PATTERN(qr/\Gdefer\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }
});
}
;
## token term:rand {
sub term__S_187rand__PEEK { $_[0]->_AUTOLEXpeek('term__S_187rand', $retree) }
sub term__S_187rand {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_187rand");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "rand";
$self->_MATCHIFYr($S, "term__S_187rand", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Grand\b/))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\(?+[\x20\t\r]*+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_187rand_0') {
        $C->deb("Fate passed to term__S_187rand_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT term__S_187rand_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM term__S_187rand_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'term__S_187rand_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("term__S_187rand_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\d/)
},
sub {
my $C=shift;
$C->_EXACT("\$")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('rand(N)', 'N.rand or (1..N).pick'))) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(\)")
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('rand()', 'rand'))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }
});
}
;
## token term:sym<*>
sub term__S_188Star__PEEK { $_[0]->_AUTOLEXpeek('term__S_188Star', $retree) }
sub term__S_188Star {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_188Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*";
$self->_MATCHIFYr($S, "term__S_188Star", do {
if (my ($C) = ($C->_EXACT("\*"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }
});
}
;
## token term:sym<**>
sub term__S_189StarStar__PEEK { $_[0]->_AUTOLEXpeek('term__S_189StarStar', $retree) }
sub term__S_189StarStar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_189StarStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*\*";
$self->_MATCHIFYr($S, "term__S_189StarStar", do {
if (my ($C) = ($C->_EXACT("\*\*"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }
});
}
;
## token infix:lambda {
sub infix__S_190lambda__PEEK { $_[0]->_AUTOLEXpeek('infix__S_190lambda', $retree) }
sub infix__S_190lambda {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_190lambda");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "lambda";
$self->_MATCHIFYr($S, "infix__S_190lambda", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_190lambda_0') {
        $C->deb("Fate passed to infix__S_190lambda_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT infix__S_190lambda_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM infix__S_190lambda_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'infix__S_190lambda_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("infix__S_190lambda_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\{")
},
sub {
my $C=shift;
$C->_EXACT("\-\>")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))
and ($C) = (scalar(do {
{
my $line = $C->lineof($C->{'_pos'});
for ('if', 'unless', 'while', 'until', 'for', 'loop', 'given', 'when', 'sub') {
my $m = $::MYSTERY{$_};
next unless $m;
if ($line - ($m->{'line'}//-123) < 5) {
if ($m->{'ctx'} eq '(') {
$C->panic("Word '$_' interpreted as '$_" . "()' function call; please use whitespace " .
                        ($_ eq 'loop' ? 'around the parens' : 'instead of parens') . $m->{'token'}->locmess .
                        "\nUnexpected block in infix position (two terms in a row)")}
else {
$C->panic("Word '$_' interpreted as a listop; please use 'do $_' to introduce the statement control word" . $m->{'token'}->cursor($m->{'token'}->from)->locmess .
                        "\nUnexpected block in infix position (two terms in a row)")}};
}
            ;
return () if $::IN_REDUCE;
my $endpos = $C->{'_pos'};
my $startpos = $::MEMOS[$endpos]->{'ws'} // $endpos;
if ($self->lineof($startpos) != $self->lineof($endpos)) {
$C->panic("Unexpected block in infix position (previous line missing its semicolon?)")}
elsif ($::MEMOS[$C->{'_pos'}-1]->{'baremeth'}) {
$C->panic("Unexpected block in infix position (method call needs colon or parens to take arguments)")}
else {
$C->panic("Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?)")};
}}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }
});
}
;
## token circumfix:sigil
sub circumfix__S_191sigil__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_191sigil', $retree) }
sub circumfix__S_191sigil {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_191sigil");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sigil";
$self->_MATCHIFYr($S, "circumfix__S_191sigil", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'contextualizer', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$::LEFTSIGIL ||= $M->{'sigil'}->Str }, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }
});
}
;
## token circumfix:sym<( )>
sub circumfix__S_192Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_192Paren_Thesis', $retree) }
sub circumfix__S_192Paren_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_192Paren_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\(\ \)";
$self->_MATCHIFYr($S, "circumfix__S_192Paren_Thesis", do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'parenthesized expression', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }
});
}
;
## token circumfix:sym<[ ]>
sub circumfix__S_193Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_193Bra_Ket', $retree) }
sub circumfix__S_193Bra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_193Bra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\[\ \]";
$self->_MATCHIFYr($S, "circumfix__S_193Bra_Ket", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'array composer', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
}))) {
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'arraycomp'} = 1}, $C)
} else { () }
});
}
;
## token PRE {
sub PRE__PEEK { $_[0]->_AUTOLEXpeek('PRE', $retree) }
sub PRE {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE PRE");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'prefix_postfix_meta_operator'} = [];
$self->_MATCHIFYr($S, "PRE", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'PRE_0') {
        $C->deb("Fate passed to PRE_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT PRE_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM PRE_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'PRE_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("PRE_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['prefix'], sub {
my $C = shift;
$C->prefix
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'prefix'}->{'O'};
$M->{'sym'} = $M->{'prefix'}->{'sym'} ;
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['prefix_circumfix_meta_operator'], sub {
my $C = shift;
$C->prefix_circumfix_meta_operator
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'prefix_circumfix_meta_operator'}->{'O'};
$M->{'sym'} = $M->{'prefix_circumfix_meta_operator'}->Str ;
}, $C)
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->_STARr(sub {
my $C=shift;
$C->_SUBSUMEr(['prefix_postfix_meta_operator'], sub {
my $C = shift;
$C->prefix_postfix_meta_operator
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token infixish ($in_meta = $*IN_META) {
sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish', $retree) }
sub infixish {
no warnings 'recursion';
my $self = shift;

my $in_meta = @_ ? shift() : $::IN_META;
my $infix;
local $::IN_META = $in_meta;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infixish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'infix_postfix_meta_operator'} = [];
$self->_MATCHIFYr($S, "infixish", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stdstopper)) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->infixstopper)) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixish_0') {
        $C->deb("Fate passed to infixish_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT infixish_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM infixish_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'infixish_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("infixish_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
}))) {
scalar(do {
my $M = $C;
$M->{'fake'} = 1;
$M->{'sym'} = ':';
$M->{'O'}->{'prec'} = $item_assignment{'prec'};
$M->{'O'}->{'assoc'} = 'unary';
$M->{'O'}->{'dba'} = 'adverb';
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixish_1') {
        $C->deb("Fate passed to infixish_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT infixish_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM infixish_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'infixish_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("infixish_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infix'], sub {
my $C = shift;
$C->infixish('[]')
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'bracketed infix', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'infix'}->{'O'};
$M->{'sym'} = $M->{'infix'}->{'sym'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['infix','infix_circumfix_meta_operator'], sub {
my $C = shift;
$C->infix_circumfix_meta_operator
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'infix'}->{'O'};
$M->{'sym'} = $M->{'infix'}->{'sym'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['infix','infix_prefix_meta_operator'], sub {
my $C = shift;
$C->infix_prefix_meta_operator
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'infix'}->{'O'};
$M->{'sym'} = $M->{'infix'}->{'sym'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['infix'], sub {
my $C = shift;
$C->infix
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'infix'}->{'O'};
$M->{'sym'} = $M->{'infix'}->{'sym'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->dotty)) { ($C) } else { () }
}))
and ($C) = ($C->panic("Method call found where infix expected (omit whitespace?)"))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->postfix)) { ($C) } else { () }
}))
and ($C) = ($C->panic("Postfix found where infix expected (omit whitespace?)"))) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\=")
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$infix = $M->{'infix'}})
}))
and ($C) = ($C->_SUBSUMEr(['infix_postfix_meta_operator'], sub {
my $C = shift;
$C->infix_postfix_meta_operator($infix)
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'infix_postfix_meta_operator'}->[0]->{'O'};
$M->{'sym'} = $M->{'infix_postfix_meta_operator'}->[0]->{'sym'};
}, $C)
} else { () }
}))) { ($C) } else { () }
})
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token dotty:sym<.*> {
sub dotty__S_194DotStar__PEEK { $_[0]->_AUTOLEXpeek('dotty__S_194DotStar', $retree) }
sub dotty__S_194DotStar {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE dotty__S_194DotStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\*";
$self->_MATCHIFYr($S, "dotty__S_194DotStar", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_EXACT("\."))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'dotty__S_194DotStar_0') {
        $C->deb("Fate passed to dotty__S_194DotStar_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT dotty__S_194DotStar_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM dotty__S_194DotStar_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'dotty__S_194DotStar_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("dotty__S_194DotStar_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G[+*?=]/)
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\^\!?+/)
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
};

})
}))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->unspacey)
and ($C) = ($C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
}))
and ($C) = (scalar(do {
my $M = $C;
$M->{'sym'} = $M->{0}->Str}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }
});
}
;
## token dotty:sym<.> {
sub dotty__S_195Dot__PEEK { $_[0]->_AUTOLEXpeek('dotty__S_195Dot', $retree) }
sub dotty__S_195Dot {
no warnings 'recursion';
my $self = shift;

;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE dotty__S_195Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.";
$self->_MATCHIFYr($S, "dotty__S_195Dot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\."))
and ($C) = ($C->unspacey)
and ($C) = ($C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }
});
}
;
## token privop {
sub privop__PEEK { $_[0]->_AUTOLEXpeek('privop', $retree) }
sub privop {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE privop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "privop", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!"))
and ($C) = ($C->_SUBSUMEr(['methodop'], sub {
my $C = shift;
$C->methodop
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }
});
}
;
## token dottyopish {
sub dottyopish__PEEK { $_[0]->_AUTOLEXpeek('dottyopish', $retree) }
sub dottyopish {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE dottyopish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "dottyopish", $C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->dottyop
}));
}
;
## token dottyop {
sub dottyop__PEEK { $_[0]->_AUTOLEXpeek('dottyop', $retree) }
sub dottyop {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE dottyop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "dottyop", $C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'dottyop_0') {
        $C->deb("Fate passed to dottyop_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT dottyop_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM dottyop_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'dottyop_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("dottyop_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['methodop'], sub {
my $C = shift;
$C->methodop
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['colonpair'], sub {
my $C = shift;
$C->colonpair
})
},
sub {
my $C=shift;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))
and ($C) = ($C->_SUBSUMEr(['postop'], sub {
my $C = shift;
$C->postop
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'postop'}->{'O'};
$M->{'sym'} = $M->{'postop'}->{'sym'};
}, $C)
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}));
}
;
## token POST {
sub POST__PEEK { $_[0]->_AUTOLEXpeek('POST', $retree) }
sub POST {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE POST");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'postfix_prefix_meta_operator'} = [];
$self->_MATCHIFYr($S, "POST", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stdstopper)) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::MEMOS[$C->{'_pos'}]->{'ws'} })
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'POST_0') {
        $C->deb("Fate passed to POST_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT POST_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM POST_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'POST_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("POST_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_EXACT("\\")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->_STARr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\."))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['postfix_prefix_meta_operator'], sub {
my $C = shift;
$C->postfix_prefix_meta_operator
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
})
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'POST_1') {
        $C->deb("Fate passed to POST_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT POST_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM POST_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'POST_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("POST_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['dotty'], sub {
my $C = shift;
$C->dotty
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'dotty'}->{'O'};
$M->{'sym'} = $M->{'dotty'}->{'sym'};
$M->{'~CAPS'} = $M->{'dotty'}->{'~CAPS'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['privop'], sub {
my $C = shift;
$C->privop
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'privop'}->{'O'};
$M->{'sym'} = $M->{'privop'}->{'sym'};
$M->{'~CAPS'} = $M->{'privop'}->{'~CAPS'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['postop'], sub {
my $C = shift;
$C->postop
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'postop'}->{'O'};
$M->{'sym'} = $M->{'postop'}->{'sym'};
$M->{'~CAPS'} = $M->{'postop'}->{'~CAPS'};
}, $C)
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
scalar(do {
$::LEFTSIGIL = '@'}, $C)
} else { () }
});
}
;
## method can_meta ($op, $meta)
sub can_meta {
no warnings 'recursion';
my $self = shift;
die 'Required argument op omitted' unless @_;
my $op = @_ ? shift() : undef;
die 'Required argument meta omitted' unless @_;
my $meta = @_ ? shift() : undef;
!$op->{'O'}->{'fiddly'} ||
            $self->sorry("Can't " . $meta . " " . $op->{'sym'} . " because " . $op->{'O'}->{'dba'} . " operators are too fiddly");
$self;
};
## regex prefix_circumfix_meta_operator:reduce {
sub prefix_circumfix_meta_operator__S_196reduce__PEEK { $_[0]->_AUTOLEXpeek('prefix_circumfix_meta_operator__S_196reduce', $retree) }
sub prefix_circumfix_meta_operator__S_196reduce {
no warnings 'recursion';
my $self = shift;

local $::IN_REDUCE = 1;
my $op;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix_circumfix_meta_operator__S_196reduce");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "reduce";
$self->_MATCHIFY($S, "prefix_circumfix_meta_operator__S_196reduce", LazyMap::lazymap(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = (scalar(do {
my $M = $C;
$op = $M->{'s'}->{'op'}}, $C))) {
LazyMap::lazymap(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = (scalar(do {
my $M = $C;
$M->{'sym'} = $M->{'s'}->Str}, $C))) {
$C->_BRACKET(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->before(sub {
my $C=shift;
$C->_EXACT("\(")
})
}
or $xact->[-2] or
do {
push @gather, $C->before(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
$C->_OPTg(sub {
my $C=shift;
$C->_BRACKET(sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
scalar(do {
my $M = $C;
$M->{'O'}->{'term'} = 1 }, $C)
},
$C->before(sub {
my $C=shift;
$C->stdstopper
}))
})
})
},
$C->_PLUSg(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))
})
}
or $xact->[-2] or
do {
push @gather, scalar(do {
my $M = $C;
$M->{'O'}->{'term'} = 1 }, $C)
};
@gather;
}
})
} else { () }
},
$C->_SUBSUME(['O'], sub {
my $C = shift;
$C->O($op->Opairs, %list_prefix, assoc => 'unary', uassoc => 'left')
}))
},
$C->_BRACKET(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$op->{'O'}->{'diffy'} })
})
}
or $xact->[-2] or
do {
push @gather, $C->before(sub {
my $C=shift;
(($C) x !!do {
$op->{'O'}->{'assoc'} eq 'chain' })
})
}
or $xact->[-2] or
do {
push @gather, $C->sorry("Can't reduce with " . $op->{'sym'} . " because " . $op->{'O'}->{'dba'} . " operators are diffy and not chaining")
};
@gather;
}
}))
},
$C->can_meta($op, "reduce with"))
} else { () }
},
$C->_SUBSUME(['s'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\["))) {
LazyMap::lazymap(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\]"))) {
$C->_BRACKET(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'prefix_circumfix_meta_operator__S_196reduce_0') {
        $C->deb("Fate passed to prefix_circumfix_meta_operator__S_196reduce_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT prefix_circumfix_meta_operator__S_196reduce_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM prefix_circumfix_meta_operator__S_196reduce_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'prefix_circumfix_meta_operator__S_196reduce_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("prefix_circumfix_meta_operator__S_196reduce_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("«")
},
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})
} else { () }
},
$C->_BRACKET(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, LazyMap::lazymap(sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_EXACT("\]")
})
},
$C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infixish('red')
}))
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_EXACT("\\"))) {
LazyMap::lazymap(sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_EXACT("\]")
})
},
$C->_SUBSUME(['op'], sub {
my $C = shift;
$C->infixish('tri')
}))
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, $C->_NOTBEFORE(sub {
my $C=shift;
$C
})
};
@gather;
}
}))
} else { () }

})
}))
},
$C->before(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\["))) {
LazyMap::lazymap(sub {
my $C=shift;
$C->_EXACT("\]")
},
$C->_PLUSg(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S/)
}))
} else { () }
})));
}
;
## token prefix_postfix_meta_operator:sym< « >    { <sym> | '<<' }
sub prefix_postfix_meta_operator__S_197Fre__PEEK { $_[0]->_AUTOLEXpeek('prefix_postfix_meta_operator__S_197Fre', $retree) }
sub prefix_postfix_meta_operator__S_197Fre {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix_postfix_meta_operator__S_197Fre");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "«";
$self->_MATCHIFYr($S, "prefix_postfix_meta_operator__S_197Fre", do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'prefix_postfix_meta_operator__S_197Fre_0') {
        $C->deb("Fate passed to prefix_postfix_meta_operator__S_197Fre_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT prefix_postfix_meta_operator__S_197Fre_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM prefix_postfix_meta_operator__S_197Fre_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'prefix_postfix_meta_operator__S_197Fre_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("prefix_postfix_meta_operator__S_197Fre_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("«")
},
sub {
my $C=shift;
$C->_EXACT("\<\<")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
});
}
;
## token postfix_prefix_meta_operator:sym< » >    {
sub postfix_prefix_meta_operator__S_198Nch__PEEK { $_[0]->_AUTOLEXpeek('postfix_prefix_meta_operator__S_198Nch', $retree) }
sub postfix_prefix_meta_operator__S_198Nch {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postfix_prefix_meta_operator__S_198Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "»";
$self->_MATCHIFYr($S, "postfix_prefix_meta_operator__S_198Nch", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'postfix_prefix_meta_operator__S_198Nch_0') {
        $C->deb("Fate passed to postfix_prefix_meta_operator__S_198Nch_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT postfix_prefix_meta_operator__S_198Nch_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM postfix_prefix_meta_operator__S_198Nch_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'postfix_prefix_meta_operator__S_198Nch_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("postfix_prefix_meta_operator__S_198Nch_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("»")
},
sub {
my $C=shift;
$C->_EXACT("\>\>")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL })
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\(")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## token infix_prefix_meta_operator:sym<!> {
sub infix_prefix_meta_operator__S_199Bang__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_199Bang', $retree) }
sub infix_prefix_meta_operator__S_199Bang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_199Bang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!";
$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_199Bang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\!")
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('neg')
})
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Negation metaoperator not followed by valid infix"))) { ($C) } else { () }
}
};
@gather;
}
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'infixish'}->Str eq '=' })
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}, "negate")
})
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'infixish'}->{'O'}->{'iffy'} })
}))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'O'} = $M->{'infixish'}->{'O'}})
}))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = (do {
my $M = $C;
$C->sorry("Can't negate " . $M->{'infixish'}->Str . " because " . $M->{'infixish'}->{'O'}->{'dba'} . " operators are not iffy enough")
})) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## token infix_prefix_meta_operator:sym<R> {
sub infix_prefix_meta_operator__S_200R__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_200R', $retree) }
sub infix_prefix_meta_operator__S_200R {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_200R");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "R";
$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_200R", do {
my $C = $C;
if (($C) = ($C->_EXACT("R"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('R')
}))
and ($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}, "reverse the args of")
})
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'O'} = $M->{'infixish'}->{'O'}})
}))) {
$C
} else { () }
});
}
;
## token infix_prefix_meta_operator:sym<S> {
sub infix_prefix_meta_operator__S_201S__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_201S', $retree) }
sub infix_prefix_meta_operator__S_201S {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_201S");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "S";
$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_201S", do {
my $C = $C;
if (($C) = ($C->_EXACT("S"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('S')
}))
and ($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}, "sequence the args of")
})
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'O'} = $M->{'infixish'}->{'O'}})
}))) {
$C
} else { () }
});
}
;
## token infix_prefix_meta_operator:sym<X> {
sub infix_prefix_meta_operator__S_202X__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_202X', $retree) }
sub infix_prefix_meta_operator__S_202X {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_202X");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'infixish'} = [];
$C->{sym} = "X";
$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_202X", do {
my $C = $C;
if (($C) = ($C->_EXACT("X"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S/)
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('X')
}))
and ($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}->[0], "cross with")
})
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'O'} = $M->{'infixish'}->[0]->{'O'};
delete $M->{'O'}->{'prec'};
$M->{'sym'} .= $M->{'infixish'}->[0]->Str ;
})
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix, $self->Opairs)
})
} else { () }
});
}
;
## token infix_prefix_meta_operator:sym<Z> {
sub infix_prefix_meta_operator__S_203Z__PEEK { $_[0]->_AUTOLEXpeek('infix_prefix_meta_operator__S_203Z', $retree) }
sub infix_prefix_meta_operator__S_203Z {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_prefix_meta_operator__S_203Z");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'infixish'} = [];
$C->{sym} = "Z";
$self->_MATCHIFYr($S, "infix_prefix_meta_operator__S_203Z", do {
my $C = $C;
if (($C) = ($C->_EXACT("Z"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S/)
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('Z')
}))
and ($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}->[0], "zip with")
})
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'O'} = $M->{'infixish'}->[0]->{'O'};
delete $M->{'O'}->{'prec'};
$M->{'sym'} .= $M->{'infixish'}->[0]->Str ;
})
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix, $self->Opairs)
})
} else { () }
});
}
;
## token infix_circumfix_meta_operator:sym<« »> {
sub infix_circumfix_meta_operator__S_204Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_204Fre_Nch', $retree) }
sub infix_circumfix_meta_operator__S_204Fre_Nch {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_circumfix_meta_operator__S_204Fre_Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "«\ »";
$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_204Fre_Nch", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_204Fre_Nch_0') {
        $C->deb("Fate passed to infix_circumfix_meta_operator__S_204Fre_Nch_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT infix_circumfix_meta_operator__S_204Fre_Nch_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM infix_circumfix_meta_operator__S_204Fre_Nch_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'infix_circumfix_meta_operator__S_204Fre_Nch_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("infix_circumfix_meta_operator__S_204Fre_Nch_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("«")
},
sub {
my $C=shift;
$C->_EXACT("»")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('hyper')
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_204Fre_Nch_1') {
        $C->deb("Fate passed to infix_circumfix_meta_operator__S_204Fre_Nch_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT infix_circumfix_meta_operator__S_204Fre_Nch_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM infix_circumfix_meta_operator__S_204Fre_Nch_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'infix_circumfix_meta_operator__S_204Fre_Nch_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("infix_circumfix_meta_operator__S_204Fre_Nch_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("«")
},
sub {
my $C=shift;
$C->_EXACT("»")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Missing « or »"))) { ($C) } else { () }
}
};
@gather;
}
}))
and ($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}, "hyper with")
})
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'O'} = $M->{'infixish'}->{'O'}})
}))) {
$C
} else { () }
});
}
;
## token infix_circumfix_meta_operator:sym«<< >>» {
sub infix_circumfix_meta_operator__S_205LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('infix_circumfix_meta_operator__S_205LtLt_GtGt', $retree) }
sub infix_circumfix_meta_operator__S_205LtLt_GtGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_circumfix_meta_operator__S_205LtLt_GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\<\ \>\>";
$self->_MATCHIFYr($S, "infix_circumfix_meta_operator__S_205LtLt_GtGt", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_205LtLt_GtGt_0') {
        $C->deb("Fate passed to infix_circumfix_meta_operator__S_205LtLt_GtGt_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT infix_circumfix_meta_operator__S_205LtLt_GtGt_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM infix_circumfix_meta_operator__S_205LtLt_GtGt_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'infix_circumfix_meta_operator__S_205LtLt_GtGt_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("infix_circumfix_meta_operator__S_205LtLt_GtGt_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\<\<")
},
sub {
my $C=shift;
$C->_EXACT("\>\>")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish('HYPER')
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix_circumfix_meta_operator__S_205LtLt_GtGt_1') {
        $C->deb("Fate passed to infix_circumfix_meta_operator__S_205LtLt_GtGt_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT infix_circumfix_meta_operator__S_205LtLt_GtGt_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM infix_circumfix_meta_operator__S_205LtLt_GtGt_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'infix_circumfix_meta_operator__S_205LtLt_GtGt_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("infix_circumfix_meta_operator__S_205LtLt_GtGt_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\<\<")
},
sub {
my $C=shift;
$C->_EXACT("\>\>")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Missing << or >>"))) { ($C) } else { () }
}
};
@gather;
}
}))
and ($C) = (do {
my $M = $C;
$C->can_meta($M->{'infixish'}, "hyper with")
})
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
my $M = $C;
$M->{'O'} = $M->{'infixish'}->{'O'}})
}))) {
$C
} else { () }
});
}
;
## token infix_postfix_meta_operator:sym<=> ($op) {
sub infix_postfix_meta_operator__S_206Equal__PEEK { $_[0]->_AUTOLEXpeek('infix_postfix_meta_operator__S_206Equal', $retree) }
sub infix_postfix_meta_operator__S_206Equal {
no warnings 'recursion';
my $self = shift;

die 'Required argument op omitted' unless @_;
my $op = @_ ? shift() : undef;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix_postfix_meta_operator__S_206Equal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=";
$self->_MATCHIFYr($S, "infix_postfix_meta_operator__S_206Equal", do {
my $C = $C;
if (($C) = ($C->_EXACT("\="))
and ($C) = ($C->can_meta($op, "make assignment out of"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$op->{'O'}->{'diffy'} })
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Can't make assignment out of " . $op->{'sym'} . " because " . $op->{'O'}->{'dba'} . " operators are diffy"))) { ($C) } else { () }
}
};
@gather;
}
}))
and ($C) = (scalar(do {
my $M = $C;
$M->{'sym'} = $op->{'sym'} . '='}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%item_assignment, $op->Opairs, dba => 'item assignment', iffy => 0)
})
} else { () }
});
}
;
## token postcircumfix:sym<( )>
sub postcircumfix__S_207Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_207Paren_Thesis', $retree) }
sub postcircumfix__S_207Paren_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postcircumfix__S_207Paren_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\(\ \)";
$self->_MATCHIFYr($S, "postcircumfix__S_207Paren_Thesis", do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'argument list', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }
});
}
;
## token postcircumfix:sym<[ ]>
sub postcircumfix__S_208Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_208Bra_Ket', $retree) }
sub postcircumfix__S_208Bra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postcircumfix__S_208Bra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\[\ \]";
$self->_MATCHIFYr($S, "postcircumfix__S_208Bra_Ket", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'subscript', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$M->{'semilist'}->Str =~ /^\s*\-1\s*$/ and $C->obs("[-1] subscript to access final element","[*-1]") }, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }
});
}
;
## token postcircumfix:sym<{ }>
sub postcircumfix__S_209Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_209Cur_Ly', $retree) }
sub postcircumfix__S_209Cur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postcircumfix__S_209Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\ \}";
$self->_MATCHIFYr($S, "postcircumfix__S_209Cur_Ly", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\}";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\{"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\}")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'subscript', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = ($C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
}))
and ($C) = ($C->curlycheck)) {
$C
} else { () }
});
}
;
## token postcircumfix:sym«< >» {
sub postcircumfix__S_210Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_210Lt_Gt', $retree) }
sub postcircumfix__S_210Lt_Gt {
no warnings 'recursion';
my $self = shift;

my $pos;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postcircumfix__S_210Lt_Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\ \>";
$self->_MATCHIFYr($S, "postcircumfix__S_210Lt_Gt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\<"))
and ($C) = (scalar(do {
$pos = $C->{'_pos'} }, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('q' => 1)->tweak('w' => 1)->balanced('<','>'))
}))) {
$C->_EXACT("\>")
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'postcircumfix__S_210Lt_Gt_0') {
        $C->deb("Fate passed to postcircumfix__S_210Lt_Gt_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT postcircumfix__S_210Lt_Gt_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM postcircumfix__S_210Lt_Gt_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'postcircumfix__S_210Lt_Gt_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("postcircumfix__S_210Lt_Gt_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\d/)
},
sub {
my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
},
sub {
my $C=shift;
$C->_EXACT("\:")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))) {
scalar(do {
$C->cursor_force($pos)->panic("Whitespace required before < operator") }, $C)
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
$C->cursor_force($pos)->panic("Unable to parse quote-words subscript; couldn't find right angle quote") }, $C)
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }
});
}
;
## token postcircumfix:sym«<< >>»
sub postcircumfix__S_211LtLt_GtGt__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_211LtLt_GtGt', $retree) }
sub postcircumfix__S_211LtLt_GtGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postcircumfix__S_211LtLt_GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\<\ \>\>";
$self->_MATCHIFYr($S, "postcircumfix__S_211LtLt_GtGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\<\<"))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('<<','>>'))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\>\>")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unable to parse quote-words subscript; couldn't find right double-angle quote"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }
});
}
;
## token postcircumfix:sym<« »>
sub postcircumfix__S_212Fre_Nch__PEEK { $_[0]->_AUTOLEXpeek('postcircumfix__S_212Fre_Nch', $retree) }
sub postcircumfix__S_212Fre_Nch {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postcircumfix__S_212Fre_Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "«\ »";
$self->_MATCHIFYr($S, "postcircumfix__S_212Fre_Nch", do {
my $C = $C;
if (($C) = ($C->_EXACT("«"))
and ($C) = ($C->_SUBSUMEr(['nibble'], sub {
my $C = shift;
$C->nibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('qq' => 1)->tweak('ww' => 1)->balanced('«','»'))
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("»")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Unable to parse quote-words subscript; couldn't find right double-angle quote"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }
});
}
;
## token postop {
sub postop__PEEK { $_[0]->_AUTOLEXpeek('postop', $retree) }
sub postop {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "postop", do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'postop_0') {
        $C->deb("Fate passed to postop_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT postop_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM postop_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'postop_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("postop_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['postfix'], sub {
my $C = shift;
$C->postfix
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'postfix'}->{'O'};
$M->{'sym'} = $M->{'postfix'}->{'sym'};
}, $C)
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'postcircumfix'}->{'O'};
$M->{'sym'} = $M->{'postcircumfix'}->{'sym'};
}, $C)
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
});
}
;
## token methodop {
sub methodop__PEEK { $_[0]->_AUTOLEXpeek('methodop', $retree) }
sub methodop {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE methodop");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{'args'} = [];
$self->_MATCHIFYr($S, "methodop", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_0') {
        $C->deb("Fate passed to methodop_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT methodop_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM methodop_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'methodop_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("methodop_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_1') {
        $C->deb("Fate passed to methodop_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT methodop_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM methodop_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'methodop_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("methodop_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\$")
},
sub {
my $C=shift;
$C->_EXACT("\@")
},
sub {
my $C=shift;
$C->_EXACT("\&")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->variable
}))) {
scalar(do {
my $M = $C;
$::VAR = $M->{'variable'} }, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G['"]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL})
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
if (my ($C) = ($C->_EXACT("\""))) {
LazyMap::lazymap(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
$C->_STARf(sub {
my $C=shift;
$C->_PATTERN(qr/\G[^"]/)
}))
} else { () }
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
};
@gather;
}
}))
and ($C) = ($C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_2') {
        $C->deb("Fate passed to methodop_2: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT methodop_2';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM methodop_2'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'methodop_2', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("methodop_2 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\(")
},
sub {
my $C=shift;
$C->_EXACT("\.\(")
},
sub {
my $C=shift;
$C->_EXACT("\\")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->obs('. to concatenate strings or to call a quoted method', '~ to concatenate, or if you meant to call a quoted method, please supply the required parentheses'))) { ($C) } else { () }
}
};
@gather;
}
}))) {
scalar(do {
my $M = $C;
my $t = $M->{'quote'}->{'nibble'}->Str;
$t =~ /\W/ or $t =~ /^(WHO|WHAT|WHERE|WHEN|WHY|HOW)$/ or $C->worry("Useless use of quotes") ;
}, $C)
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_3') {
        $C->deb("Fate passed to methodop_3: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT methodop_3';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM methodop_3'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'methodop_3', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("methodop_3 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'methodop_4') {
        $C->deb("Fate passed to methodop_4: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT methodop_4';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM methodop_4'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'methodop_4', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("methodop_4 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\{")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL })
}))) {
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\\(]/)
}))) {
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
} else { () }
},
sub {
my $C=shift;
scalar(do {
$::MEMOS[$C->{'_pos'}]->{'baremeth'} = 1 }, $C)
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token semiarglist {
sub semiarglist__PEEK { $_[0]->_AUTOLEXpeek('semiarglist', $retree) }
sub semiarglist {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE semiarglist");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$self->_MATCHIFYr($S, "semiarglist", do {
my $C = $C;
if (($C) = ($C->_REPSEPr( sub {
my $C=shift;
$C->_EXACT("\;")
}, sub {
my $C=shift;
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))
and ($C) = ($C->ws)) {
$C
} else { () }
});
}
;
## token arglist {
sub arglist__PEEK { $_[0]->_AUTOLEXpeek('arglist', $retree) }
sub arglist {
no warnings 'recursion';
my $self = shift;

my $inv_ok = $::INVOCANT_OK;
local $::endargs = 0;
local $::GOAL = 'endargs';
local $::QSIGIL = '';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE arglist");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "arglist", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'arglist_0') {
        $C->deb("Fate passed to arglist_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT arglist_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM arglist_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'arglist_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("arglist_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->stdstopper)) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%list_prefix)
}))) {
scalar(do {
my $M = $C;
{
my $delims = $M->{'EXPR'}->{'delims'};
for (@$delims) {
if ($_->{'infix'}->{'wascolon'} // '') {
if ($inv_ok) {
$::INVOCANT_IS = $M->{'EXPR'}->{'list'}->[0]}}}
            ;
}}, $C)
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token term:lambda {
sub term__S_213lambda__PEEK { $_[0]->_AUTOLEXpeek('term__S_213lambda', $retree) }
sub term__S_213lambda {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_213lambda");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "lambda";
$self->_MATCHIFYr($S, "term__S_213lambda", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->lambda)) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))
and ($C) = (scalar(do {
my $M = $C;
{
if ($::BORG) {
$::BORG->{'block'} = $M->{'pblock'}}}}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }
});
}
;
## token circumfix:sym<{ }> {
sub circumfix__S_214Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('circumfix__S_214Cur_Ly', $retree) }
sub circumfix__S_214Cur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE circumfix__S_214Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\ \}";
$self->_MATCHIFYr($S, "circumfix__S_214Cur_Ly", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['pblock'], sub {
my $C = shift;
$C->pblock
}))
and ($C) = (scalar(do {
my $M = $C;
{
if ($::BORG) {
$::BORG->{'block'} = $M->{'pblock'}}}}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }
});
}
;
## token postfix:sym<i>
sub postfix__S_215i__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_215i', $retree) }
sub postfix__S_215i {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postfix__S_215i");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "i";
$self->_MATCHIFYr($S, "postfix__S_215i", do {
if (my ($C) = ($C->_PATTERN(qr/\Gi\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%methodcall)
})
} else { () }
});
}
;
## token infix:sym<.> ()
sub infix__S_216Dot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_216Dot', $retree) }
sub infix__S_216Dot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_216Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.";
$self->_MATCHIFYr($S, "infix__S_216Dot", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\.[\]\)\},:\s\$"']/))
and ($C) = ($C->obs('. to concatenate strings', '~'))) {
$C
} else { () }
});
}
;
## token postfix:sym['->'] () {
sub postfix__S_217MinusGt__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_217MinusGt', $retree) }
sub postfix__S_217MinusGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postfix__S_217MinusGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-\>";
$self->_MATCHIFYr($S, "postfix__S_217MinusGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\-\>"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'postfix__S_217MinusGt_0') {
        $C->deb("Fate passed to postfix__S_217MinusGt_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT postfix__S_217MinusGt_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM postfix__S_217MinusGt_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'postfix__S_217MinusGt_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("postfix__S_217MinusGt_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['brack'], sub {
my $C = shift;
$C->_PATTERN(qr/\G[\[\{\(]/)
}))
and ($C) = (do {
my $M = $C;
$C->obs("'->" . $M->{'brack'}->Str . "' as postfix dereferencer", "'." . $M->{'brack'}->Str . "' or just '" . $M->{'brack'}->Str . "' to deref, or whitespace to delimit a pointy block")
})) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->obs('-> as postfix', 'either . to call a method, or whitespace to delimit a pointy block'))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token postfix:sym<++>
sub postfix__S_218PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_218PlusPlus', $retree) }
sub postfix__S_218PlusPlus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postfix__S_218PlusPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\+";
$self->_MATCHIFYr($S, "postfix__S_218PlusPlus", do {
if (my ($C) = ($C->_EXACT("\+\+"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%autoincrement)
})
} else { () }
});
}
;
## token postfix:sym«--» ()
sub postfix__S_219MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('postfix__S_219MinusMinus', $retree) }
sub postfix__S_219MinusMinus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE postfix__S_219MinusMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-\-";
$self->_MATCHIFYr($S, "postfix__S_219MinusMinus", do {
if (my ($C) = ($C->_EXACT("\-\-"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%autoincrement)
})
} else { () }
});
}
;
## token prefix:sym<++>
sub prefix__S_220PlusPlus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_220PlusPlus', $retree) }
sub prefix__S_220PlusPlus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_220PlusPlus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\+";
$self->_MATCHIFYr($S, "prefix__S_220PlusPlus", do {
if (my ($C) = ($C->_EXACT("\+\+"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%autoincrement)
})
} else { () }
});
}
;
## token prefix:sym«--» ()
sub prefix__S_221MinusMinus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_221MinusMinus', $retree) }
sub prefix__S_221MinusMinus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_221MinusMinus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-\-";
$self->_MATCHIFYr($S, "prefix__S_221MinusMinus", do {
if (my ($C) = ($C->_EXACT("\-\-"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%autoincrement)
})
} else { () }
});
}
;
## token infix:sym<**>
sub infix__S_222StarStar__PEEK { $_[0]->_AUTOLEXpeek('infix__S_222StarStar', $retree) }
sub infix__S_222StarStar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_222StarStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*\*";
$self->_MATCHIFYr($S, "infix__S_222StarStar", do {
if (my ($C) = ($C->_EXACT("\*\*"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%exponentiation)
})
} else { () }
});
}
;
## token prefix:sym<!>
sub prefix__S_223Bang__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_223Bang', $retree) }
sub prefix__S_223Bang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_223Bang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!";
$self->_MATCHIFYr($S, "prefix__S_223Bang", do {
if (my ($C) = ($C->_EXACT("\!"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }
});
}
;
## token prefix:sym<+>
sub prefix__S_224Plus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_224Plus', $retree) }
sub prefix__S_224Plus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_224Plus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+";
$self->_MATCHIFYr($S, "prefix__S_224Plus", do {
if (my ($C) = ($C->_EXACT("\+"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }
});
}
;
## token prefix:sym<->
sub prefix__S_225Minus__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_225Minus', $retree) }
sub prefix__S_225Minus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_225Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-";
$self->_MATCHIFYr($S, "prefix__S_225Minus", do {
if (my ($C) = ($C->_EXACT("\-"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }
});
}
;
## token prefix:sym<~~>
sub prefix__S_226TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_226TildeTilde', $retree) }
sub prefix__S_226TildeTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_226TildeTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\~";
$self->_MATCHIFYr($S, "prefix__S_226TildeTilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~\~"))
and ($C) = ($C->badinfix)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }
});
}
;
## token prefix:sym<~>
sub prefix__S_227Tilde__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_227Tilde', $retree) }
sub prefix__S_227Tilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_227Tilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~";
$self->_MATCHIFYr($S, "prefix__S_227Tilde", do {
if (my ($C) = ($C->_EXACT("\~"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }
});
}
;
## token prefix:sym<??>
sub prefix__S_228QuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_228QuestionQuestion', $retree) }
sub prefix__S_228QuestionQuestion {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_228QuestionQuestion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\?";
$self->_MATCHIFYr($S, "prefix__S_228QuestionQuestion", do {
my $C = $C;
if (($C) = ($C->_EXACT("\?\?"))
and ($C) = ($C->badinfix)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }
});
}
;
## token prefix:sym<?>
sub prefix__S_229Question__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_229Question', $retree) }
sub prefix__S_229Question {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_229Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?";
$self->_MATCHIFYr($S, "prefix__S_229Question", do {
if (my ($C) = ($C->_EXACT("\?"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }
});
}
;
## token prefix:sym<~^>
sub prefix__S_230TildeCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_230TildeCaret', $retree) }
sub prefix__S_230TildeCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_230TildeCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\^";
$self->_MATCHIFYr($S, "prefix__S_230TildeCaret", do {
if (my ($C) = ($C->_EXACT("\~\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }
});
}
;
## token prefix:sym<+^>
sub prefix__S_231PlusCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_231PlusCaret', $retree) }
sub prefix__S_231PlusCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_231PlusCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\^";
$self->_MATCHIFYr($S, "prefix__S_231PlusCaret", do {
if (my ($C) = ($C->_EXACT("\+\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }
});
}
;
## token prefix:sym<?^>
sub prefix__S_232QuestionCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_232QuestionCaret', $retree) }
sub prefix__S_232QuestionCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_232QuestionCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\^";
$self->_MATCHIFYr($S, "prefix__S_232QuestionCaret", do {
if (my ($C) = ($C->_EXACT("\?\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }
});
}
;
## token prefix:sym<^^>
sub prefix__S_233CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_233CaretCaret', $retree) }
sub prefix__S_233CaretCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_233CaretCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^\^";
$self->_MATCHIFYr($S, "prefix__S_233CaretCaret", do {
my $C = $C;
if (($C) = ($C->_EXACT("\^\^"))
and ($C) = ($C->badinfix)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }
});
}
;
## token prefix:sym<^>
sub prefix__S_234Caret__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_234Caret', $retree) }
sub prefix__S_234Caret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_234Caret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^";
$self->_MATCHIFYr($S, "prefix__S_234Caret", do {
if (my ($C) = ($C->_EXACT("\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }
});
}
;
## token prefix:sym<||>
sub prefix__S_235VertVert__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_235VertVert', $retree) }
sub prefix__S_235VertVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_235VertVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|\|";
$self->_MATCHIFYr($S, "prefix__S_235VertVert", do {
if (my ($C) = ($C->_EXACT("\|\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }
});
}
;
## token prefix:sym<|>
sub prefix__S_236Vert__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_236Vert', $retree) }
sub prefix__S_236Vert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_236Vert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|";
$self->_MATCHIFYr($S, "prefix__S_236Vert", do {
if (my ($C) = ($C->_EXACT("\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%symbolic_unary)
})
} else { () }
});
}
;
## token infix:sym<*>
sub infix__S_237Star__PEEK { $_[0]->_AUTOLEXpeek('infix__S_237Star', $retree) }
sub infix__S_237Star {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_237Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*";
$self->_MATCHIFYr($S, "infix__S_237Star", do {
if (my ($C) = ($C->_EXACT("\*"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }
});
}
;
## token infix:sym</>
sub infix__S_238Slash__PEEK { $_[0]->_AUTOLEXpeek('infix__S_238Slash', $retree) }
sub infix__S_238Slash {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_238Slash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\/";
$self->_MATCHIFYr($S, "infix__S_238Slash", do {
if (my ($C) = ($C->_EXACT("\/"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }
});
}
;
## token infix:sym<div>
sub infix__S_239div__PEEK { $_[0]->_AUTOLEXpeek('infix__S_239div', $retree) }
sub infix__S_239div {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_239div");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "div";
$self->_MATCHIFYr($S, "infix__S_239div", do {
if (my ($C) = ($C->_EXACT("div"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }
});
}
;
## token infix:sym<%>
sub infix__S_240Percent__PEEK { $_[0]->_AUTOLEXpeek('infix__S_240Percent', $retree) }
sub infix__S_240Percent {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_240Percent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%";
$self->_MATCHIFYr($S, "infix__S_240Percent", do {
if (my ($C) = ($C->_EXACT("\%"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative, iffy => 1)
})
} else { () }
});
}
;
## token infix:sym<mod>
sub infix__S_241mod__PEEK { $_[0]->_AUTOLEXpeek('infix__S_241mod', $retree) }
sub infix__S_241mod {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_241mod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "mod";
$self->_MATCHIFYr($S, "infix__S_241mod", do {
if (my ($C) = ($C->_EXACT("mod"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }
});
}
;
## token infix:sym<+&>
sub infix__S_242PlusAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_242PlusAmp', $retree) }
sub infix__S_242PlusAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_242PlusAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\&";
$self->_MATCHIFYr($S, "infix__S_242PlusAmp", do {
if (my ($C) = ($C->_EXACT("\+\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }
});
}
;
## token infix:sym« << »
sub infix__S_243LtLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_243LtLt', $retree) }
sub infix__S_243LtLt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_243LtLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\<";
$self->_MATCHIFYr($S, "infix__S_243LtLt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\<\<"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META eq 'HYPER' })
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorryobs('<< to do left shift', '+< or ~<'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }
});
}
;
## token infix:sym« >> »
sub infix__S_244GtGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_244GtGt', $retree) }
sub infix__S_244GtGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_244GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\>\>";
$self->_MATCHIFYr($S, "infix__S_244GtGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\>\>"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META eq 'HYPER' })
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->sorryobs('>> to do right shift', '+> or ~>'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }
});
}
;
## token infix:sym<~&>
sub infix__S_245TildeAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_245TildeAmp', $retree) }
sub infix__S_245TildeAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_245TildeAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\&";
$self->_MATCHIFYr($S, "infix__S_245TildeAmp", do {
if (my ($C) = ($C->_EXACT("\~\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }
});
}
;
## token infix:sym<?&>
sub infix__S_246QuestionAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_246QuestionAmp', $retree) }
sub infix__S_246QuestionAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_246QuestionAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\&";
$self->_MATCHIFYr($S, "infix__S_246QuestionAmp", do {
if (my ($C) = ($C->_EXACT("\?\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative, iffy => 1)
})
} else { () }
});
}
;
## token infix:sym« ~< »
sub infix__S_247TildeLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_247TildeLt', $retree) }
sub infix__S_247TildeLt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_247TildeLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\<";
$self->_MATCHIFYr($S, "infix__S_247TildeLt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~\<"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<\<")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }
});
}
;
## token infix:sym« ~> »
sub infix__S_248TildeGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_248TildeGt', $retree) }
sub infix__S_248TildeGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_248TildeGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\>";
$self->_MATCHIFYr($S, "infix__S_248TildeGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~\>"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }
});
}
;
## token infix:sym« +< »
sub infix__S_249PlusLt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_249PlusLt', $retree) }
sub infix__S_249PlusLt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_249PlusLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\<";
$self->_MATCHIFYr($S, "infix__S_249PlusLt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\+\<"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<\<")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\<")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }
});
}
;
## token infix:sym« +> »
sub infix__S_250PlusGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_250PlusGt', $retree) }
sub infix__S_250PlusGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_250PlusGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\>";
$self->_MATCHIFYr($S, "infix__S_250PlusGt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\+\>"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%multiplicative)
})
} else { () }
});
}
;
## token infix:sym<+>
sub infix__S_251Plus__PEEK { $_[0]->_AUTOLEXpeek('infix__S_251Plus', $retree) }
sub infix__S_251Plus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_251Plus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+";
$self->_MATCHIFYr($S, "infix__S_251Plus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\+"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\+")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }
});
}
;
## token infix:sym<->
sub infix__S_252Minus__PEEK { $_[0]->_AUTOLEXpeek('infix__S_252Minus', $retree) }
sub infix__S_252Minus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_252Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-";
$self->_MATCHIFYr($S, "infix__S_252Minus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\-"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\-")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }
});
}
;
## token infix:sym<+|>
sub infix__S_253PlusVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_253PlusVert', $retree) }
sub infix__S_253PlusVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_253PlusVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\|";
$self->_MATCHIFYr($S, "infix__S_253PlusVert", do {
if (my ($C) = ($C->_EXACT("\+\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }
});
}
;
## token infix:sym<+^>
sub infix__S_254PlusCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_254PlusCaret', $retree) }
sub infix__S_254PlusCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_254PlusCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+\^";
$self->_MATCHIFYr($S, "infix__S_254PlusCaret", do {
if (my ($C) = ($C->_EXACT("\+\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }
});
}
;
## token infix:sym<~|>
sub infix__S_255TildeVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_255TildeVert', $retree) }
sub infix__S_255TildeVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_255TildeVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\|";
$self->_MATCHIFYr($S, "infix__S_255TildeVert", do {
if (my ($C) = ($C->_EXACT("\~\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }
});
}
;
## token infix:sym<~^>
sub infix__S_256TildeCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_256TildeCaret', $retree) }
sub infix__S_256TildeCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_256TildeCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\^";
$self->_MATCHIFYr($S, "infix__S_256TildeCaret", do {
if (my ($C) = ($C->_EXACT("\~\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }
});
}
;
## token infix:sym<?|>
sub infix__S_257QuestionVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_257QuestionVert', $retree) }
sub infix__S_257QuestionVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_257QuestionVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\|";
$self->_MATCHIFYr($S, "infix__S_257QuestionVert", do {
if (my ($C) = ($C->_EXACT("\?\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive, iffy => 1)
})
} else { () }
});
}
;
## token infix:sym<?^>
sub infix__S_258QuestionCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_258QuestionCaret', $retree) }
sub infix__S_258QuestionCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_258QuestionCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\^";
$self->_MATCHIFYr($S, "infix__S_258QuestionCaret", do {
if (my ($C) = ($C->_EXACT("\?\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }
});
}
;
## token infix:sym<x>
sub infix__S_259x__PEEK { $_[0]->_AUTOLEXpeek('infix__S_259x', $retree) }
sub infix__S_259x {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_259x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "x";
$self->_MATCHIFYr($S, "infix__S_259x", do {
if (my ($C) = ($C->_EXACT("x"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%replication)
})
} else { () }
});
}
;
## token infix:sym<xx>
sub infix__S_260xx__PEEK { $_[0]->_AUTOLEXpeek('infix__S_260xx', $retree) }
sub infix__S_260xx {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_260xx");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "xx";
$self->_MATCHIFYr($S, "infix__S_260xx", do {
if (my ($C) = ($C->_EXACT("xx"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%replication)
})
} else { () }
});
}
;
## token infix:sym<~>
sub infix__S_261Tilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_261Tilde', $retree) }
sub infix__S_261Tilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_261Tilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~";
$self->_MATCHIFYr($S, "infix__S_261Tilde", do {
if (my ($C) = ($C->_EXACT("\~"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%concatenation)
})
} else { () }
});
}
;
## token infix:sym<&>
sub infix__S_262Amp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_262Amp', $retree) }
sub infix__S_262Amp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_262Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&";
$self->_MATCHIFYr($S, "infix__S_262Amp", do {
if (my ($C) = ($C->_EXACT("\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_and, iffy => 1)
})
} else { () }
});
}
;
## token infix:sym<|>
sub infix__S_263Vert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_263Vert', $retree) }
sub infix__S_263Vert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_263Vert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|";
$self->_MATCHIFYr($S, "infix__S_263Vert", do {
if (my ($C) = ($C->_EXACT("\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_or, iffy => 1)
})
} else { () }
});
}
;
## token infix:sym<^>
sub infix__S_264Caret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_264Caret', $retree) }
sub infix__S_264Caret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_264Caret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^";
$self->_MATCHIFYr($S, "infix__S_264Caret", do {
if (my ($C) = ($C->_EXACT("\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_or, iffy => 1)
})
} else { () }
});
}
;
## token prefix:sleep
sub prefix__S_265sleep__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_265sleep', $retree) }
sub prefix__S_265sleep {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_265sleep");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sleep";
$self->_MATCHIFYr($S, "prefix__S_265sleep", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gsleep\b/))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s*+/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%named_unary)
})
} else { () }
});
}
;
## token prefix:abs
sub prefix__S_266abs__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_266abs', $retree) }
sub prefix__S_266abs {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_266abs");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "abs";
$self->_MATCHIFYr($S, "prefix__S_266abs", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gabs\b/))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s*+/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%named_unary)
})
} else { () }
});
}
;
## token prefix:let
sub prefix__S_267let__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_267let', $retree) }
sub prefix__S_267let {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_267let");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "let";
$self->_MATCHIFYr($S, "prefix__S_267let", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Glet\b/))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s*+/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%named_unary)
})
} else { () }
});
}
;
## token prefix:temp
sub prefix__S_268temp__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_268temp', $retree) }
sub prefix__S_268temp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_268temp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "temp";
$self->_MATCHIFYr($S, "prefix__S_268temp", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gtemp\b/))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s*+/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%named_unary)
})
} else { () }
});
}
;
## token infix:sym« <=> »
sub infix__S_269LtEqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_269LtEqualGt', $retree) }
sub infix__S_269LtEqualGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_269LtEqualGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\=\>";
$self->_MATCHIFYr($S, "infix__S_269LtEqualGt", do {
if (my ($C) = ($C->_EXACT("\<\=\>"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural, returns => 'Order')
})
} else { () }
});
}
;
## token infix:cmp
sub infix__S_270cmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_270cmp', $retree) }
sub infix__S_270cmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_270cmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "cmp";
$self->_MATCHIFYr($S, "infix__S_270cmp", do {
if (my ($C) = ($C->_EXACT("cmp"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural, returns => 'Order')
})
} else { () }
});
}
;
## token infix:leg
sub infix__S_271leg__PEEK { $_[0]->_AUTOLEXpeek('infix__S_271leg', $retree) }
sub infix__S_271leg {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_271leg");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "leg";
$self->_MATCHIFYr($S, "infix__S_271leg", do {
if (my ($C) = ($C->_EXACT("leg"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural, returns => 'Order')
})
} else { () }
});
}
;
## token infix:but
sub infix__S_272but__PEEK { $_[0]->_AUTOLEXpeek('infix__S_272but', $retree) }
sub infix__S_272but {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_272but");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "but";
$self->_MATCHIFYr($S, "infix__S_272but", do {
if (my ($C) = ($C->_EXACT("but"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
})
} else { () }
});
}
;
## token infix:does
sub infix__S_273does__PEEK { $_[0]->_AUTOLEXpeek('infix__S_273does', $retree) }
sub infix__S_273does {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_273does");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "does";
$self->_MATCHIFYr($S, "infix__S_273does", do {
if (my ($C) = ($C->_EXACT("does"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
})
} else { () }
});
}
;
## token infix:sym<..>
sub infix__S_274DotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_274DotDot', $retree) }
sub infix__S_274DotDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_274DotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\.";
$self->_MATCHIFYr($S, "infix__S_274DotDot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\.\."))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::IN_META })
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_274DotDot_0') {
        $C->deb("Fate passed to infix__S_274DotDot_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT infix__S_274DotDot_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM infix__S_274DotDot_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'infix__S_274DotDot_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("infix__S_274DotDot_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\)")
},
sub {
my $C=shift;
$C->_EXACT("\]")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Please use ..* for indefinite range"))) {
$C
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
})
} else { () }
});
}
;
## token infix:sym<^..>
sub infix__S_275CaretDotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_275CaretDotDot', $retree) }
sub infix__S_275CaretDotDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_275CaretDotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^\.\.";
$self->_MATCHIFYr($S, "infix__S_275CaretDotDot", do {
if (my ($C) = ($C->_EXACT("\^\.\."))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
})
} else { () }
});
}
;
## token infix:sym<..^>
sub infix__S_276DotDotCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_276DotDotCaret', $retree) }
sub infix__S_276DotDotCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_276DotDotCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\.\^";
$self->_MATCHIFYr($S, "infix__S_276DotDotCaret", do {
if (my ($C) = ($C->_EXACT("\.\.\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
})
} else { () }
});
}
;
## token infix:sym<^..^>
sub infix__S_277CaretDotDotCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_277CaretDotDotCaret', $retree) }
sub infix__S_277CaretDotDotCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_277CaretDotDotCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^\.\.\^";
$self->_MATCHIFYr($S, "infix__S_277CaretDotDotCaret", do {
if (my ($C) = ($C->_EXACT("\^\.\.\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%structural)
})
} else { () }
});
}
;
## token infix:sym<==>
sub infix__S_278EqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_278EqualEqual', $retree) }
sub infix__S_278EqualEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_278EqualEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\=";
$self->_MATCHIFYr($S, "infix__S_278EqualEqual", do {
my $C = $C;
if (($C) = ($C->_EXACT("\=\="))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\=")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym<!=>
sub infix__S_279BangEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_279BangEqual', $retree) }
sub infix__S_279BangEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_279BangEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!\=";
$self->_MATCHIFYr($S, "infix__S_279BangEqual", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!\="))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym« < »
sub infix__S_280Lt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_280Lt', $retree) }
sub infix__S_280Lt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_280Lt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<";
$self->_MATCHIFYr($S, "infix__S_280Lt", do {
if (my ($C) = ($C->_EXACT("\<"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym« <= »
sub infix__S_281LtEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_281LtEqual', $retree) }
sub infix__S_281LtEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_281LtEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\=";
$self->_MATCHIFYr($S, "infix__S_281LtEqual", do {
if (my ($C) = ($C->_EXACT("\<\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym« > »
sub infix__S_282Gt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_282Gt', $retree) }
sub infix__S_282Gt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_282Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\>";
$self->_MATCHIFYr($S, "infix__S_282Gt", do {
if (my ($C) = ($C->_EXACT("\>"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym« >= »
sub infix__S_283GtEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_283GtEqual', $retree) }
sub infix__S_283GtEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_283GtEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\>\=";
$self->_MATCHIFYr($S, "infix__S_283GtEqual", do {
if (my ($C) = ($C->_EXACT("\>\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym<~~>
sub infix__S_284TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_284TildeTilde', $retree) }
sub infix__S_284TildeTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_284TildeTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\~";
$self->_MATCHIFYr($S, "infix__S_284TildeTilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~\~"))
and ($C) = ($C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'0'} = [];
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G[\x20\t\r]*+/))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_284TildeTilde_0') {
        $C->deb("Fate passed to infix__S_284TildeTilde_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT infix__S_284TildeTilde_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM infix__S_284TildeTilde_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'infix__S_284TildeTilde_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("infix__S_284TildeTilde_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("True")
},
sub {
my $C=shift;
$C->_EXACT("False")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }

})
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))
and ($C) = (do {
my $M = $C;
$C->dumbsmart($M->{0}->[0]->Str)
})) {
$C
} else { () }
};
}))) { ($C) } else { () }
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## method dumbsmart ($litbool)
sub dumbsmart {
no warnings 'recursion';
my $self = shift;
die 'Required argument litbool omitted' unless @_;
my $litbool = @_ ? shift() : undef;
$self->worry("Smartmatch against $litbool always " .
            ($litbool eq 'True' ? 'matches' : 'fails') .
            "; if you mean to test the topic for\n    truthiness, please use " .
            ($litbool eq 'True' ? ':so or *.so or ?*' : ':!so or *.not or !*') .
            ' instead');
$self;
};
## token infix:sym<!~>
sub infix__S_285BangTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_285BangTilde', $retree) }
sub infix__S_285BangTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_285BangTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!\~";
$self->_MATCHIFYr($S, "infix__S_285BangTilde", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\!\~\s/))
and ($C) = ($C->obs('!~ to do negated pattern matching', '!~~'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym<=~>
sub infix__S_286EqualTilde__PEEK { $_[0]->_AUTOLEXpeek('infix__S_286EqualTilde', $retree) }
sub infix__S_286EqualTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_286EqualTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\~";
$self->_MATCHIFYr($S, "infix__S_286EqualTilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\=\~"))
and ($C) = ($C->obs('=~ to do pattern matching', '~~'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym<eq>
sub infix__S_287eq__PEEK { $_[0]->_AUTOLEXpeek('infix__S_287eq', $retree) }
sub infix__S_287eq {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_287eq");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "eq";
$self->_MATCHIFYr($S, "infix__S_287eq", do {
if (my ($C) = ($C->_EXACT("eq"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym<ne>
sub infix__S_288ne__PEEK { $_[0]->_AUTOLEXpeek('infix__S_288ne', $retree) }
sub infix__S_288ne {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_288ne");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ne";
$self->_MATCHIFYr($S, "infix__S_288ne", do {
if (my ($C) = ($C->_EXACT("ne"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym<lt>
sub infix__S_289lt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_289lt', $retree) }
sub infix__S_289lt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_289lt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "lt";
$self->_MATCHIFYr($S, "infix__S_289lt", do {
if (my ($C) = ($C->_EXACT("lt"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym<le>
sub infix__S_290le__PEEK { $_[0]->_AUTOLEXpeek('infix__S_290le', $retree) }
sub infix__S_290le {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_290le");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "le";
$self->_MATCHIFYr($S, "infix__S_290le", do {
if (my ($C) = ($C->_EXACT("le"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym<gt>
sub infix__S_291gt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_291gt', $retree) }
sub infix__S_291gt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_291gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "gt";
$self->_MATCHIFYr($S, "infix__S_291gt", do {
if (my ($C) = ($C->_EXACT("gt"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym<ge>
sub infix__S_292ge__PEEK { $_[0]->_AUTOLEXpeek('infix__S_292ge', $retree) }
sub infix__S_292ge {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_292ge");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ge";
$self->_MATCHIFYr($S, "infix__S_292ge", do {
if (my ($C) = ($C->_EXACT("ge"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym<=:=>
sub infix__S_293EqualColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_293EqualColonEqual', $retree) }
sub infix__S_293EqualColonEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_293EqualColonEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\:\=";
$self->_MATCHIFYr($S, "infix__S_293EqualColonEqual", do {
if (my ($C) = ($C->_EXACT("\=\:\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym<===>
sub infix__S_294EqualEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_294EqualEqualEqual', $retree) }
sub infix__S_294EqualEqualEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_294EqualEqualEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\=\=";
$self->_MATCHIFYr($S, "infix__S_294EqualEqualEqual", do {
if (my ($C) = ($C->_EXACT("\=\=\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym<eqv>
sub infix__S_295eqv__PEEK { $_[0]->_AUTOLEXpeek('infix__S_295eqv', $retree) }
sub infix__S_295eqv {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_295eqv");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "eqv";
$self->_MATCHIFYr($S, "infix__S_295eqv", do {
if (my ($C) = ($C->_EXACT("eqv"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym<before>
sub infix__S_296before__PEEK { $_[0]->_AUTOLEXpeek('infix__S_296before', $retree) }
sub infix__S_296before {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_296before");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "before";
$self->_MATCHIFYr($S, "infix__S_296before", do {
if (my ($C) = ($C->_EXACT("before"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym<after>
sub infix__S_297after__PEEK { $_[0]->_AUTOLEXpeek('infix__S_297after', $retree) }
sub infix__S_297after {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_297after");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "after";
$self->_MATCHIFYr($S, "infix__S_297after", do {
if (my ($C) = ($C->_EXACT("after"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%chaining)
})
} else { () }
});
}
;
## token infix:sym<&&>
sub infix__S_298AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('infix__S_298AmpAmp', $retree) }
sub infix__S_298AmpAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_298AmpAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&\&";
$self->_MATCHIFYr($S, "infix__S_298AmpAmp", do {
if (my ($C) = ($C->_EXACT("\&\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_and, iffy => 1)
})
} else { () }
});
}
;
## token infix:sym<||>
sub infix__S_299VertVert__PEEK { $_[0]->_AUTOLEXpeek('infix__S_299VertVert', $retree) }
sub infix__S_299VertVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_299VertVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|\|";
$self->_MATCHIFYr($S, "infix__S_299VertVert", do {
if (my ($C) = ($C->_EXACT("\|\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or, iffy => 1)
})
} else { () }
});
}
;
## token infix:sym<^^>
sub infix__S_300CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_300CaretCaret', $retree) }
sub infix__S_300CaretCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_300CaretCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^\^";
$self->_MATCHIFYr($S, "infix__S_300CaretCaret", do {
if (my ($C) = ($C->_EXACT("\^\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or, iffy => 1)
})
} else { () }
});
}
;
## token infix:sym<//>
sub infix__S_301SlashSlash__PEEK { $_[0]->_AUTOLEXpeek('infix__S_301SlashSlash', $retree) }
sub infix__S_301SlashSlash {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_301SlashSlash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\/\/";
$self->_MATCHIFYr($S, "infix__S_301SlashSlash", do {
if (my ($C) = ($C->_EXACT("\/\/"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or)
})
} else { () }
});
}
;
## token infix:sym<min>
sub infix__S_302min__PEEK { $_[0]->_AUTOLEXpeek('infix__S_302min', $retree) }
sub infix__S_302min {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_302min");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "min";
$self->_MATCHIFYr($S, "infix__S_302min", do {
if (my ($C) = ($C->_EXACT("min"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or)
})
} else { () }
});
}
;
## token infix:sym<max>
sub infix__S_303max__PEEK { $_[0]->_AUTOLEXpeek('infix__S_303max', $retree) }
sub infix__S_303max {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_303max");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "max";
$self->_MATCHIFYr($S, "infix__S_303max", do {
if (my ($C) = ($C->_EXACT("max"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or)
})
} else { () }
});
}
;
## token infix:sym<?? !!> {
sub infix__S_304QuestionQuestion_BangBang__PEEK { $_[0]->_AUTOLEXpeek('infix__S_304QuestionQuestion_BangBang', $retree) }
sub infix__S_304QuestionQuestion_BangBang {
no warnings 'recursion';
my $self = shift;

local $::GOAL = '!!';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_304QuestionQuestion_BangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\?\ \!\!";
$self->_MATCHIFYr($S, "infix__S_304QuestionQuestion_BangBang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\?\?"))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%item_assignment)
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\!\!")
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\:\:[^=]/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Please use !! rather than ::"))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
}))) {
scalar(do {
my $M = $C;
{
my $b = $M->{'infixish'}->Str;
if ($b eq ':') {
$C->panic("Please use !! rather than $b")}
else {
$C->panic("Precedence of $b is too loose to use between ?? and !!; please use parens around inner expression")};
}}, $C)
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\n"))) {
$C->_STARf(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})
} else { () }
}))) { ($C) } else { () }
})
},
$C->_STARf(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_EXACT("\!\!"))
and ($C) = ($C->sorry("Bogus code found before the !!"))
and ($C) = ($C->panic("Confused"))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->sorry("Found ?? but no !!"))
and ($C) = ($C->panic("Confused"))) {
$C
} else { () }
}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional, _reducecheck => 'raise_middle')
})
} else { () }
});
}
;
## token infix:sym<!!> {
sub infix__S_305BangBang__PEEK { $_[0]->_AUTOLEXpeek('infix__S_305BangBang', $retree) }
sub infix__S_305BangBang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_305BangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!\!";
$self->_MATCHIFYr($S, "infix__S_305BangBang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!\!"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->suppose(sub {
my $C=shift;
$C->_SUBSUMEr(['infixish'], sub {
my $C = shift;
$C->infixish
})
}))
and ($C) = ($C->panic("An infix may not start with !!"))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Ternary !! seems to be missing its ??"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## method raise_middle
sub raise_middle {
no warnings 'recursion';
my $self = shift;
$self->{'middle'} = $self->{'infix'}->{'EXPR'};
$self;
};
## token infix:sym<?>
sub infix__S_306Question__PEEK { $_[0]->_AUTOLEXpeek('infix__S_306Question', $retree) }
sub infix__S_306Question {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_306Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?";
$self->_MATCHIFYr($S, "infix__S_306Question", do {
my $C = $C;
if (($C) = ($C->_EXACT("\?"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\?")
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
$C->_EXACT("\:")
},
$C->_STARf(sub {
my $C=shift;
$C->_PATTERN(qr/\G[^;]/)
})))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->obs('?: for the conditional operator', '??!!'))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }
});
}
;
## token infix:sym<ff>
sub infix__S_307ff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_307ff', $retree) }
sub infix__S_307ff {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_307ff");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ff";
$self->_MATCHIFYr($S, "infix__S_307ff", do {
if (my ($C) = ($C->_EXACT("ff"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }
});
}
;
## token infix:sym<^ff>
sub infix__S_308Caretff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_308Caretff', $retree) }
sub infix__S_308Caretff {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_308Caretff");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^ff";
$self->_MATCHIFYr($S, "infix__S_308Caretff", do {
if (my ($C) = ($C->_EXACT("\^ff"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }
});
}
;
## token infix:sym<ff^>
sub infix__S_309ffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_309ffCaret', $retree) }
sub infix__S_309ffCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_309ffCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ff\^";
$self->_MATCHIFYr($S, "infix__S_309ffCaret", do {
if (my ($C) = ($C->_EXACT("ff\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }
});
}
;
## token infix:sym<^ff^>
sub infix__S_310CaretffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_310CaretffCaret', $retree) }
sub infix__S_310CaretffCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_310CaretffCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^ff\^";
$self->_MATCHIFYr($S, "infix__S_310CaretffCaret", do {
if (my ($C) = ($C->_EXACT("\^ff\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }
});
}
;
## token infix:sym<fff>
sub infix__S_311fff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_311fff', $retree) }
sub infix__S_311fff {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_311fff");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "fff";
$self->_MATCHIFYr($S, "infix__S_311fff", do {
if (my ($C) = ($C->_EXACT("fff"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }
});
}
;
## token infix:sym<^fff>
sub infix__S_312Caretfff__PEEK { $_[0]->_AUTOLEXpeek('infix__S_312Caretfff', $retree) }
sub infix__S_312Caretfff {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_312Caretfff");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^fff";
$self->_MATCHIFYr($S, "infix__S_312Caretfff", do {
if (my ($C) = ($C->_EXACT("\^fff"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }
});
}
;
## token infix:sym<fff^>
sub infix__S_313fffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_313fffCaret', $retree) }
sub infix__S_313fffCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_313fffCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "fff\^";
$self->_MATCHIFYr($S, "infix__S_313fffCaret", do {
if (my ($C) = ($C->_EXACT("fff\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }
});
}
;
## token infix:sym<^fff^>
sub infix__S_314CaretfffCaret__PEEK { $_[0]->_AUTOLEXpeek('infix__S_314CaretfffCaret', $retree) }
sub infix__S_314CaretfffCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_314CaretfffCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^fff\^";
$self->_MATCHIFYr($S, "infix__S_314CaretfffCaret", do {
if (my ($C) = ($C->_EXACT("\^fff\^"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%conditional)
})
} else { () }
});
}
;
## token infix:sym<=> ()
sub infix__S_315Equal__PEEK { $_[0]->_AUTOLEXpeek('infix__S_315Equal', $retree) }
sub infix__S_315Equal {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_315Equal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=";
$self->_MATCHIFYr($S, "infix__S_315Equal", do {
my $C = $C;
if (($C) = ($C->_EXACT("\="))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::LEFTSIGIL eq '$' })
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%item_assignment)
})
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, $C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_assignment)
})
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## token infix:sym<:=>
sub infix__S_316ColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_316ColonEqual', $retree) }
sub infix__S_316ColonEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_316ColonEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\=";
$self->_MATCHIFYr($S, "infix__S_316ColonEqual", do {
if (my ($C) = ($C->_EXACT("\:\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%item_assignment)
})
} else { () }
});
}
;
## token infix:sym<::=>
sub infix__S_317ColonColonEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_317ColonColonEqual', $retree) }
sub infix__S_317ColonColonEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_317ColonColonEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\:\=";
$self->_MATCHIFYr($S, "infix__S_317ColonColonEqual", do {
if (my ($C) = ($C->_EXACT("\:\:\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%item_assignment)
})
} else { () }
});
}
;
## token infix:sym<.=> {
sub infix__S_318DotEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_318DotEqual', $retree) }
sub infix__S_318DotEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_318DotEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\=";
$self->_MATCHIFYr($S, "infix__S_318DotEqual", do {
if (my ($C) = ($C->_EXACT("\.\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%item_assignment,
            nextterm => 'dottyopish',
            _reducecheck => 'check_doteq'
        )
})
} else { () }
});
}
;
## method check_doteq
sub check_doteq {
no warnings 'recursion';
my $self = shift;
return $self if $self->{'left'}->{'scope_declarator'};
my $ok = 0;
eval {
my $methop = $self->{'right'}->{'methodop'};
my $name = $methop->{'longname'}->Str;
if ($name eq 'new' or $name eq 'sort' or $name eq 'subst' or $name eq 'trans' or $name eq 'reverse' or $name eq 'uniq' or $name eq 'map' or $name eq 'samecase' or $name eq 'substr' or $name eq 'flip' or $name eq 'fmt' or $name eq 'pick') {
$ok = 1}
elsif (not $methop->{'args'}->[0]) {
$ok = 1};
};
$self->cursor_force($self->{'infix'}->{'_pos'})->worryobs('.= as append operator', '~=') unless $ok;
$self;
};
## token infix:sym« => »
sub infix__S_319EqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_319EqualGt', $retree) }
sub infix__S_319EqualGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_319EqualGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\>";
$self->_MATCHIFYr($S, "infix__S_319EqualGt", do {
if (my ($C) = ($C->_EXACT("\=\>"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%item_assignment, fiddly => 0)
})
} else { () }
});
}
;
## token prefix:sym<so>
sub prefix__S_320so__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_320so', $retree) }
sub prefix__S_320so {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_320so");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "so";
$self->_MATCHIFYr($S, "prefix__S_320so", do {
if (my ($C) = ($C->_PATTERN(qr/\Gso\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_unary)
})
} else { () }
});
}
;
## token prefix:sym<not>
sub prefix__S_321not__PEEK { $_[0]->_AUTOLEXpeek('prefix__S_321not', $retree) }
sub prefix__S_321not {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE prefix__S_321not");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "not";
$self->_MATCHIFYr($S, "prefix__S_321not", do {
if (my ($C) = ($C->_PATTERN(qr/\Gnot\b/))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_unary)
})
} else { () }
});
}
;
## token infix:sym<,>
sub infix__S_322Comma__PEEK { $_[0]->_AUTOLEXpeek('infix__S_322Comma', $retree) }
sub infix__S_322Comma {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_322Comma");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\,";
$self->_MATCHIFYr($S, "infix__S_322Comma", do {
if (my ($C) = ($C->_EXACT("\,"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%comma, fiddly => 0)
})
} else { () }
});
}
;
## token infix:sym<:> {
sub infix__S_323Colon__PEEK { $_[0]->_AUTOLEXpeek('infix__S_323Colon', $retree) }
sub infix__S_323Colon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_323Colon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:";
$self->_MATCHIFYr($S, "infix__S_323Colon", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'infix__S_323Colon_0') {
        $C->deb("Fate passed to infix__S_323Colon_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT infix__S_323Colon_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM infix__S_323Colon_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'infix__S_323Colon_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("infix__S_323Colon_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_SUBSUMEr(['terminator'], sub {
my $C = shift;
$C->terminator
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$C->sorry("Illegal use of colon as invocant marker") unless $::INVOCANT_OK-- or $::PRECLIM ge $item_assignment_prec;
$M->{'sym'} = ',';
$M->{'wascolon'} = 1;
}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%comma)
})
} else { () }
});
}
;
## token infix:sym<X>
sub infix__S_324X__PEEK { $_[0]->_AUTOLEXpeek('infix__S_324X', $retree) }
sub infix__S_324X {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_324X");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "X";
$self->_MATCHIFYr($S, "infix__S_324X", do {
if (my ($C) = ($C->_EXACT("X"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix)
})
} else { () }
});
}
;
## token infix:sym<Z>
sub infix__S_325Z__PEEK { $_[0]->_AUTOLEXpeek('infix__S_325Z', $retree) }
sub infix__S_325Z {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_325Z");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "Z";
$self->_MATCHIFYr($S, "infix__S_325Z", do {
if (my ($C) = ($C->_EXACT("Z"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix)
})
} else { () }
});
}
;
## token infix:sym<minmax>
sub infix__S_326minmax__PEEK { $_[0]->_AUTOLEXpeek('infix__S_326minmax', $retree) }
sub infix__S_326minmax {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_326minmax");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "minmax";
$self->_MATCHIFYr($S, "infix__S_326minmax", do {
if (my ($C) = ($C->_EXACT("minmax"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix)
})
} else { () }
});
}
;
## token infix:sym<...>
sub infix__S_327DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('infix__S_327DotDotDot', $retree) }
sub infix__S_327DotDotDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_327DotDotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\.\.";
$self->_MATCHIFYr($S, "infix__S_327DotDotDot", do {
if (my ($C) = ($C->_EXACT("\.\.\."))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_infix)
})
} else { () }
});
}
;
## token term:sym<...>
sub term__S_328DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('term__S_328DotDotDot', $retree) }
sub term__S_328DotDotDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_328DotDotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'args'} = [];
$C->{sym} = "\.\.\.";
$self->_MATCHIFYr($S, "term__S_328DotDotDot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\.\.\."))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_prefix)
})
} else { () }
});
}
;
## token term:sym<???>
sub term__S_329QuestionQuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('term__S_329QuestionQuestionQuestion', $retree) }
sub term__S_329QuestionQuestionQuestion {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_329QuestionQuestionQuestion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'args'} = [];
$C->{sym} = "\?\?\?";
$self->_MATCHIFYr($S, "term__S_329QuestionQuestionQuestion", do {
my $C = $C;
if (($C) = ($C->_EXACT("\?\?\?"))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_prefix)
})
} else { () }
});
}
;
## token term:sym<!!!>
sub term__S_330BangBangBang__PEEK { $_[0]->_AUTOLEXpeek('term__S_330BangBangBang', $retree) }
sub term__S_330BangBangBang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_330BangBangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'args'} = [];
$C->{sym} = "\!\!\!";
$self->_MATCHIFYr($S, "term__S_330BangBangBang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!\!\!"))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
})
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%list_prefix)
})
} else { () }
});
}
;
my %deftrap = (
        'say' => 1, 'print' => 1, 'abs' => 1, 'alarm' => 1, 'chomp' => 1, 'chop' => 1, 'chr' => 1, 'chroot' => 1, 'cos' => 1,
        'defined' => 1, 'eval' => 1, 'exp' => 1, 'glob' => 1, 'lc' => 1, 'lcfirst' => 1, 'log' => 1, 'lstat' => 1, 'mkdir' => 1,
        'ord' => 1, 'readlink' => 1, 'readpipe' => 1, 'require' => 1, 'reverse' => 1, 'rmdir' => 1, 'sin' => 1,
        'split' => 1, 'sqrt' => 1, 'stat' => 1, 'uc' => 1, 'ucfirst' => 1, 'unlink' => 1,
        'WHAT' => 1, 'WHICH' => 1, 'WHERE' => 1, 'HOW' => 1, 'WHENCE' => 1, 'VAR' => 1,
    );
## token term:identifier
sub term__S_331identifier__PEEK { $_[0]->_AUTOLEXpeek('term__S_331identifier', $retree) }
sub term__S_331identifier {
no warnings 'recursion';
my $self = shift;

my $name;
my $pos;
my $isname = 0;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_331identifier");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "identifier";
$self->_MATCHIFYr($S, "term__S_331identifier", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['identifier'], sub {
my $C = shift;
$C->identifier
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->{'unsp'} = [];
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_331identifier_0') {
        $C->deb("Fate passed to term__S_331identifier_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT term__S_331identifier_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM term__S_331identifier_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'term__S_331identifier_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("term__S_331identifier_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['unsp'], sub {
my $C = shift;
$C->unsp
})
},
sub {
my $C=shift;
$C->_EXACT("\(")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
})
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C->_PATTERN(qr/\G[:]/)
}))
and ($C) = (scalar(do {
my $M = $C;
{
$name = $M->{'identifier'}->Str;
$pos = $C->{'_pos'};
$isname = $C->is_name($name);
$C->check_nodecl($name) if $isname;
}}, $C))
and ($C) = ($C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args($isname)
}))
and ($C) = (scalar(do {
my $M = $C;
$self->add_mystery($M->{'identifier'},$pos,substr($::ORIG,$pos,1)) unless $M->{'args'}->{'invocant'}}, $C))
and ($C) = (scalar(do {
my $M = $C;
{
if ($::BORG and $::BORG->{'block'}) {
if (not $::BORG->{'name'}) {
$::BORG->{'culprit'} = $M->{'identifier'}->cursor($pos);
$::BORG->{'name'} = $name;
}};
if ($deftrap{$name}) {
my $al = $M->{'args'}->{'arglist'}->[0];
my $ok = 0;
$ok = 1 if $al and $al->from != $al->to;
$ok = 1 if $M->{'args'}->{'semiarglist'};
if (not $ok) {
$M->{'identifier'}->worryobs("bare '$name'", ".$name if you meant \$_, or use an explicit invocant or argument")};
};
}}, $C))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }
});
}
;
## token args ($istype = 0) {
sub args__PEEK { $_[0]->_AUTOLEXpeek('args', $retree) }
sub args {
no warnings 'recursion';
my $self = shift;

my $istype = @_ ? shift() : 0;
my $listopish = 0;
local $::GOAL = '';
local $::INVOCANT_OK = 1;
local $::INVOCANT_IS;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE args");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$self->_MATCHIFYr($S, "args", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'args_0') {
        $C->deb("Fate passed to args_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT args_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM args_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'args_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("args_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'argument list', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->unsp)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['semiarglist'], sub {
my $C = shift;
$C->semiarglist
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'argument list', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = (scalar(do {
$listopish = 1 }, $C))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$istype })
}))
and ($C) = ($C->ws)
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->infixstopper)) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
} else { () }
}))) { ($C) } else { () }
})
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = (scalar(do {
my $M = $C;
$M->{'invocant'} = $::INVOCANT_IS}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$listopish })
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['moreargs'], sub {
my $C = shift;
$C->arglist
})
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, scalar(do {
my $M = $C;
{
$M->{'O'} = {
}}}, $C)
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## token term:name
sub term__S_332name__PEEK { $_[0]->_AUTOLEXpeek('term__S_332name', $retree) }
sub term__S_332name {
no warnings 'recursion';
my $self = shift;

my $name;
my $pos;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_332name");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'postcircumfix'} = [];
$C->{sym} = "name";
$self->_MATCHIFYr($S, "term__S_332name", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
}))
and ($C) = (scalar(do {
my $M = $C;
$name = $M->{'longname'}->Str;
$pos = $C->{'_pos'};
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$C->is_name($name) or substr($name,0,2) eq '::'
            })
}))
and ($C) = (scalar(do {
$C->check_nodecl($name)}, $C))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->unsp)) { ($C) } else { () }
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\[")
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
})
} else { () }
}))) { ($C) } else { () }
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->after(sub {
my $C=shift;
$C->_PATTERN(qr/\G(?<=\:\:)/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'term__S_332name_0') {
        $C->deb("Fate passed to term__S_332name_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT term__S_332name_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM term__S_332name_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'term__S_332name_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("term__S_332name_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("«")
},
sub {
my $C=shift;
$C->_EXACT("\<")
},
sub {
my $C=shift;
$C->_EXACT("\{")
},
sub {
my $C=shift;
$C->_EXACT("\<\<")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['postcircumfix'], sub {
my $C = shift;
$C->postcircumfix
}))) {
scalar(do {
$::VAR = $C->cursor_all($self->{'_pos'}, $C->{'_pos'}) }, $C)
} else { () }
}))) { ($C) } else { () }
})
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['args'], sub {
my $C = shift;
$C->args
}))
and ($C) = (scalar(do {
my $M = $C;
$self->add_mystery($M->{'longname'},$pos,'termish') unless $M->{'args'}->{'invocant'}}, $C))) {
scalar(do {
my $M = $C;
{
if ($::BORG and $::BORG->{'block'}) {
if (not $::BORG->{'name'}) {
$::BORG->{'culprit'} = $M->{'longname'}->cursor($pos);
$::BORG->{'name'} //= $name;
}}}}, $C)
} else { () }
}
};
@gather;
}
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%term)
})
} else { () }
});
}
;
## method check_nodecl($name)
sub check_nodecl {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
if ($name lt 'a') {
$::MEMOS[$self->{'_pos'}]->{'nodecl'} = $name}};
## token infix:sym<and>
sub infix__S_333and__PEEK { $_[0]->_AUTOLEXpeek('infix__S_333and', $retree) }
sub infix__S_333and {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_333and");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "and";
$self->_MATCHIFYr($S, "infix__S_333and", do {
if (my ($C) = ($C->_EXACT("and"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_and, iffy => 1)
})
} else { () }
});
}
;
## token infix:sym<andthen>
sub infix__S_334andthen__PEEK { $_[0]->_AUTOLEXpeek('infix__S_334andthen', $retree) }
sub infix__S_334andthen {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_334andthen");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "andthen";
$self->_MATCHIFYr($S, "infix__S_334andthen", do {
if (my ($C) = ($C->_EXACT("andthen"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_and)
})
} else { () }
});
}
;
## token infix:sym<or>
sub infix__S_335or__PEEK { $_[0]->_AUTOLEXpeek('infix__S_335or', $retree) }
sub infix__S_335or {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_335or");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "or";
$self->_MATCHIFYr($S, "infix__S_335or", do {
if (my ($C) = ($C->_EXACT("or"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_or, iffy => 1)
})
} else { () }
});
}
;
## token infix:sym<orelse>
sub infix__S_336orelse__PEEK { $_[0]->_AUTOLEXpeek('infix__S_336orelse', $retree) }
sub infix__S_336orelse {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_336orelse");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "orelse";
$self->_MATCHIFYr($S, "infix__S_336orelse", do {
if (my ($C) = ($C->_EXACT("orelse"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_or)
})
} else { () }
});
}
;
## token infix:sym<xor>
sub infix__S_337xor__PEEK { $_[0]->_AUTOLEXpeek('infix__S_337xor', $retree) }
sub infix__S_337xor {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_337xor");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "xor";
$self->_MATCHIFYr($S, "infix__S_337xor", do {
if (my ($C) = ($C->_EXACT("xor"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%loose_or, iffy => 1)
})
} else { () }
});
}
;
## token infix:sym« <== »
sub infix__S_338LtEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_338LtEqualEqual', $retree) }
sub infix__S_338LtEqualEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_338LtEqualEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\=\=";
$self->_MATCHIFYr($S, "infix__S_338LtEqualEqual", do {
if (my ($C) = ($C->_EXACT("\<\=\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%sequencer)
})
} else { () }
});
}
;
## token infix:sym« ==> »
sub infix__S_339EqualEqualGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_339EqualEqualGt', $retree) }
sub infix__S_339EqualEqualGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_339EqualEqualGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\=\>";
$self->_MATCHIFYr($S, "infix__S_339EqualEqualGt", do {
if (my ($C) = ($C->_EXACT("\=\=\>"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%sequencer)
})
} else { () }
});
}
;
## token infix:sym« <<== »
sub infix__S_340LtLtEqualEqual__PEEK { $_[0]->_AUTOLEXpeek('infix__S_340LtLtEqualEqual', $retree) }
sub infix__S_340LtLtEqualEqual {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_340LtLtEqualEqual");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\<\=\=";
$self->_MATCHIFYr($S, "infix__S_340LtLtEqualEqual", do {
if (my ($C) = ($C->_EXACT("\<\<\=\="))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%sequencer)
})
} else { () }
});
}
;
## token infix:sym« ==>> »
sub infix__S_341EqualEqualGtGt__PEEK { $_[0]->_AUTOLEXpeek('infix__S_341EqualEqualGtGt', $retree) }
sub infix__S_341EqualEqualGtGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infix__S_341EqualEqualGtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\=\=\>\>";
$self->_MATCHIFYr($S, "infix__S_341EqualEqualGtGt", do {
if (my ($C) = ($C->_EXACT("\=\=\>\>"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%sequencer)
})
} else { () }
});
}
;
## token terminator:sym<;>
sub terminator__S_342Semi__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_342Semi', $retree) }
sub terminator__S_342Semi {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_342Semi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\;";
$self->_MATCHIFYr($S, "terminator__S_342Semi", do {
if (my ($C) = ($C->_EXACT("\;"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }
});
}
;
## token terminator:sym<if>
sub terminator__S_343if__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_343if', $retree) }
sub terminator__S_343if {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_343if");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "if";
$self->_MATCHIFYr($S, "terminator__S_343if", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gif\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }
});
}
;
## token terminator:sym<unless>
sub terminator__S_344unless__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_344unless', $retree) }
sub terminator__S_344unless {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_344unless");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "unless";
$self->_MATCHIFYr($S, "terminator__S_344unless", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gunless\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }
});
}
;
## token terminator:sym<while>
sub terminator__S_345while__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_345while', $retree) }
sub terminator__S_345while {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_345while");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "while";
$self->_MATCHIFYr($S, "terminator__S_345while", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gwhile\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }
});
}
;
## token terminator:sym<until>
sub terminator__S_346until__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_346until', $retree) }
sub terminator__S_346until {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_346until");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "until";
$self->_MATCHIFYr($S, "terminator__S_346until", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Guntil\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }
});
}
;
## token terminator:sym<for>
sub terminator__S_347for__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_347for', $retree) }
sub terminator__S_347for {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_347for");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "for";
$self->_MATCHIFYr($S, "terminator__S_347for", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gfor\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }
});
}
;
## token terminator:sym<given>
sub terminator__S_348given__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_348given', $retree) }
sub terminator__S_348given {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_348given");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "given";
$self->_MATCHIFYr($S, "terminator__S_348given", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Ggiven\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }
});
}
;
## token terminator:sym<when>
sub terminator__S_349when__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_349when', $retree) }
sub terminator__S_349when {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_349when");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "when";
$self->_MATCHIFYr($S, "terminator__S_349when", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\Gwhen\b/))
and ($C) = ($C->nofun)) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }
});
}
;
## token terminator:sym« --> »
sub terminator__S_350MinusMinusGt__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_350MinusMinusGt', $retree) }
sub terminator__S_350MinusMinusGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_350MinusMinusGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-\-\>";
$self->_MATCHIFYr($S, "terminator__S_350MinusMinusGt", do {
if (my ($C) = ($C->_EXACT("\-\-\>"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }
});
}
;
## token terminator:sym<!!>
sub terminator__S_351BangBang__PEEK { $_[0]->_AUTOLEXpeek('terminator__S_351BangBang', $retree) }
sub terminator__S_351BangBang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE terminator__S_351BangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!\!";
$self->_MATCHIFYr($S, "terminator__S_351BangBang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!\!"))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::GOAL eq '!!' })
}))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%terminator)
})
} else { () }
});
}
;
## regex infixstopper {
sub infixstopper__PEEK { $_[0]->_AUTOLEXpeek('infixstopper', $retree) }
sub infixstopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infixstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFY($S, "infixstopper", $C->_BRACKET(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixstopper_0') {
        $C->deb("Fate passed to infixstopper_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT infixstopper_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM infixstopper_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'infixstopper_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("infixstopper_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_SUBSUME(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
},
sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
$C->before(sub {
my $C=shift;
(($C) x !!do {
$::GOAL eq '!!' })
})
},
$C->before(sub {
my $C=shift;
$C->_EXACT("\!\!")
}))
},
sub {
my $C=shift;
LazyMap::lazymap(sub {
my $C=shift;
$C->before(sub {
my $C=shift;
(($C) x !!do {
($::GOAL eq '{' or $::GOAL eq 'endargs') and $::MEMOS[$C->{'_pos'}]->{'ws'} })
})
},
$C->before(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixstopper_1') {
        $C->deb("Fate passed to infixstopper_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT infixstopper_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM infixstopper_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::P6', 'infixstopper_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("infixstopper_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\{")
},
sub {
my $C=shift;
$C->_SUBSUME(['lambda'], sub {
my $C = shift;
$C->lambda
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
},
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
(($C) x !!do {
$::GOAL eq 'endargs' and $::MEMOS[$C->{'_pos'}]->{'endargs'} })
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}));
}
;
  1; };
{ package STD::Q;
use Moose ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc
moose_extends('STD');

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

{ package STD::Q::b1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
backslash__S_001qq: !!perl/hash:RE_ast
  dba: backslash
  min: 0
  re: !!perl/hash:RE_sequence
    min: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: q
    - !!perl/hash:RE_block
      min: 0
backslash__S_002Back: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: \
    min: 12345
backslash__S_003stopper: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_method
      min: 12345
      name: stopper
      rest: ''
    min: 12345
backslash__S_004a: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: a
backslash__S_005b: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: b
backslash__S_006c: !!perl/hash:RE_ast
  dba: backslash
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: c
    - !!perl/hash:RE_method
      min: 12345
      name: charspec
      rest: ''
backslash__S_007e: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: e
backslash__S_008f: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: f
backslash__S_009n: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: n
backslash__S_010o: !!perl/hash:RE_ast
  dba: octal character
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: o
    - !!perl/hash:RE_bracket
      min: 12345
      re: &1 !!perl/hash:RE_any
        altname: backslash__S_010o_0
        dba: octal character
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          alt: backslash__S_010o_0 0
          min: 12345
          name: octint
          rest: ''
        - !!perl/hash:RE_bracket
          alt: backslash__S_010o_0 1
          min: 12347
          re: !!perl/hash:RE_sequence
            min: 12347
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: '['
            - !!perl/hash:RE_block
              min: 0
            - !!perl/hash:RE_method
              min: 12345
              name: octints
              rest: ''
            - !!perl/hash:RE_bracket
              min: 1
              re: !!perl/hash:RE_first
                min: 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: ']'
                - !!perl/hash:RE_method
                  min: 12345
                  name: FAILGOAL
                  rest: 1
backslash__S_010o_0: *1
backslash__S_011r: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: r
backslash__S_012t: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: t
backslash__S_013x: !!perl/hash:RE_ast
  dba: hex character
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: x
    - !!perl/hash:RE_bracket
      min: 12345
      re: &2 !!perl/hash:RE_any
        altname: backslash__S_013x_0
        dba: hex character
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          alt: backslash__S_013x_0 0
          min: 12345
          name: hexint
          rest: ''
        - !!perl/hash:RE_bracket
          alt: backslash__S_013x_0 1
          min: 12347
          re: !!perl/hash:RE_sequence
            min: 12347
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: '['
            - !!perl/hash:RE_block
              min: 0
            - !!perl/hash:RE_method
              min: 12345
              name: hexints
              rest: ''
            - !!perl/hash:RE_bracket
              min: 1
              re: !!perl/hash:RE_first
                min: 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: ']'
                - !!perl/hash:RE_method
                  min: 12345
                  name: FAILGOAL
                  rest: 1
backslash__S_013x_0: *2
backslash__S_0140: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: '0'
escape__S_000Back: !!perl/hash:RE_ast
  dba: escape
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: \
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        min: 12345
        name: backslash
        rest: ''
      min: 12345
RETREE_END
## token escape:sym<\\> { <sym> {} <item=.backslash> }
sub escape__S_000Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Back', $retree) }
sub escape__S_000Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "escape__S_000Back", do {
my $C = $C;
if (($C) = ($C->_EXACT("\\"))
and ($C) = (scalar(do {
}, $C))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
})
} else { () }
});
}
;
## token backslash:qq { <?before 'q'> { $<quote> = $¢.cursor_fresh(%*LANG<MAIN>).quote(); } }
sub backslash__S_001qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_001qq', $retree) }
sub backslash__S_001qq {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_001qq");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "qq";
$self->_MATCHIFYr($S, "backslash__S_001qq", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("q")
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
$M->{'quote'} = $C->cursor_fresh($::LANG{'MAIN'})->quote()}, $C)
} else { () }
});
}
;
## token backslash:sym<\\> { <text=.sym> }
sub backslash__S_002Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_002Back', $retree) }
sub backslash__S_002Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_002Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "backslash__S_002Back", $C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->_EXACT("\\")
}));
}
;
## token backslash:stopper { <text=.stopper> }
sub backslash__S_003stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_003stopper', $retree) }
sub backslash__S_003stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_003stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "stopper";
$self->_MATCHIFYr($S, "backslash__S_003stopper", $C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
}));
}
;
## token backslash:a { <sym> }
sub backslash__S_004a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_004a', $retree) }
sub backslash__S_004a {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_004a");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "a";
$self->_MATCHIFYr($S, "backslash__S_004a", $C->_EXACT("a"));
}
;
## token backslash:b { <sym> }
sub backslash__S_005b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_005b', $retree) }
sub backslash__S_005b {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_005b");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "b";
$self->_MATCHIFYr($S, "backslash__S_005b", $C->_EXACT("b"));
}
;
## token backslash:c { <sym> <charspec> }
sub backslash__S_006c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_006c', $retree) }
sub backslash__S_006c {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_006c");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "c";
$self->_MATCHIFYr($S, "backslash__S_006c", do {
if (my ($C) = ($C->_EXACT("c"))) {
$C->_SUBSUMEr(['charspec'], sub {
my $C = shift;
$C->charspec
})
} else { () }
});
}
;
## token backslash:e { <sym> }
sub backslash__S_007e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_007e', $retree) }
sub backslash__S_007e {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_007e");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "e";
$self->_MATCHIFYr($S, "backslash__S_007e", $C->_EXACT("e"));
}
;
## token backslash:f { <sym> }
sub backslash__S_008f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_008f', $retree) }
sub backslash__S_008f {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_008f");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "f";
$self->_MATCHIFYr($S, "backslash__S_008f", $C->_EXACT("f"));
}
;
## token backslash:n { <sym> }
sub backslash__S_009n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_009n', $retree) }
sub backslash__S_009n {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_009n");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "n";
$self->_MATCHIFYr($S, "backslash__S_009n", $C->_EXACT("n"));
}
;
## token backslash:o { :dba('octal character') <sym> [ <octint> | '[' ~ ']' <octints> ] }
sub backslash__S_010o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_010o', $retree) }
sub backslash__S_010o {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_010o");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "o";
$self->_MATCHIFYr($S, "backslash__S_010o", do {
my $C = $C;
if (($C) = ($C->_EXACT("o"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_010o_0') {
        $C->deb("Fate passed to backslash__S_010o_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT backslash__S_010o_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM backslash__S_010o_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_010o_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("backslash__S_010o_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['octints'], sub {
my $C = shift;
$C->octints
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'octal character', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token backslash:r { <sym> }
sub backslash__S_011r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_011r', $retree) }
sub backslash__S_011r {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_011r");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "r";
$self->_MATCHIFYr($S, "backslash__S_011r", $C->_EXACT("r"));
}
;
## token backslash:t { <sym> }
sub backslash__S_012t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_012t', $retree) }
sub backslash__S_012t {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_012t");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "t";
$self->_MATCHIFYr($S, "backslash__S_012t", $C->_EXACT("t"));
}
;
## token backslash:x { :dba('hex character') <sym> [ <hexint> | '[' ~ ']' <hexints> ] }
sub backslash__S_013x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_013x', $retree) }
sub backslash__S_013x {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_013x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "x";
$self->_MATCHIFYr($S, "backslash__S_013x", do {
my $C = $C;
if (($C) = ($C->_EXACT("x"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_013x_0') {
        $C->deb("Fate passed to backslash__S_013x_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT backslash__S_013x_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM backslash__S_013x_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Q::b1', 'backslash__S_013x_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("backslash__S_013x_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['hexints'], sub {
my $C = shift;
$C->hexints
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'hex character', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token backslash:sym<0> { <sym> }
sub backslash__S_0140__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_0140', $retree) }
sub backslash__S_0140 {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_0140");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "backslash__S_0140", $C->_EXACT("0"));
}
;
  1; };
{ package STD::Q::b0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Back: !!perl/hash:RE_ast
  dba: escape
  min: 0
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      min: 0
      nobind: 1
RETREE_END
## token escape:sym<\\> { <!> }
sub escape__S_000Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Back', $retree) }
sub escape__S_000Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "escape__S_000Back", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
  1; };
{ package STD::Q::c1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Cur_Ly: !!perl/hash:RE_ast
  dba: escape
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: '{'
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_sequence
        min: 12345
        zyg:
        - !!perl/hash:RE_decl
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: embeddedblock
          rest: ''
RETREE_END
## token escape:sym<{ }> { <?before '{'> [ :lang(%*LANG<MAIN>) <embeddedblock> ] }
sub escape__S_000Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Cur_Ly', $retree) }
sub escape__S_000Cur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\ \}";
$self->_MATCHIFYr($S, "escape__S_000Cur_Ly", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
;

$C->_SUBSUMEr(['embeddedblock'], sub {
my $C = shift;
$C->embeddedblock
})
}))) {
$C
} else { () }
});
}
  1; };
{ package STD::Q::c0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Cur_Ly: !!perl/hash:RE_ast
  dba: escape
  min: 0
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      min: 0
      nobind: 1
RETREE_END
## token escape:sym<{ }> { <!> }
sub escape__S_000Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Cur_Ly', $retree) }
sub escape__S_000Cur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\ \}";
$self->_MATCHIFYr($S, "escape__S_000Cur_Ly", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
  1; };
{ package STD::Q::s1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Dollar: !!perl/hash:RE_ast
  dba: escape
  min: 12345
  re: !!perl/hash:RE_first
    min: 12345
    zyg:
    - !!perl/hash:RE_sequence
      min: 12345
      zyg:
      - !!perl/hash:RE_assertion
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method_re
          min: 12345
          name: before
          nobind: 1
          re: !!perl/hash:RE_string
            i: 0
            min: 1
            text: $
      - !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_decl
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: EXPR
            rest: 1
    - !!perl/hash:RE_method
      min: 12345
      name: panic
      rest: 1
RETREE_END
## token escape:sym<$> {
sub escape__S_000Dollar__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Dollar', $retree) }
sub escape__S_000Dollar {
no warnings 'recursion';
my $self = shift;

local $::QSIGIL = '$';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Dollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$";
$self->_MATCHIFYr($S, "escape__S_000Dollar", do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\$")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
;

$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
}))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Non-variable \$ must be backslashed"))) { ($C) } else { () }
}
};
@gather;
});
}
  1; };
{ package STD::Q::s0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Dollar: !!perl/hash:RE_ast
  dba: escape
  min: 0
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      min: 0
      nobind: 1
RETREE_END
## token escape:sym<$> { <!> }
sub escape__S_000Dollar__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Dollar', $retree) }
sub escape__S_000Dollar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Dollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$";
$self->_MATCHIFYr($S, "escape__S_000Dollar", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
  1; };
{ package STD::Q::a1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000At: !!perl/hash:RE_ast
  dba: escape
  min: 0
  re: !!perl/hash:RE_sequence
    min: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: '@'
    - !!perl/hash:RE_bracket
      min: 0
      re: &1 !!perl/hash:RE_any
        altname: escape__S_000At_0
        dba: escape
        min: 0
        zyg:
        - !!perl/hash:RE_sequence
          alt: escape__S_000At_0 0
          min: 12345
          zyg:
          - !!perl/hash:RE_decl
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: EXPR
            rest: 1
        - !!perl/hash:RE_assertion
          alt: escape__S_000At_0 1
          assert: '!'
          min: 0
          re: !!perl/hash:RE_noop
            min: 0
            nobind: 1
escape__S_000At_0: *1
RETREE_END
## token escape:sym<@> {
sub escape__S_000At__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000At', $retree) }
sub escape__S_000At {
no warnings 'recursion';
my $self = shift;

local $::QSIGIL = '@';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000At");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@";
$self->_MATCHIFYr($S, "escape__S_000At", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\@")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'escape__S_000At_0') {
        $C->deb("Fate passed to escape__S_000At_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT escape__S_000At_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM escape__S_000At_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Q::a1', 'escape__S_000At_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("escape__S_000At_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = (do {
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
;

$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
})) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
  1; };
{ package STD::Q::a0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000At: !!perl/hash:RE_ast
  dba: escape
  min: 0
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      min: 0
      nobind: 1
RETREE_END
## token escape:sym<@> { <!> }
sub escape__S_000At__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000At', $retree) }
sub escape__S_000At {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000At");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\@";
$self->_MATCHIFYr($S, "escape__S_000At", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
  1; };
{ package STD::Q::h1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Percent: !!perl/hash:RE_ast
  dba: escape
  min: 0
  re: !!perl/hash:RE_sequence
    min: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: '%'
    - !!perl/hash:RE_bracket
      min: 0
      re: &1 !!perl/hash:RE_any
        altname: escape__S_000Percent_0
        dba: escape
        min: 0
        zyg:
        - !!perl/hash:RE_sequence
          alt: escape__S_000Percent_0 0
          min: 12345
          zyg:
          - !!perl/hash:RE_decl
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: EXPR
            rest: 1
        - !!perl/hash:RE_assertion
          alt: escape__S_000Percent_0 1
          assert: '!'
          min: 0
          re: !!perl/hash:RE_noop
            min: 0
            nobind: 1
escape__S_000Percent_0: *1
RETREE_END
## token escape:sym<%> {
sub escape__S_000Percent__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Percent', $retree) }
sub escape__S_000Percent {
no warnings 'recursion';
my $self = shift;

local $::QSIGIL = '%';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Percent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%";
$self->_MATCHIFYr($S, "escape__S_000Percent", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\%")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'escape__S_000Percent_0') {
        $C->deb("Fate passed to escape__S_000Percent_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT escape__S_000Percent_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM escape__S_000Percent_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Q::h1', 'escape__S_000Percent_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("escape__S_000Percent_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = (do {
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
;

$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
})) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
  1; };
{ package STD::Q::h0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Percent: !!perl/hash:RE_ast
  dba: escape
  min: 0
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      min: 0
      nobind: 1
RETREE_END
## token escape:sym<%> { <!> }
sub escape__S_000Percent__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Percent', $retree) }
sub escape__S_000Percent {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Percent");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\%";
$self->_MATCHIFYr($S, "escape__S_000Percent", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
  1; };
{ package STD::Q::f1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Amp: !!perl/hash:RE_ast
  dba: escape
  min: 0
  re: !!perl/hash:RE_sequence
    min: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: '&'
    - !!perl/hash:RE_bracket
      min: 0
      re: &1 !!perl/hash:RE_any
        altname: escape__S_000Amp_0
        dba: escape
        min: 0
        zyg:
        - !!perl/hash:RE_sequence
          alt: escape__S_000Amp_0 0
          min: 12345
          zyg:
          - !!perl/hash:RE_decl
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: EXPR
            rest: 1
        - !!perl/hash:RE_assertion
          alt: escape__S_000Amp_0 1
          assert: '!'
          min: 0
          re: !!perl/hash:RE_noop
            min: 0
            nobind: 1
escape__S_000Amp_0: *1
RETREE_END
## token escape:sym<&> {
sub escape__S_000Amp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Amp', $retree) }
sub escape__S_000Amp {
no warnings 'recursion';
my $self = shift;

local $::QSIGIL = '&';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&";
$self->_MATCHIFYr($S, "escape__S_000Amp", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\&")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'escape__S_000Amp_0') {
        $C->deb("Fate passed to escape__S_000Amp_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT escape__S_000Amp_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM escape__S_000Amp_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Q::f1', 'escape__S_000Amp_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("escape__S_000Amp_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = (do {
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
;

$C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR(\%methodcall)
})
})) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
  1; };
{ package STD::Q::f0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
escape__S_000Amp: !!perl/hash:RE_ast
  dba: escape
  min: 0
  re: !!perl/hash:RE_assertion
    assert: '!'
    min: 0
    re: !!perl/hash:RE_noop
      min: 0
      nobind: 1
RETREE_END
## token escape:sym<&> { <!> }
sub escape__S_000Amp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Amp', $retree) }
sub escape__S_000Amp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&";
$self->_MATCHIFYr($S, "escape__S_000Amp", $C->_NOTBEFORE(sub {
my $C=shift;
$C
}));
}
  1; };
{ package STD::Q::p1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocess ($s)
sub postprocess {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$s->parsepath }  1; };
{ package STD::Q::p0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocess ($s)
sub postprocess {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$s }  1; };
{ package STD::Q::w1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocess ($s)
sub postprocess {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$s->words }  1; };
{ package STD::Q::w0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocess ($s)
sub postprocess {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$s }  1; };
{ package STD::Q::ww1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocess ($s)
sub postprocess {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$s->words }  1; };
{ package STD::Q::ww0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocess ($s)
sub postprocess {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$s }  1; };
{ package STD::Q::x1;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocess ($s)
sub postprocess {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$s->run }  1; };
{ package STD::Q::x0;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method postprocess ($s)
sub postprocess {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$s }  1; };
{ package STD::Q::q;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
backslash__S_001qq: !!perl/hash:RE_ast
  dba: backslash
  min: 0
  re: !!perl/hash:RE_sequence
    min: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: q
    - !!perl/hash:RE_block
      min: 0
backslash__S_002Back: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: \
    min: 12345
backslash__S_003stopper: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_method
      min: 12345
      name: stopper
      rest: ''
    min: 12345
backslash__S_004misc: !!perl/hash:RE_ast
  dba: backslash
  min: 1
  re: !!perl/hash:RE_sequence
    min: 1
    zyg:
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        min: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: .
      min: 1
    - !!perl/hash:RE_block
      min: 0
escape__S_000Back: !!perl/hash:RE_ast
  dba: escape
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: \
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        min: 12345
        name: backslash
        rest: ''
      min: 12345
stopper: !!perl/hash:RE_ast
  dba: stopper
  min: 1
  re: !!perl/hash:RE_meta
    min: 1
    text: \'
RETREE_END
## token stopper { \' }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", $C->_EXACT("\'"));
}
;
## token escape:sym<\\> { <sym> <item=.backslash> }
sub escape__S_000Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000Back', $retree) }
sub escape__S_000Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "escape__S_000Back", do {
if (my ($C) = ($C->_EXACT("\\"))) {
$C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
})
} else { () }
});
}
;
## token backslash:qq { <?before 'q'> { $<quote> = $¢.cursor_fresh(%*LANG<MAIN>).quote(); } }
sub backslash__S_001qq__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_001qq', $retree) }
sub backslash__S_001qq {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_001qq");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "qq";
$self->_MATCHIFYr($S, "backslash__S_001qq", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("q")
}))) { ($C) } else { () }
}))) {
scalar(do {
my $M = $C;
$M->{'quote'} = $C->cursor_fresh($::LANG{'MAIN'})->quote()}, $C)
} else { () }
});
}
;
## token backslash:sym<\\> { <text=.sym> }
sub backslash__S_002Back__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_002Back', $retree) }
sub backslash__S_002Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_002Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "backslash__S_002Back", $C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->_EXACT("\\")
}));
}
;
## token backslash:stopper { <text=.stopper> }
sub backslash__S_003stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_003stopper', $retree) }
sub backslash__S_003stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_003stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "stopper";
$self->_MATCHIFYr($S, "backslash__S_003stopper", $C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
}));
}
;
## token backslash:misc { {} (.) { $<text> = "\\" ~ $0.Str; } }
sub backslash__S_004misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_004misc', $retree) }
sub backslash__S_004misc {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_004misc");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "misc";
$self->_MATCHIFYr($S, "backslash__S_004misc", do {
my $C = $C;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->cursor_incr()

})
}))) {
scalar(do {
my $M = $C;
$M->{'text'} = "\\" . $M->{0}->Str}, $C)
} else { () }
});
}
;
## method tweak (:single(:$q)!)
;
## method tweak (:double(:$qq)!)
;
## method tweak (:cclass(:$cc)!)
;
 moose_around tweak  => sub {
    my $orig = shift;
    no warnings 'recursion';
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{single} || exists $args{q};
my $q = exists $args{single} ? delete $args{single} : exists $args{q} ? delete $args{q} : undef;
$self->panic("Too late for :q")     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{double} || exists $args{qq};
my $qq = exists $args{double} ? delete $args{double} : exists $args{qq} ? delete $args{qq} : undef;
$self->panic("Too late for :qq")     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{cclass} || exists $args{cc};
my $cc = exists $args{cclass} ? delete $args{cclass} : exists $args{cc} ? delete $args{cc} : undef;
$self->panic("Too late for :cc")     };
}
    $orig->(@_);
};

 1; };
{ package STD::Q::qq;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc
moose_with('STD::Q::b1');
moose_with('STD::Q::c1');
moose_with('STD::Q::s1');
moose_with('STD::Q::a1');
moose_with('STD::Q::h1');
moose_with('STD::Q::f1');

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
backslash__S_000misc: !!perl/hash:RE_ast
  dba: backslash
  min: 1
  re: !!perl/hash:RE_sequence
    min: 1
    zyg:
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_bracket
      min: 1
      re: &1 !!perl/hash:RE_any
        altname: backslash__S_000misc_0
        dba: backslash
        min: 1
        zyg:
        - !!perl/hash:RE_sequence
          alt: backslash__S_000misc_0 0
          min: 1
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              min: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: \W
            min: 1
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          alt: backslash__S_000misc_0 1
          min: 12346
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_paren
              min: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: \w
            min: 1
          - !!perl/hash:RE_method
            min: 12345
            name: sorry
            rest: 1
backslash__S_000misc_0: *1
stopper: !!perl/hash:RE_ast
  dba: stopper
  min: 1
  re: !!perl/hash:RE_meta
    min: 1
    text: \"
RETREE_END
## token stopper { \" }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", $C->_EXACT("\""));
}
;
## token backslash:misc { {} [ (\W) { $<text> = $0.Str; } | $<x>=(\w) <.sorry("Unrecognized backslash s
sub backslash__S_000misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_000misc', $retree) }
sub backslash__S_000misc {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_000misc");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "misc";
$self->_MATCHIFYr($S, "backslash__S_000misc", do {
my $C = $C;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_000misc_0') {
        $C->deb("Fate passed to backslash__S_000misc_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT backslash__S_000misc_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM backslash__S_000misc_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Q::qq', 'backslash__S_000misc_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("backslash__S_000misc_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\W/)

})
}))) {
scalar(do {
my $M = $C;
$M->{'text'} = $M->{0}->Str}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['x'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)

})
}))
and ($C) = (do {
my $M = $C;
$C->sorry("Unrecognized backslash sequence: '\\" . $M->{'x'}->Str . "'")
})) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## method tweak (:single(:$q)!)
;
## method tweak (:double(:$qq)!)
;
## method tweak (:cclass(:$cc)!)
;
 moose_around tweak  => sub {
    my $orig = shift;
    no warnings 'recursion';
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{single} || exists $args{q};
my $q = exists $args{single} ? delete $args{single} : exists $args{q} ? delete $args{q} : undef;
$self->panic("Too late for :q")     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{double} || exists $args{qq};
my $qq = exists $args{double} ? delete $args{double} : exists $args{qq} ? delete $args{qq} : undef;
$self->panic("Too late for :qq")     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{cclass} || exists $args{cc};
my $cc = exists $args{cclass} ? delete $args{cclass} : exists $args{cc} ? delete $args{cc} : undef;
$self->panic("Too late for :cc")     };
}
    $orig->(@_);
};

 1; };
{ package STD::Q::cc;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
backslash__S_006stopper: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_method
      min: 12345
      name: stopper
      rest: ''
    min: 12345
backslash__S_007a: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 1
    min: 12345
    name: sym
    rest: ''
    sym: a
backslash__S_008b: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 1
    min: 12345
    name: sym
    rest: ''
    sym: b
backslash__S_009c: !!perl/hash:RE_ast
  dba: backslash
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 1
      min: 12345
      name: sym
      rest: ''
      sym: c
    - !!perl/hash:RE_method
      min: 12345
      name: charspec
      rest: ''
backslash__S_010d: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      i: 1
      min: 12345
      name: sym
      rest: ''
      sym: d
    - !!perl/hash:RE_block
      min: 0
backslash__S_011e: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 1
    min: 12345
    name: sym
    rest: ''
    sym: e
backslash__S_012f: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 1
    min: 12345
    name: sym
    rest: ''
    sym: f
backslash__S_013h: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      i: 1
      min: 12345
      name: sym
      rest: ''
      sym: h
    - !!perl/hash:RE_block
      min: 0
backslash__S_014n: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 1
    min: 12345
    name: sym
    rest: ''
    sym: n
backslash__S_015o: !!perl/hash:RE_ast
  dba: octal character
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 1
      min: 12345
      name: sym
      rest: ''
      sym: o
    - !!perl/hash:RE_bracket
      min: 12345
      re: &1 !!perl/hash:RE_any
        altname: backslash__S_015o_0
        dba: octal character
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          alt: backslash__S_015o_0 0
          min: 12345
          name: octint
          rest: ''
        - !!perl/hash:RE_bracket
          alt: backslash__S_015o_0 1
          min: 12347
          re: !!perl/hash:RE_sequence
            min: 12347
            zyg:
            - !!perl/hash:RE_string
              i: 1
              min: 1
              text: '['
            - !!perl/hash:RE_block
              min: 0
            - !!perl/hash:RE_method
              min: 12345
              name: octints
              rest: ''
            - !!perl/hash:RE_bracket
              min: 1
              re: !!perl/hash:RE_first
                min: 1
                zyg:
                - !!perl/hash:RE_string
                  i: 1
                  min: 1
                  text: ']'
                - !!perl/hash:RE_method
                  min: 12345
                  name: FAILGOAL
                  rest: 1
backslash__S_015o_0: *1
backslash__S_016r: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 1
    min: 12345
    name: sym
    rest: ''
    sym: r
backslash__S_017s: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      i: 1
      min: 12345
      name: sym
      rest: ''
      sym: s
    - !!perl/hash:RE_block
      min: 0
backslash__S_018t: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 1
    min: 12345
    name: sym
    rest: ''
    sym: t
backslash__S_019v: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      i: 1
      min: 12345
      name: sym
      rest: ''
      sym: v
    - !!perl/hash:RE_block
      min: 0
backslash__S_020w: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      i: 1
      min: 12345
      name: sym
      rest: ''
      sym: w
    - !!perl/hash:RE_block
      min: 0
backslash__S_021x: !!perl/hash:RE_ast
  dba: hex character
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 1
      min: 12345
      name: sym
      rest: ''
      sym: x
    - !!perl/hash:RE_bracket
      min: 12345
      re: &2 !!perl/hash:RE_any
        altname: backslash__S_021x_0
        dba: hex character
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          alt: backslash__S_021x_0 0
          min: 12345
          name: hexint
          rest: ''
        - !!perl/hash:RE_bracket
          alt: backslash__S_021x_0 1
          min: 12347
          re: !!perl/hash:RE_sequence
            min: 12347
            zyg:
            - !!perl/hash:RE_string
              i: 1
              min: 1
              text: '['
            - !!perl/hash:RE_block
              min: 0
            - !!perl/hash:RE_method
              min: 12345
              name: hexints
              rest: ''
            - !!perl/hash:RE_bracket
              min: 1
              re: !!perl/hash:RE_first
                min: 1
                zyg:
                - !!perl/hash:RE_string
                  i: 1
                  min: 1
                  text: ']'
                - !!perl/hash:RE_method
                  min: 12345
                  name: FAILGOAL
                  rest: 1
backslash__S_021x_0: *2
backslash__S_0220: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: '0'
backslash__S_023misc: !!perl/hash:RE_ast
  dba: backslash
  min: 1
  re: !!perl/hash:RE_sequence
    min: 1
    zyg:
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_bracket
      min: 1
      re: &3 !!perl/hash:RE_any
        altname: backslash__S_023misc_0
        dba: backslash
        min: 1
        zyg:
        - !!perl/hash:RE_sequence
          alt: backslash__S_023misc_0 0
          min: 1
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              min: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: \W
            min: 1
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          alt: backslash__S_023misc_0 1
          min: 12346
          zyg:
          - !!perl/hash:RE_bindnamed
            atom: !!perl/hash:RE_paren
              min: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: \w
            min: 1
          - !!perl/hash:RE_method
            min: 12345
            name: sorry
            rest: 1
backslash__S_023misc_0: *3
escape__S_000ws: !!perl/hash:RE_ast
  dba: escape
  min: 1
  re: !!perl/hash:RE_sequence
    min: 1
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \s
      min: 1
      quant:
      - +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                min: 1
                text: '#'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
      min: 0
      quant:
      - '?'
escape__S_001Sharp: !!perl/hash:RE_ast
  dba: escape
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: '#'
    - !!perl/hash:RE_method
      min: 12345
      name: panic
      rest: 1
escape__S_002Back: !!perl/hash:RE_ast
  dba: escape
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: \
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_method
        min: 12345
        name: backslash
        rest: ''
      min: 12345
    - !!perl/hash:RE_method
      min: 12345
      name: ccstate
      rest: 1
escape__S_003DotDot: !!perl/hash:RE_ast
  dba: escape
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ..
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_block
              min: 0
              nobind: 1
          - !!perl/hash:RE_method
            min: 12345
            name: sorry
            rest: 1
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_sequence
              min: 1
              zyg:
              - !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \s
                min: 0
                quant:
                - '*'
              - !!perl/hash:RE_assertion
                assert: '!'
                min: 0
                re: !!perl/hash:RE_method
                  min: 12345
                  name: stopper
                  rest: ''
              - !!perl/hash:RE_assertion
                assert: '!'
                min: 0
                re: !!perl/hash:RE_method_re
                  min: 12345
                  name: before
                  nobind: 1
                  re: !!perl/hash:RE_string
                    i: 0
                    min: 2
                    text: ..
              - !!perl/hash:RE_meta
                min: 1
                text: \S
        - !!perl/hash:RE_method
          min: 12345
          name: sorry
          rest: 1
    - !!perl/hash:RE_block
      min: 0
escape__S_004Minus: !!perl/hash:RE_ast
  dba: escape
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: '-'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_block
        min: 0
        nobind: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_meta
        min: 1
        text: \s
      min: 0
      quant:
      - '*'
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        min: 12345
        name: stopper
        rest: ''
    - !!perl/hash:RE_meta
      min: 1
      text: \S
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
escape__S_005ch: !!perl/hash:RE_ast
  dba: escape
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        min: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \S
      min: 1
    - !!perl/hash:RE_method
      min: 12345
      name: ccstate
      rest: 1
stopper: !!perl/hash:RE_ast
  dba: stopper
  min: 1
  re: !!perl/hash:RE_meta
    min: 1
    text: \'
RETREE_END
## token stopper { \' }
sub stopper__PEEK { $_[0]->_AUTOLEXpeek('stopper', $retree) }
sub stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "stopper", $C->_EXACT("\'"));
}
;
## method ccstate ($s)
sub ccstate {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
if ($::CCSTATE eq '..') {
$::CCSTATE = ''}
else {
$::CCSTATE = $s};
$self;
};
## token escape:ws { \s+ [ <?before '#'> <.ws> ]? }
sub escape__S_000ws__PEEK { $_[0]->_AUTOLEXpeek('escape__S_000ws', $retree) }
sub escape__S_000ws {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_000ws");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ws";
$self->_MATCHIFYr($S, "escape__S_000ws", do {
if (my ($C) = ($C->_PATTERN(qr/\G\s++/))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\#")
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token escape:sym<#> { '#' <.panic: "Please backslash # for literal char or put whitespace in front f
sub escape__S_001Sharp__PEEK { $_[0]->_AUTOLEXpeek('escape__S_001Sharp', $retree) }
sub escape__S_001Sharp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_001Sharp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\#";
$self->_MATCHIFYr($S, "escape__S_001Sharp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\#"))
and ($C) = ($C->panic("Please backslash # for literal char or put whitespace in front for comment"))) {
$C
} else { () }
});
}
;
## token escape:sym<\\> { <sym> <item=.backslash>  <.ccstate('\\' ~ $<item>.Str)> }
sub escape__S_002Back__PEEK { $_[0]->_AUTOLEXpeek('escape__S_002Back', $retree) }
sub escape__S_002Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_002Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "escape__S_002Back", do {
my $C = $C;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->_SUBSUMEr(['item'], sub {
my $C = shift;
$C->backslash
}))
and ($C) = (do {
my $M = $C;
$C->ccstate('\\' . $M->{'item'}->Str)
})) {
$C
} else { () }
});
}
;
## token escape:sym<..> { <sym>
sub escape__S_003DotDot__PEEK { $_[0]->_AUTOLEXpeek('escape__S_003DotDot', $retree) }
sub escape__S_003DotDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_003DotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\.";
$self->_MATCHIFYr($S, "escape__S_003DotDot", do {
my $C = $C;
if (($C) = ($C->_EXACT("\.\."))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::CCSTATE eq '' or $::CCSTATE eq '..' })
}))
and ($C) = ($C->sorry("Range missing start character on the left"))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\s*+/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stopper)) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\.\.")
}))) { ($C) } else { () }
}))) {
$C->_PATTERN(qr/\G\S/)
} else { () }
};
}))) { ($C) } else { () }
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->sorry("Range missing stop character on the right"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
scalar(do {
$::CCSTATE = '..'}, $C)
} else { () }
});
}
;
## token escape:sym<-> { '-' <?{ $*CCSTATE ne '' }> \s* <!stopper> \S <.obs('- as character range','..'
sub escape__S_004Minus__PEEK { $_[0]->_AUTOLEXpeek('escape__S_004Minus', $retree) }
sub escape__S_004Minus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_004Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-";
$self->_MATCHIFYr($S, "escape__S_004Minus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\-"))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::CCSTATE ne '' })
}))
and ($C) = ($C->_PATTERN(qr/\G\s*+/))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stopper)) { ($C) } else { () }
}))
and ($C) = ($C->_PATTERN(qr/\G\S/))
and ($C) = ($C->obs('- as character range','..'))) {
$C
} else { () }
});
}
;
## token escape:ch { $<ch> = [\S] <.ccstate($<ch>.Str)> }
sub escape__S_005ch__PEEK { $_[0]->_AUTOLEXpeek('escape__S_005ch', $retree) }
sub escape__S_005ch {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE escape__S_005ch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "ch";
$self->_MATCHIFYr($S, "escape__S_005ch", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['ch'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
$C->_PATTERN(qr/\G\S/)
})
}))
and ($C) = (do {
my $M = $C;
$C->ccstate($M->{'ch'}->Str)
})) {
$C
} else { () }
});
}
;
## token backslash:stopper { <text=.stopper> }
sub backslash__S_006stopper__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_006stopper', $retree) }
sub backslash__S_006stopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_006stopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "stopper";
$self->_MATCHIFYr($S, "backslash__S_006stopper", $C->_SUBSUMEr(['text'], sub {
my $C = shift;
$C->stopper
}));
}
;
## token backslash:a { :i <sym> }
sub backslash__S_007a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_007a', $retree) }
sub backslash__S_007a {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_007a");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "a";
$self->_MATCHIFYr($S, "backslash__S_007a", $C->_PATTERN(qr/\G(?i:a)/));
}
;
## token backslash:b { :i <sym> }
sub backslash__S_008b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_008b', $retree) }
sub backslash__S_008b {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_008b");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "b";
$self->_MATCHIFYr($S, "backslash__S_008b", $C->_PATTERN(qr/\G(?i:b)/));
}
;
## token backslash:c { :i <sym> <charspec> }
sub backslash__S_009c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_009c', $retree) }
sub backslash__S_009c {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_009c");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "c";
$self->_MATCHIFYr($S, "backslash__S_009c", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:c)/))) {
$C->_SUBSUMEr(['charspec'], sub {
my $C = shift;
$C->charspec
})
} else { () }
});
}
;
## token backslash:d { :i <sym> { $*CCSTATE = '' } }
sub backslash__S_010d__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_010d', $retree) }
sub backslash__S_010d {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_010d");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "d";
$self->_MATCHIFYr($S, "backslash__S_010d", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:d)/))) {
scalar(do {
$::CCSTATE = '' }, $C)
} else { () }
});
}
;
## token backslash:e { :i <sym> }
sub backslash__S_011e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_011e', $retree) }
sub backslash__S_011e {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_011e");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "e";
$self->_MATCHIFYr($S, "backslash__S_011e", $C->_PATTERN(qr/\G(?i:e)/));
}
;
## token backslash:f { :i <sym> }
sub backslash__S_012f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_012f', $retree) }
sub backslash__S_012f {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_012f");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "f";
$self->_MATCHIFYr($S, "backslash__S_012f", $C->_PATTERN(qr/\G(?i:f)/));
}
;
## token backslash:h { :i <sym> { $*CCSTATE = '' } }
sub backslash__S_013h__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_013h', $retree) }
sub backslash__S_013h {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_013h");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "h";
$self->_MATCHIFYr($S, "backslash__S_013h", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:h)/))) {
scalar(do {
$::CCSTATE = '' }, $C)
} else { () }
});
}
;
## token backslash:n { :i <sym> }
sub backslash__S_014n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_014n', $retree) }
sub backslash__S_014n {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_014n");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "n";
$self->_MATCHIFYr($S, "backslash__S_014n", $C->_PATTERN(qr/\G(?i:n)/));
}
;
## token backslash:o { :i :dba('octal character') <sym> [ <octint> | '[' ~ ']' <octints> ] }
sub backslash__S_015o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_015o', $retree) }
sub backslash__S_015o {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_015o");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "o";
$self->_MATCHIFYr($S, "backslash__S_015o", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:o)/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_015o_0') {
        $C->deb("Fate passed to backslash__S_015o_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT backslash__S_015o_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM backslash__S_015o_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Q::cc', 'backslash__S_015o_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("backslash__S_015o_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
;

if (($C) = ($C->_PATTERN(qr/\G(?i:\[)/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['octints'], sub {
my $C = shift;
$C->octints
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G(?i:\])/)
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'octal character', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token backslash:r { :i <sym> }
sub backslash__S_016r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_016r', $retree) }
sub backslash__S_016r {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_016r");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "r";
$self->_MATCHIFYr($S, "backslash__S_016r", $C->_PATTERN(qr/\G(?i:r)/));
}
;
## token backslash:s { :i <sym> { $*CCSTATE = '' } }
sub backslash__S_017s__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_017s', $retree) }
sub backslash__S_017s {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_017s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "s";
$self->_MATCHIFYr($S, "backslash__S_017s", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:s)/))) {
scalar(do {
$::CCSTATE = '' }, $C)
} else { () }
});
}
;
## token backslash:t { :i <sym> }
sub backslash__S_018t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_018t', $retree) }
sub backslash__S_018t {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_018t");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "t";
$self->_MATCHIFYr($S, "backslash__S_018t", $C->_PATTERN(qr/\G(?i:t)/));
}
;
## token backslash:v { :i <sym> { $*CCSTATE = '' } }
sub backslash__S_019v__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_019v', $retree) }
sub backslash__S_019v {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_019v");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "v";
$self->_MATCHIFYr($S, "backslash__S_019v", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:v)/))) {
scalar(do {
$::CCSTATE = '' }, $C)
} else { () }
});
}
;
## token backslash:w { :i <sym> { $*CCSTATE = '' } }
sub backslash__S_020w__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_020w', $retree) }
sub backslash__S_020w {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_020w");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "w";
$self->_MATCHIFYr($S, "backslash__S_020w", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:w)/))) {
scalar(do {
$::CCSTATE = '' }, $C)
} else { () }
});
}
;
## token backslash:x { :i :dba('hex character') <sym> [ <hexint> | '[' ~ ']' <hexints> ] }
sub backslash__S_021x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_021x', $retree) }
sub backslash__S_021x {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_021x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "x";
$self->_MATCHIFYr($S, "backslash__S_021x", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:x)/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_021x_0') {
        $C->deb("Fate passed to backslash__S_021x_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT backslash__S_021x_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM backslash__S_021x_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Q::cc', 'backslash__S_021x_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("backslash__S_021x_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
;

if (($C) = ($C->_PATTERN(qr/\G(?i:\[)/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['hexints'], sub {
my $C = shift;
$C->hexints
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G(?i:\])/)
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'hex character', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token backslash:sym<0> { <sym> }
sub backslash__S_0220__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_0220', $retree) }
sub backslash__S_0220 {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_0220");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "backslash__S_0220", $C->_EXACT("0"));
}
;
## token backslash:misc { {} [ (\W) { $<text> = $0.Str; } | $<x>=(\w) <.sorry("Unrecognized backslash s
sub backslash__S_023misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_023misc', $retree) }
sub backslash__S_023misc {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_023misc");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "misc";
$self->_MATCHIFYr($S, "backslash__S_023misc", do {
my $C = $C;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_023misc_0') {
        $C->deb("Fate passed to backslash__S_023misc_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT backslash__S_023misc_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM backslash__S_023misc_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Q::cc', 'backslash__S_023misc_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("backslash__S_023misc_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\W/)

})
}))) {
scalar(do {
my $M = $C;
$M->{'text'} = $M->{0}->Str}, $C)
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['x'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)

})
}))
and ($C) = (do {
my $M = $C;
$C->sorry("Unrecognized backslash sequence: '\\" . $M->{'x'}->Str . "'")
})) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## method tweak (:single(:$q)!)
;
## method tweak (:double(:$qq)!)
;
## method tweak (:cclass(:$cc)!)
;
 moose_around tweak  => sub {
    my $orig = shift;
    no warnings 'recursion';
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{single} || exists $args{q};
my $q = exists $args{single} ? delete $args{single} : exists $args{q} ? delete $args{q} : undef;
$self->panic("Too late for :q")     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{double} || exists $args{qq};
my $qq = exists $args{double} ? delete $args{double} : exists $args{qq} ? delete $args{qq} : undef;
$self->panic("Too late for :qq")     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{cclass} || exists $args{cc};
my $cc = exists $args{cclass} ? delete $args{cclass} : exists $args{cc} ? delete $args{cc} : undef;
$self->panic("Too late for :cc")     };
}
    $orig->(@_);
};

 1; };
{ package STD::Q::p5;
use Moose::Role ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

## method tweak (:$g!)
;
## method tweak (:$i!)
;
## method tweak (:$m!)
;
## method tweak (:$s!)
;
## method tweak (:$x!)
;
## method tweak (:$p!)
;
## method tweak (:$c!)
;
 moose_around tweak  => sub {
    my $orig = shift;
    no warnings 'recursion';
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{g};
my $g = exists $args{g} ? delete $args{g} : undef;
$self     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{i};
my $i = exists $args{i} ? delete $args{i} : undef;
$self     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{m};
my $m = exists $args{m} ? delete $args{m} : undef;
$self     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{s};
my $s = exists $args{s} ? delete $args{s} : undef;
$self     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{x};
my $x = exists $args{x} ? delete $args{x} : undef;
$self     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{p};
my $p = exists $args{p} ? delete $args{p} : undef;
$self     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{c};
my $c = exists $args{c} ? delete $args{c} : undef;
$self     };
}
    $orig->(@_);
};

 1; };
## method tweak (:single(:$q)!)
;
## method tweak (:double(:$qq)!)
;
## method tweak (:cclass(:$cc)!)
;
## method tweak (:backslash(:$b)!)
;
## method tweak (:scalar(:$s)!)
;
## method tweak (:array(:$a)!)
;
## method tweak (:hash(:$h)!)
;
## method tweak (:function(:$f)!)
;
## method tweak (:closure(:$c)!)
;
## method tweak (:path(:$p)!)
;
## method tweak (:exec(:$x)!)
;
## method tweak (:words(:$w)!)
;
## method tweak (:quotewords(:$ww)!)
;
## method tweak (:heredoc(:$to)!)
;
## method tweak (:$regex!)
;
## method tweak (*%x)
;
 moose_around tweak  => sub {
    my $orig = shift;
    no warnings 'recursion';
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{single} || exists $args{q};
my $q = exists $args{single} ? delete $args{single} : exists $args{q} ? delete $args{q} : undef;
$self->truly($q,':q');
$self->mixin( 'STD::Q::q' );
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{double} || exists $args{qq};
my $qq = exists $args{double} ? delete $args{double} : exists $args{qq} ? delete $args{qq} : undef;
$self->truly($qq, ':qq');
$self->mixin( 'STD::Q::qq' );
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{cclass} || exists $args{cc};
my $cc = exists $args{cclass} ? delete $args{cclass} : exists $args{cc} ? delete $args{cc} : undef;
$self->truly($cc, ':cc');
$self->mixin( 'STD::Q::cc' );
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{backslash} || exists $args{b};
my $b = exists $args{backslash} ? delete $args{backslash} : exists $args{b} ? delete $args{b} : undef;
$self->mixin($b ? 'STD::Q::b1' : 'STD::Q::b0')     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{scalar} || exists $args{s};
my $s = exists $args{scalar} ? delete $args{scalar} : exists $args{s} ? delete $args{s} : undef;
$self->mixin($s ? 'STD::Q::s1' : 'STD::Q::s0')     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{array} || exists $args{a};
my $a = exists $args{array} ? delete $args{array} : exists $args{a} ? delete $args{a} : undef;
$self->mixin($a ? 'STD::Q::a1' : 'STD::Q::a0')     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{hash} || exists $args{h};
my $h = exists $args{hash} ? delete $args{hash} : exists $args{h} ? delete $args{h} : undef;
$self->mixin($h ? 'STD::Q::h1' : 'STD::Q::h0')     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{function} || exists $args{f};
my $f = exists $args{function} ? delete $args{function} : exists $args{f} ? delete $args{f} : undef;
$self->mixin($f ? 'STD::Q::f1' : 'STD::Q::f0')     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{closure} || exists $args{c};
my $c = exists $args{closure} ? delete $args{closure} : exists $args{c} ? delete $args{c} : undef;
$self->mixin($c ? 'STD::Q::c1' : 'STD::Q::c0')     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{path} || exists $args{p};
my $p = exists $args{path} ? delete $args{path} : exists $args{p} ? delete $args{p} : undef;
$self->mixin($p ? 'STD::Q::p1' : 'STD::Q::p0')     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{exec} || exists $args{x};
my $x = exists $args{exec} ? delete $args{exec} : exists $args{x} ? delete $args{x} : undef;
$self->mixin($x ? 'STD::Q::x1' : 'STD::Q::x0')     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{words} || exists $args{w};
my $w = exists $args{words} ? delete $args{words} : exists $args{w} ? delete $args{w} : undef;
$self->mixin($w ? 'STD::Q::w1' : 'STD::Q::w0')     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{quotewords} || exists $args{ww};
my $ww = exists $args{quotewords} ? delete $args{quotewords} : exists $args{ww} ? delete $args{ww} : undef;
$self->mixin($ww ? 'STD::Q::ww1' : 'STD::Q::ww0')     };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{heredoc} || exists $args{to};
my $to = exists $args{heredoc} ? delete $args{heredoc} : exists $args{to} ? delete $args{to} : undef;
$self->truly($to, ':to');
$self->cursor_herelang;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{regex};
my $regex = exists $args{regex} ? delete $args{regex} : undef;
return $::LANG{'Regex'}    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
my %x = %args;
my @k = keys(%x);
$self->sorry("Unrecognized quote modifier: " . join('',@k));
    };
}
    $orig->(@_);
};

 1; };
{ package STD::Quasi;
use Moose ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc
moose_extends('STD::P6');

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
term__S_000unquote: !!perl/hash:RE_ast
  dba: term
  min: 61725
  re: !!perl/hash:RE_sequence
    min: 61725
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: starter
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: starter
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: starter
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_first
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          min: 49380
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: EXPR
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: stopper
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: stopper
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: stopper
            rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
RETREE_END
## token term:unquote {
sub term__S_000unquote__PEEK { $_[0]->_AUTOLEXpeek('term__S_000unquote', $retree) }
sub term__S_000unquote {
no warnings 'recursion';
my $self = shift;

local $::QUASIMODO = 0;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_000unquote");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'starter'} = [];
$C->{'stopper'} = [];
$C->{sym} = "unquote";
$self->_MATCHIFYr($S, "term__S_000unquote", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))
and ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))
and ($C) = ($C->_SUBSUMEr(['starter'], sub {
my $C = shift;
$C->starter
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))
and ($C) = ($C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
}))) {
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Confused"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## method tweak (:$ast!)
;
## method tweak (:$lang!)
;
## method tweak (:$unquote!)
;
## method tweak (:$COMPILING!)
;
## method tweak (*%x)
;
 moose_around tweak  => sub {
    my $orig = shift;
    no warnings 'recursion';
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{ast};
my $ast = exists $args{ast} ? delete $args{ast} : undef;
$self    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{lang};
my $lang = exists $args{lang} ? delete $args{lang} : undef;
$self->cursor_fresh( $lang )    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{unquote};
my $unquote = exists $args{unquote} ? delete $args{unquote} : undef;
$self    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{COMPILING};
my $COMPILING = exists $args{COMPILING} ? delete $args{COMPILING} : undef;
$::QUASIMODO = 1;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
my %x = %args;
my @k = keys(%x);
$self->sorry("Unrecognized quasiquote modifier: " . join('',@k));
    };
}
    $orig->(@_);
};

 1; };
## method EXPR ($preclvl?)
sub EXPR {
no warnings 'recursion';
my $self = shift;
my $preclvl = @_ ? shift() : undef;
local $::CTX = $self->callm if $::DEBUG & DEBUG::trace_call;
my $preclim = $preclvl ? $preclvl->{'prec'} // $LOOSEST : $LOOSEST;
local $::LEFTSIGIL = '';
local $::PRECLIM = $preclim;
my @termstack;
my @opstack;
my $termish = 'termish';
push @opstack, {
'O' => \%terminator, 'sym' => '' };
my $here = $self;
my $S = $here->{'_pos'};
$self->deb("In EXPR, at $S") if $::DEBUG & DEBUG::EXPR;
my $reduce = sub{
$self->deb("entering reduce, termstack == ", 0+@termstack, " opstack == ", 0+@opstack) if $::DEBUG & DEBUG::EXPR;
my $op = pop @opstack;
my $sym = $op->{'sym'};
given ($op->{'O'}->{'assoc'} // 'unary') {
when ('chain') {
$self->deb("reducing chain") if $::DEBUG & DEBUG::EXPR;
my @chain;
push @chain, pop(@termstack);
push @chain, $op;
while (@opstack) {
last if $op->{'O'}->{'prec'} ne $opstack[-1]->{'O'}->{'prec'};
push @chain, pop(@termstack);
push @chain, pop(@opstack);
}
                ;
push @chain, pop(@termstack);
for (@chain) {
delete $_->{'_xact'}}
                ;
my $endpos = $chain[0]->{'_pos'};
@chain = reverse @chain if @chain > 1;
my $startpos = $chain[0]->{'_from'};
my $nop = $op->cursor_fresh();
$nop->{'chain'} = [@chain];
$nop->{'_arity'} = 'CHAIN';
$nop->{'_from'} = $startpos;
$nop->{'_pos'} = $endpos;
my @caps;
my $i = 0;
for (@chain) {
push(@caps, $i++ % 2 ? 'op' : 'term' );
push(@caps, $_);
}
                ;
$nop->{'~CAPS'} = \@caps;
push @termstack, $nop->_REDUCE($startpos, 'CHAIN');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
            ;
when ('list') {
$self->deb("reducing list") if $::DEBUG & DEBUG::EXPR;
my @list;
my @delims = $op;
push @list, pop(@termstack);
while (@opstack) {
$self->deb($sym . " vs " . $opstack[-1]->{'sym'}) if $::DEBUG & DEBUG::EXPR;
last if $sym ne $opstack[-1]->{'sym'};
if (@termstack and defined $termstack[0]) {
push @list, pop(@termstack)}
else {
$self->worry("Missing term in " . $sym . " list")};
push @delims, pop(@opstack);
}
                ;
if (@termstack and defined $termstack[0]) {
push @list, pop(@termstack)}
else {
$self->worry("Missing final term in '" . $sym . "' list")};
for (@list) {
delete $_->{'_xact'}}
                ;
for (@delims) {
delete $_->{'_xact'}}
                ;
my $endpos = $list[0]->{'_pos'};
@list = reverse @list if @list > 1;
my $startpos = $list[0]->{'_from'};
@delims = reverse @delims if @delims > 1;
my $nop = $op->cursor_fresh();
$nop->{'sym'} = $sym;
$nop->{'O'} = $op->{'O'};
$nop->{'list'} = [@list];
$nop->{'delims'} = [@delims];
$nop->{'_arity'} = 'LIST';
$nop->{'_from'} = $startpos;
$nop->{'_pos'} = $endpos;
if (@list) {
my @caps;
push @caps, 'elem', $list[0] if $list[0];
for (0..@delims-1) {
my $d = $delims[$_];
my $l = $list[$_+1];
push @caps, 'delim', $d;
push @caps, 'elem', $l if $l;
}
                    ;
$nop->{'~CAPS'} = \@caps;
};
push @termstack, $nop->_REDUCE($startpos, 'LIST');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
            ;
when ('unary') {
$self->deb("reducing") if $::DEBUG & DEBUG::EXPR;
$self->deb("Termstack size: ", 0+@termstack) if $::DEBUG & DEBUG::EXPR;
$self->deb($op->dump) if $::DEBUG & DEBUG::EXPR;
my $nop = $op->cursor_fresh();
my $arg = pop @termstack;
delete $arg->{'_xact'};
$op->{'arg'} = $arg;
my $a = $op->{'~CAPS'};
$op->{'_arity'} = 'UNARY';
if ($arg->{'_from'} < $op->{'_from'}) {
$op->{'_from'} = $arg->{'_from'};
unshift @$a, 'arg', $arg;
push @termstack, $op->_REDUCE($op->{'_from'}, 'POSTFIX');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
elsif ($arg->{'_pos'} > $op->{'_pos'}) {
$op->{'_pos'} = $arg->{'_pos'};
push @$a, 'arg', $arg;
push @termstack, $op->_REDUCE($op->{'_from'}, 'PREFIX');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
};
}
            ;
default {
$self->deb("reducing") if $::DEBUG & DEBUG::EXPR;
$self->deb("Termstack size: ", 0+@termstack) if $::DEBUG & DEBUG::EXPR;
my $right = pop @termstack;
my $left = pop @termstack;
delete $right->{'_xact'};
delete $left->{'_xact'};
$op->{'right'} = $right;
$op->{'left'} = $left;
$op->{'_from'} = $left->{'_from'};
$op->{'_pos'} = $right->{'_pos'};
$op->{'_arity'} = 'BINARY';
my $a = $op->{'~CAPS'};
unshift @$a, 'left', $left;
push @$a, 'right', $right;
$self->deb($op->dump) if $::DEBUG & DEBUG::EXPR;
my $ck;
if ($ck = $op->{'O'}->{'_reducecheck'}) {
$op = $op->$ck};
push @termstack, $op->_REDUCE($op->{'_from'}, 'INFIX');
delete $termstack[-1]->{'PRE'};
delete $termstack[-1]->{'POST'};
}
        ;
}
    ;
};
TERM:
    for (;;) {
$self->deb("In loop, at ", $here->{'_pos'}) if $::DEBUG & DEBUG::EXPR;
my $oldpos = $here->{'_pos'};
$here = $here->cursor_fresh();
$::LEFTSIGIL = $opstack[-1]->{'O'}->{'prec'} gt $item_assignment_prec ? '@' : '';
my @t = $here->$termish;
if (not @t or not $here = $t[0] or ($here->{'_pos'} == $oldpos and $termish eq 'termish')) {
$here->panic("Bogus term") if @opstack > 1;
return ();
};
$termish = 'termish';
my $PRE = delete $here->{'PRE'} // [];
my $POST = delete $here->{'POST'} // [];
my @PRE = @$PRE;
my @POST = reverse @$POST;
my $M = $here;
while (@PRE and @POST) {
my $postO = $POST[0]->{'O'};
my $preO = $PRE[0]->{'O'};
if ($postO->{'prec'} lt $preO->{'prec'}) {
push @opstack, shift @POST}
elsif ($postO->{'prec'} gt $preO->{'prec'}) {
push @opstack, shift @PRE}
elsif ($postO->{'uassoc'} eq 'left') {
push @opstack, shift @POST}
elsif ($postO->{'uassoc'} eq 'right') {
push @opstack, shift @PRE}
else {
$here->sorry('"' . $PRE[0]->{'sym'} . '" and "' . $POST[0]->{'sym'} . '" are not associative')};
}
        ;
push @opstack, @PRE,@POST;
push @termstack, $here->{'term'};
delete $termstack[-1]->{'POST'};
$self->deb("after push: " . (0+@termstack)) if $::DEBUG & DEBUG::EXPR;
last TERM if $preclim eq $methodcall_prec;
for (;;) {
$oldpos = $here->{'_pos'};
last TERM if ($::MEMOS[$oldpos]->{'endstmt'} // 0) == 2;
$here = $here->cursor_fresh->ws;
my @infix = $here->cursor_fresh->infixish();
last TERM unless @infix;
my $infix = $infix[0];
last TERM unless $infix->{'_pos'} > $oldpos;
if (not $infix->{'sym'}) {
die $infix->dump if $::DEBUG & DEBUG::EXPR};
my $inO = $infix->{'O'};
my $inprec = $inO->{'prec'};
if (not defined $inprec) {
$self->deb("No prec given in infix!") if $::DEBUG & DEBUG::EXPR;
die $infix->dump if $::DEBUG & DEBUG::EXPR;
$inprec = $terminator{'prec'};
};
if ($inprec le $preclim) {
if ($preclim ne $LOOSEST) {
my $dba = $preclvl->{'dba'};
my $h = $::HIGHEXPECT;
%$h = ();
$h->{"an infix operator with precedence tighter than $dba"} = 1;
};
last TERM;
};
$here = $infix->cursor_fresh->ws();
$inO->{'prec'} = $inO->{'sub'} if $inO->{'sub'};
while ($opstack[-1]->{'O'}->{'prec'} gt $inprec) {
$reduce->()}

            # Not much point in reducing the sentinels...
            ;
last if $inprec lt $LOOSEST;
if ($infix->{'fake'}) {
push @opstack, $infix;
$reduce->();
next;
};
if ($opstack[-1]->{'O'}->{'prec'} eq $inprec) {
my $assoc = 1;
given ($inO->{'assoc'}) {
when ('non')   {
$assoc = 0}
                    ;
when ('left')  {
$reduce->() }
                    ;
when ('right') {
}
                    ;
when ('chain') {
}
                    ;
when ('unary') {
}
                    ;
when ('list')  {
$assoc = 0 unless $infix->{'sym'} eq $opstack[-1]->{'sym'}}
                    ;
default {
$here->panic('Unknown associativity "' . $_ . '" for "' . $infix->{'sym'} . '"') }
                ;
}
                ;
if (not $assoc) {
$here->sorry('"' . $opstack[-1]->{'sym'} . '" and "' . $infix->Str . '" are non-associative and require parens')};
};
$termish = $inO->{'nextterm'} if $inO->{'nextterm'};
push @opstack, $infix;
last;
};
};
$reduce->() while 0+@opstack > 1;
if (@termstack) {
0+@termstack == 1 or $here->panic("Internal operator parser error, termstack == " . (0+@termstack));
$termstack[0]->{'_from'} = $self->{'_pos'};
$termstack[0]->{'_pos'} = $here->{'_pos'};
};
$self->_MATCHIFYr($S, "EXPR", @termstack);
};
{ package STD::Regex;
use Moose ':all' => { -prefix => "moose_" };
use Cursor; # for DEBUG::, etc
moose_extends('STD');

no warnings 'qw', 'recursion';
my $retree;

$DB::deep = $DB::deep = 1000; # suppress used-once warning

use YAML::XS;

$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'STD'->lineof($::LASTSTATE), "
" } if $::DEBUG;

$retree = YAML::XS::Load(Encode::encode_utf8(<<'RETREE_END'));
---
assertion__S_071DotDotDot: !!perl/hash:RE_ast
  dba: assertion
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: '...'
assertion__S_072QuestionQuestionQuestion: !!perl/hash:RE_ast
  dba: assertion
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: ???
assertion__S_073BangBangBang: !!perl/hash:RE_ast
  dba: assertion
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: '!!!'
assertion__S_074Question: !!perl/hash:RE_ast
  dba: assertion
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '?'
    - !!perl/hash:RE_bracket
      min: 0
      re: &1 !!perl/hash:RE_any
        altname: assertion__S_074Question_0
        dba: assertion
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          alt: assertion__S_074Question_0 0
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 1
              text: '>'
        - !!perl/hash:RE_method
          alt: assertion__S_074Question_0 1
          min: 12345
          name: assertion
          rest: ''
assertion__S_074Question_0: *1
assertion__S_075Bang: !!perl/hash:RE_ast
  dba: assertion
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '!'
    - !!perl/hash:RE_bracket
      min: 0
      re: &2 !!perl/hash:RE_any
        altname: assertion__S_075Bang_0
        dba: assertion
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          alt: assertion__S_075Bang_0 0
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 1
              text: '>'
        - !!perl/hash:RE_method
          alt: assertion__S_075Bang_0 1
          min: 12345
          name: assertion
          rest: ''
assertion__S_075Bang_0: *2
assertion__S_076Star: !!perl/hash:RE_ast
  dba: assertion
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '*'
    - !!perl/hash:RE_bracket
      min: 0
      re: &3 !!perl/hash:RE_any
        altname: assertion__S_076Star_0
        dba: assertion
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          alt: assertion__S_076Star_0 0
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 1
              text: '>'
        - !!perl/hash:RE_sequence
          alt: assertion__S_076Star_0 1
          min: 24690
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: nibbler
            rest: ''
assertion__S_076Star_0: *3
assertion__S_077Cur_Ly: !!perl/hash:RE_ast
  dba: assertion
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: embeddedblock
    rest: ''
assertion__S_078variable: !!perl/hash:RE_ast
  dba: assertion
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_method
          min: 12345
          name: sigil
          rest: ''
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_sequence
        min: 12345
        zyg:
        - !!perl/hash:RE_decl
          min: 0
        - !!perl/hash:RE_bindnamed
          atom: !!perl/hash:RE_method
            min: 12345
            name: EXPR
            rest: 1
          min: 12345
assertion__S_079method: !!perl/hash:RE_ast
  dba: assertion
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: .
    - !!perl/hash:RE_bracket
      min: 12345
      re: &4 !!perl/hash:RE_any
        altname: assertion__S_079method_0
        dba: assertion
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          alt: assertion__S_079method_0 0
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_method
                min: 12345
                name: alpha
                rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: assertion
            rest: ''
        - !!perl/hash:RE_bracket
          alt: assertion__S_079method_0 1
          min: 12345
          re: !!perl/hash:RE_sequence
            min: 12345
            zyg:
            - !!perl/hash:RE_decl
              min: 0
            - !!perl/hash:RE_method
              min: 12345
              name: dottyop
              rest: ''
assertion__S_079method_0: *4
assertion__S_080name: !!perl/hash:RE_ast
  dba: assertion
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_sequence
        min: 12345
        zyg:
        - !!perl/hash:RE_decl
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: longname
          rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 0
        re: &5 !!perl/hash:RE_any
          altname: assertion__S_080name_0
          dba: assertion
          min: 0
          zyg:
          - !!perl/hash:RE_assertion
            alt: assertion__S_080name_0 0
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_string
                i: 0
                min: 1
                text: '>'
          - !!perl/hash:RE_sequence
            alt: assertion__S_080name_0 1
            min: 37035
            zyg:
            - !!perl/hash:RE_method
              min: 12345
              name: ws
              rest: ''
            - !!perl/hash:RE_method
              min: 12345
              name: nibbler
              rest: ''
            - !!perl/hash:RE_method
              min: 12345
              name: ws
              rest: ''
          - !!perl/hash:RE_sequence
            alt: assertion__S_080name_0 2
            min: 12346
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: =
            - !!perl/hash:RE_method
              min: 12345
              name: assertion
              rest: ''
          - !!perl/hash:RE_sequence
            alt: assertion__S_080name_0 3
            min: 24691
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: ':'
            - !!perl/hash:RE_method
              min: 12345
              name: ws
              rest: ''
            - !!perl/hash:RE_bracket
              min: 12345
              re: !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_decl
                  min: 0
                - !!perl/hash:RE_method
                  min: 12345
                  name: arglist
                  rest: ''
          - !!perl/hash:RE_sequence
            alt: assertion__S_080name_0 4
            min: 12347
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: (
            - !!perl/hash:RE_block
              min: 0
            - !!perl/hash:RE_bracket
              min: 12345
              re: !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_decl
                  min: 0
                - !!perl/hash:RE_method
                  min: 12345
                  name: arglist
                  rest: ''
            - !!perl/hash:RE_bracket
              min: 1
              re: !!perl/hash:RE_first
                min: 1
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 1
                  text: )
                - !!perl/hash:RE_method
                  min: 12345
                  name: panic
                  rest: 1
      min: 0
      quant:
      - '?'
assertion__S_080name_0: *5
assertion__S_081Bra: !!perl/hash:RE_ast
  dba: assertion
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: '['
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: cclass_elem
        rest: ''
      min: 12345
      quant:
      - +
assertion__S_082Plus: !!perl/hash:RE_ast
  dba: assertion
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: +
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: cclass_elem
        rest: ''
      min: 12345
      quant:
      - +
assertion__S_083Minus: !!perl/hash:RE_ast
  dba: assertion
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: '-'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: cclass_elem
        rest: ''
      min: 12345
      quant:
      - +
assertion__S_084Dot: !!perl/hash:RE_ast
  dba: assertion
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: .
assertion__S_085Comma: !!perl/hash:RE_ast
  dba: assertion
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: ','
assertion__S_086TildeTilde: !!perl/hash:RE_ast
  dba: assertion
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ~~
    - !!perl/hash:RE_bracket
      min: 0
      re: &6 !!perl/hash:RE_any
        altname: assertion__S_086TildeTilde_0
        dba: assertion
        min: 0
        zyg:
        - !!perl/hash:RE_assertion
          alt: assertion__S_086TildeTilde_0 0
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method_re
            min: 12345
            name: before
            nobind: 1
            re: !!perl/hash:RE_string
              i: 0
              min: 1
              text: '>'
        - !!perl/hash:RE_quantified_atom
          alt: assertion__S_086TildeTilde_0 1
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          min: 1
          quant:
          - +
        - !!perl/hash:RE_method
          alt: assertion__S_086TildeTilde_0 2
          min: 12345
          name: desigilname
          rest: ''
assertion__S_086TildeTilde_0: *6
assertion__S_087bogus: !!perl/hash:RE_ast
  dba: assertion
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: panic
    rest: 1
atom: !!perl/hash:RE_ast
  dba: regex atom
  min: 1
  re: !!perl/hash:RE_bracket
    min: 1
    re: &7 !!perl/hash:RE_any
      altname: atom_0
      dba: regex atom
      min: 1
      zyg:
      - !!perl/hash:RE_meta
        alt: atom_0 0
        min: 1
        text: \w
      - !!perl/hash:RE_sequence
        alt: atom_0 1
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          min: 12345
          name: metachar
          rest: ''
        - !!perl/hash:RE_meta
          min: 0
          text: '::'
atom_0: *7
backslash__S_046unspace: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      min: 12345
      name: SUPER::ws
      rest: ''
backslash__S_0470: !!perl/hash:RE_ast
  dba: backslash
  min: 1
  re: !!perl/hash:RE_sequence
    min: 1
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: '0'
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_cclass
          i: 0
          min: 1
          text: '[0..7]'
backslash__S_048A: !!perl/hash:RE_ast
  dba: backslash
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: A
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
backslash__S_049a: !!perl/hash:RE_ast
  dba: backslash
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: a
    - !!perl/hash:RE_method
      min: 12345
      name: sorry
      rest: 1
backslash__S_050B: !!perl/hash:RE_ast
  dba: backslash
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: B
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
backslash__S_051b: !!perl/hash:RE_ast
  dba: backslash
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: b
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
backslash__S_052c: !!perl/hash:RE_ast
  dba: backslash
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 1
      min: 12345
      name: sym
      rest: ''
      sym: c
    - !!perl/hash:RE_method
      min: 12345
      name: charspec
      rest: ''
backslash__S_053d: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 1
    min: 12345
    name: sym
    rest: ''
    sym: d
backslash__S_054e: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 1
    min: 12345
    name: sym
    rest: ''
    sym: e
backslash__S_055f: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 1
    min: 12345
    name: sym
    rest: ''
    sym: f
backslash__S_056h: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 1
    min: 12345
    name: sym
    rest: ''
    sym: h
backslash__S_057n: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 1
    min: 12345
    name: sym
    rest: ''
    sym: n
backslash__S_058o: !!perl/hash:RE_ast
  dba: octal character
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 1
      min: 12345
      name: sym
      rest: ''
      sym: o
    - !!perl/hash:RE_bracket
      min: 12345
      re: &8 !!perl/hash:RE_any
        altname: backslash__S_058o_0
        dba: octal character
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          alt: backslash__S_058o_0 0
          min: 12345
          name: octint
          rest: ''
        - !!perl/hash:RE_bracket
          alt: backslash__S_058o_0 1
          min: 12347
          re: !!perl/hash:RE_sequence
            min: 12347
            zyg:
            - !!perl/hash:RE_string
              i: 1
              min: 1
              text: '['
            - !!perl/hash:RE_block
              min: 0
            - !!perl/hash:RE_method
              min: 12345
              name: octints
              rest: ''
            - !!perl/hash:RE_bracket
              min: 1
              re: !!perl/hash:RE_first
                min: 1
                zyg:
                - !!perl/hash:RE_string
                  i: 1
                  min: 1
                  text: ']'
                - !!perl/hash:RE_method
                  min: 12345
                  name: FAILGOAL
                  rest: 1
backslash__S_058o_0: *8
backslash__S_059Q: !!perl/hash:RE_ast
  dba: backslash
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: Q
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
backslash__S_060r: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 1
    min: 12345
    name: sym
    rest: ''
    sym: r
backslash__S_061s: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 1
    min: 12345
    name: sym
    rest: ''
    sym: s
backslash__S_062t: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 1
    min: 12345
    name: sym
    rest: ''
    sym: t
backslash__S_063v: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 1
    min: 12345
    name: sym
    rest: ''
    sym: v
backslash__S_064w: !!perl/hash:RE_ast
  dba: backslash
  min: 12345
  re: !!perl/hash:RE_method
    i: 1
    min: 12345
    name: sym
    rest: ''
    sym: w
backslash__S_065x: !!perl/hash:RE_ast
  dba: hex character
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 1
      min: 12345
      name: sym
      rest: ''
      sym: x
    - !!perl/hash:RE_bracket
      min: 12345
      re: &9 !!perl/hash:RE_any
        altname: backslash__S_065x_0
        dba: hex character
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          alt: backslash__S_065x_0 0
          min: 12345
          name: hexint
          rest: ''
        - !!perl/hash:RE_bracket
          alt: backslash__S_065x_0 1
          min: 12347
          re: !!perl/hash:RE_sequence
            min: 12347
            zyg:
            - !!perl/hash:RE_string
              i: 1
              min: 1
              text: '['
            - !!perl/hash:RE_block
              min: 0
            - !!perl/hash:RE_method
              min: 12345
              name: hexints
              rest: ''
            - !!perl/hash:RE_bracket
              min: 1
              re: !!perl/hash:RE_first
                min: 1
                zyg:
                - !!perl/hash:RE_string
                  i: 1
                  min: 1
                  text: ']'
                - !!perl/hash:RE_method
                  min: 12345
                  name: FAILGOAL
                  rest: 1
backslash__S_065x_0: *9
backslash__S_066z: !!perl/hash:RE_ast
  dba: backslash
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: z
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
backslash__S_067Z: !!perl/hash:RE_ast
  dba: backslash
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: Z
    - !!perl/hash:RE_method
      min: 12345
      name: obs
      rest: 1
backslash__S_068misc: !!perl/hash:RE_ast
  dba: backslash
  min: 1
  re: !!perl/hash:RE_bindnamed
    atom: !!perl/hash:RE_paren
      min: 1
      re: !!perl/hash:RE_meta
        min: 1
        text: \W
    min: 1
backslash__S_069oldbackref: !!perl/hash:RE_ast
  dba: backslash
  min: 1
  re: !!perl/hash:RE_sequence
    min: 1
    zyg:
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        min: 1
        re: !!perl/hash:RE_sequence
          min: 1
          zyg:
          - !!perl/hash:RE_cclass
            i: 0
            min: 1
            text: '[1..9]'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \d
            min: 0
            quant:
            - '*'
      min: 1
    - !!perl/hash:RE_block
      min: 0
backslash__S_070oops: !!perl/hash:RE_ast
  dba: backslash
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: sorry
      rest: 1
    - !!perl/hash:RE_meta
      min: 1
      text: .
category__S_000metachar: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: metachar
category__S_001backslash: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: backslash
category__S_002assertion: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: assertion
category__S_003quantifier: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: quantifier
category__S_004mod_internal: !!perl/hash:RE_ast
  dba: category
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: mod_internal
cclass_elem: !!perl/hash:RE_ast
  dba: character class element
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: sign
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: normspace
        rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_bracket
      min: 12345
      re: &10 !!perl/hash:RE_any
        altname: cclass_elem_0
        dba: character class element
        min: 12345
        zyg:
        - !!perl/hash:RE_method
          alt: cclass_elem_0 0
          min: 12345
          name: name
          rest: ''
        - !!perl/hash:RE_sequence
          alt: cclass_elem_0 1
          min: 24690
          zyg:
          - !!perl/hash:RE_method_re
            min: 12345
            name: before
            re: !!perl/hash:RE_string
              i: 0
              min: 1
              text: '['
          - !!perl/hash:RE_method
            min: 12345
            name: quibble
            rest: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: normspace
        rest: ''
      min: 0
      quant:
      - '?'
cclass_elem_0: *10
infixish: !!perl/hash:RE_ast
  dba: infixish
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        min: 12345
        name: infixstopper
        rest: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        min: 12345
        name: stdstopper
        rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: regex_infix
      rest: ''
    - !!perl/hash:RE_block
      min: 0
infixstopper: !!perl/hash:RE_ast
  dba: infix stopper
  min: 0
  re: !!perl/hash:RE_bracket
    min: 0
    re: &11 !!perl/hash:RE_any
      altname: infixstopper_0
      dba: infix stopper
      min: 0
      zyg:
      - !!perl/hash:RE_assertion
        alt: infixstopper_0 0
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method_re
          min: 12345
          name: before
          nobind: 1
          re: !!perl/hash:RE_cclass
            i: 0
            min: 1
            text: '[\) \} \]]'
      - !!perl/hash:RE_assertion
        alt: infixstopper_0 1
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method_re
          min: 12345
          name: before
          nobind: 1
          re: !!perl/hash:RE_sequence
            min: 2
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: '>'
            - !!perl/hash:RE_cclass
              i: 0
              min: 1
              text: -[>)]
      - !!perl/hash:RE_assertion
        alt: infixstopper_0 2
        assert: '?'
        min: 0
        re: !!perl/hash:RE_method_re
          min: 12345
          name: before
          nobind: 1
          re: !!perl/hash:RE_method
            min: 12345
            name: stopper
            rest: ''
infixstopper_0: *11
metachar__S_010Gt: !!perl/hash:RE_ast
  dba: metachar
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: '>'
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: '>'
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_method
      min: 12345
      name: fail
      rest: ''
metachar__S_011AmpAmp: !!perl/hash:RE_ast
  dba: metachar
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: '&&'
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_method
      min: 12345
      name: fail
      rest: ''
metachar__S_012Amp: !!perl/hash:RE_ast
  dba: metachar
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: '&'
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_method
      min: 12345
      name: fail
      rest: ''
metachar__S_013VertVert: !!perl/hash:RE_ast
  dba: metachar
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: '||'
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_method
      min: 12345
      name: fail
      rest: ''
metachar__S_014Vert: !!perl/hash:RE_ast
  dba: metachar
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: '|'
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_method
      min: 12345
      name: fail
      rest: ''
metachar__S_015Ket: !!perl/hash:RE_ast
  dba: metachar
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: ']'
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_method
      min: 12345
      name: fail
      rest: ''
metachar__S_016Thesis: !!perl/hash:RE_ast
  dba: metachar
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: )
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_method
      min: 12345
      name: fail
      rest: ''
metachar__S_017Semi: !!perl/hash:RE_ast
  dba: metachar
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: ;
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_first
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_sequence
                min: 12345
                zyg:
                - !!perl/hash:RE_quantified_atom
                  atom: !!perl/hash:RE_meta
                    min: 1
                    text: \N
                  min: 0
                  quant:
                  - '*'
                - !!perl/hash:RE_method
                  min: 12345
                  name: stopper
                  rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: .
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
metachar__S_018quant: !!perl/hash:RE_ast
  dba: metachar
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: quantifier
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: sorry
      rest: 1
metachar__S_019sigwhite: !!perl/hash:RE_ast
  dba: metachar
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: normspace
    rest: ''
metachar__S_020unsp: !!perl/hash:RE_ast
  dba: metachar
  min: 12345
  re: !!perl/hash:RE_method
    min: 12345
    name: unsp
    rest: ''
metachar__S_021Cur_Ly: !!perl/hash:RE_ast
  dba: metachar
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: '{'
    - !!perl/hash:RE_method
      min: 12345
      name: embeddedblock
      rest: ''
    - !!perl/hash:RE_block
      min: 0
metachar__S_022mod: !!perl/hash:RE_ast
  dba: metachar
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: mod_internal
      rest: ''
    - !!perl/hash:RE_block
      min: 0
metachar__S_023Minus: !!perl/hash:RE_ast
  dba: metachar
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: '-'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_block
        min: 0
        nobind: 1
    - !!perl/hash:RE_method
      min: 12345
      name: sorry
      rest: 1
metachar__S_024Colon: !!perl/hash:RE_ast
  dba: metachar
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ':'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
    - !!perl/hash:RE_method
      min: 12345
      name: panic
      rest: 1
metachar__S_025ColonColon: !!perl/hash:RE_ast
  dba: metachar
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: '::'
metachar__S_026ColonColonColon: !!perl/hash:RE_ast
  dba: metachar
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: ':::'
metachar__S_027Bra_Ket: !!perl/hash:RE_ast
  dba: bracketed regex
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_bracket
      min: 12347
      re: !!perl/hash:RE_sequence
        min: 12347
        zyg:
        - !!perl/hash:RE_string
          i: 0
          min: 1
          text: '['
        - !!perl/hash:RE_block
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: nibbler
          rest: ''
        - !!perl/hash:RE_bracket
          min: 1
          re: !!perl/hash:RE_first
            min: 1
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: ']'
            - !!perl/hash:RE_method
              min: 12345
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_block
      min: 0
metachar__S_028Paren_Thesis: !!perl/hash:RE_ast
  dba: capture parens
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_bracket
      min: 12347
      re: !!perl/hash:RE_sequence
        min: 12347
        zyg:
        - !!perl/hash:RE_string
          i: 0
          min: 1
          text: (
        - !!perl/hash:RE_block
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: nibbler
          rest: ''
        - !!perl/hash:RE_bracket
          min: 1
          re: !!perl/hash:RE_first
            min: 1
            zyg:
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: )
            - !!perl/hash:RE_method
              min: 12345
              name: FAILGOAL
              rest: 1
    - !!perl/hash:RE_block
      min: 0
metachar__S_029LtParen: !!perl/hash:RE_ast
  dba: metachar
  min: 2
  re: !!perl/hash:RE_string
    i: 0
    min: 2
    text: <(
metachar__S_030ThesisGt: !!perl/hash:RE_ast
  dba: metachar
  min: 2
  re: !!perl/hash:RE_string
    i: 0
    min: 2
    text: )>
metachar__S_031LtLt: !!perl/hash:RE_ast
  dba: metachar
  min: 2
  re: !!perl/hash:RE_string
    i: 0
    min: 2
    text: <<
metachar__S_032GtGt: !!perl/hash:RE_ast
  dba: metachar
  min: 2
  re: !!perl/hash:RE_string
    i: 0
    min: 2
    text: '>>'
metachar__S_033Fre: !!perl/hash:RE_ast
  dba: metachar
  min: 1
  re: !!perl/hash:RE_string
    i: 0
    min: 1
    text: «
metachar__S_034Nch: !!perl/hash:RE_ast
  dba: metachar
  min: 1
  re: !!perl/hash:RE_string
    i: 0
    min: 1
    text: »
metachar__S_035qw: !!perl/hash:RE_ast
  dba: metachar
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          min: 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: <
          - !!perl/hash:RE_meta
            min: 1
            text: \s
    - !!perl/hash:RE_method
      min: 12345
      name: circumfix
      rest: ''
metachar__S_036Lt_Gt: !!perl/hash:RE_ast
  dba: metachar
  min: 12347
  re: !!perl/hash:RE_bracket
    min: 12347
    re: !!perl/hash:RE_sequence
      min: 12347
      zyg:
      - !!perl/hash:RE_string
        i: 0
        min: 1
        text: <
      - !!perl/hash:RE_block
        min: 0
      - !!perl/hash:RE_method
        min: 12345
        name: assertion
        rest: ''
      - !!perl/hash:RE_bracket
        min: 1
        re: !!perl/hash:RE_first
          min: 1
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: '>'
          - !!perl/hash:RE_method
            min: 12345
            name: FAILGOAL
            rest: 1
metachar__S_037Back: !!perl/hash:RE_ast
  dba: metachar
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: \
    - !!perl/hash:RE_method
      min: 12345
      name: backslash
      rest: ''
metachar__S_038Dot: !!perl/hash:RE_ast
  dba: metachar
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: .
metachar__S_039CaretCaret: !!perl/hash:RE_ast
  dba: metachar
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: ^^
metachar__S_040Caret: !!perl/hash:RE_ast
  dba: metachar
  min: 12345
  re: !!perl/hash:RE_method
    i: 0
    min: 12345
    name: sym
    rest: ''
    sym: ^
metachar__S_041DollarDollar: !!perl/hash:RE_ast
  dba: metachar
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: $$
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12346
        re: !!perl/hash:RE_sequence
          min: 12346
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              min: 1
              re: !!perl/hash:RE_quantified_atom
                atom: !!perl/hash:RE_meta
                  min: 1
                  text: \w
                min: 1
                quant:
                - +
            min: 1
          - !!perl/hash:RE_method
            min: 12345
            name: obs
            rest: 1
      min: 0
      quant:
      - '?'
metachar__S_042Dollar: !!perl/hash:RE_ast
  dba: metachar
  min: 1
  re: !!perl/hash:RE_sequence
    min: 1
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: $
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &12 !!perl/hash:RE_any
          altname: metachar__S_042Dollar_0
          dba: metachar
          min: 0
          zyg:
          - !!perl/hash:RE_meta
            alt: metachar__S_042Dollar_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: metachar__S_042Dollar_0 1
            i: 0
            min: 1
            text: '|'
          - !!perl/hash:RE_string
            alt: metachar__S_042Dollar_0 2
            i: 0
            min: 1
            text: '&'
          - !!perl/hash:RE_string
            alt: metachar__S_042Dollar_0 3
            i: 0
            min: 1
            text: )
          - !!perl/hash:RE_string
            alt: metachar__S_042Dollar_0 4
            i: 0
            min: 1
            text: ']'
          - !!perl/hash:RE_string
            alt: metachar__S_042Dollar_0 5
            i: 0
            min: 1
            text: '>'
          - !!perl/hash:RE_meta
            alt: metachar__S_042Dollar_0 6
            min: 0
            text: $
          - !!perl/hash:RE_method
            alt: metachar__S_042Dollar_0 7
            min: 12345
            name: stopper
            rest: ''
metachar__S_042Dollar_0: *12
metachar__S_043Single_Single: !!perl/hash:RE_ast
  dba: metachar
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_double
          i: 0
          min: 1
          text: ''''
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_sequence
        min: 12345
        zyg:
        - !!perl/hash:RE_decl
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: quote
          rest: ''
metachar__S_044Double_Double: !!perl/hash:RE_ast
  dba: metachar
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 1
          text: '"'
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_sequence
        min: 12345
        zyg:
        - !!perl/hash:RE_decl
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: quote
          rest: ''
metachar__S_045var: !!perl/hash:RE_ast
  dba: metachar
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_string
          i: 0
          min: 2
          text: $$
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_method
          min: 12345
          name: sigil
          rest: ''
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_sequence
        min: 12345
        zyg:
        - !!perl/hash:RE_decl
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: termish
          rest: ''
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_quantified_atom
        atom: !!perl/hash:RE_paren
          min: 12346
          re: !!perl/hash:RE_sequence
            min: 12346
            zyg:
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                min: 1
                text: \s
              min: 0
              quant:
              - '*'
            - !!perl/hash:RE_string
              i: 0
              min: 1
              text: =
            - !!perl/hash:RE_quantified_atom
              atom: !!perl/hash:RE_meta
                min: 1
                text: \s
              min: 0
              quant:
              - '*'
            - !!perl/hash:RE_method
              min: 12345
              name: quantified_atom
              rest: ''
        min: 0
        quant:
        - '?'
      min: 0
    - !!perl/hash:RE_block
      min: 0
mod_arg: !!perl/hash:RE_ast
  dba: modifier argument
  min: 12347
  re: !!perl/hash:RE_bracket
    min: 12347
    re: !!perl/hash:RE_sequence
      min: 12347
      zyg:
      - !!perl/hash:RE_string
        i: 0
        min: 1
        text: (
      - !!perl/hash:RE_block
        min: 0
      - !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_decl
            min: 0
          - !!perl/hash:RE_method
            min: 12345
            name: semilist
            rest: ''
      - !!perl/hash:RE_bracket
        min: 1
        re: !!perl/hash:RE_first
          min: 1
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: )
          - !!perl/hash:RE_method
            min: 12345
            name: FAILGOAL
            rest: 1
mod_internal__S_088Colonmy: !!perl/hash:RE_ast
  dba: mod_internal
  min: 24691
  re: !!perl/hash:RE_sequence
    min: 24691
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: ':'
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          min: 3
          zyg:
          - !!perl/hash:RE_bracket
            min: 2
            re: &13 !!perl/hash:RE_any
              altname: mod_internal__S_088Colonmy_0
              dba: mod_internal
              min: 2
              zyg:
              - !!perl/hash:RE_string
                alt: mod_internal__S_088Colonmy_0 0
                i: 0
                min: 2
                text: my
              - !!perl/hash:RE_string
                alt: mod_internal__S_088Colonmy_0 1
                i: 0
                min: 5
                text: state
              - !!perl/hash:RE_string
                alt: mod_internal__S_088Colonmy_0 2
                i: 0
                min: 3
                text: our
              - !!perl/hash:RE_string
                alt: mod_internal__S_088Colonmy_0 3
                i: 0
                min: 4
                text: anon
              - !!perl/hash:RE_string
                alt: mod_internal__S_088Colonmy_0 4
                i: 0
                min: 8
                text: constant
              - !!perl/hash:RE_string
                alt: mod_internal__S_088Colonmy_0 5
                i: 0
                min: 4
                text: temp
              - !!perl/hash:RE_string
                alt: mod_internal__S_088Colonmy_0 6
                i: 0
                min: 3
                text: let
          - !!perl/hash:RE_meta
            min: 1
            text: \s
    - !!perl/hash:RE_bracket
      min: 24690
      re: !!perl/hash:RE_sequence
        min: 24690
        zyg:
        - !!perl/hash:RE_decl
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: statement
          rest: ''
        - !!perl/hash:RE_method
          min: 12345
          name: eat_terminator
          rest: ''
mod_internal__S_088Colonmy_0: *13
mod_internal__S_089Coloni: !!perl/hash:RE_ast
  dba: mod_internal
  min: 2
  re: !!perl/hash:RE_sequence
    min: 2
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        min: 2
        re: &14 !!perl/hash:RE_any
          altname: mod_internal__S_089Coloni_0
          dba: mod_internal
          min: 2
          zyg:
          - !!perl/hash:RE_string
            alt: mod_internal__S_089Coloni_0 0
            i: 0
            min: 2
            text: :i
          - !!perl/hash:RE_string
            alt: mod_internal__S_089Coloni_0 1
            i: 0
            min: 11
            text: :ignorecase
      min: 2
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_block
      min: 0
mod_internal__S_089Coloni_0: *14
mod_internal__S_090ColonBangi: !!perl/hash:RE_ast
  dba: mod_internal
  min: 3
  re: !!perl/hash:RE_sequence
    min: 3
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        min: 3
        re: &15 !!perl/hash:RE_any
          altname: mod_internal__S_090ColonBangi_0
          dba: mod_internal
          min: 3
          zyg:
          - !!perl/hash:RE_string
            alt: mod_internal__S_090ColonBangi_0 0
            i: 0
            min: 3
            text: :!i
          - !!perl/hash:RE_string
            alt: mod_internal__S_090ColonBangi_0 1
            i: 0
            min: 12
            text: :!ignorecase
      min: 3
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_block
      min: 0
mod_internal__S_090ColonBangi_0: *15
mod_internal__S_091ColoniParen_Thesis: !!perl/hash:RE_ast
  dba: mod_internal
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        min: 2
        re: &16 !!perl/hash:RE_any
          altname: mod_internal__S_091ColoniParen_Thesis_0
          dba: mod_internal
          min: 2
          zyg:
          - !!perl/hash:RE_string
            alt: mod_internal__S_091ColoniParen_Thesis_0 0
            i: 0
            min: 2
            text: :i
          - !!perl/hash:RE_string
            alt: mod_internal__S_091ColoniParen_Thesis_0 1
            i: 0
            min: 11
            text: :ignorecase
      min: 2
    - !!perl/hash:RE_method
      min: 12345
      name: mod_arg
      rest: ''
    - !!perl/hash:RE_block
      min: 0
mod_internal__S_091ColoniParen_Thesis_0: *16
mod_internal__S_092Colon0i: !!perl/hash:RE_ast
  dba: mod_internal
  min: 3
  re: !!perl/hash:RE_sequence
    min: 3
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: ':'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        min: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          min: 1
          quant:
          - +
      min: 1
    - !!perl/hash:RE_bracket
      min: 1
      re: &17 !!perl/hash:RE_any
        altname: mod_internal__S_092Colon0i_0
        dba: mod_internal
        min: 1
        zyg:
        - !!perl/hash:RE_string
          alt: mod_internal__S_092Colon0i_0 0
          i: 0
          min: 1
          text: i
        - !!perl/hash:RE_string
          alt: mod_internal__S_092Colon0i_0 1
          i: 0
          min: 10
          text: ignorecase
    - !!perl/hash:RE_block
      min: 0
mod_internal__S_092Colon0i_0: *17
mod_internal__S_093Colona: !!perl/hash:RE_ast
  dba: mod_internal
  min: 2
  re: !!perl/hash:RE_sequence
    min: 2
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        min: 2
        re: &18 !!perl/hash:RE_any
          altname: mod_internal__S_093Colona_0
          dba: mod_internal
          min: 2
          zyg:
          - !!perl/hash:RE_string
            alt: mod_internal__S_093Colona_0 0
            i: 0
            min: 2
            text: :a
          - !!perl/hash:RE_string
            alt: mod_internal__S_093Colona_0 1
            i: 0
            min: 13
            text: :ignoreaccent
      min: 2
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_block
      min: 0
mod_internal__S_093Colona_0: *18
mod_internal__S_094ColonBanga: !!perl/hash:RE_ast
  dba: mod_internal
  min: 3
  re: !!perl/hash:RE_sequence
    min: 3
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        min: 3
        re: &19 !!perl/hash:RE_any
          altname: mod_internal__S_094ColonBanga_0
          dba: mod_internal
          min: 3
          zyg:
          - !!perl/hash:RE_string
            alt: mod_internal__S_094ColonBanga_0 0
            i: 0
            min: 3
            text: :!a
          - !!perl/hash:RE_string
            alt: mod_internal__S_094ColonBanga_0 1
            i: 0
            min: 14
            text: :!ignoreaccent
      min: 3
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_block
      min: 0
mod_internal__S_094ColonBanga_0: *19
mod_internal__S_095ColonaParen_Thesis: !!perl/hash:RE_ast
  dba: mod_internal
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_bindnamed
      atom: !!perl/hash:RE_bracket
        min: 2
        re: &20 !!perl/hash:RE_any
          altname: mod_internal__S_095ColonaParen_Thesis_0
          dba: mod_internal
          min: 2
          zyg:
          - !!perl/hash:RE_string
            alt: mod_internal__S_095ColonaParen_Thesis_0 0
            i: 0
            min: 2
            text: :a
          - !!perl/hash:RE_string
            alt: mod_internal__S_095ColonaParen_Thesis_0 1
            i: 0
            min: 13
            text: :ignoreaccent
      min: 2
    - !!perl/hash:RE_method
      min: 12345
      name: mod_arg
      rest: ''
    - !!perl/hash:RE_block
      min: 0
mod_internal__S_095ColonaParen_Thesis_0: *20
mod_internal__S_096Colon0a: !!perl/hash:RE_ast
  dba: mod_internal
  min: 3
  re: !!perl/hash:RE_sequence
    min: 3
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: ':'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        min: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          min: 1
          quant:
          - +
      min: 1
    - !!perl/hash:RE_bracket
      min: 1
      re: &21 !!perl/hash:RE_any
        altname: mod_internal__S_096Colon0a_0
        dba: mod_internal
        min: 1
        zyg:
        - !!perl/hash:RE_string
          alt: mod_internal__S_096Colon0a_0 0
          i: 0
          min: 1
          text: a
        - !!perl/hash:RE_string
          alt: mod_internal__S_096Colon0a_0 1
          i: 0
          min: 12
          text: ignoreaccent
    - !!perl/hash:RE_block
      min: 0
mod_internal__S_096Colon0a_0: *21
mod_internal__S_097Colons: !!perl/hash:RE_ast
  dba: mod_internal
  min: 2
  re: !!perl/hash:RE_sequence
    min: 2
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: :s
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        min: 7
        text: igspace
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_block
      min: 0
mod_internal__S_098ColonBangs: !!perl/hash:RE_ast
  dba: mod_internal
  min: 3
  re: !!perl/hash:RE_sequence
    min: 3
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 3
      text: :!s
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        min: 7
        text: igspace
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_block
      min: 0
mod_internal__S_099ColonsParen_Thesis: !!perl/hash:RE_ast
  dba: mod_internal
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: :s
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        min: 7
        text: igspace
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: mod_arg
      rest: ''
    - !!perl/hash:RE_block
      min: 0
mod_internal__S_100Colon0s: !!perl/hash:RE_ast
  dba: mod_internal
  min: 3
  re: !!perl/hash:RE_sequence
    min: 3
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: ':'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        min: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          min: 1
          quant:
          - +
      min: 1
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: s
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        min: 7
        text: igspace
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_block
      min: 0
mod_internal__S_101Colonr: !!perl/hash:RE_ast
  dba: mod_internal
  min: 2
  re: !!perl/hash:RE_sequence
    min: 2
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: :r
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        min: 6
        text: atchet
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_block
      min: 0
mod_internal__S_102ColonBangr: !!perl/hash:RE_ast
  dba: mod_internal
  min: 3
  re: !!perl/hash:RE_sequence
    min: 3
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 3
      text: :!r
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        min: 6
        text: atchet
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_block
      min: 0
mod_internal__S_103ColonrParen_Thesis: !!perl/hash:RE_ast
  dba: mod_internal
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 2
      text: :r
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        min: 6
        text: atchet
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_method
      min: 12345
      name: mod_arg
      rest: ''
    - !!perl/hash:RE_block
      min: 0
mod_internal__S_104Colon0r: !!perl/hash:RE_ast
  dba: mod_internal
  min: 3
  re: !!perl/hash:RE_sequence
    min: 3
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: ':'
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        min: 1
        re: !!perl/hash:RE_quantified_atom
          atom: !!perl/hash:RE_meta
            min: 1
            text: \d
          min: 1
          quant:
          - +
      min: 1
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: r
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        min: 6
        text: atchet
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_meta
      min: 0
      text: »
    - !!perl/hash:RE_block
      min: 0
mod_internal__S_105ColonPerl5: !!perl/hash:RE_ast
  dba: mod_internal
  min: 24693
  re: !!perl/hash:RE_sequence
    min: 24693
    zyg:
    - !!perl/hash:RE_bracket
      min: 3
      re: &22 !!perl/hash:RE_any
        altname: mod_internal__S_105ColonPerl5_0
        dba: mod_internal
        min: 3
        zyg:
        - !!perl/hash:RE_string
          alt: mod_internal__S_105ColonPerl5_0 0
          i: 0
          min: 6
          text: :Perl5
        - !!perl/hash:RE_string
          alt: mod_internal__S_105ColonPerl5_0 1
          i: 0
          min: 3
          text: :P5
    - !!perl/hash:RE_method
      min: 12345
      name: require_P5
      rest: ''
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_sequence
        min: 12345
        zyg:
        - !!perl/hash:RE_decl
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: nibbler
          rest: ''
mod_internal__S_105ColonPerl5_0: *22
mod_internal__S_106p6adv: !!perl/hash:RE_ast
  dba: mod_internal
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_sequence
          min: 4
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: ':'
          - !!perl/hash:RE_bracket
            min: 3
            re: &23 !!perl/hash:RE_any
              altname: mod_internal__S_106p6adv_0
              dba: mod_internal
              min: 3
              zyg:
              - !!perl/hash:RE_string
                alt: mod_internal__S_106p6adv_0 0
                i: 0
                min: 3
                text: dba
              - !!perl/hash:RE_string
                alt: mod_internal__S_106p6adv_0 1
                i: 0
                min: 4
                text: lang
          - !!perl/hash:RE_meta
            min: 0
            text: »
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_sequence
        min: 12345
        zyg:
        - !!perl/hash:RE_decl
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: quotepair
          rest: ''
    - !!perl/hash:RE_block
      min: 0
mod_internal__S_106p6adv_0: *23
mod_internal__S_107oops: !!perl/hash:RE_ast
  dba: mod_internal
  min: 12347
  re: !!perl/hash:RE_sequence
    min: 12347
    zyg:
    - !!perl/hash:RE_bindpos
      atom: !!perl/hash:RE_paren
        min: 2
        re: !!perl/hash:RE_sequence
          min: 2
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: ':'
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \w
            min: 1
            quant:
            - +
      min: 2
    - !!perl/hash:RE_method
      min: 12345
      name: sorry
      rest: 1
nibbler: !!perl/hash:RE_ast
  dba: nibbler
  min: 98760
  re: !!perl/hash:RE_sequence
    min: 98760
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 37036
        re: !!perl/hash:RE_sequence
          min: 37036
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \s
            min: 0
            quant:
            - '*'
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_qw
            min: 1
            text: < || | && & >
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: EXPR
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 24690
      re: !!perl/hash:RE_first
        min: 24690
        zyg:
        - !!perl/hash:RE_assertion
          assert: '?'
          min: 0
          re: !!perl/hash:RE_method
            min: 12345
            name: infixstopper
            rest: ''
        - !!perl/hash:RE_sequence
          min: 49380
          zyg:
          - !!perl/hash:RE_meta
            min: 0
            text: $$
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          min: 37036
          zyg:
          - !!perl/hash:RE_bindpos
            atom: !!perl/hash:RE_paren
              min: 1
              re: !!perl/hash:RE_meta
                min: 1
                text: \W
            min: 1
          - !!perl/hash:RE_method
            min: 12345
            name: sorry
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
        - !!perl/hash:RE_sequence
          min: 37035
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
normspace: !!perl/hash:RE_ast
  dba: normspace
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &24 !!perl/hash:RE_any
          altname: normspace_0
          dba: normspace
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: normspace_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: normspace_0 1
            i: 0
            min: 1
            text: '#'
    - !!perl/hash:RE_bracket
      min: 12345
      re: !!perl/hash:RE_sequence
        min: 12345
        zyg:
        - !!perl/hash:RE_decl
          min: 0
        - !!perl/hash:RE_method
          min: 12345
          name: ws
          rest: ''
normspace_0: *24
quant_atom_list: !!perl/hash:RE_ast
  dba: quant_atom_list
  min: 12345
  re: !!perl/hash:RE_quantified_atom
    atom: !!perl/hash:RE_method
      min: 12345
      name: quantified_atom
      rest: ''
    min: 12345
    quant:
    - +
quantified_atom: !!perl/hash:RE_ast
  dba: quantified_atom
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        min: 12345
        name: stopper
        rest: ''
    - !!perl/hash:RE_assertion
      assert: '!'
      min: 0
      re: !!perl/hash:RE_method
        min: 12345
        name: regex_infix
        rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: atom
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 24690
        re: !!perl/hash:RE_sequence
          min: 24690
          zyg:
          - !!perl/hash:RE_method
            min: 12345
            name: quantifier
            rest: ''
          - !!perl/hash:RE_method
            min: 12345
            name: ws
            rest: ''
      min: 0
      quant:
      - '?'
quantifier__S_108Star: !!perl/hash:RE_ast
  dba: quantifier
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '*'
    - !!perl/hash:RE_method
      min: 12345
      name: quantmod
      rest: ''
quantifier__S_109Plus: !!perl/hash:RE_ast
  dba: quantifier
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: +
    - !!perl/hash:RE_method
      min: 12345
      name: quantmod
      rest: ''
quantifier__S_110Question: !!perl/hash:RE_ast
  dba: quantifier
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '?'
    - !!perl/hash:RE_method
      min: 12345
      name: quantmod
      rest: ''
quantifier__S_111Colon: !!perl/hash:RE_ast
  dba: quantifier
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: ':'
    - !!perl/hash:RE_block
      min: 0
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: !!perl/hash:RE_meta
          min: 1
          text: \s
quantifier__S_112StarStar: !!perl/hash:RE_ast
  dba: quantifier
  min: 24691
  re: !!perl/hash:RE_sequence
    min: 24691
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '**'
    - !!perl/hash:RE_meta
      min: 0
      text: '::'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: normspace
        rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_method
      min: 12345
      name: quantmod
      rest: ''
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_method
        min: 12345
        name: normspace
        rest: ''
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_bracket
      min: 1
      re: &25 !!perl/hash:RE_any
        altname: quantifier__S_112StarStar_0
        dba: quantifier
        min: 1
        zyg:
        - !!perl/hash:RE_sequence
          alt: quantifier__S_112StarStar_0 0
          min: 12349
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \d
            min: 1
            quant:
            - +
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \s
            min: 1
            quant:
            - +
          - !!perl/hash:RE_string
            i: 0
            min: 2
            text: ..
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          alt: quantifier__S_112StarStar_0 1
          min: 1
          zyg:
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_meta
              min: 1
              text: \d
            min: 1
            quant:
            - +
          - !!perl/hash:RE_quantified_atom
            atom: !!perl/hash:RE_bracket
              min: 3
              re: !!perl/hash:RE_sequence
                min: 3
                zyg:
                - !!perl/hash:RE_string
                  i: 0
                  min: 2
                  text: ..
                - !!perl/hash:RE_bracket
                  min: 1
                  re: &26 !!perl/hash:RE_any
                    altname: quantifier__S_112StarStar_1
                    dba: quantifier
                    min: 1
                    zyg:
                    - !!perl/hash:RE_quantified_atom
                      alt: quantifier__S_112StarStar_1 0
                      atom: !!perl/hash:RE_meta
                        min: 1
                        text: \d
                      min: 1
                      quant:
                      - +
                    - !!perl/hash:RE_string
                      alt: quantifier__S_112StarStar_1 1
                      i: 0
                      min: 1
                      text: '*'
                    - !!perl/hash:RE_method
                      alt: quantifier__S_112StarStar_1 2
                      min: 12345
                      name: panic
                      rest: 1
            min: 0
            quant:
            - '?'
        - !!perl/hash:RE_method
          alt: quantifier__S_112StarStar_0 2
          min: 12345
          name: embeddedblock
          rest: ''
        - !!perl/hash:RE_method
          alt: quantifier__S_112StarStar_0 3
          min: 12345
          name: quantified_atom
          rest: ''
quantifier__S_112StarStar_0: *25
quantifier__S_112StarStar_1: *26
quantifier__S_113TildeTilde: !!perl/hash:RE_ast
  dba: quantifier
  min: 37035
  re: !!perl/hash:RE_sequence
    min: 37035
    zyg:
    - !!perl/hash:RE_bracket
      min: 12345
      re: &27 !!perl/hash:RE_any
        altname: quantifier__S_113TildeTilde_0
        dba: quantifier
        min: 12345
        zyg:
        - !!perl/hash:RE_sequence
          alt: quantifier__S_113TildeTilde_0 0
          min: 12346
          zyg:
          - !!perl/hash:RE_string
            i: 0
            min: 1
            text: '!'
          - !!perl/hash:RE_method
            i: 0
            min: 12345
            name: sym
            rest: ''
            sym: ~~
        - !!perl/hash:RE_method
          alt: quantifier__S_113TildeTilde_0 1
          i: 0
          min: 12345
          name: sym
          rest: ''
          sym: ~~
    - !!perl/hash:RE_method
      min: 12345
      name: normspace
      rest: ''
    - !!perl/hash:RE_method
      min: 12345
      name: quantified_atom
      rest: ''
quantifier__S_113TildeTilde_0: *27
quantmod: !!perl/hash:RE_ast
  dba: quantmod
  min: 0
  re: !!perl/hash:RE_sequence
    min: 0
    zyg:
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_string
        i: 0
        min: 1
        text: ':'
      min: 0
      quant:
      - '?'
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 1
        re: &28 !!perl/hash:RE_any
          altname: quantmod_0
          dba: quantmod
          min: 1
          zyg:
          - !!perl/hash:RE_string
            alt: quantmod_0 0
            i: 0
            min: 1
            text: '?'
          - !!perl/hash:RE_string
            alt: quantmod_0 1
            i: 0
            min: 1
            text: '!'
          - !!perl/hash:RE_string
            alt: quantmod_0 2
            i: 0
            min: 1
            text: +
      min: 0
      quant:
      - '?'
quantmod_0: *28
regex_infix__S_005VertVert: !!perl/hash:RE_ast
  dba: regex_infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '||'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
regex_infix__S_006AmpAmp: !!perl/hash:RE_ast
  dba: regex_infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '&&'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
regex_infix__S_007Vert: !!perl/hash:RE_ast
  dba: regex_infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '|'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
regex_infix__S_008Amp: !!perl/hash:RE_ast
  dba: regex_infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '&'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
regex_infix__S_009Tilde: !!perl/hash:RE_ast
  dba: regex_infix
  min: 24690
  re: !!perl/hash:RE_sequence
    min: 24690
    zyg:
    - !!perl/hash:RE_method
      i: 0
      min: 12345
      name: sym
      rest: ''
      sym: '~'
    - !!perl/hash:RE_method
      min: 12345
      name: O
      rest: 1
sign: !!perl/hash:RE_ast
  dba: sign
  min: 0
  re: &29 !!perl/hash:RE_any
    altname: sign_0
    dba: sign
    min: 0
    zyg:
    - !!perl/hash:RE_string
      alt: sign_0 0
      i: 0
      min: 1
      text: +
    - !!perl/hash:RE_string
      alt: sign_0 1
      i: 0
      min: 1
      text: '-'
    - !!perl/hash:RE_assertion
      alt: sign_0 2
      assert: '?'
      min: 0
      re: !!perl/hash:RE_noop
        min: 0
        nobind: 1
sign_0: *29
termish: !!perl/hash:RE_ast
  dba: termish
  min: 12345
  re: !!perl/hash:RE_sequence
    min: 12345
    zyg:
    - !!perl/hash:RE_method
      min: 12345
      name: ws
      rest: ''
    - !!perl/hash:RE_bracket
      min: 0
      re: !!perl/hash:RE_first
        min: 0
        zyg:
        - !!perl/hash:RE_bindnamed
          atom: !!perl/hash:RE_method
            min: 12345
            name: quant_atom_list
            rest: ''
          min: 12345
        - !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: &30 !!perl/hash:RE_any
                altname: termish_0
                dba: termish
                min: 1
                zyg:
                - !!perl/hash:RE_method
                  alt: termish_0 0
                  min: 12345
                  name: stopper
                  rest: ''
                - !!perl/hash:RE_cclass
                  alt: termish_0 1
                  i: 0
                  min: 1
                  text: '[&|~]'
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          min: 0
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: !!perl/hash:RE_cclass
                i: 0
                min: 1
                text: '[ \] \) \> ]'
          - !!perl/hash:RE_block
            min: 0
        - !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_meta
            min: 0
            text: $$
          - !!perl/hash:RE_method
            min: 12345
            name: panic
            rest: 1
        - !!perl/hash:RE_sequence
          min: 12346
          zyg:
          - !!perl/hash:RE_meta
            min: 1
            text: \W
          - !!perl/hash:RE_method
            min: 12345
            name: sorry
            rest: 1
        - !!perl/hash:RE_method
          min: 12345
          name: panic
          rest: 1
termish_0: *30
unsp: !!perl/hash:RE_ast
  dba: unsp
  min: 12346
  re: !!perl/hash:RE_sequence
    min: 12346
    zyg:
    - !!perl/hash:RE_string
      i: 0
      min: 1
      text: \
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_method_re
        min: 12345
        name: before
        nobind: 1
        re: &31 !!perl/hash:RE_any
          altname: unsp_0
          dba: unsp
          min: 1
          zyg:
          - !!perl/hash:RE_meta
            alt: unsp_0 0
            min: 1
            text: \s
          - !!perl/hash:RE_string
            alt: unsp_0 1
            i: 0
            min: 1
            text: '#'
    - !!perl/hash:RE_method
      min: 12345
      name: panic
      rest: 1
unsp_0: *31
ws: !!perl/hash:RE_ast
  dba: ws
  min: 0
  re: !!perl/hash:RE_first
    min: 0
    zyg:
    - !!perl/hash:RE_assertion
      assert: '?'
      min: 0
      re: !!perl/hash:RE_block
        min: 0
        nobind: 1
    - !!perl/hash:RE_quantified_atom
      atom: !!perl/hash:RE_bracket
        min: 12345
        re: !!perl/hash:RE_sequence
          min: 12345
          zyg:
          - !!perl/hash:RE_assertion
            assert: '?'
            min: 0
            re: !!perl/hash:RE_method_re
              min: 12345
              name: before
              nobind: 1
              re: &32 !!perl/hash:RE_any
                altname: ws_0
                dba: ws
                min: 1
                zyg:
                - !!perl/hash:RE_meta
                  alt: ws_0 0
                  min: 1
                  text: \s
                - !!perl/hash:RE_string
                  alt: ws_0 1
                  i: 0
                  min: 1
                  text: '#'
          - !!perl/hash:RE_method
            min: 12345
            name: nextsame
            rest: ''
      min: 0
      quant:
      - '?'
ws_0: *32
RETREE_END
## method tweak (:Perl5(:$P5)!)
;
## method tweak (:overlap(:$ov)!)
;
## method tweak (:exhaustive(:$ex)!)
;
## method tweak (:continue(:$c)!)
;
## method tweak (:pos(:$p)!)
;
## method tweak (:sigspace(:$s)!)
;
## method tweak (:ratchet(:$r)!)
;
## method tweak (:global(:$g)!)
;
## method tweak (:ignorecase(:$i)!)
;
## method tweak (:ignoreaccent(:$a)!)
;
## method tweak (:samecase(:$ii)!)
;
## method tweak (:sameaccent(:$aa)!)
;
## method tweak (:$nth!)
;
## method tweak (:st(:$nd)!)
;
## method tweak (:rd(:$th)!)
;
## method tweak (:$x!)
;
## method tweak (:$bytes!)
;
## method tweak (:$codes!)
;
## method tweak (:$graphs!)
;
## method tweak (:$chars!)
;
## method tweak (:$rw!)
;
## token category:metachar { <sym> }
sub category__S_000metachar__PEEK { $_[0]->_AUTOLEXpeek('category__S_000metachar', $retree) }
sub category__S_000metachar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_000metachar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "metachar";
$self->_MATCHIFYr($S, "category__S_000metachar", $C->_EXACT("metachar"));
}
;
## token metachar { <...> }
sub metachar__PEEK { $_[0]->_AUTOLEXpeek('metachar:*',$retree); }
sub metachar {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE metachar');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'metachar') {
                $C->deb("Fate passed to metachar: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT metachar';
            }
            else {
                $x = 'ALTLTM metachar';
            }
        }
        else {
            $x = 'ALTLTM metachar';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD::Regex', 'metachar:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("metachar trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "metachar", @gather);
    };
    @result;
}
;
## token category:backslash { <sym> }
sub category__S_001backslash__PEEK { $_[0]->_AUTOLEXpeek('category__S_001backslash', $retree) }
sub category__S_001backslash {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_001backslash");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "backslash";
$self->_MATCHIFYr($S, "category__S_001backslash", $C->_EXACT("backslash"));
}
;
## token backslash { <...> }
sub backslash__PEEK { $_[0]->_AUTOLEXpeek('backslash:*',$retree); }
sub backslash {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE backslash');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'backslash') {
                $C->deb("Fate passed to backslash: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT backslash';
            }
            else {
                $x = 'ALTLTM backslash';
            }
        }
        else {
            $x = 'ALTLTM backslash';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD::Regex', 'backslash:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("backslash trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "backslash", @gather);
    };
    @result;
}
;
## token category:assertion { <sym> }
sub category__S_002assertion__PEEK { $_[0]->_AUTOLEXpeek('category__S_002assertion', $retree) }
sub category__S_002assertion {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_002assertion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "assertion";
$self->_MATCHIFYr($S, "category__S_002assertion", $C->_EXACT("assertion"));
}
;
## token assertion { <...> }
sub assertion__PEEK { $_[0]->_AUTOLEXpeek('assertion:*',$retree); }
sub assertion {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE assertion');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'assertion') {
                $C->deb("Fate passed to assertion: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT assertion';
            }
            else {
                $x = 'ALTLTM assertion';
            }
        }
        else {
            $x = 'ALTLTM assertion';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD::Regex', 'assertion:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("assertion trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "assertion", @gather);
    };
    @result;
}
;
## token category:quantifier { <sym> }
sub category__S_003quantifier__PEEK { $_[0]->_AUTOLEXpeek('category__S_003quantifier', $retree) }
sub category__S_003quantifier {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_003quantifier");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quantifier";
$self->_MATCHIFYr($S, "category__S_003quantifier", $C->_EXACT("quantifier"));
}
;
## token quantifier { <...> }
sub quantifier__PEEK { $_[0]->_AUTOLEXpeek('quantifier:*',$retree); }
sub quantifier {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE quantifier');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'quantifier') {
                $C->deb("Fate passed to quantifier: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT quantifier';
            }
            else {
                $x = 'ALTLTM quantifier';
            }
        }
        else {
            $x = 'ALTLTM quantifier';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD::Regex', 'quantifier:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("quantifier trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "quantifier", @gather);
    };
    @result;
}
;
## token category:mod_internal { <sym> }
sub category__S_004mod_internal__PEEK { $_[0]->_AUTOLEXpeek('category__S_004mod_internal', $retree) }
sub category__S_004mod_internal {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE category__S_004mod_internal");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "mod_internal";
$self->_MATCHIFYr($S, "category__S_004mod_internal", $C->_EXACT("mod_internal"));
}
;
## token mod_internal { <...> }
sub mod_internal__PEEK { $_[0]->_AUTOLEXpeek('mod_internal:*',$retree); }
sub mod_internal {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE mod_internal');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'mod_internal') {
                $C->deb("Fate passed to mod_internal: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT mod_internal';
            }
            else {
                $x = 'ALTLTM mod_internal';
            }
        }
        else {
            $x = 'ALTLTM mod_internal';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD::Regex', 'mod_internal:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("mod_internal trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "mod_internal", @gather);
    };
    @result;
}
;
## token regex_infix { <...> }
sub regex_infix__PEEK { $_[0]->_AUTOLEXpeek('regex_infix:*',$retree); }
sub regex_infix {
    my $self = shift;
    my $subs;

    local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

    my $C = $self->cursor_xact('RULE regex_infix');
    my $S = $C->{'_pos'};

    my @result = do {
        my ($tag, $try);
        my @try;
        my $relex;
        my $x;
        if (my $fate = $C->{'_fate'}) {
            if ($fate->[1] eq 'regex_infix') {
                $C->deb("Fate passed to regex_infix: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
                ($C->{'_fate'}, $tag, $try) = @$fate;
                @try = ($try);
                $x = 'ALT regex_infix';
            }
            else {
                $x = 'ALTLTM regex_infix';
            }
        }
        else {
            $x = 'ALTLTM regex_infix';
        }
        my $C = $C->cursor_xact($x);
        my $xact = $C->{_xact};

        my @gather = ();
        for (;;) {
            unless (@try) {
                $relex //= $C->cursor_fate('STD::Regex', 'regex_infix:*', $retree);
                @try = $relex->($C) or last;
            }
            $try = shift(@try) // next;

            if (ref $try) {
                ($C->{'_fate'}, $tag, $try) = @$try;       # next candidate fate
            }

            $C->deb("regex_infix trying $tag $try") if $::DEBUG & DEBUG::try_processing;
            push @gather, $C->$try(@_);
            last if @gather;
            last if $xact->[-2];  # committed?
        }
        $self->_MATCHIFYr($S, "regex_infix", @gather);
    };
    @result;
}
;
## token ws {
sub ws__PEEK { $_[0]->_AUTOLEXpeek('ws', $retree) }
sub ws {
no warnings 'recursion';
my $self = shift;

    my @origargs = @_;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE ws");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "ws", do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::RX{'s'} })
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, $C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'ws_0') {
        $C->deb("Fate passed to ws_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT ws_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM ws_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'ws_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("ws_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\#")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($self->SUPER::ws(@origargs))) {
$C
} else { () }
}))) { ($C) } else { () }
})
};
@gather;
});
}
;
## token normspace {
sub normspace__PEEK { $_[0]->_AUTOLEXpeek('normspace', $retree) }
sub normspace {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE normspace");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "normspace", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'normspace_0') {
        $C->deb("Fate passed to normspace_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT normspace_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM normspace_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'normspace_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("normspace_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\#")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
;

do {
if (my ($C) = ($C->ws)) { ($C) } else { () }
}
}))) {
$C
} else { () }
});
}
;
## token unsp { '\\' <?before \s | '#'> <.panic: "No unspace allowed in regex; if you meant to match th
sub unsp__PEEK { $_[0]->_AUTOLEXpeek('unsp', $retree) }
sub unsp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE unsp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "unsp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\\"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'unsp_0') {
        $C->deb("Fate passed to unsp_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT unsp_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM unsp_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'unsp_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("unsp_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\#")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = (do {
my $M = $C;
$C->panic("No unspace allowed in regex; if you meant to match the literal character, please enclose in single quotes ('" . substr($::ORIG,$C->{'_pos'},1) . "') or use a backslashed form like \\x" . sprintf("%M->{02}x", ord(substr($::ORIG,$C->{'_pos'},1))))
})) {
$C
} else { () }
});
}
;
## rule nibbler {
sub nibbler__PEEK { $_[0]->_AUTOLEXpeek('nibbler', $retree) }
sub nibbler {
no warnings 'recursion';
my $self = shift;

local %::RX = %::RX;

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE nibbler");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "nibbler", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_PATTERN(qr/\G\s*+/))
and ($C) = ($C->ws)
and ($C) = ($C->_ARRAY( qw< || | && & > ))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['EXPR'], sub {
my $C = shift;
$C->EXPR
}))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->infixstopper)) { ($C) } else { () }
}))) { ($C) } else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?m:$)/))
and ($C) = ($C->ws)
and ($C) = ($C->panic( "Regex not terminated"))
and ($C) = ($C->ws)) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\W/)

})
}))
and ($C) = (do {
my $M = $C;
$C->sorry("Unrecognized regex metacharacter " . $M->{0}->Str . " (must be quoted to match literally)")
})
and ($C) = ($C->ws)) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->panic( "Regex not terminated"))
and ($C) = ($C->ws)) {
$C
} else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## token termish {
sub termish__PEEK { $_[0]->_AUTOLEXpeek('termish', $retree) }
sub termish {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE termish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "termish", do {
my $C = $C;
if (($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_SUBSUMEr(['term'], sub {
my $C = shift;
$C->quant_atom_list
})
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'termish_0') {
        $C->deb("Fate passed to termish_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT termish_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM termish_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'termish_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("termish_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G[&|~]/)
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Null pattern not allowed"))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\]\)\>]/)
}))) { ($C) } else { () }
}))) {
scalar(do {
{
my $c = substr($::ORIG,$C->{'_pos'},1);
if ($::GOAL eq $c) {
$C->panic("Null pattern not allowed")}
else {
$C->panic("Unmatched closing $c")};
}}, $C)
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?m:$)/))
and ($C) = ($C->panic("Regex not terminated"))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\W/))
and ($C) = ($C->sorry("Unrecognized regex metacharacter (must be quoted to match literally)"))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Regex not terminated"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## token quant_atom_list {
sub quant_atom_list__PEEK { $_[0]->_AUTOLEXpeek('quant_atom_list', $retree) }
sub quant_atom_list {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quant_atom_list");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'quantified_atom'} = [];
$self->_MATCHIFYr($S, "quant_atom_list", $C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
}));
}
;
## token infixish {
sub infixish__PEEK { $_[0]->_AUTOLEXpeek('infixish', $retree) }
sub infixish {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infixish");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "infixish", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->infixstopper)) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stdstopper)) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['regex_infix'], sub {
my $C = shift;
$C->regex_infix
}))) {
scalar(do {
my $M = $C;
$M->{'O'} = $M->{'regex_infix'}->{'O'};
$M->{'sym'} = $M->{'regex_infix'}->{'sym'};
}, $C)
} else { () }
});
}
;
## regex infixstopper {
sub infixstopper__PEEK { $_[0]->_AUTOLEXpeek('infixstopper', $retree) }
sub infixstopper {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE infixstopper");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFY($S, "infixstopper", $C->_BRACKET(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'infixstopper_0') {
        $C->deb("Fate passed to infixstopper_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT infixstopper_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM infixstopper_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'infixstopper_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("infixstopper_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[\)\}\]]/)
})
},
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\>[^>)]/)
})
},
sub {
my $C=shift;
$C->before(sub {
my $C=shift;
$C->_SUBSUME(['stopper'], sub {
my $C = shift;
$C->stopper
})
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}));
}
;
## token regex_infix:sym<||> { <sym> <O(|%tight_or)>  }
sub regex_infix__S_005VertVert__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_005VertVert', $retree) }
sub regex_infix__S_005VertVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_infix__S_005VertVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|\|";
$self->_MATCHIFYr($S, "regex_infix__S_005VertVert", do {
if (my ($C) = ($C->_EXACT("\|\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_or)
})
} else { () }
});
}
;
## token regex_infix:sym<&&> { <sym> <O(|%tight_and)>  }
sub regex_infix__S_006AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_006AmpAmp', $retree) }
sub regex_infix__S_006AmpAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_infix__S_006AmpAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&\&";
$self->_MATCHIFYr($S, "regex_infix__S_006AmpAmp", do {
if (my ($C) = ($C->_EXACT("\&\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%tight_and)
})
} else { () }
});
}
;
## token regex_infix:sym<|> { <sym> <O(|%junctive_or)>  }
sub regex_infix__S_007Vert__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_007Vert', $retree) }
sub regex_infix__S_007Vert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_infix__S_007Vert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|";
$self->_MATCHIFYr($S, "regex_infix__S_007Vert", do {
if (my ($C) = ($C->_EXACT("\|"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_or)
})
} else { () }
});
}
;
## token regex_infix:sym<&> { <sym> <O(|%junctive_and)>  }
sub regex_infix__S_008Amp__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_008Amp', $retree) }
sub regex_infix__S_008Amp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_infix__S_008Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&";
$self->_MATCHIFYr($S, "regex_infix__S_008Amp", do {
if (my ($C) = ($C->_EXACT("\&"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%junctive_and)
})
} else { () }
});
}
;
## token regex_infix:sym<~> { <sym> <O(|%additive)>  }
sub regex_infix__S_009Tilde__PEEK { $_[0]->_AUTOLEXpeek('regex_infix__S_009Tilde', $retree) }
sub regex_infix__S_009Tilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE regex_infix__S_009Tilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~";
$self->_MATCHIFYr($S, "regex_infix__S_009Tilde", do {
if (my ($C) = ($C->_EXACT("\~"))) {
$C->_SUBSUMEr(['O'], sub {
my $C = shift;
$C->O(%additive)
})
} else { () }
});
}
;
## token quantified_atom {
sub quantified_atom__PEEK { $_[0]->_AUTOLEXpeek('quantified_atom', $retree) }
sub quantified_atom {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantified_atom");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'quantifier'} = [];
$self->_MATCHIFYr($S, "quantified_atom", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->stopper)) { ($C) } else { () }
}))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->regex_infix)) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['atom'], sub {
my $C = shift;
$C->atom
}))
and ($C) = ($C->ws)) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))
and ($C) = ($C->ws)) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token atom {
sub atom__PEEK { $_[0]->_AUTOLEXpeek('atom', $retree) }
sub atom {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE atom");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "atom", $C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'atom_0') {
        $C->deb("Fate passed to atom_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT atom_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM atom_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'atom_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("atom_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\w/)
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['metachar'], sub {
my $C = shift;
$C->metachar
}))) {
$C->_COMMITLTM()
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}));
}
;
## token metachar:sym« > » { '>'<!before '>'> :: <fail> }
sub metachar__S_010Gt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_010Gt', $retree) }
sub metachar__S_010Gt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_010Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\>";
$self->_MATCHIFYr($S, "metachar__S_010Gt", do {
my $C = $C;
if (($C) = ($C->_EXACT("\>"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }
});
}
;
## token metachar:sym<&&>  { '&&' :: <fail> }
sub metachar__S_011AmpAmp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_011AmpAmp', $retree) }
sub metachar__S_011AmpAmp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_011AmpAmp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&\&";
$self->_MATCHIFYr($S, "metachar__S_011AmpAmp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\&\&"))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }
});
}
;
## token metachar:sym<&>   { '&'  :: <fail> }
sub metachar__S_012Amp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_012Amp', $retree) }
sub metachar__S_012Amp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_012Amp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\&";
$self->_MATCHIFYr($S, "metachar__S_012Amp", do {
my $C = $C;
if (($C) = ($C->_EXACT("\&"))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }
});
}
;
## token metachar:sym<||>  { '||' :: <fail> }
sub metachar__S_013VertVert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_013VertVert', $retree) }
sub metachar__S_013VertVert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_013VertVert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|\|";
$self->_MATCHIFYr($S, "metachar__S_013VertVert", do {
my $C = $C;
if (($C) = ($C->_EXACT("\|\|"))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }
});
}
;
## token metachar:sym<|>   { '|'  :: <fail> }
sub metachar__S_014Vert__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_014Vert', $retree) }
sub metachar__S_014Vert {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_014Vert");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\|";
$self->_MATCHIFYr($S, "metachar__S_014Vert", do {
my $C = $C;
if (($C) = ($C->_EXACT("\|"))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }
});
}
;
## token metachar:sym<]>   { ']'  :: <fail> }
sub metachar__S_015Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_015Ket', $retree) }
sub metachar__S_015Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_015Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\]";
$self->_MATCHIFYr($S, "metachar__S_015Ket", do {
my $C = $C;
if (($C) = ($C->_EXACT("\]"))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }
});
}
;
## token metachar:sym<)>   { ')'  :: <fail> }
sub metachar__S_016Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_016Thesis', $retree) }
sub metachar__S_016Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_016Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\)";
$self->_MATCHIFYr($S, "metachar__S_016Thesis", do {
my $C = $C;
if (($C) = ($C->_EXACT("\)"))
and ($C) = ($C->_COMMITLTM())) {
$C->_SUBSUMEr(['fail'], sub {
my $C = shift;
$C->fail
})
} else { () }
});
}
;
## token metachar:sym<;>   {
sub metachar__S_017Semi__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_017Semi', $retree) }
sub metachar__S_017Semi {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_017Semi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\;";
$self->_MATCHIFYr($S, "metachar__S_017Semi", do {
my $C = $C;
if (($C) = ($C->_EXACT("\;"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (LazyMap::lazymap(sub {
my $C=shift;
$C->_SUBSUMEr(['stopper'], sub {
my $C = shift;
$C->stopper
})
},
$C->_STARf(sub {
my $C=shift;
$C->_NOTCHAR( sub { my $C=shift;
$C->_EXACT("\n")
})
})))) { ($C) } else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Semicolon must be quoted"))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->cursor_incr()
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Regex missing terminator (or semicolon must be quoted?)"))) {
$C
} else { () }
}
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Regex missing terminator"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
});
}
;
## token metachar:quant { <quantifier> <.sorry: "Quantifier quantifies nothing"> }
sub metachar__S_018quant__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_018quant', $retree) }
sub metachar__S_018quant {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_018quant");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "quant";
$self->_MATCHIFYr($S, "metachar__S_018quant", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['quantifier'], sub {
my $C = shift;
$C->quantifier
}))
and ($C) = ($C->sorry("Quantifier quantifies nothing"))) {
$C
} else { () }
});
}
;
## token metachar:sigwhite {
sub metachar__S_019sigwhite__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_019sigwhite', $retree) }
sub metachar__S_019sigwhite {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_019sigwhite");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "sigwhite";
$self->_MATCHIFYr($S, "metachar__S_019sigwhite", $C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
}));
}
;
## token metachar:unsp   { <unsp> }
sub metachar__S_020unsp__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_020unsp', $retree) }
sub metachar__S_020unsp {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_020unsp");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "unsp";
$self->_MATCHIFYr($S, "metachar__S_020unsp", $C->_SUBSUMEr(['unsp'], sub {
my $C = shift;
$C->unsp
}));
}
;
## token metachar:sym<{ }> {
sub metachar__S_021Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_021Cur_Ly', $retree) }
sub metachar__S_021Cur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_021Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\ \}";
$self->_MATCHIFYr($S, "metachar__S_021Cur_Ly", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\{")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_SUBSUMEr(['embeddedblock'], sub {
my $C = shift;
$C->embeddedblock
}))) {
scalar(do {
my $M = $C;
{
$M->{'sym'} = <{ }> }}, $C)
} else { () }
});
}
;
## token metachar:mod {
sub metachar__S_022mod__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_022mod', $retree) }
sub metachar__S_022mod {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_022mod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "mod";
$self->_MATCHIFYr($S, "metachar__S_022mod", do {
if (my ($C) = ($C->_SUBSUMEr(['mod_internal'], sub {
my $C = shift;
$C->mod_internal
}))) {
scalar(do {
my $M = $C;
$M->{'sym'} = $M->{'mod_internal'}->{'sym'} }, $C)
} else { () }
});
}
;
## token metachar:sym<-> {
sub metachar__S_023Minus__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_023Minus', $retree) }
sub metachar__S_023Minus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_023Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\-";
$self->_MATCHIFYr($S, "metachar__S_023Minus", do {
my $C = $C;
if (($C) = ($C->_EXACT("\-"))
and ($C) = ($C->before(sub {
my $C=shift;
(($C) x !!do {
$::GOAL eq ']' })
}))
and ($C) = ($C->sorry("Invalid regex metacharacter (must be quoted to match literally)"))) {
$C
} else { () }
});
}
;
## token metachar:sym<:> {
sub metachar__S_024Colon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_024Colon', $retree) }
sub metachar__S_024Colon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_024Colon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:";
$self->_MATCHIFYr($S, "metachar__S_024Colon", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->panic("Backtrack control ':' does not seem to have a preceding atom to control"))) {
$C
} else { () }
});
}
;
## token metachar:sym<::> {
sub metachar__S_025ColonColon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_025ColonColon', $retree) }
sub metachar__S_025ColonColon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_025ColonColon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\:";
$self->_MATCHIFYr($S, "metachar__S_025ColonColon", $C->_EXACT("\:\:"));
}
;
## token metachar:sym<:::> {
sub metachar__S_026ColonColonColon__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_026ColonColonColon', $retree) }
sub metachar__S_026ColonColonColon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_026ColonColonColon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\:\:";
$self->_MATCHIFYr($S, "metachar__S_026ColonColonColon", $C->_EXACT("\:\:\:"));
}
;
## token metachar:sym<[ ]> {
sub metachar__S_027Bra_Ket__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_027Bra_Ket', $retree) }
sub metachar__S_027Bra_Ket {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_027Bra_Ket");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\[\ \]";
$self->_MATCHIFYr($S, "metachar__S_027Bra_Ket", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\["))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\]")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'bracketed regex', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))
and ($C) = (scalar(do {
my $M = $C;
$C->check_old_cclass($M->{'nibbler'}->Str)}, $C))) {
scalar(do {
my $M = $C;
$M->{'sym'} = <[ ]>}, $C)
} else { () }
});
}
;
## token metachar:sym<( )> {
sub metachar__S_028Paren_Thesis__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_028Paren_Thesis', $retree) }
sub metachar__S_028Paren_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_028Paren_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\(\ \)";
$self->_MATCHIFYr($S, "metachar__S_028Paren_Thesis", do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'capture parens', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) {
scalar(do {
my $M = $C;
$M->{'sym'} = <( )> }, $C)
} else { () }
});
}
;
## token metachar:sym« <( » { '<(' }
sub metachar__S_029LtParen__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_029LtParen', $retree) }
sub metachar__S_029LtParen {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_029LtParen");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\(";
$self->_MATCHIFYr($S, "metachar__S_029LtParen", $C->_EXACT("\<\("));
}
;
## token metachar:sym« )> » { ')>' }
sub metachar__S_030ThesisGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_030ThesisGt', $retree) }
sub metachar__S_030ThesisGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_030ThesisGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\)\>";
$self->_MATCHIFYr($S, "metachar__S_030ThesisGt", $C->_EXACT("\)\>"));
}
;
## token metachar:sym« << » { '<<' }
sub metachar__S_031LtLt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_031LtLt', $retree) }
sub metachar__S_031LtLt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_031LtLt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\<";
$self->_MATCHIFYr($S, "metachar__S_031LtLt", $C->_EXACT("\<\<"));
}
;
## token metachar:sym« >> » { '>>' }
sub metachar__S_032GtGt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_032GtGt', $retree) }
sub metachar__S_032GtGt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_032GtGt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\>\>";
$self->_MATCHIFYr($S, "metachar__S_032GtGt", $C->_EXACT("\>\>"));
}
;
## token metachar:sym< « > { '«' }
sub metachar__S_033Fre__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_033Fre', $retree) }
sub metachar__S_033Fre {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_033Fre");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "«";
$self->_MATCHIFYr($S, "metachar__S_033Fre", $C->_EXACT("«"));
}
;
## token metachar:sym< » > { '»' }
sub metachar__S_034Nch__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_034Nch', $retree) }
sub metachar__S_034Nch {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_034Nch");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "»";
$self->_MATCHIFYr($S, "metachar__S_034Nch", $C->_EXACT("»"));
}
;
## token metachar:qw {
sub metachar__S_035qw__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_035qw', $retree) }
sub metachar__S_035qw {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_035qw");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "qw";
$self->_MATCHIFYr($S, "metachar__S_035qw", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\<\s/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['circumfix'], sub {
my $C = shift;
$C->circumfix
})
} else { () }
});
}
;
## token metachar:sym«< >» {
sub metachar__S_036Lt_Gt__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_036Lt_Gt', $retree) }
sub metachar__S_036Lt_Gt {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_036Lt_Gt");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\<\ \>";
$self->_MATCHIFYr($S, "metachar__S_036Lt_Gt", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\>";
my $goalpos = $C;
my $newlang = $C->unbalanced($::GOAL);
$C = bless($C, (ref($newlang) || $newlang))
;

if (($C) = ($C->_EXACT("\<"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\>")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'metachar', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token metachar:sym<\\> { <sym> <backslash> }
sub metachar__S_037Back__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_037Back', $retree) }
sub metachar__S_037Back {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_037Back");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\\";
$self->_MATCHIFYr($S, "metachar__S_037Back", do {
if (my ($C) = ($C->_EXACT("\\"))) {
$C->_SUBSUMEr(['backslash'], sub {
my $C = shift;
$C->backslash
})
} else { () }
});
}
;
## token metachar:sym<.>  { <sym> }
sub metachar__S_038Dot__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_038Dot', $retree) }
sub metachar__S_038Dot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_038Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.";
$self->_MATCHIFYr($S, "metachar__S_038Dot", $C->_EXACT("\."));
}
;
## token metachar:sym<^^> { <sym> }
sub metachar__S_039CaretCaret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_039CaretCaret', $retree) }
sub metachar__S_039CaretCaret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_039CaretCaret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^\^";
$self->_MATCHIFYr($S, "metachar__S_039CaretCaret", $C->_EXACT("\^\^"));
}
;
## token metachar:sym<^>  { <sym> }
sub metachar__S_040Caret__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_040Caret', $retree) }
sub metachar__S_040Caret {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_040Caret");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\^";
$self->_MATCHIFYr($S, "metachar__S_040Caret", $C->_EXACT("\^"));
}
;
## token metachar:sym<$$> {
sub metachar__S_041DollarDollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_041DollarDollar', $retree) }
sub metachar__S_041DollarDollar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_041DollarDollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'0'} = [];
$C->{sym} = "\$\$";
$self->_MATCHIFYr($S, "metachar__S_041DollarDollar", do {
if (my ($C) = ($C->_EXACT("\$\$"))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\w++/)

})
}))
and ($C) = (do {
my $M = $C;
$C->obs("\$\$" . $M->{0}->Str . " to deref var inside a regex", "\$(\$" . $M->{0}->Str . ")")
})) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token metachar:sym<$>  {
sub metachar__S_042Dollar__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_042Dollar', $retree) }
sub metachar__S_042Dollar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_042Dollar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\$";
$self->_MATCHIFYr($S, "metachar__S_042Dollar", do {
my $C = $C;
if (($C) = ($C->_EXACT("\$"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = (do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'metachar__S_042Dollar_0') {
        $C->deb("Fate passed to metachar__S_042Dollar_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT metachar__S_042Dollar_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM metachar__S_042Dollar_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'metachar__S_042Dollar_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("metachar__S_042Dollar_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
},
sub {
my $C=shift;
$C->_EXACT("\|")
},
sub {
my $C=shift;
$C->_EXACT("\&")
},
sub {
my $C=shift;
$C->_EXACT("\)")
},
sub {
my $C=shift;
$C->_EXACT("\]")
},
sub {
my $C=shift;
$C->_EXACT("\>")
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\z/)
},
sub {
my $C=shift;
if (my ($C) = ($C->stopper)) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})) { ($C) } else { () }
}))) { ($C) } else { () }
}))) {
$C
} else { () }
});
}
;
## token metachar:sym<' '> { <?before "'"> [:lang(%*LANG<MAIN>) <quote>] }
sub metachar__S_043Single_Single__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_043Single_Single', $retree) }
sub metachar__S_043Single_Single {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_043Single_Single");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\'\ \'";
$self->_MATCHIFYr($S, "metachar__S_043Single_Single", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\'")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
;

$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
}))) {
$C
} else { () }
});
}
;
## token metachar:sym<" "> { <?before '"'> [:lang(%*LANG<MAIN>) <quote>] }
sub metachar__S_044Double_Double__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_044Double_Double', $retree) }
sub metachar__S_044Double_Double {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_044Double_Double");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\"\ \"";
$self->_MATCHIFYr($S, "metachar__S_044Double_Double", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\"")
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
;

$C->_SUBSUMEr(['quote'], sub {
my $C = shift;
$C->quote
})
}))) {
$C
} else { () }
});
}
;
## token metachar:var {
sub metachar__S_045var__PEEK { $_[0]->_AUTOLEXpeek('metachar__S_045var', $retree) }
sub metachar__S_045var {
no warnings 'recursion';
my $self = shift;

local $::QSIGIL = substr($::ORIG,$self->{'_pos'},1);

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE metachar__S_045var");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "var";
$self->_MATCHIFYr($S, "metachar__S_045var", do {
my $C = $C;
if (($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\$\$")
}))) { ($C) } else { () }
}))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
;

$C->_SUBSUMEr(['termish'], sub {
my $C = shift;
$C->termish
})
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['binding'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G\s*+\=\s*+/))) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
} else { () }

})
})
}))) {
scalar(do {
my $M = $C;
$M->{'sym'} = $M->{'termish'}->{'term'}->Str}, $C)
} else { () }
});
}
;
## token backslash:unspace { <?before \s> <.SUPER::ws> }
sub backslash__S_046unspace__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_046unspace', $retree) }
sub backslash__S_046unspace {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_046unspace");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "unspace";
$self->_MATCHIFYr($S, "backslash__S_046unspace", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))
and ($C) = ($C->SUPER::ws)) {
$C
} else { () }
});
}
;
## token backslash:sym<0> { '0' <!before <[0..7]> > }
sub backslash__S_0470__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_0470', $retree) }
sub backslash__S_0470 {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_0470");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "backslash__S_0470", do {
my $C = $C;
if (($C) = ($C->_EXACT("0"))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[0-7]/)
}))) { ($C) } else { () }
}))) {
$C
} else { () }
});
}
;
## token backslash:A { <sym> <.obs('\\A as beginning-of-string matcher', '^')> }
sub backslash__S_048A__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_048A', $retree) }
sub backslash__S_048A {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_048A");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "A";
$self->_MATCHIFYr($S, "backslash__S_048A", do {
my $C = $C;
if (($C) = ($C->_EXACT("A"))
and ($C) = ($C->obs('\\A as beginning-of-string matcher', '^'))) {
$C
} else { () }
});
}
;
## token backslash:a { <sym> <.sorry: "\\a is allowed only in strings, not regexes"> }
sub backslash__S_049a__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_049a', $retree) }
sub backslash__S_049a {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_049a");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "a";
$self->_MATCHIFYr($S, "backslash__S_049a", do {
my $C = $C;
if (($C) = ($C->_EXACT("a"))
and ($C) = ($C->sorry("\\a is allowed only in strings, not regexes"))) {
$C
} else { () }
});
}
;
## token backslash:B { <sym> <.obs('\\B as word non-boundary', '<!wb>')> }
sub backslash__S_050B__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_050B', $retree) }
sub backslash__S_050B {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_050B");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "B";
$self->_MATCHIFYr($S, "backslash__S_050B", do {
my $C = $C;
if (($C) = ($C->_EXACT("B"))
and ($C) = ($C->obs('\\B as word non-boundary', '<!wb>'))) {
$C
} else { () }
});
}
;
## token backslash:b { <sym> <.obs('\\b as word boundary', '<?wb> (or either of « or »)')> }
sub backslash__S_051b__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_051b', $retree) }
sub backslash__S_051b {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_051b");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "b";
$self->_MATCHIFYr($S, "backslash__S_051b", do {
my $C = $C;
if (($C) = ($C->_EXACT("b"))
and ($C) = ($C->obs('\\b as word boundary', '<?wb> (or either of « or »)'))) {
$C
} else { () }
});
}
;
## token backslash:c { :i <sym> <charspec> }
sub backslash__S_052c__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_052c', $retree) }
sub backslash__S_052c {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_052c");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "c";
$self->_MATCHIFYr($S, "backslash__S_052c", do {
if (my ($C) = ($C->_PATTERN(qr/\G(?i:c)/))) {
$C->_SUBSUMEr(['charspec'], sub {
my $C = shift;
$C->charspec
})
} else { () }
});
}
;
## token backslash:d { :i <sym> }
sub backslash__S_053d__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_053d', $retree) }
sub backslash__S_053d {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_053d");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "d";
$self->_MATCHIFYr($S, "backslash__S_053d", $C->_PATTERN(qr/\G(?i:d)/));
}
;
## token backslash:e { :i <sym> }
sub backslash__S_054e__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_054e', $retree) }
sub backslash__S_054e {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_054e");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "e";
$self->_MATCHIFYr($S, "backslash__S_054e", $C->_PATTERN(qr/\G(?i:e)/));
}
;
## token backslash:f { :i <sym> }
sub backslash__S_055f__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_055f', $retree) }
sub backslash__S_055f {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_055f");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "f";
$self->_MATCHIFYr($S, "backslash__S_055f", $C->_PATTERN(qr/\G(?i:f)/));
}
;
## token backslash:h { :i <sym> }
sub backslash__S_056h__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_056h', $retree) }
sub backslash__S_056h {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_056h");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "h";
$self->_MATCHIFYr($S, "backslash__S_056h", $C->_PATTERN(qr/\G(?i:h)/));
}
;
## token backslash:n { :i <sym> }
sub backslash__S_057n__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_057n', $retree) }
sub backslash__S_057n {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_057n");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "n";
$self->_MATCHIFYr($S, "backslash__S_057n", $C->_PATTERN(qr/\G(?i:n)/));
}
;
## token backslash:o { :i :dba('octal character') <sym> [ <octint> | '[' ~ ']' <octints> ] }
sub backslash__S_058o__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_058o', $retree) }
sub backslash__S_058o {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_058o");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "o";
$self->_MATCHIFYr($S, "backslash__S_058o", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:o)/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_058o_0') {
        $C->deb("Fate passed to backslash__S_058o_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT backslash__S_058o_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM backslash__S_058o_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'backslash__S_058o_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("backslash__S_058o_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['octint'], sub {
my $C = shift;
$C->octint
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
;

if (($C) = ($C->_PATTERN(qr/\G(?i:\[)/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['octints'], sub {
my $C = shift;
$C->octints
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G(?i:\])/)
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'octal character', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token backslash:Q { <sym> <.obs('\\Q as quotemeta', 'quotes or literal variable match')> }
sub backslash__S_059Q__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_059Q', $retree) }
sub backslash__S_059Q {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_059Q");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "Q";
$self->_MATCHIFYr($S, "backslash__S_059Q", do {
my $C = $C;
if (($C) = ($C->_EXACT("Q"))
and ($C) = ($C->obs('\\Q as quotemeta', 'quotes or literal variable match'))) {
$C
} else { () }
});
}
;
## token backslash:r { :i <sym> }
sub backslash__S_060r__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_060r', $retree) }
sub backslash__S_060r {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_060r");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "r";
$self->_MATCHIFYr($S, "backslash__S_060r", $C->_PATTERN(qr/\G(?i:r)/));
}
;
## token backslash:s { :i <sym> }
sub backslash__S_061s__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_061s', $retree) }
sub backslash__S_061s {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_061s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "s";
$self->_MATCHIFYr($S, "backslash__S_061s", $C->_PATTERN(qr/\G(?i:s)/));
}
;
## token backslash:t { :i <sym> }
sub backslash__S_062t__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_062t', $retree) }
sub backslash__S_062t {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_062t");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "t";
$self->_MATCHIFYr($S, "backslash__S_062t", $C->_PATTERN(qr/\G(?i:t)/));
}
;
## token backslash:v { :i <sym> }
sub backslash__S_063v__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_063v', $retree) }
sub backslash__S_063v {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_063v");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "v";
$self->_MATCHIFYr($S, "backslash__S_063v", $C->_PATTERN(qr/\G(?i:v)/));
}
;
## token backslash:w { :i <sym> }
sub backslash__S_064w__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_064w', $retree) }
sub backslash__S_064w {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_064w");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "w";
$self->_MATCHIFYr($S, "backslash__S_064w", $C->_PATTERN(qr/\G(?i:w)/));
}
;
## token backslash:x { :i :dba('hex character') <sym> [ <hexint> | '[' ~ ']' <hexints> ] }
sub backslash__S_065x__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_065x', $retree) }
sub backslash__S_065x {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_065x");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "x";
$self->_MATCHIFYr($S, "backslash__S_065x", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G(?i:x)/))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'backslash__S_065x_0') {
        $C->deb("Fate passed to backslash__S_065x_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT backslash__S_065x_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM backslash__S_065x_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'backslash__S_065x_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("backslash__S_065x_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['hexint'], sub {
my $C = shift;
$C->hexint
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\]";
my $goalpos = $C;
;

if (($C) = ($C->_PATTERN(qr/\G(?i:\[)/))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_SUBSUMEr(['hexints'], sub {
my $C = shift;
$C->hexints
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_PATTERN(qr/\G(?i:\])/)
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'hex character', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token backslash:z { <sym> <.obs('\\z as end-of-string matcher', '$')> }
sub backslash__S_066z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_066z', $retree) }
sub backslash__S_066z {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_066z");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "z";
$self->_MATCHIFYr($S, "backslash__S_066z", do {
my $C = $C;
if (($C) = ($C->_EXACT("z"))
and ($C) = ($C->obs('\\z as end-of-string matcher', '$'))) {
$C
} else { () }
});
}
;
## token backslash:Z { <sym> <.obs('\\Z as end-of-string matcher', '\\n?$')> }
sub backslash__S_067Z__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_067Z', $retree) }
sub backslash__S_067Z {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_067Z");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "Z";
$self->_MATCHIFYr($S, "backslash__S_067Z", do {
my $C = $C;
if (($C) = ($C->_EXACT("Z"))
and ($C) = ($C->obs('\\Z as end-of-string matcher', '\\n?$'))) {
$C
} else { () }
});
}
;
## token backslash:misc { $<litchar>=(\W) }
sub backslash__S_068misc__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_068misc', $retree) }
sub backslash__S_068misc {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_068misc");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "misc";
$self->_MATCHIFYr($S, "backslash__S_068misc", $C->_SUBSUMEr(['litchar'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\W/)

})
}));
}
;
## token backslash:oldbackref { (<[1..9]>\d*) { my $d = $0.Str; $¢.sorryobs("the 1-based special form '
sub backslash__S_069oldbackref__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_069oldbackref', $retree) }
sub backslash__S_069oldbackref {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_069oldbackref");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "oldbackref";
$self->_MATCHIFYr($S, "backslash__S_069oldbackref", do {
if (my ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G[1-9]\d*+/)

})
}))) {
scalar(do {
my $M = $C;
my $d = $M->{0}->Str;
$C->sorryobs("the 1-based special form '\\$d' as a backreference", "the 0-based variable '\$" . ($d - 1) . "' instead" );
}, $C)
} else { () }
});
}
;
## token backslash:oops { <.sorry: "Unrecognized regex backslash sequence"> . }
sub backslash__S_070oops__PEEK { $_[0]->_AUTOLEXpeek('backslash__S_070oops', $retree) }
sub backslash__S_070oops {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE backslash__S_070oops");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "oops";
$self->_MATCHIFYr($S, "backslash__S_070oops", do {
if (my ($C) = ($C->sorry("Unrecognized regex backslash sequence"))) {
$C->cursor_incr()
} else { () }
});
}
;
## token assertion:sym<...> { <sym> }
sub assertion__S_071DotDotDot__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_071DotDotDot', $retree) }
sub assertion__S_071DotDotDot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_071DotDotDot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.\.\.";
$self->_MATCHIFYr($S, "assertion__S_071DotDotDot", $C->_EXACT("\.\.\."));
}
;
## token assertion:sym<???> { <sym> }
sub assertion__S_072QuestionQuestionQuestion__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_072QuestionQuestionQuestion', $retree) }
sub assertion__S_072QuestionQuestionQuestion {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_072QuestionQuestionQuestion");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?\?\?";
$self->_MATCHIFYr($S, "assertion__S_072QuestionQuestionQuestion", $C->_EXACT("\?\?\?"));
}
;
## token assertion:sym<!!!> { <sym> }
sub assertion__S_073BangBangBang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_073BangBangBang', $retree) }
sub assertion__S_073BangBangBang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_073BangBangBang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!\!\!";
$self->_MATCHIFYr($S, "assertion__S_073BangBangBang", $C->_EXACT("\!\!\!"));
}
;
## token assertion:sym<?> { <sym> [ <?before '>'> | <assertion> ] }
sub assertion__S_074Question__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_074Question', $retree) }
sub assertion__S_074Question {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_074Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?";
$self->_MATCHIFYr($S, "assertion__S_074Question", do {
my $C = $C;
if (($C) = ($C->_EXACT("\?"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_074Question_0') {
        $C->deb("Fate passed to assertion__S_074Question_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT assertion__S_074Question_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM assertion__S_074Question_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'assertion__S_074Question_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("assertion__S_074Question_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token assertion:sym<!> { <sym> [ <?before '>'> | <assertion> ] }
sub assertion__S_075Bang__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_075Bang', $retree) }
sub assertion__S_075Bang {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_075Bang");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\!";
$self->_MATCHIFYr($S, "assertion__S_075Bang", do {
my $C = $C;
if (($C) = ($C->_EXACT("\!"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_075Bang_0') {
        $C->deb("Fate passed to assertion__S_075Bang_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT assertion__S_075Bang_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM assertion__S_075Bang_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'assertion__S_075Bang_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("assertion__S_075Bang_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token assertion:sym<*> { <sym> [ <?before '>'> | <.ws> <nibbler> ] }
sub assertion__S_076Star__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_076Star', $retree) }
sub assertion__S_076Star {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_076Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*";
$self->_MATCHIFYr($S, "assertion__S_076Star", do {
my $C = $C;
if (($C) = ($C->_EXACT("\*"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_076Star_0') {
        $C->deb("Fate passed to assertion__S_076Star_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT assertion__S_076Star_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM assertion__S_076Star_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'assertion__S_076Star_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("assertion__S_076Star_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->ws)) {
$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token assertion:sym<{ }> { <embeddedblock> }
sub assertion__S_077Cur_Ly__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_077Cur_Ly', $retree) }
sub assertion__S_077Cur_Ly {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_077Cur_Ly");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\{\ \}";
$self->_MATCHIFYr($S, "assertion__S_077Cur_Ly", $C->_SUBSUMEr(['embeddedblock'], sub {
my $C = shift;
$C->embeddedblock
}));
}
;
## token assertion:variable {
sub assertion__S_078variable__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_078variable', $retree) }
sub assertion__S_078variable {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_078variable");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "variable";
$self->_MATCHIFYr($S, "assertion__S_078variable", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_SUBSUMEr(['sigil'], sub {
my $C = shift;
$C->sigil
})
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));
$C = bless($C, (ref($newlang) || $newlang));
;

$C->_SUBSUMEr(['variable'], sub {
my $C = shift;
$C->EXPR(\%LOOSEST)
})
}))) {
$C
} else { () }
});
}
;
## token assertion:method {
sub assertion__S_079method__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_079method', $retree) }
sub assertion__S_079method {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_079method");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "method";
$self->_MATCHIFYr($S, "assertion__S_079method", do {
my $C = $C;
if (($C) = ($C->_EXACT("\."))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_079method_0') {
        $C->deb("Fate passed to assertion__S_079method_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT assertion__S_079method_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM assertion__S_079method_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'assertion__S_079method_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("assertion__S_079method_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G[_[:alpha:]]/)
}))) { ($C) } else { () }
}))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));
$C = bless($C, (ref($newlang) || $newlang));
;

$C->_SUBSUMEr(['dottyop'], sub {
my $C = shift;
$C->dottyop
})
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token assertion:name { [ :lang($¢.cursor_fresh(%*LANG<MAIN>).unbalanced('>')) <longname> ]
sub assertion__S_080name__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_080name', $retree) }
sub assertion__S_080name {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_080name");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'arglist'} = [];
$C->{'assertion'} = [];
$C->{'nibbler'} = [];
$C->{sym} = "name";
$self->_MATCHIFYr($S, "assertion__S_080name", do {
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));
$C = bless($C, (ref($newlang) || $newlang));
;

$C->_SUBSUMEr(['longname'], sub {
my $C = shift;
$C->longname
})
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_080name_0') {
        $C->deb("Fate passed to assertion__S_080name_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT assertion__S_080name_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM assertion__S_080name_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'assertion__S_080name_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("assertion__S_080name_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
if (($C) = ($C->ws)
and ($C) = ($C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
}))
and ($C) = ($C->ws)) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_EXACT("\="))) {
$C->_SUBSUMEr(['assertion'], sub {
my $C = shift;
$C->assertion
})
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->ws)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($C->cursor_fresh($::LANG{'MAIN'})->unbalanced('>'));
$C = bless($C, (ref($newlang) || $newlang));
;

$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))) {
$C
} else { () }
},
sub {
my $C=shift;
if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
;

$C->_SUBSUMEr(['arglist'], sub {
my $C = shift;
$C->arglist
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->panic("Assertion call missing right parenthesis"))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
})
} else { () }
});
}
;
## token assertion:sym<[> { <?before '['> <cclass_elem>+ }
sub assertion__S_081Bra__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_081Bra', $retree) }
sub assertion__S_081Bra {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_081Bra");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'cclass_elem'} = [];
$C->{sym} = "\[";
$self->_MATCHIFYr($S, "assertion__S_081Bra", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\[")
}))) { ($C) } else { () }
}))) {
$C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
})
} else { () }
});
}
;
## token assertion:sym<+> { <?before '+'> <cclass_elem>+ }
sub assertion__S_082Plus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_082Plus', $retree) }
sub assertion__S_082Plus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_082Plus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'cclass_elem'} = [];
$C->{sym} = "\+";
$self->_MATCHIFYr($S, "assertion__S_082Plus", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\+")
}))) { ($C) } else { () }
}))) {
$C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
})
} else { () }
});
}
;
## token assertion:sym<-> { <?before '-'> <cclass_elem>+ }
sub assertion__S_083Minus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_083Minus', $retree) }
sub assertion__S_083Minus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_083Minus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'cclass_elem'} = [];
$C->{sym} = "\-";
$self->_MATCHIFYr($S, "assertion__S_083Minus", do {
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\-")
}))) { ($C) } else { () }
}))) {
$C->_PLUSr(sub {
my $C=shift;
$C->_SUBSUMEr(['cclass_elem'], sub {
my $C = shift;
$C->cclass_elem
})
})
} else { () }
});
}
;
## token assertion:sym<.> { <sym> }
sub assertion__S_084Dot__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_084Dot', $retree) }
sub assertion__S_084Dot {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_084Dot");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\.";
$self->_MATCHIFYr($S, "assertion__S_084Dot", $C->_EXACT("\."));
}
;
## token assertion:sym<,> { <sym> }
sub assertion__S_085Comma__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_085Comma', $retree) }
sub assertion__S_085Comma {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_085Comma");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\,";
$self->_MATCHIFYr($S, "assertion__S_085Comma", $C->_EXACT("\,"));
}
;
## token assertion:sym<~~> { <sym> [ <?before '>'> | \d+ | <desigilname> ] }
sub assertion__S_086TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_086TildeTilde', $retree) }
sub assertion__S_086TildeTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_086TildeTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\~";
$self->_MATCHIFYr($S, "assertion__S_086TildeTilde", do {
my $C = $C;
if (($C) = ($C->_EXACT("\~\~"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'assertion__S_086TildeTilde_0') {
        $C->deb("Fate passed to assertion__S_086TildeTilde_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT assertion__S_086TildeTilde_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM assertion__S_086TildeTilde_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'assertion__S_086TildeTilde_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("assertion__S_086TildeTilde_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_EXACT("\>")
}))) { ($C) } else { () }
}))) { ($C) } else { () }
},
sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)
},
sub {
my $C=shift;
$C->_SUBSUMEr(['desigilname'], sub {
my $C = shift;
$C->desigilname
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token assertion:bogus { <.panic: "Unrecognized regex assertion"> }
sub assertion__S_087bogus__PEEK { $_[0]->_AUTOLEXpeek('assertion__S_087bogus', $retree) }
sub assertion__S_087bogus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE assertion__S_087bogus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "bogus";
$self->_MATCHIFYr($S, "assertion__S_087bogus", $C->panic("Unrecognized regex assertion"));
}
;
## token sign { '+' | '-' | <?> }
sub sign__PEEK { $_[0]->_AUTOLEXpeek('sign', $retree) }
sub sign {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE sign");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "sign", do {
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'sign_0') {
        $C->deb("Fate passed to sign_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT sign_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM sign_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'sign_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("sign_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\+")
},
sub {
my $C=shift;
$C->_EXACT("\-")
},
sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C
}))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
});
}
;
## token cclass_elem {
sub cclass_elem__PEEK { $_[0]->_AUTOLEXpeek('cclass_elem', $retree) }
sub cclass_elem {
no warnings 'recursion';
my $self = shift;

local $::CCSTATE = '';

local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE cclass_elem");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "cclass_elem", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sign'], sub {
my $C = shift;
$C->sign
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->normspace)) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'cclass_elem_0') {
        $C->deb("Fate passed to cclass_elem_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT cclass_elem_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM cclass_elem_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'cclass_elem_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("cclass_elem_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_SUBSUMEr(['name'], sub {
my $C = shift;
$C->name
})
},
sub {
my $C=shift;
if (my ($C) = ($C->_SUBSUMEr(['before'], sub {
my $C = shift;
$C->before(sub {
my $C=shift;
$C->_EXACT("\[")
})
}))) {
$C->_SUBSUMEr(['quibble'], sub {
my $C = shift;
$C->quibble($C->cursor_fresh( $::LANG{'Q'} )->tweak('cc' => 1))
})
} else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->normspace)) { ($C) } else { () }
})
} else { () }
});
}
;
## token mod_arg { :dba('modifier argument') '(' ~ ')' [:lang(%*LANG<MAIN>) <semilist> ] }
sub mod_arg__PEEK { $_[0]->_AUTOLEXpeek('mod_arg', $retree) }
sub mod_arg {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_arg");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "mod_arg", $C->_BRACKETr(sub {
my $C=shift;
local $::GOAL = "\)";
my $goalpos = $C;
;

if (($C) = ($C->_EXACT("\("))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
;

$C->_SUBSUMEr(['semilist'], sub {
my $C = shift;
$C->semilist
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {my $C = $C->cursor_xact('ALT ||');
my $xact = $C->xact;
my @gather;
do {
push @gather, $C->_EXACT("\)")
}
or $xact->[-2] or
do {
push @gather, do {
if (my ($C) = ($C->FAILGOAL($::GOAL, 'modifier argument', $goalpos))) { ($C) } else { () }
}
};
@gather;
}
}))) {
$C
} else { () }
}));
}
;
## token mod_internal:sym<:my>    { ':' <?before ['my'|'state'|'our'|'anon'|'constant'|'temp'|'let'] \s
sub mod_internal__S_088Colonmy__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_088Colonmy', $retree) }
sub mod_internal__S_088Colonmy {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_088Colonmy");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:my";
$self->_MATCHIFYr($S, "mod_internal__S_088Colonmy", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_088Colonmy_0') {
        $C->deb("Fate passed to mod_internal__S_088Colonmy_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT mod_internal__S_088Colonmy_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM mod_internal__S_088Colonmy_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_088Colonmy_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("mod_internal__S_088Colonmy_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("my")
},
sub {
my $C=shift;
$C->_EXACT("state")
},
sub {
my $C=shift;
$C->_EXACT("our")
},
sub {
my $C=shift;
$C->_EXACT("anon")
},
sub {
my $C=shift;
$C->_EXACT("constant")
},
sub {
my $C=shift;
$C->_EXACT("temp")
},
sub {
my $C=shift;
$C->_EXACT("let")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C->_PATTERN(qr/\G\s/)
} else { () }
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
;

do {
if (my ($C) = ($C->_SUBSUMEr(['statement'], sub {
my $C = shift;
$C->statement
}))) {
$C->_SUBSUMEr(['eat_terminator'], sub {
my $C = shift;
$C->eat_terminator
})
} else { () }
}
}))) {
$C
} else { () }
});
}
;
## token mod_internal:sym<:i>    { $<sym>=[':i'|':ignorecase'] » { %*RX<i> = 1 } }
sub mod_internal__S_089Coloni__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_089Coloni', $retree) }
sub mod_internal__S_089Coloni {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_089Coloni");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:i";
$self->_MATCHIFYr($S, "mod_internal__S_089Coloni", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_089Coloni_0') {
        $C->deb("Fate passed to mod_internal__S_089Coloni_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT mod_internal__S_089Coloni_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM mod_internal__S_089Coloni_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_089Coloni_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("mod_internal__S_089Coloni_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:i")
},
sub {
my $C=shift;
$C->_EXACT("\:ignorecase")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'i'} = 1 }, $C)
} else { () }
});
}
;
## token mod_internal:sym<:!i>   { $<sym>=[':!i'|':!ignorecase'] » { %*RX<i> = 0 } }
sub mod_internal__S_090ColonBangi__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_090ColonBangi', $retree) }
sub mod_internal__S_090ColonBangi {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_090ColonBangi");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\!i";
$self->_MATCHIFYr($S, "mod_internal__S_090ColonBangi", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_090ColonBangi_0') {
        $C->deb("Fate passed to mod_internal__S_090ColonBangi_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT mod_internal__S_090ColonBangi_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM mod_internal__S_090ColonBangi_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_090ColonBangi_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("mod_internal__S_090ColonBangi_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:\!i")
},
sub {
my $C=shift;
$C->_EXACT("\:\!ignorecase")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'i'} = 0 }, $C)
} else { () }
});
}
;
## token mod_internal:sym<:i( )> { $<sym>=[':i'|':ignorecase'] <mod_arg> { %*RX<i> = eval $<mod_arg>.St
sub mod_internal__S_091ColoniParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_091ColoniParen_Thesis', $retree) }
sub mod_internal__S_091ColoniParen_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_091ColoniParen_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:i\(\ \)";
$self->_MATCHIFYr($S, "mod_internal__S_091ColoniParen_Thesis", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_091ColoniParen_Thesis_0') {
        $C->deb("Fate passed to mod_internal__S_091ColoniParen_Thesis_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT mod_internal__S_091ColoniParen_Thesis_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM mod_internal__S_091ColoniParen_Thesis_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_091ColoniParen_Thesis_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("mod_internal__S_091ColoniParen_Thesis_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:i")
},
sub {
my $C=shift;
$C->_EXACT("\:ignorecase")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})
}))
and ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;
$::RX{'i'} = eval $M->{'mod_arg'}->Str }, $C)
} else { () }
});
}
;
## token mod_internal:sym<:0i>   { ':' (\d+) ['i'|'ignorecase'] { %*RX<i> = $0 } }
sub mod_internal__S_092Colon0i__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_092Colon0i', $retree) }
sub mod_internal__S_092Colon0i {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_092Colon0i");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:0i";
$self->_MATCHIFYr($S, "mod_internal__S_092Colon0i", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_092Colon0i_0') {
        $C->deb("Fate passed to mod_internal__S_092Colon0i_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT mod_internal__S_092Colon0i_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM mod_internal__S_092Colon0i_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_092Colon0i_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("mod_internal__S_092Colon0i_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("i")
},
sub {
my $C=shift;
$C->_EXACT("ignorecase")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
scalar(do {
my $M = $C;
$::RX{'i'} = $M->{0} }, $C)
} else { () }
});
}
;
## token mod_internal:sym<:a>    { $<sym>=[':a'|':ignoreaccent'] » { %*RX<a> = 1 } }
sub mod_internal__S_093Colona__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_093Colona', $retree) }
sub mod_internal__S_093Colona {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_093Colona");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:a";
$self->_MATCHIFYr($S, "mod_internal__S_093Colona", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_093Colona_0') {
        $C->deb("Fate passed to mod_internal__S_093Colona_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT mod_internal__S_093Colona_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM mod_internal__S_093Colona_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_093Colona_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("mod_internal__S_093Colona_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:a")
},
sub {
my $C=shift;
$C->_EXACT("\:ignoreaccent")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'a'} = 1 }, $C)
} else { () }
});
}
;
## token mod_internal:sym<:!a>   { $<sym>=[':!a'|':!ignoreaccent'] » { %*RX<a> = 0 } }
sub mod_internal__S_094ColonBanga__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_094ColonBanga', $retree) }
sub mod_internal__S_094ColonBanga {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_094ColonBanga");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\!a";
$self->_MATCHIFYr($S, "mod_internal__S_094ColonBanga", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_094ColonBanga_0') {
        $C->deb("Fate passed to mod_internal__S_094ColonBanga_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT mod_internal__S_094ColonBanga_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM mod_internal__S_094ColonBanga_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_094ColonBanga_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("mod_internal__S_094ColonBanga_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:\!a")
},
sub {
my $C=shift;
$C->_EXACT("\:\!ignoreaccent")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})
}))
and ($C) = ($C->_PATTERN(qr/\G\b/))) {
scalar(do {
$::RX{'a'} = 0 }, $C)
} else { () }
});
}
;
## token mod_internal:sym<:a( )> { $<sym>=[':a'|':ignoreaccent'] <mod_arg> { %*RX<a> = eval $<mod_arg>.
sub mod_internal__S_095ColonaParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_095ColonaParen_Thesis', $retree) }
sub mod_internal__S_095ColonaParen_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_095ColonaParen_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:a\(\ \)";
$self->_MATCHIFYr($S, "mod_internal__S_095ColonaParen_Thesis", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['sym'], sub {
my $C = shift;
$C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_095ColonaParen_Thesis_0') {
        $C->deb("Fate passed to mod_internal__S_095ColonaParen_Thesis_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT mod_internal__S_095ColonaParen_Thesis_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM mod_internal__S_095ColonaParen_Thesis_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_095ColonaParen_Thesis_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("mod_internal__S_095ColonaParen_Thesis_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:a")
},
sub {
my $C=shift;
$C->_EXACT("\:ignoreaccent")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
})
}))
and ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;
$::RX{'a'} = eval $M->{'mod_arg'}->Str }, $C)
} else { () }
});
}
;
## token mod_internal:sym<:0a>   { ':' (\d+) ['a'|'ignoreaccent'] { %*RX<a> = $0 } }
sub mod_internal__S_096Colon0a__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_096Colon0a', $retree) }
sub mod_internal__S_096Colon0a {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_096Colon0a");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:0a";
$self->_MATCHIFYr($S, "mod_internal__S_096Colon0a", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_096Colon0a_0') {
        $C->deb("Fate passed to mod_internal__S_096Colon0a_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT mod_internal__S_096Colon0a_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM mod_internal__S_096Colon0a_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_096Colon0a_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("mod_internal__S_096Colon0a_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("a")
},
sub {
my $C=shift;
$C->_EXACT("ignoreaccent")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
scalar(do {
my $M = $C;
$::RX{'a'} = $M->{0} }, $C)
} else { () }
});
}
;
## token mod_internal:sym<:s>    { ':s' 'igspace'? » { %*RX<s> = 1 } }
sub mod_internal__S_097Colons__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_097Colons', $retree) }
sub mod_internal__S_097Colons {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_097Colons");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:s";
$self->_MATCHIFYr($S, "mod_internal__S_097Colons", do {
if (my ($C) = ($C->_PATTERN(qr/\G\:s(?:igspace)?+\b/))) {
scalar(do {
$::RX{'s'} = 1 }, $C)
} else { () }
});
}
;
## token mod_internal:sym<:!s>   { ':!s' 'igspace'? » { %*RX<s> = 0 } }
sub mod_internal__S_098ColonBangs__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_098ColonBangs', $retree) }
sub mod_internal__S_098ColonBangs {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_098ColonBangs");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\!s";
$self->_MATCHIFYr($S, "mod_internal__S_098ColonBangs", do {
if (my ($C) = ($C->_PATTERN(qr/\G\:\!s(?:igspace)?+\b/))) {
scalar(do {
$::RX{'s'} = 0 }, $C)
} else { () }
});
}
;
## token mod_internal:sym<:s( )> { ':s' 'igspace'? <mod_arg> { %*RX<s> = eval $<mod_arg>.Str } }
sub mod_internal__S_099ColonsParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_099ColonsParen_Thesis', $retree) }
sub mod_internal__S_099ColonsParen_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_099ColonsParen_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:s\(\ \)";
$self->_MATCHIFYr($S, "mod_internal__S_099ColonsParen_Thesis", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\:s(?:igspace)?+/))
and ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;
$::RX{'s'} = eval $M->{'mod_arg'}->Str }, $C)
} else { () }
});
}
;
## token mod_internal:sym<:0s>   { ':' (\d+) 's' 'igspace'? » { %*RX<s> = $0 } }
sub mod_internal__S_100Colon0s__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_100Colon0s', $retree) }
sub mod_internal__S_100Colon0s {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_100Colon0s");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:0s";
$self->_MATCHIFYr($S, "mod_internal__S_100Colon0s", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))
and ($C) = ($C->_PATTERN(qr/\Gs(?:igspace)?+\b/))) {
scalar(do {
my $M = $C;
$::RX{'s'} = $M->{0} }, $C)
} else { () }
});
}
;
## token mod_internal:sym<:r>    { ':r' 'atchet'? » { %*RX<r> = 1 } }
sub mod_internal__S_101Colonr__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_101Colonr', $retree) }
sub mod_internal__S_101Colonr {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_101Colonr");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:r";
$self->_MATCHIFYr($S, "mod_internal__S_101Colonr", do {
if (my ($C) = ($C->_PATTERN(qr/\G\:r(?:atchet)?+\b/))) {
scalar(do {
$::RX{'r'} = 1 }, $C)
} else { () }
});
}
;
## token mod_internal:sym<:!r>   { ':!r' 'atchet'? » { %*RX<r> = 0 } }
sub mod_internal__S_102ColonBangr__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_102ColonBangr', $retree) }
sub mod_internal__S_102ColonBangr {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_102ColonBangr");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:\!r";
$self->_MATCHIFYr($S, "mod_internal__S_102ColonBangr", do {
if (my ($C) = ($C->_PATTERN(qr/\G\:\!r(?:atchet)?+\b/))) {
scalar(do {
$::RX{'r'} = 0 }, $C)
} else { () }
});
}
;
## token mod_internal:sym<:r( )> { ':r' 'atchet'? » <mod_arg> { %*RX<r> = eval $<mod_arg>.Str } }
sub mod_internal__S_103ColonrParen_Thesis__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_103ColonrParen_Thesis', $retree) }
sub mod_internal__S_103ColonrParen_Thesis {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_103ColonrParen_Thesis");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:r\(\ \)";
$self->_MATCHIFYr($S, "mod_internal__S_103ColonrParen_Thesis", do {
my $C = $C;
if (($C) = ($C->_PATTERN(qr/\G\:r(?:atchet)?+\b/))
and ($C) = ($C->_SUBSUMEr(['mod_arg'], sub {
my $C = shift;
$C->mod_arg
}))) {
scalar(do {
my $M = $C;
$::RX{'r'} = eval $M->{'mod_arg'}->Str }, $C)
} else { () }
});
}
;
## token mod_internal:sym<:0r>   { ':' (\d+) 'r' 'atchet'? » { %*RX<r> = $0 } }
sub mod_internal__S_104Colon0r__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_104Colon0r', $retree) }
sub mod_internal__S_104Colon0r {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_104Colon0r");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:0r";
$self->_MATCHIFYr($S, "mod_internal__S_104Colon0r", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)

})
}))
and ($C) = ($C->_PATTERN(qr/\Gr(?:atchet)?+\b/))) {
scalar(do {
my $M = $C;
$::RX{'r'} = $M->{0} }, $C)
} else { () }
});
}
;
## token mod_internal:sym<:Perl5>    { [':Perl5' | ':P5'] <.require_P5> [ :lang( $¢.cursor_fresh( %*LAN
sub mod_internal__S_105ColonPerl5__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_105ColonPerl5', $retree) }
sub mod_internal__S_105ColonPerl5 {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_105ColonPerl5");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:Perl5";
$self->_MATCHIFYr($S, "mod_internal__S_105ColonPerl5", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_105ColonPerl5_0') {
        $C->deb("Fate passed to mod_internal__S_105ColonPerl5_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT mod_internal__S_105ColonPerl5_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM mod_internal__S_105ColonPerl5_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_105ColonPerl5_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("mod_internal__S_105ColonPerl5_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\:Perl5")
},
sub {
my $C=shift;
$C->_EXACT("\:P5")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->require_P5)
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ( $C->cursor_fresh( $::LANG{'P5Regex'} )->unbalanced($::GOAL) );
$C = bless($C, (ref($newlang) || $newlang));
;

$C->_SUBSUMEr(['nibbler'], sub {
my $C = shift;
$C->nibbler
})
}))) {
$C
} else { () }
});
}
;
## token mod_internal:p6adv {
sub mod_internal__S_106p6adv__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_106p6adv', $retree) }
sub mod_internal__S_106p6adv {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_106p6adv");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "p6adv";
$self->_MATCHIFYr($S, "mod_internal__S_106p6adv", do {
my $C = $C;
if (($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'mod_internal__S_106p6adv_0') {
        $C->deb("Fate passed to mod_internal__S_106p6adv_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT mod_internal__S_106p6adv_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM mod_internal__S_106p6adv_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'mod_internal__S_106p6adv_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("mod_internal__S_106p6adv_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("dba")
},
sub {
my $C=shift;
$C->_EXACT("lang")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C->_PATTERN(qr/\G\b/)
} else { () }
};
}))) { ($C) } else { () }
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
my $newlang = ($::LANG{'MAIN'});
$C = bless($C, (ref($newlang) || $newlang));
;

$C->_SUBSUMEr(['quotepair'], sub {
my $C = shift;
$C->quotepair
})
}))) {
scalar(do {
my $M = $C;
$M->{'sym'} = ':' . $M->{'quotepair'}->{'k'} }, $C)
} else { () }
});
}
;
## token mod_internal:oops { (':'\w+) <.sorry: "Unrecognized regex modifier " ~ $0.Str > }
sub mod_internal__S_107oops__PEEK { $_[0]->_AUTOLEXpeek('mod_internal__S_107oops', $retree) }
sub mod_internal__S_107oops {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE mod_internal__S_107oops");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "oops";
$self->_MATCHIFYr($S, "mod_internal__S_107oops", do {
my $C = $C;
if (($C) = ($C->_SUBSUMEr(['0'], sub {
my $C = shift;
$C->_PAREN( sub {
my $C=shift;
$C->_PATTERN(qr/\G\:\w++/)

})
}))
and ($C) = (do {
my $M = $C;
$C->sorry("Unrecognized regex modifier " . $M->{0}->Str )
})) {
$C
} else { () }
});
}
;
## token quantifier:sym<*>  { <sym> <quantmod> }
sub quantifier__S_108Star__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_108Star', $retree) }
sub quantifier__S_108Star {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_108Star");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\*";
$self->_MATCHIFYr($S, "quantifier__S_108Star", do {
if (my ($C) = ($C->_EXACT("\*"))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
})
} else { () }
});
}
;
## token quantifier:sym<+>  { <sym> <quantmod> }
sub quantifier__S_109Plus__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_109Plus', $retree) }
sub quantifier__S_109Plus {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_109Plus");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\+";
$self->_MATCHIFYr($S, "quantifier__S_109Plus", do {
if (my ($C) = ($C->_EXACT("\+"))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
})
} else { () }
});
}
;
## token quantifier:sym<?>  { <sym> <quantmod> }
sub quantifier__S_110Question__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_110Question', $retree) }
sub quantifier__S_110Question {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_110Question");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\?";
$self->_MATCHIFYr($S, "quantifier__S_110Question", do {
if (my ($C) = ($C->_EXACT("\?"))) {
$C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
})
} else { () }
});
}
;
## token quantifier:sym<:>  { <sym> {} <?before \s> }
sub quantifier__S_111Colon__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_111Colon', $retree) }
sub quantifier__S_111Colon {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_111Colon");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\:";
$self->_MATCHIFYr($S, "quantifier__S_111Colon", do {
my $C = $C;
if (($C) = ($C->_EXACT("\:"))
and ($C) = (scalar(do {
}, $C))
and ($C) = ($C->before(sub {
my $C=shift;
if (my ($C) = ($C->before(sub {
my $C=shift;
$C->_PATTERN(qr/\G\s/)
}))) { ($C) } else { () }
}))) {
$C
} else { () }
});
}
;
## token quantifier:sym<**> { <sym> :: <normspace>? <quantmod> <normspace>?
sub quantifier__S_112StarStar__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_112StarStar', $retree) }
sub quantifier__S_112StarStar {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_112StarStar");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{'normspace'} = [];
$C->{sym} = "\*\*";
$self->_MATCHIFYr($S, "quantifier__S_112StarStar", do {
my $C = $C;
if (($C) = ($C->_EXACT("\*\*"))
and ($C) = ($C->_COMMITLTM())
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))
and ($C) = ($C->_SUBSUMEr(['quantmod'], sub {
my $C = shift;
$C->quantmod
}))
and ($C) = ($C->_OPTr(sub {
my $C=shift;
$C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
})
}))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantifier__S_112StarStar_0') {
        $C->deb("Fate passed to quantifier__S_112StarStar_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT quantifier__S_112StarStar_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM quantifier__S_112StarStar_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_112StarStar_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("quantifier__S_112StarStar_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
if (($C) = ($C->_PATTERN(qr/\G\d++\s++\.\./))
and ($C) = ($C->panic("Spaces not allowed in bare range"))) {
$C
} else { () }
},
sub {
my $C=shift;
if (my ($C) = ($C->_PATTERN(qr/\G\d++/))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
if (($C) = ($C->_EXACT("\.\."))
and ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantifier__S_112StarStar_1') {
        $C->deb("Fate passed to quantifier__S_112StarStar_1: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT quantifier__S_112StarStar_1';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM quantifier__S_112StarStar_1'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_112StarStar_1', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("quantifier__S_112StarStar_1 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_PATTERN(qr/\G\d++/)
},
sub {
my $C=shift;
$C->_EXACT("\*")
},
sub {
my $C=shift;
if (my ($C) = ($C->panic("Malformed range"))) { ($C) } else { () }
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
}))) { ($C) } else { () }
})
} else { () }
},
sub {
my $C=shift;
$C->_SUBSUMEr(['embeddedblock'], sub {
my $C = shift;
$C->embeddedblock
})
},
sub {
my $C=shift;
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) {
$C
} else { () }
});
}
;
## token quantifier:sym<~~> {
sub quantifier__S_113TildeTilde__PEEK { $_[0]->_AUTOLEXpeek('quantifier__S_113TildeTilde', $retree) }
sub quantifier__S_113TildeTilde {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantifier__S_113TildeTilde");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "\~\~";
$self->_MATCHIFYr($S, "quantifier__S_113TildeTilde", do {
my $C = $C;
if (($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantifier__S_113TildeTilde_0') {
        $C->deb("Fate passed to quantifier__S_113TildeTilde_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT quantifier__S_113TildeTilde_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM quantifier__S_113TildeTilde_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'quantifier__S_113TildeTilde_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("quantifier__S_113TildeTilde_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\!\~\~")
},
sub {
my $C=shift;
$C->_EXACT("\~\~")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))
and ($C) = ($C->_SUBSUMEr(['normspace'], sub {
my $C = shift;
$C->normspace
}))) {
$C->_SUBSUMEr(['quantified_atom'], sub {
my $C = shift;
$C->quantified_atom
})
} else { () }
});
}
;
## token quantmod { ':'? [ '?' | '!' | '+' ]? }
sub quantmod__PEEK { $_[0]->_AUTOLEXpeek('quantmod', $retree) }
sub quantmod {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE quantmod");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$self->_MATCHIFYr($S, "quantmod", do {
if (my ($C) = ($C->_PATTERN(qr/\G\:?+/))) {
$C->_OPTr(sub {
my $C=shift;
if (my ($C) = ($C->_BRACKETr(sub {
my $C=shift;
do {
    my ($tag, $try);
    my @try;
    my $relex;

    my $fate;
    my $x;
    if ($fate = $C->{'_fate'} and $fate->[1] eq 'quantmod_0') {
        $C->deb("Fate passed to quantmod_0: ", ::fatestr($fate)) if $::DEBUG & DEBUG::fates;
        ($C->{'_fate'}, $tag, $try) = @$fate;
        @try = ($try);
        $x = 'ALT quantmod_0';    # some outer ltm is controlling us
    }
    else {
        $x = 'ALTLTM quantmod_0'; # we are top level ltm
    }
    my $C = $C->cursor_xact($x);
    my $xact = $C->{_xact};

    my @gather = ();
    for (;;) {
        unless (@try) {
            $relex //= $C->cursor_fate('STD::Regex', 'quantmod_0', $retree);
            @try = $relex->($C) or last;
        }
        $try = shift(@try) // next;

        if (ref $try) {
            ($C->{'_fate'}, $tag, $try) = @$try;   # next candidate fate
        }

        $C->deb("quantmod_0 trying $tag $try") if $::DEBUG & DEBUG::try_processing;
        push @gather, ((
sub {
my $C=shift;
$C->_EXACT("\?")
},
sub {
my $C=shift;
$C->_EXACT("\!")
},
sub {
my $C=shift;
$C->_EXACT("\+")
}
        )[$try])->($C);
        last if @gather;
        last if $xact->[-2];  # committed?
    }
    @gather;
};
}))) { ($C) } else { () }
})
} else { () }
});
}
;
 moose_around tweak  => sub {
    my $orig = shift;
    no warnings 'recursion';
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{Perl5} || exists $args{P5};
my $P5 = exists $args{Perl5} ? delete $args{Perl5} : exists $args{P5} ? delete $args{P5} : undef;
$self->require_P5;
$self->cursor_fresh( $::LANG{'Q'} )->mixin( 'STD::Q::q' )->mixin( 'STD::Q::p5' ) ;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{overlap} || exists $args{ov};
my $ov = exists $args{overlap} ? delete $args{overlap} : exists $args{ov} ? delete $args{ov} : undef;
$::RX{'ov'} = $ov;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{exhaustive} || exists $args{ex};
my $ex = exists $args{exhaustive} ? delete $args{exhaustive} : exists $args{ex} ? delete $args{ex} : undef;
$::RX{'ex'} = $ex;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{continue} || exists $args{c};
my $c = exists $args{continue} ? delete $args{continue} : exists $args{c} ? delete $args{c} : undef;
$::RX{'c'} = $c;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{pos} || exists $args{p};
my $p = exists $args{pos} ? delete $args{pos} : exists $args{p} ? delete $args{p} : undef;
$::RX{'p'} = $p;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{sigspace} || exists $args{s};
my $s = exists $args{sigspace} ? delete $args{sigspace} : exists $args{s} ? delete $args{s} : undef;
$::RX{'s'} = $s;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{ratchet} || exists $args{r};
my $r = exists $args{ratchet} ? delete $args{ratchet} : exists $args{r} ? delete $args{r} : undef;
$::RX{'r'} = $r;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{global} || exists $args{g};
my $g = exists $args{global} ? delete $args{global} : exists $args{g} ? delete $args{g} : undef;
$::RX{'g'} = $g;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{ignorecase} || exists $args{i};
my $i = exists $args{ignorecase} ? delete $args{ignorecase} : exists $args{i} ? delete $args{i} : undef;
$::RX{'i'} = $i;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{ignoreaccent} || exists $args{a};
my $a = exists $args{ignoreaccent} ? delete $args{ignoreaccent} : exists $args{a} ? delete $args{a} : undef;
$::RX{'a'} = $a;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{samecase} || exists $args{ii};
my $ii = exists $args{samecase} ? delete $args{samecase} : exists $args{ii} ? delete $args{ii} : undef;
$::RX{'ii'} = $ii;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{sameaccent} || exists $args{aa};
my $aa = exists $args{sameaccent} ? delete $args{sameaccent} : exists $args{aa} ? delete $args{aa} : undef;
$::RX{'aa'} = $aa;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{nth};
my $nth = exists $args{nth} ? delete $args{nth} : undef;
$::RX{'nth'} = $nth;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{st} || exists $args{nd};
my $nd = exists $args{st} ? delete $args{st} : exists $args{nd} ? delete $args{nd} : undef;
$::RX{'nth'} = $nd;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{rd} || exists $args{th};
my $th = exists $args{rd} ? delete $args{rd} : exists $args{th} ? delete $args{th} : undef;
$::RX{'nth'} = $th;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{x};
my $x = exists $args{x} ? delete $args{x} : undef;
$::RX{'x'} = $x;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{bytes};
my $bytes = exists $args{bytes} ? delete $args{bytes} : undef;
$::RX{'bytes'} = $bytes;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{codes};
my $codes = exists $args{codes} ? delete $args{codes} : undef;
$::RX{'codes'} = $codes;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{graphs};
my $graphs = exists $args{graphs} ? delete $args{graphs} : undef;
$::RX{'graphs'} = $graphs;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{chars};
my $chars = exists $args{chars} ? delete $args{chars} : undef;
$::RX{'chars'} = $chars;
$self;
    };
}
{
    local @_ = @_;
    return scalar do { # work around #38809
        my $self = shift;
my %args = @_;
last unless exists $args{rw};
my $rw = exists $args{rw} ? delete $args{rw} : undef;
$::RX{'rw'} = $rw;
$self;
    };
}
    $orig->(@_);
};

 1; };
## method require_P5
sub require_P5 {
no warnings 'recursion';
my $self = shift;
require STD_P5;
$self;
};
## method require_P6
sub require_P6 {
no warnings 'recursion';
my $self = shift;
require STD_P6;
$self;
};
## method newpad ($needsig = 0)
sub newpad {
no warnings 'recursion';
my $self = shift;
my $needsig = @_ ? shift() : 0;
my $oid = $::CURPAD->id;
$ALL->{$oid} == $::CURPAD or die "internal error: current pad id is invalid";
my $line = $self->lineof($self->{'_pos'});
my $id;
if ($::NEWPAD) {
$::NEWPAD->{'OUTER::'} = $::CURPAD->idref;
$::CURPAD = $::NEWPAD;
$::NEWPAD = 0;
$id = $::CURPAD->id;
}
else {
$id = 'MY:file<' . $::FILE->{'name'} . '>:line(' . $line . '):pos(' . $self->{'_pos'} . ')';
$::CURPAD = Stash->new(
            'OUTER::' => [$oid],
            '!file' => $::FILE, '!line' => $line,
            '!id' => [$id],
        );
};
$::CURPAD->{'!NEEDSIG'} = 1 if $needsig;
$::CURPAD->{'!IN_DECL'} = $::IN_DECL if $::IN_DECL;
$ALL->{$id} = $::CURPAD;
$self;
};
## method finishpad
sub finishpad {
no warnings 'recursion';
my $self = shift;
my $line = $self->lineof($self->{'_pos'});
$::CURPAD->{'$_'} //= NAME->new( name => '$_', file => $::FILE, line => $line );
$::CURPAD->{'$/'} //= NAME->new( name => '$/', file => $::FILE, line => $line );
$::CURPAD->{'$!'} //= NAME->new( name => '$!', file => $::FILE, line => $line );
$::SIGNUM = 0;
$self;
};
## method getsig
sub getsig {
no warnings 'recursion';
my $self = shift;
my $pv = $::CURPAD->{'%?PLACEHOLDERS'};
my $sig;
if (delete $::CURPAD->{'!NEEDSIG'}) {
if ($pv) {
my $h_ = delete $pv->{'%_'};
my $a_ = delete $pv->{'@_'};
$sig = join ', ', sort {
substr($a,1) cmp substr($b,1) }  keys %$pv;
$sig .= ', *@_' if $a_;
$sig .= ', *%_' if $h_;
}
else {
$sig = '$_ is ref = OUTER::<$_>'};
$::CURPAD->{'$?SIGNATURE'} = $sig;
}
else {
$sig = $::CURPAD->{'$?SIGNATURE'}};
$self->{'sig'} = $self->makestr(TEXT => $sig);
$self->{'pad'} = $::CURPAD->idref;
$self;
};
## method getdecl
sub getdecl {
no warnings 'recursion';
my $self = shift;
$self->{'decl'} = $::DECLARAND;
$self;
};
## method is_name ($n, $curpad = $*CURPAD)
sub is_name {
no warnings 'recursion';
my $self = shift;
die 'Required argument n omitted' unless @_;
my $n = @_ ? shift() : undef;
my $curpad = @_ ? shift() : $::CURPAD;
my $name = $n;
$self->deb("is_name $name") if $::DEBUG & DEBUG::symtab;
my $curpkg = $::CURPKG;
return 1 if $name =~ /\:\:\(/;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
return 1 if $components[0] eq 'COMPILING::';
return 1 if $components[0] eq 'CALLER::';
return 1 if $components[0] eq 'CONTEXT::';
if ($curpkg = $self->find_top_pkg($components[0])) {
$self->deb("Found lexical package ", $components[0]) if $::DEBUG & DEBUG::symtab;
shift @components;
}
else {
$self->deb("Looking for GLOBAL::<$name>") if $::DEBUG & DEBUG::symtab;
$curpkg = $::GLOBAL;
};
while (@components > 1) {
my $pkg = shift @components;
$curpkg = $curpkg->{$pkg};
return 0 unless $curpkg;
eval {
my $outpadid = $curpkg->[0];
return 0 unless $outpadid;
$curpkg = $ALL->{$outpadid};
return 0 unless $curpkg;
};
$self->deb("Found $pkg okay") if $::DEBUG & DEBUG::symtab;
}
    ;
};
$name = shift(@components)//'';
$self->deb("Looking for $name") if $::DEBUG & DEBUG::symtab;
return 1 if $name eq '';
my $pad = $curpad;
while ($pad) {
$self->deb("Looking in ", $pad->id) if $::DEBUG & DEBUG::symtab;
if ($pad->{$name}) {
$self->deb("Found $name in ", $pad->id) if $::DEBUG & DEBUG::symtab;
return 1;
};
my $oid = $pad->{'OUTER::'}->[0] || last;
$pad = $ALL->{$oid};
}
    ;
return 1 if $curpkg->{$name};
return 1 if $::GLOBAL->{$name};
$self->deb("$name not found") if $::DEBUG & DEBUG::symtab;
return 0;
};
## method find_stash ($n, $curpad = $*CURPAD)
sub find_stash {
no warnings 'recursion';
my $self = shift;
die 'Required argument n omitted' unless @_;
my $n = @_ ? shift() : undef;
my $curpad = @_ ? shift() : $::CURPAD;
my $name = $n;
$self->deb("find_stash $name") if $::DEBUG & DEBUG::symtab;
return () if $name =~ /\:\:\(/;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
return () if $components[0] eq 'COMPILING::';
return () if $components[0] eq 'CALLER::';
return () if $components[0] eq 'CONTEXT::';
if ($curpad = $self->find_top_pkg($components[0])) {
$self->deb("Found lexical package ", $components[0]) if $::DEBUG & DEBUG::symtab;
shift @components;
}
else {
$self->deb("Looking for GLOBAL::<$name>") if $::DEBUG & DEBUG::symtab;
$curpad = $::GLOBAL;
};
while (@components > 1) {
my $pad = shift @components;
$curpad = $curpad->{$pad};
return () unless $curpad;
eval {
my $outpadid = $curpad->[0];
return 0 unless $outpadid;
$curpad = $ALL->{$outpadid};
return () unless $curpad;
};
$self->deb("Found $pad okay") if $::DEBUG & DEBUG::symtab;
}
    ;
};
$name = shift(@components)//'';
return $curpad if $name eq '';
my $pad = $curpad;
while ($pad) {
return $_ if $_ = $pad->{$name};
my $oid = $pad->{'OUTER::'}->[0] || last;
$pad = $ALL->{$oid};
}
    ;
return $_ if $_ = $curpad->{$name};
return $_ if $_ = $::GLOBAL->{$name};
return ();
};
## method find_top_pkg ($name)
sub find_top_pkg {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
$self->deb("find_top_pkg $name") if $::DEBUG & DEBUG::symtab;
$name .= '::' unless $name =~ /\:\:$/;
if ($name eq 'OUR::') {
return $::CURPKG}
elsif ($name eq 'MY::') {
return $::CURPAD}
elsif ($name eq 'OUTER::') {
return $ALL->{$::CURPAD->{'OUTER::'}->[0]}}
elsif ($name eq 'CORE::') {
return $::CORE}
elsif ($name eq 'SETTING::') {
return $::SETTING}
elsif ($name eq 'UNIT::') {
return $::UNIT};
my $pad = $::CURPAD;
while ($pad) {
return $pad->{$name} if $pad->{$name};
my $oid = $pad->{'OUTER::'}->[0] || last;
$pad = $ALL->{$oid};
}
    ;
return 0;
};
## method add_name ($name)
sub add_name {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
my $scope = $::SCOPE || 'my';
my $pkgdecl = $::PKGDECL || 'symbol';
return $self if $scope eq 'anon' or $pkgdecl eq 'slang';
$self->deb("Adding $scope $name") if $::DEBUG & DEBUG::symtab;
if ($scope eq 'augment' or $scope eq 'supersede') {
$self->is_name($name) or
            $self->worry("Can't $scope $pkgdecl $name because it doesn't exist");
$::MONKEY_TYPING or
            $self->sorry("Can't $scope $pkgdecl $name without MONKEY_TYPING");
}
else {
if ($scope eq 'our') {
$self->add_our_name($name)}
else {
$self->add_my_name($name)}};
$self;
};
## method add_my_name ($n, $d = Nil, $p = Nil)
sub add_my_name {
no warnings 'recursion';
my $self = shift;
die 'Required argument n omitted' unless @_;
my $n = @_ ? shift() : undef;
my $d = @_ ? shift() : ();
my $p = @_ ? shift() : ();
my $name = $n;
$self->deb("add_my_name $name in ", $::CURPAD->id) if $::DEBUG & DEBUG::symtab;
return $self if $name =~ /\:\:\(/;
my $curstash = $::CURPAD;
my @components = $self->canonicalize_name($name);
my $sid = $curstash->id // '???';
while (@components > 1) {
my $pkg = shift @components;
$sid .= "::$pkg";
my $newstash = $curstash->{$pkg} //= Stash->new(
            'PARENT::' => $curstash->idref,
            '!stub' => 1,
            '!id' => [$sid] );
$self->deb("Adding new package $pkg in ", $curstash->id) if $::DEBUG & DEBUG::symtab;
$curstash = $newstash;
}
    ;
$name = my $shortname = shift @components;
return $self unless defined $name and $name ne '';
return $self if $name eq '$' or $name eq '@' or $name eq '%';
return $self->add_categorical(substr($name,1)) if $name =~ /^\&\w+\:/;
if ($shortname =~ /\:/) {
$shortname =~ s/\:.*//};
my $declaring = $d // NAME->new(
        xpad => $curstash->idref,
        name => $name,
        file => $::FILE, line => $self->line,
        mult => ($::MULTINESS||'only'),
    );
my $old = $curstash->{$name};
if ($old and $old->{'line'} and not $old->{'stub'}) {
$self->deb("$name exists, curstash = ", $curstash->id) if $::DEBUG & DEBUG::symtab;
my $omult = $old->{'mult'} // '';
if ($declaring == $old) {
}
elsif ($::SCOPE eq 'use') {
}
elsif ($::MULTINESS eq 'multi' and $omult ne 'only') {
}
elsif ($omult eq 'proto') {
}
elsif ($::PKGDECL eq 'role') {
}
elsif ($::SIGNUM and $old->{'signum'} and $::SIGNUM != $old->{'signum'}) {
$old->{'signum'} = $::SIGNUM}
else {
my $ofile = $old->file // 0;
my $oline = $old->line // '???';
my $loc = '';
if ($ofile) {
if ($ofile != $::FILE) {
my $oname = $ofile->{'name'};
$loc = " (see $oname line $oline)";
}
else {
$loc = " (see line $oline)"}};
if ($old->opad) {
my $rebind = $old->{'rebind'};
my $truename = $old->{'varbind'}->{'truename'};
$self->sorry("Lexical symbol '$name' is already bound to an outer symbol$loc;\n  the implicit outer binding at line $rebind must be rewritten as $truename\n  before you can unambiguously declare a new '$name' in this scope");
}
elsif ($name =~ /^\w/) {
$self->sorry("Illegal redeclaration of symbol '$name'$loc")}
elsif ($name =~ s/^\&//) {
$self->sorry("Illegal redeclaration of routine '$name'$loc") unless $name eq ''}
else {
$self->worry("Useless redeclaration of variable $name$loc")};
};
}
else {
$::DECLARAND = $curstash->{$name} = $declaring;
$curstash->{$shortname} = $declaring unless $shortname eq $name;
$::DECLARAND->{'inpad'} = $curstash->idref;
$::DECLARAND->{'signum'} = $::SIGNUM if $::SIGNUM;
$::DECLARAND->{'const'} ||= 1 if $::IN_DECL eq 'constant';
if (!$::DECLARAND->{'const'} and $shortname =~ /^\w+$/) {
$curstash->{"&$shortname"} //= $curstash->{$shortname};
$sid .= "::$name";
if ($name !~ /\:\</) {
$::NEWPAD = $curstash->{$name . '::'} = ($p // Stash->new(
                    'PARENT::' => $curstash->idref,
                    '!file' => $::FILE, '!line' => $self->line,
                    '!id' => [$sid] ))};
};
};
$self;
};
## method add_our_name ($n)
sub add_our_name {
no warnings 'recursion';
my $self = shift;
die 'Required argument n omitted' unless @_;
my $n = @_ ? shift() : undef;
my $name = $n;
$self->deb("add_our_name $name in " . $::CURPKG->id) if $::DEBUG & DEBUG::symtab;
return $self if $name =~ /\:\:\(/;
my $curstash = $::CURPKG;
$self->deb("curstash $curstash global $::GLOBAL ", join ' ', %$::GLOBAL) if $::DEBUG & DEBUG::symtab;
$name =~ s/\:ver\<.*?\>//;
$name =~ s/\:auth\<.*?\>//;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
my $c = $self->find_top_pkg($components[0]);
if ($c) {
shift @components;
$curstash = $c;
};
};
my $sid = $curstash->id // '???';
while (@components > 1) {
my $pkg = shift @components;
$sid .= "::$pkg";
my $newstash = $curstash->{$pkg} //= Stash->new(
            'PARENT::' => $curstash->idref,
            '!stub' => 1,
            '!id' => [$sid] );
$curstash = $newstash;
$self->deb("Adding new package $pkg in $curstash ") if $::DEBUG & DEBUG::symtab;
}
    ;
$name = my $shortname = shift @components;
return $self unless defined $name and $name ne '';
if ($shortname =~ /\:/) {
$shortname =~ s/\:.*//};
my $declaring = $::DECLARAND // NAME->new(
        xpad => $curstash->idref,
        name => $name,
        file => $::FILE, line => $self->line,
        mult => ($::MULTINESS||'only'),
    );
my $old = $curstash->{$name};
if ($old and $old->{'line'} and not $old->{'stub'}) {
my $omult = $old->{'mult'} // '';
if ($declaring == $old) {
}
elsif ($::SCOPE eq 'use') {
}
elsif ($::MULTINESS eq 'multi' and $omult ne 'only') {
}
elsif ($omult eq 'proto') {
}
elsif ($::PKGDECL eq 'role') {
}
else {
my $ofile = $old->file // 0;
my $oline = $old->line // '???';
my $loc = '';
if ($ofile) {
if ($ofile != $::FILE) {
my $oname = $ofile->{'name'};
$loc = " (from $oname line $oline)";
}
else {
$loc = " (from line $oline)"}};
$sid = $self->clean_id($sid, $name);
if ($name =~ /^\w/) {
$self->sorry("Illegal redeclaration of symbol '$sid'$loc")}
elsif ($name =~ /^\&/) {
$self->sorry("Illegal redeclaration of routine '$sid'$loc") unless $name eq ''}
else {
};
};
}
else {
$::DECLARAND = $curstash->{$name} = $declaring;
$curstash->{$shortname} //= $declaring unless $shortname eq $name;
$::DECLARAND->{'inpkg'} = $curstash->idref;
if ($shortname =~ /^\w+$/ and $::IN_DECL ne 'constant') {
$curstash->{"&$shortname"} //= $declaring;
$sid .= "::$name";
$::NEWPKG = $curstash->{$name . '::'} //= Stash->new(
                'PARENT::' => $curstash->idref,
                '!file' => $::FILE, '!line' => $self->line,
                '!id' => [$sid] );
};
};
$self->add_my_name($n, $declaring, $curstash->{$name . '::'}) if $curstash == $::CURPKG;
$self;
};
## method add_mystery ($token,$pos,$ctx)
sub add_mystery {
no warnings 'recursion';
my $self = shift;
die 'Required argument token omitted' unless @_;
my $token = @_ ? shift() : undef;
die 'Required argument pos omitted' unless @_;
my $pos = @_ ? shift() : undef;
die 'Required argument ctx omitted' unless @_;
my $ctx = @_ ? shift() : undef;
my $name = $token->Str;
return $self if $::IN_PANIC;
if (not $self->is_known($name)) {
$self->deb("add_mystery $name $::CURPAD") if $::DEBUG & DEBUG::symtab;
$::MYSTERY{$name}->{'pad'} = $::CURPAD;
$::MYSTERY{$name}->{'token'} = $token;
$::MYSTERY{$name}->{'ctx'} = $ctx;
$::MYSTERY{$name}->{'line'} .= ',' if $::MYSTERY{$name}->{'line'};
$::MYSTERY{$name}->{'line'} .= $self->lineof($pos);
}
else {
$self->deb("$name is known") if $::DEBUG & DEBUG::symtab};
$self;
};
## method explain_mystery()
sub explain_mystery {
no warnings 'recursion';
my $self = shift;
my %post_types;
my %unk_types;
my %unk_routines;
my $m = '';
for (keys(%::MYSTERY)) {
my $p = $::MYSTERY{$_}->{'pad'};
if ($self->is_name($_, $p)) {
$post_types{$_} = $::MYSTERY{$_};
next;
};
next if $self->is_known($_, $p) or $self->is_known('&' . $_, $p);
if ($_ lt 'a') {
$unk_types{$_} = $::MYSTERY{$_}}
else {
$unk_routines{$_} = $::MYSTERY{$_}};
}
    ;
if (%post_types) {
my @tmp = sort keys(%post_types);
$m .= "Illegally post-declared type" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
$m .= "\t'$_' used at line " . $post_types{$_}->{'line'} . "\n"}
    ;
};
if (%unk_types) {
my @tmp = sort keys(%unk_types);
$m .= "Undeclared name" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
$m .= "\t'$_' used at line " . $unk_types{$_}->{'line'} . "\n"}
    ;
};
if (%unk_routines) {
my @tmp = sort keys(%unk_routines);
$m .= "Undeclared routine" . ('s' x (@tmp != 1)) . ":\n";
for (@tmp) {
$m .= "\t'$_' used at line " . $unk_routines{$_}->{'line'} . "\n"}
    ;
};
$self->sorry($m) if $m;
$self;
};
## method load_setting ($setting)
sub load_setting {
no warnings 'recursion';
my $self = shift;
die 'Required argument setting omitted' unless @_;
my $setting = @_ ? shift() : undef;
$ALL = $self->load_pad($setting);
$::CORE = $ALL->{'CORE'};
$::CORE->{'!id'} //= ['CORE'];
$::SETTING = $ALL->{'SETTING'};
$::CURPAD = $::SETTING;
$::GLOBAL = $::CORE->{'GLOBAL::'} = Stash->new(
        '!file' => $::FILE, '!line' => 1,
        '!id' => ['GLOBAL'],
    );
$::CURPKG = $::GLOBAL;
};
## method is_known ($n, $curpad = $*CURPAD)
sub is_known {
no warnings 'recursion';
my $self = shift;
die 'Required argument n omitted' unless @_;
my $n = @_ ? shift() : undef;
my $curpad = @_ ? shift() : $::CURPAD;
my $name = $n;
$self->deb("is_known $name") if $::DEBUG & DEBUG::symtab;
return 1 if $::QUASIMODO;
return 1 if $::CURPKG->{$name};
return 0 if $name =~ /\:\:\(/;
my $curpkg = $::CURPKG;
my @components = $self->canonicalize_name($name);
if (@components > 1) {
return 1 if $components[0] eq 'COMPILING::';
return 1 if $components[0] eq 'CALLER::';
return 1 if $components[0] eq 'CONTEXT::';
if ($curpkg = $self->find_top_pkg($components[0])) {
$self->deb("Found lexical package ", $components[0]) if $::DEBUG & DEBUG::symtab;
shift @components;
}
else {
$self->deb("Looking for GLOBAL::<$name>") if $::DEBUG & DEBUG::symtab;
$curpkg = $::GLOBAL;
};
while (@components > 1) {
my $pkg = shift @components;
$self->deb("Looking for $pkg in $curpkg ", join ' ', keys(%$curpkg)) if $::DEBUG & DEBUG::symtab;
$curpkg = $curpkg->{$pkg};
return 0 unless $curpkg;
eval {
my $outpadid = $curpkg->[0];
return 0 unless $outpadid;
$curpkg = $ALL->{$outpadid};
return 0 unless $curpkg;
};
$self->deb("Found $pkg okay, now in $curpkg ") if $::DEBUG & DEBUG::symtab;
}
    ;
};
$name = shift(@components)//'';
$self->deb("Final component is $name") if $::DEBUG & DEBUG::symtab;
return 1 if $name eq '';
if ($curpkg->{$name}) {
$self->deb("Found") if $::DEBUG & DEBUG::symtab;
return 1;
};
return 0 if $curpkg != $::CURPKG and $curpkg->{'!id'}->[0] =~ /^GLOBAL($|\:\:)/;
my $varbind = {
truename => '???' };
return 1 if $n !~ /\:\:/ and $self->pad_can_find_name($curpad,$name,$varbind);
$self->deb("Not Found") if $::DEBUG & DEBUG::symtab;
return 0;
};
## method pad_can_find_name ($pad, $name, $varbind)
sub pad_can_find_name {
no warnings 'recursion';
my $self = shift;
die 'Required argument pad omitted' unless @_;
my $pad = @_ ? shift() : undef;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
die 'Required argument varbind omitted' unless @_;
my $varbind = @_ ? shift() : undef;
$self->deb("Looking in ", $pad->id) if $::DEBUG & DEBUG::symtab;
if ($pad->{$name}) {
$self->deb("Found $name in ", $pad->id) if $::DEBUG & DEBUG::symtab;
return 1;
};
my $outpadid = $pad->{'OUTER::'}->[0];
return 0 unless $outpadid;
my $outpad = $ALL->{$outpadid};
if ($self->pad_can_find_name($outpad,$name,$varbind)) {
my $outname = $outpad->{$name}->{'name'};
my $outfile = $outpad->{$name}->{'file'};
my $outline = $outpad->{$name}->{'line'};
$outname = '<' . $outname . '>' unless $outname =~ /\:\:\</;
$outname = "OUTER::" . $outname;
$pad->{$name} = NAME->new(
            xpad => $pad->idref,
            opad => $pad->idref,
            name => $outname,
            file => $outfile, line => $outline,
            rebind => $self->line,
            varbind => $varbind,
            mult => 'only',
        );
$varbind->{'truename'} = $outname;
return 1;
};
return 0;
};
## method add_routine ($name)
sub add_routine {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
$::MEMOS[$self->{'_pos'}]->{'wasname'} = $name if $self->is_name($name);
my $vname = '&' . $name;
$self->add_name($vname);
$self;
};
## method add_variable ($name)
sub add_variable {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
my $scope = $::SCOPE || 'our';
return $self if $scope eq 'anon';
if ($scope eq 'our') {
$self->add_our_name($name)}
else {
$self->add_my_name($name)};
$self;
};
## method add_constant($name,$value)
sub add_constant {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
die 'Required argument value omitted' unless @_;
my $value = @_ ? shift() : undef;
local $::IN_DECL = 'constant';
$self->deb("add_constant $name = $value in", $::CURPAD->id) if $::DEBUG & DEBUG::symtab;
local $::DECLARAND;
$self->add_my_name($name);
$::DECLARAND->{'value'} = $value;
$self;
};
## method add_placeholder($name)
sub add_placeholder {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
my $decl = $::CURPAD->{'!IN_DECL'} // '';
$decl = ' ' . $decl if $decl;
local $::IN_DECL = 'variable';
if ($::SIGNUM) {
return $self->sorry("Placeholder variable $name is not allowed in the$decl signature")}
elsif (my $siggy = $::CURPAD->{'$?SIGNATURE'}) {
return $self->sorry("Placeholder variable $name cannot override existing signature $siggy")};
if (not $::CURPAD->{'!NEEDSIG'}) {
if ($::CURPAD == $::UNIT) {
return $self->sorry("Placeholder variable $name may not be used outside of a block")};
return $self->sorry("Placeholder variable $name may not be used here because the surrounding$decl block takes no signature");
};
if ($name =~ /\:\:/) {
return $self->sorry("Placeholder variable $name may not be package qualified")};
my $varname = $name;
my $twigil;
my $signame;
$twigil = '^' if $varname =~ s/\^//;
$signame = $twigil = ':' if $varname =~ s/\://;
$signame .= $varname;
return $self if $::CURPAD->{'%?PLACEHOLDERS'}->{$signame}++;
if ($::CURPAD->{$varname}) {
return $self->sorry("$varname has already been used as a non-placeholder in the surrounding$decl block,\n  so you will confuse the reader if you suddenly declare $name here")};
$self->add_my_name($varname);
$self;
};
## method check_variable ($variable)
sub check_variable {
no warnings 'recursion';
my $self = shift;
die 'Required argument variable omitted' unless @_;
my $variable = @_ ? shift() : undef;
my $name = $variable->Str;
$self->deb("check_variable $name") if $::DEBUG & DEBUG::symtab;
my ($sigil, $twigil, $first) = $name =~ /(\$|\@|\%|\&)(\W*)(.?)/;
given ($twigil) {
when ('') {
my $ok = 0;
$ok ||= $::IN_DECL;
$ok ||= $sigil eq '&';
$ok ||= $first lt 'A';
$ok ||= $self->is_known($name);
$ok ||= $name =~ /.\:\:/ && $name !~ /MY|UNIT|OUTER|SETTING|CORE/;
if (not $ok) {
my $id = $name;
$id =~ s/^\W\W?//;
if ($name eq '@_' or $name eq '%_') {
$variable->add_placeholder($name)}
else {
if (my $scope = $::MEMOS[$variable->from]->{'declend'}) {
return $variable->sorry("Variable $name is not predeclared (declarators are tighter than comma, so maybe your '$scope' signature needs parens?)")}
elsif ($id !~ /\:\:/) {
if ($self->is_known('@' . $id)) {
return $variable->sorry("Variable $name is not predeclared (did you mean \@$id?)")}
elsif ($self->is_known('%' . $id)) {
return $variable->sorry("Variable $name is not predeclared (did you mean \%$id?)")}};
return $variable->sorry("Variable $name is not predeclared");
};
};
}
        ;
when ('^') {
local $::MULTINESS = 'multi';
$variable->add_placeholder($name);
}
        ;
when (':') {
local $::MULTINESS = 'multi';
$variable->add_placeholder($name);
}
        ;
when ('~') {
return @::LANG{substr($name,2)}}
        ;
when ('?') {
if ($name =~ /\:\:/) {
my ($first) = $self->canonicalize_name($name);
$variable->worry("Unrecognized variable: $name") unless $first =~ /^(CALLER|CONTEXT|OUTER|MY|SETTING|CORE)$/;
}
else {
my $v = $variable->lookup_compiler_var($name);
$variable->{'value'} = $v if $v;
}}
    ;
}
    ;
$self;
};
## method lookup_compiler_var($name, $default = Nil)
sub lookup_compiler_var {
no warnings 'recursion';
my $self = shift;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
my $default = @_ ? shift() : ();
my $lex = $::CURPAD->{$name};
if (defined $lex) {
if (exists $lex->{'thunk'}) {
return $lex->{'thunk'}->()}
else {
return $lex->{'value'}}};
given ($name) {
when ('$?FILE')     {
return $::FILE->{'name'}}
        ;
when ('$?LINE')     {
return $self->lineof($self->{'_pos'})}
        ;
when ('$?POSITION') {
return $self->{'_pos'}}

        ;
when ('$?LANG')     {
return \%::LANG}

        ;
when ('$?LEXPAD')   {
return $::CURPAD}

        ;
when ('$?PACKAGE')  {
return $::CURPKG}
        ;
when ('$?MODULE')   {
return $::CURPKG}
        ;
when ('$?CLASS')    {
return $::CURPKG}
        ;
when ('$?ROLE')     {
return $::CURPKG}
        ;
when ('$?GRAMMAR')  {
return $::CURPKG}

        ;
when ('$?PACKAGENAME') {
return $::CURPKG->id }

        ;
when ('$?OS')       {
return 'unimpl'}
        ;
when ('$?DISTRO')   {
return 'unimpl'}
        ;
when ('$?VM')       {
return 'unimpl'}
        ;
when ('$?XVM')      {
return 'unimpl'}
        ;
when ('$?PERL')     {
return 'unimpl'}

        ;
when ('$?USAGE')    {
return 'unimpl'}

        ;
when ('&?ROUTINE')  {
return 'unimpl'}
        ;
when ('&?BLOCK')    {
return 'unimpl'}

        ;
when ('%?CONFIG')    {
return 'unimpl'}
        ;
when ('%?DEEPMAGIC') {
return 'unimpl'}

        ;
my $dynvar = $self->lookup_dynvar($name);
return $dynvar if defined $dynvar;
return $default if defined $default;
default {
$self->worry("Unrecognized variable: $name");
return 0;
}
    ;
}
;
};
## method panic (Str $s)
sub panic {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
die "Recursive panic" if $::IN_PANIC;
$::IN_PANIC++;
$self->deb("panic $s") if $::DEBUG;
my $m;
my $here = $self;
my $highvalid = $self->{'_pos'} <= $::HIGHWATER;
$here = $self->cursor($::HIGHWATER) if $highvalid;
my $first = $here->lineof($::LAST_NIBBLE->{'_from'});
my $last = $here->lineof($::LAST_NIBBLE->{'_pos'});
if ($first != $last) {
if ($here->lineof($here->{'_pos'}) == $last) {
$m .= "(Possible runaway string from line $first)\n"}
else {
$first = $here->lineof($::LAST_NIBBLE_MULTILINE->{'_from'});
$last = $here->lineof($::LAST_NIBBLE_MULTILINE->{'_pos'});
if ($here->lineof($here->{'_pos'}) - $last < $last - $first)  {
$m .= "(Possible runaway string from line $first to line $last)\n"};
}};
$m .= $s;
if ($highvalid) {
$m .= $::HIGHMESS if $::HIGHMESS;
$::HIGHMESS = $m;
}
else {
$::HIGHMESS .= $s . "\n"};
$m .= $here->locmess;
$m .= "\n" unless $m =~ /\n$/;
if ($highvalid and %$::HIGHEXPECT) {
my @keys = sort keys %$::HIGHEXPECT;
if (@keys > 1) {
$m .= "    expecting any of:\n\t" . join("\n\t", sort keys %$::HIGHEXPECT) . "\n"}
else {
$m .= "    expecting @keys\n" unless $keys[0] eq 'whitespace'};
};
if ($m =~ /infix|nofun/ and not $m =~ /regex/ and not $m =~ /infix_circumfix/) {
my @t = $here->suppose( sub {
$here->term } );
if (@t) {
my $endpos = $here->{'_pos'};
my $startpos = $::MEMOS[$endpos]->{'ws'} // $endpos;
if ($self->lineof($startpos) != $self->lineof($endpos)) {
$m =~ s|Confused|Two terms in a row (previous line missing its semicolon?)|}
elsif ($::MEMOS[$here->{'_pos'} - 1]->{'baremeth'}) {
$m =~ s|Confused|Two terms in a row (method call requires colon or parens to take arguments)|}
elsif ($::MEMOS[$here->{'_pos'} - 1]->{'arraycomp'}) {
$m =~ s|Confused|Two terms in a row (preceding is not a valid reduce operator)|}
else {
$m =~ s|Confused|Two terms in a row|};
}
elsif (my $type = $::MEMOS[$here->{'_pos'} - 1]->{'nodecl'}) {
my @t = $here->suppose( sub {
$here->variable } );
if (@t) {
my $variable = $t[0]->Str;
$m =~ s|Confused|Bare type $type cannot declare $variable without a preceding scope declarator such as 'my'|;
};
};
}
elsif (my $type = $::MEMOS[$here->{'_pos'} - 1]->{'wasname'}) {
my @t = $here->suppose( sub {
$here->identifier } );
my $name = $t[0]->Str;
my $s = $::SCOPE ? "'$::SCOPE'" : '(missing) scope declarator';
my $d = $::IN_DECL;
$d = "$::MULTINESS $d" if $::MULTINESS and $::MULTINESS ne $d;
$m =~ s|Malformed block|Return type $type is not allowed between '$d' and '$name'; please put it:\n  after the $s but before the '$d',\n  within the signature following the '-->' marker, or\n  as the argument of a 'returns' trait after the signature.|;
};
if (@::WORRIES) {
$m .= "Other potential difficulties:\n  " . join( "\n  ", @::WORRIES) . "\n"};
$::IN_PANIC--;
die $m if $::IN_SUPPOSE;
$::IN_PANIC++;
print STDERR $Cursor::RED, '===', $Cursor::CLEAR, 'SORRY!', $Cursor::RED, '===', $Cursor::CLEAR, "\n"
        unless $::FATALS++;
print STDERR $m;
$self->explain_mystery();
$::IN_PANIC--;
die "Parse failed\n";
};
## method worry (Str $s)
sub worry {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
my $m = $s . $self->locmess;
push @::WORRIES, $m unless $::WORRIES{$s}++;
$self;
};
## method sorry (Str $s)
sub sorry {
no warnings 'recursion';
my $self = shift;
die 'Required argument s omitted' unless @_;
my $s = @_ ? shift() : undef;
$self->deb("sorry $s") if $::DEBUG;
print STDERR $Cursor::RED, '===', $Cursor::CLEAR, 'SORRY!', $Cursor::RED, '===', $Cursor::CLEAR, "\n"
        unless $::IN_SUPPOSE or $::FATALS++;
if ($s) {
my $m = $s;
$m .= $self->locmess . "\n" unless $m =~ /\n$/;
if ($::FATALS > 10 or $::IN_SUPPOSE) {
die $m}
else {
print STDERR $m unless $::WORRIES{$m}++};
};
$self;
};
## method locmess ()
sub locmess {
no warnings 'recursion';
my $self = shift;
my $pos = $self->{'_pos'};
my $line = $self->lineof($pos);
if ($pos >= @::MEMOS - 1) {
$pos = $pos - 1;
$line = $line . " (EOF)";
};
my $pre = substr($::ORIG, 0, $pos);
$pre = substr($pre, -40, 40);
1 while $pre =~ s!.*\n!!;
$pre = '<BOL>' if $pre eq '';
my $post = substr($::ORIG, $pos, 40);
1 while $post =~ s!(\n.*)!!;
$post = '<EOL>' if $post eq '';
" at " . $::FILE->{'name'} . " line $line:\n------> " . $Cursor::GREEN . $pre . $Cursor::YELLOW . $::PERL6HERE . $Cursor::RED . 
        "$post$Cursor::CLEAR";
};
## method line
sub line {
no warnings 'recursion';
my $self = shift;
$self->lineof($self->{'_pos'})};
## method lineof ($p)
sub lineof {
no warnings 'recursion';
my $self = shift;
die 'Required argument p omitted' unless @_;
my $p = @_ ? shift() : undef;
return 1 unless defined $p;
my $line = $::MEMOS[$p]->{'L'};
return $line if $line;
$line = 0;
my $pos = 0;
my @text = split(/^/,$::ORIG);
for (@text) {
$line++;
$::MEMOS[$pos++]->{'L'} = $line
            for 1 .. length($_);
}
    ;
$::MEMOS[$pos++]->{'L'} = $line;
return $::MEMOS[$p]->{'L'} // 0;
};
## method SETGOAL
sub SETGOAL {
no warnings 'recursion';
my $self = shift;
};
## method FAILGOAL (Str $stop, Str $name, $startpos)
sub FAILGOAL {
no warnings 'recursion';
my $self = shift;
die 'Required argument stop omitted' unless @_;
my $stop = @_ ? shift() : undef;
die 'Required argument name omitted' unless @_;
my $name = @_ ? shift() : undef;
die 'Required argument startpos omitted' unless @_;
my $startpos = @_ ? shift() : undef;
my $s = "'$stop'";
$s = '"\'"' if $s eq "'''";
$self->panic("Unable to parse $name" . $startpos->locmess . "\nCouldn't find final $s; gave up");
};
## method obs (Str $old, Str $new, Str $when = ' in Perl 6')
sub obs {
no warnings 'recursion';
my $self = shift;
die 'Required argument old omitted' unless @_;
my $old = @_ ? shift() : undef;
die 'Required argument new omitted' unless @_;
my $new = @_ ? shift() : undef;
my $when = @_ ? shift() : ' in Perl 6';
%$::HIGHEXPECT = ();
$self->panic("Unsupported use of $old;$when please use $new");
};
## method sorryobs (Str $old, Str $new, Str $when = ' in Perl 6')
sub sorryobs {
no warnings 'recursion';
my $self = shift;
die 'Required argument old omitted' unless @_;
my $old = @_ ? shift() : undef;
die 'Required argument new omitted' unless @_;
my $new = @_ ? shift() : undef;
my $when = @_ ? shift() : ' in Perl 6';
%$::HIGHEXPECT = ();
$self->sorry("Unsupported use of $old;$when please use $new");
$self;
};
## method worryobs (Str $old, Str $new, Str $when = ' in Perl 6')
sub worryobs {
no warnings 'recursion';
my $self = shift;
die 'Required argument old omitted' unless @_;
my $old = @_ ? shift() : undef;
die 'Required argument new omitted' unless @_;
my $new = @_ ? shift() : undef;
my $when = @_ ? shift() : ' in Perl 6';
$self->worry("Unsupported use of $old;$when please use $new");
$self;
};
## method badinfix (Str $bad = $*sym)
sub badinfix {
no warnings 'recursion';
my $self = shift;
my $bad = @_ ? shift() : $::sym;
$self->panic("Preceding context expects a term, but found infix $bad instead")};
## token term:sym<miscbad> {
sub term__S_062miscbad__PEEK { $_[0]->_AUTOLEXpeek('term__S_062miscbad', $retree) }
sub term__S_062miscbad {
no warnings 'recursion';
my $self = shift;


local $::CTX = $self->callm() if $::DEBUG & DEBUG::trace_call;

my $C = $self->cursor_xact("RULE term__S_062miscbad");
my $xact = $C->xact;
my $S = $C->{'_pos'};
$C->{sym} = "miscbad";
$self->_MATCHIFYr($S, "term__S_062miscbad", do {
my $C = $C;
if (($C) = (scalar(do {
}, $C))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
(($C) x !!do {
$::QSIGIL })
}))
and ($C) = (scalar(do {
{
my ($bad) = $C->suppose( sub {
$C->infixish});
$::HIGHWATER = -1;
$::HIGHMESS = '';
$self->badinfix($bad->Str) if $bad;
}}, $C))
and ($C) = ($C->_NOTBEFORE(sub {
my $C=shift;
$C
}))) {
$C
} else { () }
});
}
;
  1; }
